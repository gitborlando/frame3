"use strict";
var frame3 = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name41 in all)
      __defProp(target, name41, { get: all[name41], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code2.length; i < len; ++i) {
        lookup[i] = code2[i];
        revLookup[code2.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer2, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer2[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer2[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer3;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer3.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer3.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function Buffer3(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer3.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer3.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer3.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer3, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer3.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer3.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer3.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy2 = new Uint8Array(arrayView);
          return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer3.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer3.alloc(+length);
      }
      Buffer3.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer3.prototype;
      };
      Buffer3.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer3.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer3.from(b, b.offset, b.byteLength);
        if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer3.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer3.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer3.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer2 = Buffer3.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer2.length) {
              if (!Buffer3.isBuffer(buf))
                buf = Buffer3.from(buf);
              buf.copy(buffer2, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer2,
                buf,
                pos
              );
            }
          } else if (!Buffer3.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer2, pos);
          }
          pos += buf.length;
        }
        return buffer2;
      };
      function byteLength(string, encoding) {
        if (Buffer3.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer3.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer3.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer3.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer3.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
      Buffer3.prototype.equals = function equals(b) {
        if (!Buffer3.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer3.compare(this, b) === 0;
      };
      Buffer3.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
      }
      Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer3.from(target, target.offset, target.byteLength);
        }
        if (!Buffer3.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
        if (buffer2.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer2.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer2.length + byteOffset;
        if (byteOffset >= buffer2.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer2.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer3.from(val, encoding);
        }
        if (Buffer3.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer3.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer3.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer3.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer3.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer3.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!Buffer3.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer3.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code2 = val.charCodeAt(0);
            if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
              val = code2;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name41) {
          if (name41) {
            return `${name41} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name41, actual) {
          return `The "${name41}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name41) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name41, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/process/browser.js"(exports, module) {
      var process3 = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process3.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process3.title = "browser";
      process3.browser = true;
      process3.env = {};
      process3.argv = [];
      process3.version = "";
      process3.versions = {};
      function noop4() {
      }
      process3.on = noop4;
      process3.addListener = noop4;
      process3.once = noop4;
      process3.off = noop4;
      process3.removeListener = noop4;
      process3.removeAllListeners = noop4;
      process3.emit = noop4;
      process3.prependListener = noop4;
      process3.prependOnceListener = noop4;
      process3.listeners = function(name41) {
        return [];
      };
      process3.binding = function(name41) {
        throw new Error("process.binding is not supported");
      };
      process3.cwd = function() {
        return "/";
      };
      process3.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process3.umask = function() {
        return 0;
      };
    }
  });

  // node_modules/source-map/lib/base64.js
  var require_base64 = __commonJS({
    "node_modules/source-map/lib/base64.js"(exports) {
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      exports.encode = function(number2) {
        if (0 <= number2 && number2 < intToCharMap.length) {
          return intToCharMap[number2];
        }
        throw new TypeError("Must be between 0 and 63: " + number2);
      };
      exports.decode = function(charCode2) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero2 = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode2 && charCode2 <= bigZ) {
          return charCode2 - bigA;
        }
        if (littleA <= charCode2 && charCode2 <= littleZ) {
          return charCode2 - littleA + littleOffset;
        }
        if (zero2 <= charCode2 && charCode2 <= nine) {
          return charCode2 - zero2 + numberOffset;
        }
        if (charCode2 == plus) {
          return 62;
        }
        if (charCode2 == slash) {
          return 63;
        }
        return -1;
      };
    }
  });

  // node_modules/source-map/lib/base64-vlq.js
  var require_base64_vlq = __commonJS({
    "node_modules/source-map/lib/base64-vlq.js"(exports) {
      var base64 = require_base64();
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    }
  });

  // node_modules/source-map/lib/util.js
  var require_util = __commonJS({
    "node_modules/source-map/lib/util.js"(exports) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join("/");
        if (path === "") {
          path = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      exports.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
      var supportsNullProto = function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length = s.length;
        if (length < 9) {
          return false;
        }
        if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
          return false;
        }
        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    }
  });

  // node_modules/source-map/lib/array-set.js
  var require_array_set = __commonJS({
    "node_modules/source-map/lib/array-set.js"(exports) {
      var util = require_util();
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    }
  });

  // node_modules/source-map/lib/mapping-list.js
  var require_mapping_list = __commonJS({
    "node_modules/source-map/lib/mapping-list.js"(exports) {
      var util = require_util();
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;
    }
  });

  // node_modules/source-map/lib/source-map-generator.js
  var require_source_map_generator = __commonJS({
    "node_modules/source-map/lib/source-map-generator.js"(exports) {
      var base64VLQ = require_base64_vlq();
      var util = require_util();
      var ArraySet = require_array_set().ArraySet;
      var MappingList = require_mapping_list().MappingList;
      function SourceMapGenerator2(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator2.prototype._version = 3;
      SourceMapGenerator2.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator2({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator2.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, "generated");
        var original = util.getArg(aArgs, "original", null);
        var source = util.getArg(aArgs, "source", null);
        var name41 = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name41);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name41 != null) {
          name41 = String(name41);
          if (!this._names.has(name41)) {
            this._names.add(name41);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name: name41
        });
      };
      SourceMapGenerator2.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator2.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet();
        var newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name41 = mapping.name;
          if (name41 != null && !newNames.has(name41)) {
            newNames.add(name41);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(sourceFile2) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile2 = util.join(aSourceMapPath, sourceFile2);
            }
            if (sourceRoot != null) {
              sourceFile2 = util.relative(sourceRoot, sourceFile2);
            }
            this.setSourceContent(sourceFile2, content);
          }
        }, this);
      };
      SourceMapGenerator2.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator2.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = "";
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else {
            if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                continue;
              }
              next += ",";
            }
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      };
      SourceMapGenerator2.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator2.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      };
      SourceMapGenerator2.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      exports.SourceMapGenerator = SourceMapGenerator2;
    }
  });

  // node_modules/prettier/standalone.js
  var require_standalone = __commonJS({
    "node_modules/prettier/standalone.js"(exports, module) {
      (function(e) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var f = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          f.prettier = e();
        }
      })(function() {
        "use strict";
        var xe = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
        var pt = xe((r0, pu) => {
          var ir = function(e) {
            return e && e.Math == Math && e;
          };
          pu.exports = ir(typeof globalThis == "object" && globalThis) || ir(typeof window == "object" && window) || ir(typeof self == "object" && self) || ir(typeof global == "object" && global) || function() {
            return this;
          }() || Function("return this")();
        });
        var Dt = xe((n0, fu) => {
          fu.exports = function(e) {
            try {
              return !!e();
            } catch {
              return true;
            }
          };
        });
        var yt = xe((u0, Du) => {
          var Mo = Dt();
          Du.exports = !Mo(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        });
        var ar = xe((s0, mu) => {
          var Ro = Dt();
          mu.exports = !Ro(function() {
            var e = function() {
            }.bind();
            return typeof e != "function" || e.hasOwnProperty("prototype");
          });
        });
        var At = xe((i0, du) => {
          var $o = ar(), or = Function.prototype.call;
          du.exports = $o ? or.bind(or) : function() {
            return or.apply(or, arguments);
          };
        });
        var vu = xe((hu) => {
          "use strict";
          var gu = {}.propertyIsEnumerable, yu = Object.getOwnPropertyDescriptor, Vo = yu && !gu.call({ 1: 2 }, 1);
          hu.f = Vo ? function(r) {
            var t4 = yu(this, r);
            return !!t4 && t4.enumerable;
          } : gu;
        });
        var lr = xe((o0, Cu) => {
          Cu.exports = function(e, r) {
            return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
          };
        });
        var mt = xe((l0, Au) => {
          var Eu = ar(), Fu = Function.prototype, Wr = Fu.call, Wo = Eu && Fu.bind.bind(Wr, Wr);
          Au.exports = Eu ? Wo : function(e) {
            return function() {
              return Wr.apply(e, arguments);
            };
          };
        });
        var Vt = xe((c0, xu) => {
          var Su = mt(), Ho = Su({}.toString), Go = Su("".slice);
          xu.exports = function(e) {
            return Go(Ho(e), 8, -1);
          };
        });
        var Tu = xe((p0, bu) => {
          var Uo = mt(), Jo = Dt(), zo = Vt(), Hr = Object, Xo = Uo("".split);
          bu.exports = Jo(function() {
            return !Hr("z").propertyIsEnumerable(0);
          }) ? function(e) {
            return zo(e) == "String" ? Xo(e, "") : Hr(e);
          } : Hr;
        });
        var cr = xe((f0, Bu) => {
          Bu.exports = function(e) {
            return e == null;
          };
        });
        var Gr = xe((D0, Nu) => {
          var Ko = cr(), Yo = TypeError;
          Nu.exports = function(e) {
            if (Ko(e))
              throw Yo("Can't call method on " + e);
            return e;
          };
        });
        var pr = xe((m0, wu) => {
          var Qo = Tu(), Zo = Gr();
          wu.exports = function(e) {
            return Qo(Zo(e));
          };
        });
        var Jr = xe((d0, _u) => {
          var Ur = typeof document == "object" && document.all, el = typeof Ur > "u" && Ur !== void 0;
          _u.exports = { all: Ur, IS_HTMLDDA: el };
        });
        var ot = xe((g0, Iu) => {
          var Pu = Jr(), tl = Pu.all;
          Iu.exports = Pu.IS_HTMLDDA ? function(e) {
            return typeof e == "function" || e === tl;
          } : function(e) {
            return typeof e == "function";
          };
        });
        var St = xe((y0, Ou) => {
          var ku = ot(), Lu = Jr(), rl = Lu.all;
          Ou.exports = Lu.IS_HTMLDDA ? function(e) {
            return typeof e == "object" ? e !== null : ku(e) || e === rl;
          } : function(e) {
            return typeof e == "object" ? e !== null : ku(e);
          };
        });
        var Wt = xe((h0, ju) => {
          var zr = pt(), nl = ot(), ul = function(e) {
            return nl(e) ? e : void 0;
          };
          ju.exports = function(e, r) {
            return arguments.length < 2 ? ul(zr[e]) : zr[e] && zr[e][r];
          };
        });
        var Xr = xe((v0, qu) => {
          var sl = mt();
          qu.exports = sl({}.isPrototypeOf);
        });
        var Ru = xe((C0, Mu) => {
          var il = Wt();
          Mu.exports = il("navigator", "userAgent") || "";
        });
        var Ju = xe((E0, Uu) => {
          var Gu = pt(), Kr = Ru(), $u = Gu.process, Vu = Gu.Deno, Wu = $u && $u.versions || Vu && Vu.version, Hu = Wu && Wu.v8, dt, fr;
          Hu && (dt = Hu.split("."), fr = dt[0] > 0 && dt[0] < 4 ? 1 : +(dt[0] + dt[1]));
          !fr && Kr && (dt = Kr.match(/Edge\/(\d+)/), (!dt || dt[1] >= 74) && (dt = Kr.match(/Chrome\/(\d+)/), dt && (fr = +dt[1])));
          Uu.exports = fr;
        });
        var Yr = xe((F0, Xu) => {
          var zu = Ju(), al = Dt();
          Xu.exports = !!Object.getOwnPropertySymbols && !al(function() {
            var e = Symbol();
            return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && zu && zu < 41;
          });
        });
        var Qr = xe((A0, Ku) => {
          var ol = Yr();
          Ku.exports = ol && !Symbol.sham && typeof Symbol.iterator == "symbol";
        });
        var Zr = xe((S0, Yu) => {
          var ll = Wt(), cl = ot(), pl = Xr(), fl = Qr(), Dl = Object;
          Yu.exports = fl ? function(e) {
            return typeof e == "symbol";
          } : function(e) {
            var r = ll("Symbol");
            return cl(r) && pl(r.prototype, Dl(e));
          };
        });
        var Dr = xe((x0, Qu) => {
          var ml = String;
          Qu.exports = function(e) {
            try {
              return ml(e);
            } catch {
              return "Object";
            }
          };
        });
        var Ht = xe((b0, Zu) => {
          var dl = ot(), gl = Dr(), yl = TypeError;
          Zu.exports = function(e) {
            if (dl(e))
              return e;
            throw yl(gl(e) + " is not a function");
          };
        });
        var mr = xe((T0, es) => {
          var hl = Ht(), vl = cr();
          es.exports = function(e, r) {
            var t4 = e[r];
            return vl(t4) ? void 0 : hl(t4);
          };
        });
        var rs = xe((B0, ts) => {
          var en = At(), tn = ot(), rn = St(), Cl = TypeError;
          ts.exports = function(e, r) {
            var t4, s;
            if (r === "string" && tn(t4 = e.toString) && !rn(s = en(t4, e)) || tn(t4 = e.valueOf) && !rn(s = en(t4, e)) || r !== "string" && tn(t4 = e.toString) && !rn(s = en(t4, e)))
              return s;
            throw Cl("Can't convert object to primitive value");
          };
        });
        var us = xe((N0, ns) => {
          ns.exports = false;
        });
        var dr = xe((w0, is2) => {
          var ss = pt(), El = Object.defineProperty;
          is2.exports = function(e, r) {
            try {
              El(ss, e, { value: r, configurable: true, writable: true });
            } catch {
              ss[e] = r;
            }
            return r;
          };
        });
        var gr = xe((_0, os) => {
          var Fl = pt(), Al = dr(), as = "__core-js_shared__", Sl = Fl[as] || Al(as, {});
          os.exports = Sl;
        });
        var nn = xe((P0, cs) => {
          var xl = us(), ls = gr();
          (cs.exports = function(e, r) {
            return ls[e] || (ls[e] = r !== void 0 ? r : {});
          })("versions", []).push({ version: "3.26.1", mode: xl ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
        });
        var yr = xe((I0, ps) => {
          var bl = Gr(), Tl = Object;
          ps.exports = function(e) {
            return Tl(bl(e));
          };
        });
        var Ct = xe((k0, fs) => {
          var Bl = mt(), Nl = yr(), wl = Bl({}.hasOwnProperty);
          fs.exports = Object.hasOwn || function(r, t4) {
            return wl(Nl(r), t4);
          };
        });
        var un = xe((L0, Ds) => {
          var _l = mt(), Pl = 0, Il = Math.random(), kl = _l(1 .toString);
          Ds.exports = function(e) {
            return "Symbol(" + (e === void 0 ? "" : e) + ")_" + kl(++Pl + Il, 36);
          };
        });
        var bt = xe((O0, hs) => {
          var Ll = pt(), Ol = nn(), ms = Ct(), jl = un(), ds = Yr(), ys = Qr(), It = Ol("wks"), xt = Ll.Symbol, gs = xt && xt.for, ql = ys ? xt : xt && xt.withoutSetter || jl;
          hs.exports = function(e) {
            if (!ms(It, e) || !(ds || typeof It[e] == "string")) {
              var r = "Symbol." + e;
              ds && ms(xt, e) ? It[e] = xt[e] : ys && gs ? It[e] = gs(r) : It[e] = ql(r);
            }
            return It[e];
          };
        });
        var Fs = xe((j0, Es) => {
          var Ml = At(), vs = St(), Cs = Zr(), Rl = mr(), $l = rs(), Vl = bt(), Wl = TypeError, Hl = Vl("toPrimitive");
          Es.exports = function(e, r) {
            if (!vs(e) || Cs(e))
              return e;
            var t4 = Rl(e, Hl), s;
            if (t4) {
              if (r === void 0 && (r = "default"), s = Ml(t4, e, r), !vs(s) || Cs(s))
                return s;
              throw Wl("Can't convert object to primitive value");
            }
            return r === void 0 && (r = "number"), $l(e, r);
          };
        });
        var hr = xe((q0, As) => {
          var Gl = Fs(), Ul = Zr();
          As.exports = function(e) {
            var r = Gl(e, "string");
            return Ul(r) ? r : r + "";
          };
        });
        var bs = xe((M0, xs) => {
          var Jl = pt(), Ss = St(), sn = Jl.document, zl = Ss(sn) && Ss(sn.createElement);
          xs.exports = function(e) {
            return zl ? sn.createElement(e) : {};
          };
        });
        var an = xe((R0, Ts) => {
          var Xl = yt(), Kl = Dt(), Yl = bs();
          Ts.exports = !Xl && !Kl(function() {
            return Object.defineProperty(Yl("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        });
        var on = xe((Ns) => {
          var Ql = yt(), Zl = At(), ec = vu(), tc = lr(), rc = pr(), nc = hr(), uc = Ct(), sc = an(), Bs = Object.getOwnPropertyDescriptor;
          Ns.f = Ql ? Bs : function(r, t4) {
            if (r = rc(r), t4 = nc(t4), sc)
              try {
                return Bs(r, t4);
              } catch {
              }
            if (uc(r, t4))
              return tc(!Zl(ec.f, r, t4), r[t4]);
          };
        });
        var _s = xe((V0, ws) => {
          var ic = yt(), ac = Dt();
          ws.exports = ic && ac(function() {
            return Object.defineProperty(function() {
            }, "prototype", { value: 42, writable: false }).prototype != 42;
          });
        });
        var Tt = xe((W0, Ps) => {
          var oc = St(), lc = String, cc = TypeError;
          Ps.exports = function(e) {
            if (oc(e))
              return e;
            throw cc(lc(e) + " is not an object");
          };
        });
        var kt = xe((ks) => {
          var pc = yt(), fc = an(), Dc = _s(), vr = Tt(), Is = hr(), mc = TypeError, ln = Object.defineProperty, dc = Object.getOwnPropertyDescriptor, cn = "enumerable", pn = "configurable", fn = "writable";
          ks.f = pc ? Dc ? function(r, t4, s) {
            if (vr(r), t4 = Is(t4), vr(s), typeof r == "function" && t4 === "prototype" && "value" in s && fn in s && !s[fn]) {
              var a = dc(r, t4);
              a && a[fn] && (r[t4] = s.value, s = { configurable: pn in s ? s[pn] : a[pn], enumerable: cn in s ? s[cn] : a[cn], writable: false });
            }
            return ln(r, t4, s);
          } : ln : function(r, t4, s) {
            if (vr(r), t4 = Is(t4), vr(s), fc)
              try {
                return ln(r, t4, s);
              } catch {
              }
            if ("get" in s || "set" in s)
              throw mc("Accessors not supported");
            return "value" in s && (r[t4] = s.value), r;
          };
        });
        var Dn = xe((G0, Ls) => {
          var gc = yt(), yc = kt(), hc = lr();
          Ls.exports = gc ? function(e, r, t4) {
            return yc.f(e, r, hc(1, t4));
          } : function(e, r, t4) {
            return e[r] = t4, e;
          };
        });
        var qs = xe((U0, js) => {
          var mn = yt(), vc = Ct(), Os = Function.prototype, Cc = mn && Object.getOwnPropertyDescriptor, dn = vc(Os, "name"), Ec = dn && function() {
          }.name === "something", Fc = dn && (!mn || mn && Cc(Os, "name").configurable);
          js.exports = { EXISTS: dn, PROPER: Ec, CONFIGURABLE: Fc };
        });
        var yn = xe((J0, Ms) => {
          var Ac = mt(), Sc = ot(), gn = gr(), xc = Ac(Function.toString);
          Sc(gn.inspectSource) || (gn.inspectSource = function(e) {
            return xc(e);
          });
          Ms.exports = gn.inspectSource;
        });
        var Vs = xe((z0, $s) => {
          var bc = pt(), Tc = ot(), Rs = bc.WeakMap;
          $s.exports = Tc(Rs) && /native code/.test(String(Rs));
        });
        var Gs = xe((X0, Hs) => {
          var Bc = nn(), Nc = un(), Ws = Bc("keys");
          Hs.exports = function(e) {
            return Ws[e] || (Ws[e] = Nc(e));
          };
        });
        var hn = xe((K0, Us) => {
          Us.exports = {};
        });
        var Ks = xe((Y0, Xs) => {
          var wc = Vs(), zs = pt(), _c = St(), Pc = Dn(), vn = Ct(), Cn = gr(), Ic = Gs(), kc = hn(), Js = "Object already initialized", En = zs.TypeError, Lc = zs.WeakMap, Cr, Gt, Er, Oc = function(e) {
            return Er(e) ? Gt(e) : Cr(e, {});
          }, jc = function(e) {
            return function(r) {
              var t4;
              if (!_c(r) || (t4 = Gt(r)).type !== e)
                throw En("Incompatible receiver, " + e + " required");
              return t4;
            };
          };
          wc || Cn.state ? (gt = Cn.state || (Cn.state = new Lc()), gt.get = gt.get, gt.has = gt.has, gt.set = gt.set, Cr = function(e, r) {
            if (gt.has(e))
              throw En(Js);
            return r.facade = e, gt.set(e, r), r;
          }, Gt = function(e) {
            return gt.get(e) || {};
          }, Er = function(e) {
            return gt.has(e);
          }) : (Bt = Ic("state"), kc[Bt] = true, Cr = function(e, r) {
            if (vn(e, Bt))
              throw En(Js);
            return r.facade = e, Pc(e, Bt, r), r;
          }, Gt = function(e) {
            return vn(e, Bt) ? e[Bt] : {};
          }, Er = function(e) {
            return vn(e, Bt);
          });
          var gt, Bt;
          Xs.exports = { set: Cr, get: Gt, has: Er, enforce: Oc, getterFor: jc };
        });
        var An = xe((Q0, Qs) => {
          var qc = Dt(), Mc = ot(), Fr = Ct(), Fn = yt(), Rc = qs().CONFIGURABLE, $c = yn(), Ys = Ks(), Vc = Ys.enforce, Wc = Ys.get, Ar = Object.defineProperty, Hc = Fn && !qc(function() {
            return Ar(function() {
            }, "length", { value: 8 }).length !== 8;
          }), Gc = String(String).split("String"), Uc = Qs.exports = function(e, r, t4) {
            String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t4 && t4.getter && (r = "get " + r), t4 && t4.setter && (r = "set " + r), (!Fr(e, "name") || Rc && e.name !== r) && (Fn ? Ar(e, "name", { value: r, configurable: true }) : e.name = r), Hc && t4 && Fr(t4, "arity") && e.length !== t4.arity && Ar(e, "length", { value: t4.arity });
            try {
              t4 && Fr(t4, "constructor") && t4.constructor ? Fn && Ar(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
            } catch {
            }
            var s = Vc(e);
            return Fr(s, "source") || (s.source = Gc.join(typeof r == "string" ? r : "")), e;
          };
          Function.prototype.toString = Uc(function() {
            return Mc(this) && Wc(this).source || $c(this);
          }, "toString");
        });
        var ei = xe((Z0, Zs) => {
          var Jc = ot(), zc = kt(), Xc = An(), Kc = dr();
          Zs.exports = function(e, r, t4, s) {
            s || (s = {});
            var a = s.enumerable, n = s.name !== void 0 ? s.name : r;
            if (Jc(t4) && Xc(t4, n, s), s.global)
              a ? e[r] = t4 : Kc(r, t4);
            else {
              try {
                s.unsafe ? e[r] && (a = true) : delete e[r];
              } catch {
              }
              a ? e[r] = t4 : zc.f(e, r, { value: t4, enumerable: false, configurable: !s.nonConfigurable, writable: !s.nonWritable });
            }
            return e;
          };
        });
        var ri = xe((ey, ti) => {
          var Yc = Math.ceil, Qc = Math.floor;
          ti.exports = Math.trunc || function(r) {
            var t4 = +r;
            return (t4 > 0 ? Qc : Yc)(t4);
          };
        });
        var Sr = xe((ty, ni) => {
          var Zc = ri();
          ni.exports = function(e) {
            var r = +e;
            return r !== r || r === 0 ? 0 : Zc(r);
          };
        });
        var si = xe((ry, ui) => {
          var ep = Sr(), tp = Math.max, rp = Math.min;
          ui.exports = function(e, r) {
            var t4 = ep(e);
            return t4 < 0 ? tp(t4 + r, 0) : rp(t4, r);
          };
        });
        var ai = xe((ny, ii) => {
          var np = Sr(), up = Math.min;
          ii.exports = function(e) {
            return e > 0 ? up(np(e), 9007199254740991) : 0;
          };
        });
        var Lt = xe((uy, oi) => {
          var sp = ai();
          oi.exports = function(e) {
            return sp(e.length);
          };
        });
        var pi = xe((sy, ci) => {
          var ip = pr(), ap = si(), op = Lt(), li = function(e) {
            return function(r, t4, s) {
              var a = ip(r), n = op(a), u = ap(s, n), i;
              if (e && t4 != t4) {
                for (; n > u; )
                  if (i = a[u++], i != i)
                    return true;
              } else
                for (; n > u; u++)
                  if ((e || u in a) && a[u] === t4)
                    return e || u || 0;
              return !e && -1;
            };
          };
          ci.exports = { includes: li(true), indexOf: li(false) };
        });
        var mi = xe((iy, Di) => {
          var lp = mt(), Sn = Ct(), cp = pr(), pp = pi().indexOf, fp = hn(), fi = lp([].push);
          Di.exports = function(e, r) {
            var t4 = cp(e), s = 0, a = [], n;
            for (n in t4)
              !Sn(fp, n) && Sn(t4, n) && fi(a, n);
            for (; r.length > s; )
              Sn(t4, n = r[s++]) && (~pp(a, n) || fi(a, n));
            return a;
          };
        });
        var gi = xe((ay, di) => {
          di.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
        });
        var hi = xe((yi) => {
          var Dp = mi(), mp = gi(), dp = mp.concat("length", "prototype");
          yi.f = Object.getOwnPropertyNames || function(r) {
            return Dp(r, dp);
          };
        });
        var Ci = xe((vi) => {
          vi.f = Object.getOwnPropertySymbols;
        });
        var Fi = xe((cy, Ei) => {
          var gp = Wt(), yp = mt(), hp = hi(), vp = Ci(), Cp = Tt(), Ep = yp([].concat);
          Ei.exports = gp("Reflect", "ownKeys") || function(r) {
            var t4 = hp.f(Cp(r)), s = vp.f;
            return s ? Ep(t4, s(r)) : t4;
          };
        });
        var xi = xe((py, Si) => {
          var Ai = Ct(), Fp = Fi(), Ap = on(), Sp = kt();
          Si.exports = function(e, r, t4) {
            for (var s = Fp(r), a = Sp.f, n = Ap.f, u = 0; u < s.length; u++) {
              var i = s[u];
              !Ai(e, i) && !(t4 && Ai(t4, i)) && a(e, i, n(r, i));
            }
          };
        });
        var Ti = xe((fy, bi) => {
          var xp = Dt(), bp = ot(), Tp = /#|\.prototype\./, Ut = function(e, r) {
            var t4 = Np[Bp(e)];
            return t4 == _p ? true : t4 == wp ? false : bp(r) ? xp(r) : !!r;
          }, Bp = Ut.normalize = function(e) {
            return String(e).replace(Tp, ".").toLowerCase();
          }, Np = Ut.data = {}, wp = Ut.NATIVE = "N", _p = Ut.POLYFILL = "P";
          bi.exports = Ut;
        });
        var Jt = xe((Dy, Bi) => {
          var xn = pt(), Pp = on().f, Ip = Dn(), kp = ei(), Lp = dr(), Op = xi(), jp = Ti();
          Bi.exports = function(e, r) {
            var t4 = e.target, s = e.global, a = e.stat, n, u, i, l, p, y;
            if (s ? u = xn : a ? u = xn[t4] || Lp(t4, {}) : u = (xn[t4] || {}).prototype, u)
              for (i in r) {
                if (p = r[i], e.dontCallGetSet ? (y = Pp(u, i), l = y && y.value) : l = u[i], n = jp(s ? i : t4 + (a ? "." : "#") + i, e.forced), !n && l !== void 0) {
                  if (typeof p == typeof l)
                    continue;
                  Op(p, l);
                }
                (e.sham || l && l.sham) && Ip(p, "sham", true), kp(u, i, p, e);
              }
          };
        });
        var bn = xe((my, Ni) => {
          var qp = Vt();
          Ni.exports = Array.isArray || function(r) {
            return qp(r) == "Array";
          };
        });
        var _i = xe((dy, wi) => {
          var Mp = TypeError, Rp = 9007199254740991;
          wi.exports = function(e) {
            if (e > Rp)
              throw Mp("Maximum allowed index exceeded");
            return e;
          };
        });
        var Ii = xe((gy, Pi) => {
          var $p = Vt(), Vp = mt();
          Pi.exports = function(e) {
            if ($p(e) === "Function")
              return Vp(e);
          };
        });
        var Tn = xe((yy, Li) => {
          var ki = Ii(), Wp = Ht(), Hp = ar(), Gp = ki(ki.bind);
          Li.exports = function(e, r) {
            return Wp(e), r === void 0 ? e : Hp ? Gp(e, r) : function() {
              return e.apply(r, arguments);
            };
          };
        });
        var Bn = xe((hy, ji) => {
          "use strict";
          var Up = bn(), Jp = Lt(), zp = _i(), Xp = Tn(), Oi = function(e, r, t4, s, a, n, u, i) {
            for (var l = a, p = 0, y = u ? Xp(u, i) : false, h2, g; p < s; )
              p in t4 && (h2 = y ? y(t4[p], p, r) : t4[p], n > 0 && Up(h2) ? (g = Jp(h2), l = Oi(e, r, h2, g, l, n - 1) - 1) : (zp(l + 1), e[l] = h2), l++), p++;
            return l;
          };
          ji.exports = Oi;
        });
        var Ri = xe((vy, Mi) => {
          var Kp = bt(), Yp = Kp("toStringTag"), qi = {};
          qi[Yp] = "z";
          Mi.exports = String(qi) === "[object z]";
        });
        var Nn = xe((Cy, $i) => {
          var Qp = Ri(), Zp = ot(), xr = Vt(), ef = bt(), tf = ef("toStringTag"), rf = Object, nf = xr(function() {
            return arguments;
          }()) == "Arguments", uf = function(e, r) {
            try {
              return e[r];
            } catch {
            }
          };
          $i.exports = Qp ? xr : function(e) {
            var r, t4, s;
            return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t4 = uf(r = rf(e), tf)) == "string" ? t4 : nf ? xr(r) : (s = xr(r)) == "Object" && Zp(r.callee) ? "Arguments" : s;
          };
        });
        var Ji = xe((Ey, Ui) => {
          var sf = mt(), af = Dt(), Vi = ot(), of = Nn(), lf = Wt(), cf = yn(), Wi = function() {
          }, pf = [], Hi = lf("Reflect", "construct"), wn = /^\s*(?:class|function)\b/, ff = sf(wn.exec), Df = !wn.exec(Wi), zt = function(r) {
            if (!Vi(r))
              return false;
            try {
              return Hi(Wi, pf, r), true;
            } catch {
              return false;
            }
          }, Gi = function(r) {
            if (!Vi(r))
              return false;
            switch (of(r)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return false;
            }
            try {
              return Df || !!ff(wn, cf(r));
            } catch {
              return true;
            }
          };
          Gi.sham = true;
          Ui.exports = !Hi || af(function() {
            var e;
            return zt(zt.call) || !zt(Object) || !zt(function() {
              e = true;
            }) || e;
          }) ? Gi : zt;
        });
        var Yi = xe((Fy, Ki) => {
          var zi = bn(), mf = Ji(), df = St(), gf = bt(), yf = gf("species"), Xi = Array;
          Ki.exports = function(e) {
            var r;
            return zi(e) && (r = e.constructor, mf(r) && (r === Xi || zi(r.prototype)) ? r = void 0 : df(r) && (r = r[yf], r === null && (r = void 0))), r === void 0 ? Xi : r;
          };
        });
        var _n = xe((Ay, Qi) => {
          var hf = Yi();
          Qi.exports = function(e, r) {
            return new (hf(e))(r === 0 ? 0 : r);
          };
        });
        var Zi = xe(() => {
          "use strict";
          var vf = Jt(), Cf = Bn(), Ef = Ht(), Ff = yr(), Af = Lt(), Sf = _n();
          vf({ target: "Array", proto: true }, { flatMap: function(r) {
            var t4 = Ff(this), s = Af(t4), a;
            return Ef(r), a = Sf(t4, 0), a.length = Cf(a, t4, t4, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a;
          } });
        });
        var Pn = xe((by, ea) => {
          ea.exports = {};
        });
        var ra = xe((Ty, ta) => {
          var xf = bt(), bf = Pn(), Tf = xf("iterator"), Bf = Array.prototype;
          ta.exports = function(e) {
            return e !== void 0 && (bf.Array === e || Bf[Tf] === e);
          };
        });
        var In = xe((By, ua) => {
          var Nf = Nn(), na = mr(), wf = cr(), _f = Pn(), Pf = bt(), If = Pf("iterator");
          ua.exports = function(e) {
            if (!wf(e))
              return na(e, If) || na(e, "@@iterator") || _f[Nf(e)];
          };
        });
        var ia = xe((Ny, sa) => {
          var kf = At(), Lf = Ht(), Of = Tt(), jf = Dr(), qf = In(), Mf = TypeError;
          sa.exports = function(e, r) {
            var t4 = arguments.length < 2 ? qf(e) : r;
            if (Lf(t4))
              return Of(kf(t4, e));
            throw Mf(jf(e) + " is not iterable");
          };
        });
        var la = xe((wy, oa) => {
          var Rf = At(), aa = Tt(), $f = mr();
          oa.exports = function(e, r, t4) {
            var s, a;
            aa(e);
            try {
              if (s = $f(e, "return"), !s) {
                if (r === "throw")
                  throw t4;
                return t4;
              }
              s = Rf(s, e);
            } catch (n) {
              a = true, s = n;
            }
            if (r === "throw")
              throw t4;
            if (a)
              throw s;
            return aa(s), t4;
          };
        });
        var ma = xe((_y, Da) => {
          var Vf = Tn(), Wf = At(), Hf = Tt(), Gf = Dr(), Uf = ra(), Jf = Lt(), ca = Xr(), zf = ia(), Xf = In(), pa = la(), Kf = TypeError, br = function(e, r) {
            this.stopped = e, this.result = r;
          }, fa = br.prototype;
          Da.exports = function(e, r, t4) {
            var s = t4 && t4.that, a = !!(t4 && t4.AS_ENTRIES), n = !!(t4 && t4.IS_RECORD), u = !!(t4 && t4.IS_ITERATOR), i = !!(t4 && t4.INTERRUPTED), l = Vf(r, s), p, y, h2, g, c, f, F4, _ = function(E) {
              return p && pa(p, "normal", E), new br(true, E);
            }, w = function(E) {
              return a ? (Hf(E), i ? l(E[0], E[1], _) : l(E[0], E[1])) : i ? l(E, _) : l(E);
            };
            if (n)
              p = e.iterator;
            else if (u)
              p = e;
            else {
              if (y = Xf(e), !y)
                throw Kf(Gf(e) + " is not iterable");
              if (Uf(y)) {
                for (h2 = 0, g = Jf(e); g > h2; h2++)
                  if (c = w(e[h2]), c && ca(fa, c))
                    return c;
                return new br(false);
              }
              p = zf(e, y);
            }
            for (f = n ? e.next : p.next; !(F4 = Wf(f, p)).done; ) {
              try {
                c = w(F4.value);
              } catch (E) {
                pa(p, "throw", E);
              }
              if (typeof c == "object" && c && ca(fa, c))
                return c;
            }
            return new br(false);
          };
        });
        var ga = xe((Py, da) => {
          "use strict";
          var Yf = hr(), Qf = kt(), Zf = lr();
          da.exports = function(e, r, t4) {
            var s = Yf(r);
            s in e ? Qf.f(e, s, Zf(0, t4)) : e[s] = t4;
          };
        });
        var ya = xe(() => {
          var eD = Jt(), tD = ma(), rD = ga();
          eD({ target: "Object", stat: true }, { fromEntries: function(r) {
            var t4 = {};
            return tD(r, function(s, a) {
              rD(t4, s, a);
            }, { AS_ENTRIES: true }), t4;
          } });
        });
        var Ca = xe((Ly, va) => {
          var ha = An(), nD = kt();
          va.exports = function(e, r, t4) {
            return t4.get && ha(t4.get, r, { getter: true }), t4.set && ha(t4.set, r, { setter: true }), nD.f(e, r, t4);
          };
        });
        var Fa = xe((Oy, Ea) => {
          "use strict";
          var uD = Tt();
          Ea.exports = function() {
            var e = uD(this), r = "";
            return e.hasIndices && (r += "d"), e.global && (r += "g"), e.ignoreCase && (r += "i"), e.multiline && (r += "m"), e.dotAll && (r += "s"), e.unicode && (r += "u"), e.unicodeSets && (r += "v"), e.sticky && (r += "y"), r;
          };
        });
        var xa = xe(() => {
          var sD = pt(), iD = yt(), aD = Ca(), oD = Fa(), lD = Dt(), Aa = sD.RegExp, Sa = Aa.prototype, cD = iD && lD(function() {
            var e = true;
            try {
              Aa(".", "d");
            } catch {
              e = false;
            }
            var r = {}, t4 = "", s = e ? "dgimsy" : "gimsy", a = function(l, p) {
              Object.defineProperty(r, l, { get: function() {
                return t4 += p, true;
              } });
            }, n = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
            e && (n.hasIndices = "d");
            for (var u in n)
              a(u, n[u]);
            var i = Object.getOwnPropertyDescriptor(Sa, "flags").get.call(r);
            return i !== s || t4 !== s;
          });
          cD && aD(Sa, "flags", { configurable: true, get: oD });
        });
        var ba = xe(() => {
          var pD = Jt(), kn = pt();
          pD({ global: true, forced: kn.globalThis !== kn }, { globalThis: kn });
        });
        var Ta = xe(() => {
          ba();
        });
        var Ba = xe(() => {
          "use strict";
          var fD = Jt(), DD = Bn(), mD = yr(), dD = Lt(), gD = Sr(), yD = _n();
          fD({ target: "Array", proto: true }, { flat: function() {
            var r = arguments.length ? arguments[0] : void 0, t4 = mD(this), s = dD(t4), a = yD(t4, 0);
            return a.length = DD(a, t4, t4, s, 0, r === void 0 ? 1 : gD(r)), a;
          } });
        });
        var e0 = xe((Uy, jo) => {
          var hD = ["cliName", "cliCategory", "cliDescription"], vD = ["_"], CD = ["languageId"];
          function Hn(e, r) {
            if (e == null)
              return {};
            var t4 = ED(e, r), s, a;
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              for (a = 0; a < n.length; a++)
                s = n[a], !(r.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s) && (t4[s] = e[s]);
            }
            return t4;
          }
          function ED(e, r) {
            if (e == null)
              return {};
            var t4 = {}, s = Object.keys(e), a, n;
            for (n = 0; n < s.length; n++)
              a = s[n], !(r.indexOf(a) >= 0) && (t4[a] = e[a]);
            return t4;
          }
          Zi();
          ya();
          xa();
          Ta();
          Ba();
          var FD = Object.create, _r = Object.defineProperty, AD = Object.getOwnPropertyDescriptor, Gn = Object.getOwnPropertyNames, SD = Object.getPrototypeOf, xD = Object.prototype.hasOwnProperty, ht = (e, r) => function() {
            return e && (r = (0, e[Gn(e)[0]])(e = 0)), r;
          }, te = (e, r) => function() {
            return r || (0, e[Gn(e)[0]])((r = { exports: {} }).exports, r), r.exports;
          }, Kt = (e, r) => {
            for (var t4 in r)
              _r(e, t4, { get: r[t4], enumerable: true });
          }, Pa = (e, r, t4, s) => {
            if (r && typeof r == "object" || typeof r == "function")
              for (let a of Gn(r))
                !xD.call(e, a) && a !== t4 && _r(e, a, { get: () => r[a], enumerable: !(s = AD(r, a)) || s.enumerable });
            return e;
          }, bD = (e, r, t4) => (t4 = e != null ? FD(SD(e)) : {}, Pa(r || !e || !e.__esModule ? _r(t4, "default", { value: e, enumerable: true }) : t4, e)), ft = (e) => Pa(_r({}, "__esModule", { value: true }), e), wt, ne = ht({ "<define:process>"() {
            wt = { env: {}, argv: [] };
          } }), Ia = te({ "package.json"(e, r) {
            r.exports = { version: "2.8.4" };
          } }), TD = te({ "node_modules/diff/lib/diff/base.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.default = r;
            function r() {
            }
            r.prototype = { diff: function(n, u) {
              var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
              typeof i == "function" && (l = i, i = {}), this.options = i;
              var p = this;
              function y(N6) {
                return l ? (setTimeout(function() {
                  l(void 0, N6);
                }, 0), true) : N6;
              }
              n = this.castInput(n), u = this.castInput(u), n = this.removeEmpty(this.tokenize(n)), u = this.removeEmpty(this.tokenize(u));
              var h2 = u.length, g = n.length, c = 1, f = h2 + g, F4 = [{ newPos: -1, components: [] }], _ = this.extractCommon(F4[0], u, n, 0);
              if (F4[0].newPos + 1 >= h2 && _ + 1 >= g)
                return y([{ value: this.join(u), count: u.length }]);
              function w() {
                for (var N6 = -1 * c; N6 <= c; N6 += 2) {
                  var x = void 0, I = F4[N6 - 1], P = F4[N6 + 1], $ = (P ? P.newPos : 0) - N6;
                  I && (F4[N6 - 1] = void 0);
                  var D = I && I.newPos + 1 < h2, T = P && 0 <= $ && $ < g;
                  if (!D && !T) {
                    F4[N6] = void 0;
                    continue;
                  }
                  if (!D || T && I.newPos < P.newPos ? (x = s(P), p.pushComponent(x.components, void 0, true)) : (x = I, x.newPos++, p.pushComponent(x.components, true, void 0)), $ = p.extractCommon(x, u, n, N6), x.newPos + 1 >= h2 && $ + 1 >= g)
                    return y(t4(p, x.components, u, n, p.useLongestToken));
                  F4[N6] = x;
                }
                c++;
              }
              if (l)
                (function N6() {
                  setTimeout(function() {
                    if (c > f)
                      return l();
                    w() || N6();
                  }, 0);
                })();
              else
                for (; c <= f; ) {
                  var E = w();
                  if (E)
                    return E;
                }
            }, pushComponent: function(n, u, i) {
              var l = n[n.length - 1];
              l && l.added === u && l.removed === i ? n[n.length - 1] = { count: l.count + 1, added: u, removed: i } : n.push({ count: 1, added: u, removed: i });
            }, extractCommon: function(n, u, i, l) {
              for (var p = u.length, y = i.length, h2 = n.newPos, g = h2 - l, c = 0; h2 + 1 < p && g + 1 < y && this.equals(u[h2 + 1], i[g + 1]); )
                h2++, g++, c++;
              return c && n.components.push({ count: c }), n.newPos = h2, g;
            }, equals: function(n, u) {
              return this.options.comparator ? this.options.comparator(n, u) : n === u || this.options.ignoreCase && n.toLowerCase() === u.toLowerCase();
            }, removeEmpty: function(n) {
              for (var u = [], i = 0; i < n.length; i++)
                n[i] && u.push(n[i]);
              return u;
            }, castInput: function(n) {
              return n;
            }, tokenize: function(n) {
              return n.split("");
            }, join: function(n) {
              return n.join("");
            } };
            function t4(a, n, u, i, l) {
              for (var p = 0, y = n.length, h2 = 0, g = 0; p < y; p++) {
                var c = n[p];
                if (c.removed) {
                  if (c.value = a.join(i.slice(g, g + c.count)), g += c.count, p && n[p - 1].added) {
                    var F4 = n[p - 1];
                    n[p - 1] = n[p], n[p] = F4;
                  }
                } else {
                  if (!c.added && l) {
                    var f = u.slice(h2, h2 + c.count);
                    f = f.map(function(w, E) {
                      var N6 = i[g + E];
                      return N6.length > w.length ? N6 : w;
                    }), c.value = a.join(f);
                  } else
                    c.value = a.join(u.slice(h2, h2 + c.count));
                  h2 += c.count, c.added || (g += c.count);
                }
              }
              var _ = n[y - 1];
              return y > 1 && typeof _.value == "string" && (_.added || _.removed) && a.equals("", _.value) && (n[y - 2].value += _.value, n.pop()), n;
            }
            function s(a) {
              return { newPos: a.newPos, components: a.components.slice(0) };
            }
          } }), BD = te({ "node_modules/diff/lib/diff/array.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
            var r = t4(TD());
            function t4(n) {
              return n && n.__esModule ? n : { default: n };
            }
            var s = new r.default();
            e.arrayDiff = s, s.tokenize = function(n) {
              return n.slice();
            }, s.join = s.removeEmpty = function(n) {
              return n;
            };
            function a(n, u, i) {
              return s.diff(n, u, i);
            }
          } }), Un = te({ "src/document/doc-builders.js"(e, r) {
            "use strict";
            ne();
            function t4(C) {
              return { type: "concat", parts: C };
            }
            function s(C) {
              return { type: "indent", contents: C };
            }
            function a(C, o) {
              return { type: "align", contents: o, n: C };
            }
            function n(C) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return { type: "group", id: o.id, contents: C, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
            }
            function u(C) {
              return a(Number.NEGATIVE_INFINITY, C);
            }
            function i(C) {
              return a({ type: "root" }, C);
            }
            function l(C) {
              return a(-1, C);
            }
            function p(C, o) {
              return n(C[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C }));
            }
            function y(C) {
              return { type: "fill", parts: C };
            }
            function h2(C, o) {
              let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return { type: "if-break", breakContents: C, flatContents: o, groupId: d.groupId };
            }
            function g(C, o) {
              return { type: "indent-if-break", contents: C, groupId: o.groupId, negate: o.negate };
            }
            function c(C) {
              return { type: "line-suffix", contents: C };
            }
            var f = { type: "line-suffix-boundary" }, F4 = { type: "break-parent" }, _ = { type: "trim" }, w = { type: "line", hard: true }, E = { type: "line", hard: true, literal: true }, N6 = { type: "line" }, x = { type: "line", soft: true }, I = t4([w, F4]), P = t4([E, F4]), $ = { type: "cursor", placeholder: Symbol("cursor") };
            function D(C, o) {
              let d = [];
              for (let v = 0; v < o.length; v++)
                v !== 0 && d.push(C), d.push(o[v]);
              return t4(d);
            }
            function T(C, o, d) {
              let v = C;
              if (o > 0) {
                for (let S = 0; S < Math.floor(o / d); ++S)
                  v = s(v);
                v = a(o % d, v), v = a(Number.NEGATIVE_INFINITY, v);
              }
              return v;
            }
            function m(C, o) {
              return { type: "label", label: C, contents: o };
            }
            r.exports = { concat: t4, join: D, line: N6, softline: x, hardline: I, literalline: P, group: n, conditionalGroup: p, fill: y, lineSuffix: c, lineSuffixBoundary: f, cursor: $, breakParent: F4, ifBreak: h2, trim: _, indent: s, indentIfBreak: g, align: a, addAlignmentToDoc: T, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w, literallineWithoutBreakParent: E, label: m };
          } }), Jn = te({ "src/common/end-of-line.js"(e, r) {
            "use strict";
            ne();
            function t4(u) {
              let i = u.indexOf("\r");
              return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
            }
            function s(u) {
              switch (u) {
                case "cr":
                  return "\r";
                case "crlf":
                  return `\r
`;
                default:
                  return `
`;
              }
            }
            function a(u, i) {
              let l;
              switch (i) {
                case `
`:
                  l = /\n/g;
                  break;
                case "\r":
                  l = /\r/g;
                  break;
                case `\r
`:
                  l = /\r\n/g;
                  break;
                default:
                  throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
              }
              let p = u.match(l);
              return p ? p.length : 0;
            }
            function n(u) {
              return u.replace(/\r\n?/g, `
`);
            }
            r.exports = { guessEndOfLine: t4, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: n };
          } }), lt = te({ "src/utils/get-last.js"(e, r) {
            "use strict";
            ne();
            var t4 = (s) => s[s.length - 1];
            r.exports = t4;
          } });
          function ND() {
            let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
            return new RegExp(r, e ? void 0 : "g");
          }
          var wD = ht({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
            ne();
          } });
          function _D(e) {
            if (typeof e != "string")
              throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
            return e.replace(ND(), "");
          }
          var PD = ht({ "node_modules/strip-ansi/index.js"() {
            ne(), wD();
          } });
          function ID(e) {
            return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
          }
          var kD = ht({ "node_modules/is-fullwidth-code-point/index.js"() {
            ne();
          } }), LD = te({ "node_modules/emoji-regex/index.js"(e, r) {
            "use strict";
            ne(), r.exports = function() {
              return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
            };
          } }), ka = {};
          Kt(ka, { default: () => OD });
          function OD(e) {
            if (typeof e != "string" || e.length === 0 || (e = _D(e), e.length === 0))
              return 0;
            e = e.replace((0, La.default)(), "  ");
            let r = 0;
            for (let t4 = 0; t4 < e.length; t4++) {
              let s = e.codePointAt(t4);
              s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t4++, r += ID(s) ? 2 : 1);
            }
            return r;
          }
          var La, jD = ht({ "node_modules/string-width/index.js"() {
            ne(), PD(), kD(), La = bD(LD());
          } }), Oa = te({ "src/utils/get-string-width.js"(e, r) {
            "use strict";
            ne();
            var t4 = (jD(), ft(ka)).default, s = /[^\x20-\x7F]/;
            function a(n) {
              return n ? s.test(n) ? t4(n) : n.length : 0;
            }
            r.exports = a;
          } }), Yt = te({ "src/document/doc-utils.js"(e, r) {
            "use strict";
            ne();
            var t4 = lt(), { literalline: s, join: a } = Un(), n = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
              if (Array.isArray(o))
                return o;
              if (o.type !== "concat" && o.type !== "fill")
                throw new Error("Expect doc type to be `concat` or `fill`.");
              return o.parts;
            }, i = {};
            function l(o, d, v, S) {
              let b = [o];
              for (; b.length > 0; ) {
                let B = b.pop();
                if (B === i) {
                  v(b.pop());
                  continue;
                }
                if (v && b.push(B, i), !d || d(B) !== false)
                  if (n(B) || B.type === "fill") {
                    let k = u(B);
                    for (let M = k.length, R4 = M - 1; R4 >= 0; --R4)
                      b.push(k[R4]);
                  } else if (B.type === "if-break")
                    B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
                  else if (B.type === "group" && B.expandedStates)
                    if (S)
                      for (let k = B.expandedStates.length, M = k - 1; M >= 0; --M)
                        b.push(B.expandedStates[M]);
                    else
                      b.push(B.contents);
                  else
                    B.contents && b.push(B.contents);
              }
            }
            function p(o, d) {
              let v = /* @__PURE__ */ new Map();
              return S(o);
              function S(B) {
                if (v.has(B))
                  return v.get(B);
                let k = b(B);
                return v.set(B, k), k;
              }
              function b(B) {
                if (Array.isArray(B))
                  return d(B.map(S));
                if (B.type === "concat" || B.type === "fill") {
                  let k = B.parts.map(S);
                  return d(Object.assign(Object.assign({}, B), {}, { parts: k }));
                }
                if (B.type === "if-break") {
                  let k = B.breakContents && S(B.breakContents), M = B.flatContents && S(B.flatContents);
                  return d(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M }));
                }
                if (B.type === "group" && B.expandedStates) {
                  let k = B.expandedStates.map(S), M = k[0];
                  return d(Object.assign(Object.assign({}, B), {}, { contents: M, expandedStates: k }));
                }
                if (B.contents) {
                  let k = S(B.contents);
                  return d(Object.assign(Object.assign({}, B), {}, { contents: k }));
                }
                return d(B);
              }
            }
            function y(o, d, v) {
              let S = v, b = false;
              function B(k) {
                let M = d(k);
                if (M !== void 0 && (b = true, S = M), b)
                  return false;
              }
              return l(o, B), S;
            }
            function h2(o) {
              if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
                return true;
            }
            function g(o) {
              return y(o, h2, false);
            }
            function c(o) {
              if (o.length > 0) {
                let d = t4(o);
                !d.expandedStates && !d.break && (d.break = "propagated");
              }
              return null;
            }
            function f(o) {
              let d = /* @__PURE__ */ new Set(), v = [];
              function S(B) {
                if (B.type === "break-parent" && c(v), B.type === "group") {
                  if (v.push(B), d.has(B))
                    return false;
                  d.add(B);
                }
              }
              function b(B) {
                B.type === "group" && v.pop().break && c(v);
              }
              l(o, S, b, true);
            }
            function F4(o) {
              return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
            }
            function _(o) {
              return p(o, F4);
            }
            var w = (o, d) => o && o.type === "line" && o.hard && d && d.type === "break-parent";
            function E(o) {
              if (!o)
                return o;
              if (n(o) || o.type === "fill") {
                let d = u(o);
                for (; d.length > 1 && w(...d.slice(-2)); )
                  d.length -= 2;
                if (d.length > 0) {
                  let v = E(t4(d));
                  d[d.length - 1] = v;
                }
                return Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
              }
              switch (o.type) {
                case "align":
                case "indent":
                case "indent-if-break":
                case "group":
                case "line-suffix":
                case "label": {
                  let d = E(o.contents);
                  return Object.assign(Object.assign({}, o), {}, { contents: d });
                }
                case "if-break": {
                  let d = E(o.breakContents), v = E(o.flatContents);
                  return Object.assign(Object.assign({}, o), {}, { breakContents: d, flatContents: v });
                }
              }
              return o;
            }
            function N6(o) {
              return E(I(o));
            }
            function x(o) {
              switch (o.type) {
                case "fill":
                  if (o.parts.every((v) => v === ""))
                    return "";
                  break;
                case "group":
                  if (!o.contents && !o.id && !o.break && !o.expandedStates)
                    return "";
                  if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
                    return o.contents;
                  break;
                case "align":
                case "indent":
                case "indent-if-break":
                case "line-suffix":
                  if (!o.contents)
                    return "";
                  break;
                case "if-break":
                  if (!o.flatContents && !o.breakContents)
                    return "";
                  break;
              }
              if (!n(o))
                return o;
              let d = [];
              for (let v of u(o)) {
                if (!v)
                  continue;
                let [S, ...b] = n(v) ? u(v) : [v];
                typeof S == "string" && typeof t4(d) == "string" ? d[d.length - 1] += S : d.push(S), d.push(...b);
              }
              return d.length === 0 ? "" : d.length === 1 ? d[0] : Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
            }
            function I(o) {
              return p(o, (d) => x(d));
            }
            function P(o) {
              let d = [], v = o.filter(Boolean);
              for (; v.length > 0; ) {
                let S = v.shift();
                if (S) {
                  if (n(S)) {
                    v.unshift(...u(S));
                    continue;
                  }
                  if (d.length > 0 && typeof t4(d) == "string" && typeof S == "string") {
                    d[d.length - 1] += S;
                    continue;
                  }
                  d.push(S);
                }
              }
              return d;
            }
            function $(o) {
              return p(o, (d) => Array.isArray(d) ? P(d) : d.parts ? Object.assign(Object.assign({}, d), {}, { parts: P(d.parts) }) : d);
            }
            function D(o) {
              return p(o, (d) => typeof d == "string" && d.includes(`
`) ? T(d) : d);
            }
            function T(o) {
              let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
              return a(d, o.split(`
`)).parts;
            }
            function m(o) {
              if (o.type === "line")
                return true;
            }
            function C(o) {
              return y(o, m, false);
            }
            r.exports = { isConcat: n, getDocParts: u, willBreak: g, traverseDoc: l, findInDoc: y, mapDoc: p, propagateBreaks: f, removeLines: _, stripTrailingHardline: N6, normalizeParts: P, normalizeDoc: $, cleanDoc: I, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C };
          } }), qD = te({ "src/document/doc-printer.js"(e, r) {
            "use strict";
            ne();
            var { convertEndOfLineToChars: t4 } = Jn(), s = lt(), a = Oa(), { fill: n, cursor: u, indent: i } = Un(), { isConcat: l, getDocParts: p } = Yt(), y, h2 = 1, g = 2;
            function c() {
              return { value: "", length: 0, queue: [] };
            }
            function f(x, I) {
              return _(x, { type: "indent" }, I);
            }
            function F4(x, I, P) {
              return I === Number.NEGATIVE_INFINITY ? x.root || c() : I < 0 ? _(x, { type: "dedent" }, P) : I ? I.type === "root" ? Object.assign(Object.assign({}, x), {}, { root: x }) : _(x, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P) : x;
            }
            function _(x, I, P) {
              let $ = I.type === "dedent" ? x.queue.slice(0, -1) : [...x.queue, I], D = "", T = 0, m = 0, C = 0;
              for (let k of $)
                switch (k.type) {
                  case "indent":
                    v(), P.useTabs ? o(1) : d(P.tabWidth);
                    break;
                  case "stringAlign":
                    v(), D += k.n, T += k.n.length;
                    break;
                  case "numberAlign":
                    m += 1, C += k.n;
                    break;
                  default:
                    throw new Error(`Unexpected type '${k.type}'`);
                }
              return b(), Object.assign(Object.assign({}, x), {}, { value: D, length: T, queue: $ });
              function o(k) {
                D += "	".repeat(k), T += P.tabWidth * k;
              }
              function d(k) {
                D += " ".repeat(k), T += k;
              }
              function v() {
                P.useTabs ? S() : b();
              }
              function S() {
                m > 0 && o(m), B();
              }
              function b() {
                C > 0 && d(C), B();
              }
              function B() {
                m = 0, C = 0;
              }
            }
            function w(x) {
              if (x.length === 0)
                return 0;
              let I = 0;
              for (; x.length > 0 && typeof s(x) == "string" && /^[\t ]*$/.test(s(x)); )
                I += x.pop().length;
              if (x.length > 0 && typeof s(x) == "string") {
                let P = s(x).replace(/[\t ]*$/, "");
                I += s(x).length - P.length, x[x.length - 1] = P;
              }
              return I;
            }
            function E(x, I, P, $, D) {
              let T = I.length, m = [x], C = [];
              for (; P >= 0; ) {
                if (m.length === 0) {
                  if (T === 0)
                    return true;
                  m.push(I[--T]);
                  continue;
                }
                let { mode: o, doc: d } = m.pop();
                if (typeof d == "string")
                  C.push(d), P -= a(d);
                else if (l(d) || d.type === "fill") {
                  let v = p(d);
                  for (let S = v.length - 1; S >= 0; S--)
                    m.push({ mode: o, doc: v[S] });
                } else
                  switch (d.type) {
                    case "indent":
                    case "align":
                    case "indent-if-break":
                    case "label":
                      m.push({ mode: o, doc: d.contents });
                      break;
                    case "trim":
                      P += w(C);
                      break;
                    case "group": {
                      if (D && d.break)
                        return false;
                      let v = d.break ? h2 : o, S = d.expandedStates && v === h2 ? s(d.expandedStates) : d.contents;
                      m.push({ mode: v, doc: S });
                      break;
                    }
                    case "if-break": {
                      let S = (d.groupId ? y[d.groupId] || g : o) === h2 ? d.breakContents : d.flatContents;
                      S && m.push({ mode: o, doc: S });
                      break;
                    }
                    case "line":
                      if (o === h2 || d.hard)
                        return true;
                      d.soft || (C.push(" "), P--);
                      break;
                    case "line-suffix":
                      $ = true;
                      break;
                    case "line-suffix-boundary":
                      if ($)
                        return false;
                      break;
                  }
              }
              return false;
            }
            function N6(x, I) {
              y = {};
              let P = I.printWidth, $ = t4(I.endOfLine), D = 0, T = [{ ind: c(), mode: h2, doc: x }], m = [], C = false, o = [];
              for (; T.length > 0; ) {
                let { ind: v, mode: S, doc: b } = T.pop();
                if (typeof b == "string") {
                  let B = $ !== `
` ? b.replace(/\n/g, $) : b;
                  m.push(B), D += a(B);
                } else if (l(b)) {
                  let B = p(b);
                  for (let k = B.length - 1; k >= 0; k--)
                    T.push({ ind: v, mode: S, doc: B[k] });
                } else
                  switch (b.type) {
                    case "cursor":
                      m.push(u.placeholder);
                      break;
                    case "indent":
                      T.push({ ind: f(v, I), mode: S, doc: b.contents });
                      break;
                    case "align":
                      T.push({ ind: F4(v, b.n, I), mode: S, doc: b.contents });
                      break;
                    case "trim":
                      D -= w(m);
                      break;
                    case "group":
                      switch (S) {
                        case g:
                          if (!C) {
                            T.push({ ind: v, mode: b.break ? h2 : g, doc: b.contents });
                            break;
                          }
                        case h2: {
                          C = false;
                          let B = { ind: v, mode: g, doc: b.contents }, k = P - D, M = o.length > 0;
                          if (!b.break && E(B, T, k, M))
                            T.push(B);
                          else if (b.expandedStates) {
                            let R4 = s(b.expandedStates);
                            if (b.break) {
                              T.push({ ind: v, mode: h2, doc: R4 });
                              break;
                            } else
                              for (let q = 1; q < b.expandedStates.length + 1; q++)
                                if (q >= b.expandedStates.length) {
                                  T.push({ ind: v, mode: h2, doc: R4 });
                                  break;
                                } else {
                                  let J = b.expandedStates[q], L = { ind: v, mode: g, doc: J };
                                  if (E(L, T, k, M)) {
                                    T.push(L);
                                    break;
                                  }
                                }
                          } else
                            T.push({ ind: v, mode: h2, doc: b.contents });
                          break;
                        }
                      }
                      b.id && (y[b.id] = s(T).mode);
                      break;
                    case "fill": {
                      let B = P - D, { parts: k } = b;
                      if (k.length === 0)
                        break;
                      let [M, R4] = k, q = { ind: v, mode: g, doc: M }, J = { ind: v, mode: h2, doc: M }, L = E(q, [], B, o.length > 0, true);
                      if (k.length === 1) {
                        L ? T.push(q) : T.push(J);
                        break;
                      }
                      let Q = { ind: v, mode: g, doc: R4 }, V = { ind: v, mode: h2, doc: R4 };
                      if (k.length === 2) {
                        L ? T.push(Q, q) : T.push(V, J);
                        break;
                      }
                      k.splice(0, 2);
                      let j = { ind: v, mode: S, doc: n(k) }, Y = k[0];
                      E({ ind: v, mode: g, doc: [M, R4, Y] }, [], B, o.length > 0, true) ? T.push(j, Q, q) : L ? T.push(j, V, q) : T.push(j, V, J);
                      break;
                    }
                    case "if-break":
                    case "indent-if-break": {
                      let B = b.groupId ? y[b.groupId] : S;
                      if (B === h2) {
                        let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
                        k && T.push({ ind: v, mode: S, doc: k });
                      }
                      if (B === g) {
                        let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
                        k && T.push({ ind: v, mode: S, doc: k });
                      }
                      break;
                    }
                    case "line-suffix":
                      o.push({ ind: v, mode: S, doc: b.contents });
                      break;
                    case "line-suffix-boundary":
                      o.length > 0 && T.push({ ind: v, mode: S, doc: { type: "line", hard: true } });
                      break;
                    case "line":
                      switch (S) {
                        case g:
                          if (b.hard)
                            C = true;
                          else {
                            b.soft || (m.push(" "), D += 1);
                            break;
                          }
                        case h2:
                          if (o.length > 0) {
                            T.push({ ind: v, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                            break;
                          }
                          b.literal ? v.root ? (m.push($, v.root.value), D = v.root.length) : (m.push($), D = 0) : (D -= w(m), m.push($ + v.value), D = v.length);
                          break;
                      }
                      break;
                    case "label":
                      T.push({ ind: v, mode: S, doc: b.contents });
                      break;
                    default:
                  }
                T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
              }
              let d = m.indexOf(u.placeholder);
              if (d !== -1) {
                let v = m.indexOf(u.placeholder, d + 1), S = m.slice(0, d).join(""), b = m.slice(d + 1, v).join(""), B = m.slice(v + 1).join("");
                return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
              }
              return { formatted: m.join("") };
            }
            r.exports = { printDocToString: N6 };
          } }), MD = te({ "src/document/doc-debug.js"(e, r) {
            "use strict";
            ne();
            var { isConcat: t4, getDocParts: s } = Yt();
            function a(u) {
              if (!u)
                return "";
              if (t4(u)) {
                let i = [];
                for (let l of s(u))
                  if (t4(l))
                    i.push(...a(l).parts);
                  else {
                    let p = a(l);
                    p !== "" && i.push(p);
                  }
                return { type: "concat", parts: i };
              }
              return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
            }
            function n(u) {
              let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
              return p(a(u));
              function p(h2, g, c) {
                if (typeof h2 == "string")
                  return JSON.stringify(h2);
                if (t4(h2)) {
                  let f = s(h2).map(p).filter(Boolean);
                  return f.length === 1 ? f[0] : `[${f.join(", ")}]`;
                }
                if (h2.type === "line") {
                  let f = Array.isArray(c) && c[g + 1] && c[g + 1].type === "break-parent";
                  return h2.literal ? f ? "literalline" : "literallineWithoutBreakParent" : h2.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : h2.soft ? "softline" : "line";
                }
                if (h2.type === "break-parent")
                  return Array.isArray(c) && c[g - 1] && c[g - 1].type === "line" && c[g - 1].hard ? void 0 : "breakParent";
                if (h2.type === "trim")
                  return "trim";
                if (h2.type === "indent")
                  return "indent(" + p(h2.contents) + ")";
                if (h2.type === "align")
                  return h2.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p(h2.contents) + ")" : h2.n < 0 ? "dedent(" + p(h2.contents) + ")" : h2.n.type === "root" ? "markAsRoot(" + p(h2.contents) + ")" : "align(" + JSON.stringify(h2.n) + ", " + p(h2.contents) + ")";
                if (h2.type === "if-break")
                  return "ifBreak(" + p(h2.breakContents) + (h2.flatContents ? ", " + p(h2.flatContents) : "") + (h2.groupId ? (h2.flatContents ? "" : ', ""') + `, { groupId: ${y(h2.groupId)} }` : "") + ")";
                if (h2.type === "indent-if-break") {
                  let f = [];
                  h2.negate && f.push("negate: true"), h2.groupId && f.push(`groupId: ${y(h2.groupId)}`);
                  let F4 = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                  return `indentIfBreak(${p(h2.contents)}${F4})`;
                }
                if (h2.type === "group") {
                  let f = [];
                  h2.break && h2.break !== "propagated" && f.push("shouldBreak: true"), h2.id && f.push(`id: ${y(h2.id)}`);
                  let F4 = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                  return h2.expandedStates ? `conditionalGroup([${h2.expandedStates.map((_) => p(_)).join(",")}]${F4})` : `group(${p(h2.contents)}${F4})`;
                }
                if (h2.type === "fill")
                  return `fill([${h2.parts.map((f) => p(f)).join(", ")}])`;
                if (h2.type === "line-suffix")
                  return "lineSuffix(" + p(h2.contents) + ")";
                if (h2.type === "line-suffix-boundary")
                  return "lineSuffixBoundary";
                if (h2.type === "label")
                  return `label(${JSON.stringify(h2.label)}, ${p(h2.contents)})`;
                throw new Error("Unknown doc type " + h2.type);
              }
              function y(h2) {
                if (typeof h2 != "symbol")
                  return JSON.stringify(String(h2));
                if (h2 in i)
                  return i[h2];
                let g = String(h2).slice(7, -1) || "symbol";
                for (let c = 0; ; c++) {
                  let f = g + (c > 0 ? ` #${c}` : "");
                  if (!l.has(f))
                    return l.add(f), i[h2] = `Symbol.for(${JSON.stringify(f)})`;
                }
              }
            }
            r.exports = { printDocToDebug: n };
          } }), qe = te({ "src/document/index.js"(e, r) {
            "use strict";
            ne(), r.exports = { builders: Un(), printer: qD(), utils: Yt(), debug: MD() };
          } }), ja = {};
          Kt(ja, { default: () => RD });
          function RD(e) {
            if (typeof e != "string")
              throw new TypeError("Expected a string");
            return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
          }
          var $D = ht({ "node_modules/escape-string-regexp/index.js"() {
            ne();
          } }), qa = te({ "node_modules/semver/internal/debug.js"(e, r) {
            ne();
            var t4 = typeof wt == "object" && wt.env && wt.env.NODE_DEBUG && /\bsemver\b/i.test(wt.env.NODE_DEBUG) ? function() {
              for (var s = arguments.length, a = new Array(s), n = 0; n < s; n++)
                a[n] = arguments[n];
              return console.error("SEMVER", ...a);
            } : () => {
            };
            r.exports = t4;
          } }), Ma = te({ "node_modules/semver/internal/constants.js"(e, r) {
            ne();
            var t4 = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
            r.exports = { SEMVER_SPEC_VERSION: t4, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: n };
          } }), VD = te({ "node_modules/semver/internal/re.js"(e, r) {
            ne();
            var { MAX_SAFE_COMPONENT_LENGTH: t4 } = Ma(), s = qa();
            e = r.exports = {};
            var a = e.re = [], n = e.src = [], u = e.t = {}, i = 0, l = (p, y, h2) => {
              let g = i++;
              s(p, g, y), u[p] = g, n[g] = y, a[g] = new RegExp(y, h2 ? "g" : void 0);
            };
            l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\.${n[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n[u.BUILDIDENTIFIER]}(?:\\.${n[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`), l("FULL", `^${n[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`), l("LOOSE", `^${n[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`), l("XRANGE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t4}})(?:\\.(\\d{1,${t4}}))?(?:\\.(\\d{1,${t4}}))?(?:$|[^\\d])`), l("COERCERTL", n[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n[u.GTLT]}\\s*(${n[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n[u.XRANGEPLAIN]})\\s+-\\s+(${n[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
          } }), WD = te({ "node_modules/semver/internal/parse-options.js"(e, r) {
            ne();
            var t4 = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t4.filter((n) => a[n]).reduce((n, u) => (n[u] = true, n), {}) : {};
            r.exports = s;
          } }), HD = te({ "node_modules/semver/internal/identifiers.js"(e, r) {
            ne();
            var t4 = /^[0-9]+$/, s = (n, u) => {
              let i = t4.test(n), l = t4.test(u);
              return i && l && (n = +n, u = +u), n === u ? 0 : i && !l ? -1 : l && !i ? 1 : n < u ? -1 : 1;
            }, a = (n, u) => s(u, n);
            r.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
          } }), GD = te({ "node_modules/semver/classes/semver.js"(e, r) {
            ne();
            var t4 = qa(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = Ma(), { re: n, t: u } = VD(), i = WD(), { compareIdentifiers: l } = HD(), p = class {
              constructor(y, h2) {
                if (h2 = i(h2), y instanceof p) {
                  if (y.loose === !!h2.loose && y.includePrerelease === !!h2.includePrerelease)
                    return y;
                  y = y.version;
                } else if (typeof y != "string")
                  throw new TypeError(`Invalid Version: ${y}`);
                if (y.length > s)
                  throw new TypeError(`version is longer than ${s} characters`);
                t4("SemVer", y, h2), this.options = h2, this.loose = !!h2.loose, this.includePrerelease = !!h2.includePrerelease;
                let g = y.trim().match(h2.loose ? n[u.LOOSE] : n[u.FULL]);
                if (!g)
                  throw new TypeError(`Invalid Version: ${y}`);
                if (this.raw = y, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a || this.major < 0)
                  throw new TypeError("Invalid major version");
                if (this.minor > a || this.minor < 0)
                  throw new TypeError("Invalid minor version");
                if (this.patch > a || this.patch < 0)
                  throw new TypeError("Invalid patch version");
                g[4] ? this.prerelease = g[4].split(".").map((c) => {
                  if (/^[0-9]+$/.test(c)) {
                    let f = +c;
                    if (f >= 0 && f < a)
                      return f;
                  }
                  return c;
                }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
              }
              format() {
                return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
              }
              toString() {
                return this.version;
              }
              compare(y) {
                if (t4("SemVer.compare", this.version, this.options, y), !(y instanceof p)) {
                  if (typeof y == "string" && y === this.version)
                    return 0;
                  y = new p(y, this.options);
                }
                return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);
              }
              compareMain(y) {
                return y instanceof p || (y = new p(y, this.options)), l(this.major, y.major) || l(this.minor, y.minor) || l(this.patch, y.patch);
              }
              comparePre(y) {
                if (y instanceof p || (y = new p(y, this.options)), this.prerelease.length && !y.prerelease.length)
                  return -1;
                if (!this.prerelease.length && y.prerelease.length)
                  return 1;
                if (!this.prerelease.length && !y.prerelease.length)
                  return 0;
                let h2 = 0;
                do {
                  let g = this.prerelease[h2], c = y.prerelease[h2];
                  if (t4("prerelease compare", h2, g, c), g === void 0 && c === void 0)
                    return 0;
                  if (c === void 0)
                    return 1;
                  if (g === void 0)
                    return -1;
                  if (g === c)
                    continue;
                  return l(g, c);
                } while (++h2);
              }
              compareBuild(y) {
                y instanceof p || (y = new p(y, this.options));
                let h2 = 0;
                do {
                  let g = this.build[h2], c = y.build[h2];
                  if (t4("prerelease compare", h2, g, c), g === void 0 && c === void 0)
                    return 0;
                  if (c === void 0)
                    return 1;
                  if (g === void 0)
                    return -1;
                  if (g === c)
                    continue;
                  return l(g, c);
                } while (++h2);
              }
              inc(y, h2) {
                switch (y) {
                  case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h2);
                    break;
                  case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h2);
                    break;
                  case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", h2), this.inc("pre", h2);
                    break;
                  case "prerelease":
                    this.prerelease.length === 0 && this.inc("patch", h2), this.inc("pre", h2);
                    break;
                  case "major":
                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                  case "minor":
                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                  case "patch":
                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                    break;
                  case "pre":
                    if (this.prerelease.length === 0)
                      this.prerelease = [0];
                    else {
                      let g = this.prerelease.length;
                      for (; --g >= 0; )
                        typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
                      g === -1 && this.prerelease.push(0);
                    }
                    h2 && (l(this.prerelease[0], h2) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h2, 0]) : this.prerelease = [h2, 0]);
                    break;
                  default:
                    throw new Error(`invalid increment argument: ${y}`);
                }
                return this.format(), this.raw = this.version, this;
              }
            };
            r.exports = p;
          } }), zn = te({ "node_modules/semver/functions/compare.js"(e, r) {
            ne();
            var t4 = GD(), s = (a, n, u) => new t4(a, u).compare(new t4(n, u));
            r.exports = s;
          } }), UD = te({ "node_modules/semver/functions/lt.js"(e, r) {
            ne();
            var t4 = zn(), s = (a, n, u) => t4(a, n, u) < 0;
            r.exports = s;
          } }), JD = te({ "node_modules/semver/functions/gte.js"(e, r) {
            ne();
            var t4 = zn(), s = (a, n, u) => t4(a, n, u) >= 0;
            r.exports = s;
          } }), zD = te({ "src/utils/arrayify.js"(e, r) {
            "use strict";
            ne(), r.exports = (t4, s) => Object.entries(t4).map((a) => {
              let [n, u] = a;
              return Object.assign({ [s]: n }, u);
            });
          } }), XD = te({ "node_modules/outdent/lib/index.js"(e, r) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
            function t4() {
              for (var E = [], N6 = 0; N6 < arguments.length; N6++)
                E[N6] = arguments[N6];
            }
            function s() {
              return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
            }
            function a() {
              return { add: t4, delete: t4, get: t4, set: t4, has: function(E) {
                return false;
              } };
            }
            var n = Object.prototype.hasOwnProperty, u = function(E, N6) {
              return n.call(E, N6);
            };
            function i(E, N6) {
              for (var x in N6)
                u(N6, x) && (E[x] = N6[x]);
              return E;
            }
            var l = /^[ \t]*(?:\r\n|\r|\n)/, p = /(?:\r\n|\r|\n)[ \t]*$/, y = /^(?:[\r\n]|$)/, h2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
            function c(E, N6, x) {
              var I = 0, P = E[0].match(h2);
              P && (I = P[1].length);
              var $ = "(\\r\\n|\\r|\\n).{0," + I + "}", D = new RegExp($, "g");
              N6 && (E = E.slice(1));
              var T = x.newline, m = x.trimLeadingNewline, C = x.trimTrailingNewline, o = typeof T == "string", d = E.length, v = E.map(function(S, b) {
                return S = S.replace(D, "$1"), b === 0 && m && (S = S.replace(l, "")), b === d - 1 && C && (S = S.replace(p, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
                  return T;
                })), S;
              });
              return v;
            }
            function f(E, N6) {
              for (var x = "", I = 0, P = E.length; I < P; I++)
                x += E[I], I < P - 1 && (x += N6[I]);
              return x;
            }
            function F4(E) {
              return u(E, "raw") && u(E, "length");
            }
            function _(E) {
              var N6 = s(), x = s();
              function I($) {
                for (var D = [], T = 1; T < arguments.length; T++)
                  D[T - 1] = arguments[T];
                if (F4($)) {
                  var m = $, C = (D[0] === I || D[0] === w) && g.test(m[0]) && y.test(m[1]), o = C ? x : N6, d = o.get(m);
                  if (d || (d = c(m, C, E), o.set(m, d)), D.length === 0)
                    return d[0];
                  var v = f(d, C ? D.slice(1) : D);
                  return v;
                } else
                  return _(i(i({}, E), $ || {}));
              }
              var P = i(I, { string: function($) {
                return c([$], false, E)[0];
              } });
              return P;
            }
            var w = _({ trimLeadingNewline: true, trimTrailingNewline: true });
            if (e.outdent = w, e.default = w, typeof r < "u")
              try {
                r.exports = w, Object.defineProperty(w, "__esModule", { value: true }), w.default = w, w.outdent = w;
              } catch {
              }
          } }), KD = te({ "src/main/core-options.js"(e, r) {
            "use strict";
            ne();
            var { outdent: t4 } = XD(), s = "Config", a = "Editor", n = "Format", u = "Other", i = "Output", l = "Global", p = "Special", y = { cursorOffset: { since: "1.4.0", category: p, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t4`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t4`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h2) => typeof h2 == "string" || typeof h2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h2) => typeof h2 == "string" || typeof h2 == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t4`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h2) => typeof h2 == "string" || typeof h2 == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t4`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: p, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t4`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: p, type: "boolean", default: false, description: t4`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
            r.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: n, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p, options: y };
          } }), Xn = te({ "src/main/support.js"(e, r) {
            "use strict";
            ne();
            var t4 = { compare: zn(), lt: UD(), gte: JD() }, s = zD(), a = Ia().version, n = KD().options;
            function u() {
              let { plugins: l = [], showUnreleased: p = false, showDeprecated: y = false, showInternal: h2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = a.split("-", 1)[0], c = l.flatMap((E) => E.languages || []).filter(F4), f = s(Object.assign({}, ...l.map((E) => {
                let { options: N6 } = E;
                return N6;
              }), n), "name").filter((E) => F4(E) && _(E)).sort((E, N6) => E.name === N6.name ? 0 : E.name < N6.name ? -1 : 1).map(w).map((E) => {
                E = Object.assign({}, E), Array.isArray(E.default) && (E.default = E.default.length === 1 ? E.default[0].value : E.default.filter(F4).sort((x, I) => t4.compare(I.since, x.since))[0].value), Array.isArray(E.choices) && (E.choices = E.choices.filter((x) => F4(x) && _(x)), E.name === "parser" && i(E, c, l));
                let N6 = Object.fromEntries(l.filter((x) => x.defaultOptions && x.defaultOptions[E.name] !== void 0).map((x) => [x.name, x.defaultOptions[E.name]]));
                return Object.assign(Object.assign({}, E), {}, { pluginDefaults: N6 });
              });
              return { languages: c, options: f };
              function F4(E) {
                return p || !("since" in E) || E.since && t4.gte(g, E.since);
              }
              function _(E) {
                return y || !("deprecated" in E) || E.deprecated && t4.lt(g, E.deprecated);
              }
              function w(E) {
                if (h2)
                  return E;
                let { cliName: N6, cliCategory: x, cliDescription: I } = E;
                return Hn(E, hD);
              }
            }
            function i(l, p, y) {
              let h2 = new Set(l.choices.map((g) => g.value));
              for (let g of p)
                if (g.parsers) {
                  for (let c of g.parsers)
                    if (!h2.has(c)) {
                      h2.add(c);
                      let f = y.find((_) => _.parsers && _.parsers[c]), F4 = g.name;
                      f && f.name && (F4 += ` (plugin: ${f.name})`), l.choices.push({ value: c, description: F4 });
                    }
                }
            }
            r.exports = { getSupportInfo: u };
          } }), Kn = te({ "src/utils/is-non-empty-array.js"(e, r) {
            "use strict";
            ne();
            function t4(s) {
              return Array.isArray(s) && s.length > 0;
            }
            r.exports = t4;
          } }), Pr = te({ "src/utils/text/skip.js"(e, r) {
            "use strict";
            ne();
            function t4(i) {
              return (l, p, y) => {
                let h2 = y && y.backwards;
                if (p === false)
                  return false;
                let { length: g } = l, c = p;
                for (; c >= 0 && c < g; ) {
                  let f = l.charAt(c);
                  if (i instanceof RegExp) {
                    if (!i.test(f))
                      return c;
                  } else if (!i.includes(f))
                    return c;
                  h2 ? c-- : c++;
                }
                return c === -1 || c === g ? c : false;
              };
            }
            var s = t4(/\s/), a = t4(" 	"), n = t4(",; 	"), u = t4(/[^\n\r]/);
            r.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: n, skipEverythingButNewLine: u };
          } }), Ra = te({ "src/utils/text/skip-inline-comment.js"(e, r) {
            "use strict";
            ne();
            function t4(s, a) {
              if (a === false)
                return false;
              if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
                for (let n = a + 2; n < s.length; ++n)
                  if (s.charAt(n) === "*" && s.charAt(n + 1) === "/")
                    return n + 2;
              }
              return a;
            }
            r.exports = t4;
          } }), $a = te({ "src/utils/text/skip-trailing-comment.js"(e, r) {
            "use strict";
            ne();
            var { skipEverythingButNewLine: t4 } = Pr();
            function s(a, n) {
              return n === false ? false : a.charAt(n) === "/" && a.charAt(n + 1) === "/" ? t4(a, n) : n;
            }
            r.exports = s;
          } }), Va = te({ "src/utils/text/skip-newline.js"(e, r) {
            "use strict";
            ne();
            function t4(s, a, n) {
              let u = n && n.backwards;
              if (a === false)
                return false;
              let i = s.charAt(a);
              if (u) {
                if (s.charAt(a - 1) === "\r" && i === `
`)
                  return a - 2;
                if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                  return a - 1;
              } else {
                if (i === "\r" && s.charAt(a + 1) === `
`)
                  return a + 2;
                if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                  return a + 1;
              }
              return a;
            }
            r.exports = t4;
          } }), YD = te({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
            "use strict";
            ne();
            var t4 = Ra(), s = Va(), a = $a(), { skipSpaces: n } = Pr();
            function u(i, l) {
              let p = null, y = l;
              for (; y !== p; )
                p = y, y = n(i, y), y = t4(i, y), y = a(i, y), y = s(i, y);
              return y;
            }
            r.exports = u;
          } }), Ue = te({ "src/common/util.js"(e, r) {
            "use strict";
            ne();
            var { default: t4 } = ($D(), ft(ja)), s = lt(), { getSupportInfo: a } = Xn(), n = Kn(), u = Oa(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y } = Pr(), h2 = Ra(), g = $a(), c = Va(), f = YD(), F4 = (V) => V[V.length - 2];
            function _(V) {
              return (j, Y, ie) => {
                let ee = ie && ie.backwards;
                if (Y === false)
                  return false;
                let { length: ce } = j, W = Y;
                for (; W >= 0 && W < ce; ) {
                  let K = j.charAt(W);
                  if (V instanceof RegExp) {
                    if (!V.test(K))
                      return W;
                  } else if (!V.includes(K))
                    return W;
                  ee ? W-- : W++;
                }
                return W === -1 || W === ce ? W : false;
              };
            }
            function w(V, j) {
              let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie = l(V, Y.backwards ? j - 1 : j, Y), ee = c(V, ie, Y);
              return ie !== ee;
            }
            function E(V, j, Y) {
              for (let ie = j; ie < Y; ++ie)
                if (V.charAt(ie) === `
`)
                  return true;
              return false;
            }
            function N6(V, j, Y) {
              let ie = Y(j) - 1;
              ie = l(V, ie, { backwards: true }), ie = c(V, ie, { backwards: true }), ie = l(V, ie, { backwards: true });
              let ee = c(V, ie, { backwards: true });
              return ie !== ee;
            }
            function x(V, j) {
              let Y = null, ie = j;
              for (; ie !== Y; )
                Y = ie, ie = p(V, ie), ie = h2(V, ie), ie = l(V, ie);
              return ie = g(V, ie), ie = c(V, ie), ie !== false && w(V, ie);
            }
            function I(V, j, Y) {
              return x(V, Y(j));
            }
            function P(V, j, Y) {
              return f(V, Y(j));
            }
            function $(V, j, Y) {
              return V.charAt(P(V, j, Y));
            }
            function D(V, j) {
              let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return l(V, Y.backwards ? j - 1 : j, Y) !== j;
            }
            function T(V, j) {
              let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie = 0;
              for (let ee = Y; ee < V.length; ++ee)
                V[ee] === "	" ? ie = ie + j - ie % j : ie++;
              return ie;
            }
            function m(V, j) {
              let Y = V.lastIndexOf(`
`);
              return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\t ]*/)[0], j);
            }
            function C(V, j) {
              let Y = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee = j === "'" ? ie : Y, ce = ee === ie ? Y : ie, W = ee;
              if (V.includes(ee.quote) || V.includes(ce.quote)) {
                let K = (V.match(ee.regex) || []).length, de = (V.match(ce.regex) || []).length;
                W = K > de ? ce : ee;
              }
              return W;
            }
            function o(V, j) {
              let Y = V.slice(1, -1), ie = j.parser === "json" || j.parser === "json5" && j.quoteProps === "preserve" && !j.singleQuote ? '"' : j.__isInHtmlAttribute ? "'" : C(Y, j.singleQuote ? "'" : '"').quote;
              return d(Y, ie, !(j.parser === "css" || j.parser === "less" || j.parser === "scss" || j.__embeddedInHtml));
            }
            function d(V, j, Y) {
              let ie = j === '"' ? "'" : '"', ee = /\\(.)|(["'])/gs, ce = V.replace(ee, (W, K, de) => K === ie ? K : de === j ? "\\" + de : de || (Y && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K) ? K : "\\" + K));
              return j + ce + j;
            }
            function v(V) {
              return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
            }
            function S(V, j) {
              let Y = V.match(new RegExp(`(${t4(j)})+`, "g"));
              return Y === null ? 0 : Y.reduce((ie, ee) => Math.max(ie, ee.length / j.length), 0);
            }
            function b(V, j) {
              let Y = V.match(new RegExp(`(${t4(j)})+`, "g"));
              if (Y === null)
                return 0;
              let ie = /* @__PURE__ */ new Map(), ee = 0;
              for (let ce of Y) {
                let W = ce.length / j.length;
                ie.set(W, true), W > ee && (ee = W);
              }
              for (let ce = 1; ce < ee; ce++)
                if (!ie.get(ce))
                  return ce;
              return ee + 1;
            }
            function B(V, j) {
              (V.comments || (V.comments = [])).push(j), j.printed = false, j.nodeDescription = Q(V);
            }
            function k(V, j) {
              j.leading = true, j.trailing = false, B(V, j);
            }
            function M(V, j, Y) {
              j.leading = false, j.trailing = false, Y && (j.marker = Y), B(V, j);
            }
            function R4(V, j) {
              j.leading = false, j.trailing = true, B(V, j);
            }
            function q(V, j) {
              let { languages: Y } = a({ plugins: j.plugins }), ie = Y.find((ee) => {
                let { name: ce } = ee;
                return ce.toLowerCase() === V;
              }) || Y.find((ee) => {
                let { aliases: ce } = ee;
                return Array.isArray(ce) && ce.includes(V);
              }) || Y.find((ee) => {
                let { extensions: ce } = ee;
                return Array.isArray(ce) && ce.includes(`.${V}`);
              });
              return ie && ie.parsers[0];
            }
            function J(V) {
              return V && V.type === "front-matter";
            }
            function L(V) {
              let j = /* @__PURE__ */ new WeakMap();
              return function(Y) {
                return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);
              };
            }
            function Q(V) {
              let j = V.type || V.kind || "(unknown type)", Y = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
              return Y.length > 20 && (Y = Y.slice(0, 19) + "\u2026"), j + (Y ? " " + Y : "");
            }
            r.exports = { inferParserByLanguage: q, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: F4, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $, skip: _, skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y, skipInlineComment: h2, skipTrailingComment: g, skipNewline: c, isNextLineEmptyAfterIndex: x, isNextLineEmpty: I, isPreviousLineEmpty: N6, hasNewline: w, hasNewlineInRange: E, hasSpaces: D, getAlignmentSize: T, getIndentSize: m, getPreferredQuote: C, printString: o, printNumber: v, makeString: d, addLeadingComment: k, addDanglingComment: M, addTrailingComment: R4, isFrontMatterNode: J, isNonEmptyArray: n, createGroupIdMapper: L };
          } }), Wa = {};
          Kt(Wa, { basename: () => za, default: () => Ka, delimiter: () => Mn, dirname: () => Ja, extname: () => Xa, isAbsolute: () => Qn, join: () => Ga, normalize: () => Yn, relative: () => Ua, resolve: () => wr, sep: () => qn });
          function Ha(e, r) {
            for (var t4 = 0, s = e.length - 1; s >= 0; s--) {
              var a = e[s];
              a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t4++) : t4 && (e.splice(s, 1), t4--);
            }
            if (r)
              for (; t4--; t4)
                e.unshift("..");
            return e;
          }
          function wr() {
            for (var e = "", r = false, t4 = arguments.length - 1; t4 >= -1 && !r; t4--) {
              var s = t4 >= 0 ? arguments[t4] : "/";
              if (typeof s != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              if (!s)
                continue;
              e = s + "/" + e, r = s.charAt(0) === "/";
            }
            return e = Ha(Zn(e.split("/"), function(a) {
              return !!a;
            }), !r).join("/"), (r ? "/" : "") + e || ".";
          }
          function Yn(e) {
            var r = Qn(e), t4 = Ya(e, -1) === "/";
            return e = Ha(Zn(e.split("/"), function(s) {
              return !!s;
            }), !r).join("/"), !e && !r && (e = "."), e && t4 && (e += "/"), (r ? "/" : "") + e;
          }
          function Qn(e) {
            return e.charAt(0) === "/";
          }
          function Ga() {
            var e = Array.prototype.slice.call(arguments, 0);
            return Yn(Zn(e, function(r, t4) {
              if (typeof r != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return r;
            }).join("/"));
          }
          function Ua(e, r) {
            e = wr(e).substr(1), r = wr(r).substr(1);
            function t4(p) {
              for (var y = 0; y < p.length && p[y] === ""; y++)
                ;
              for (var h2 = p.length - 1; h2 >= 0 && p[h2] === ""; h2--)
                ;
              return y > h2 ? [] : p.slice(y, h2 - y + 1);
            }
            for (var s = t4(e.split("/")), a = t4(r.split("/")), n = Math.min(s.length, a.length), u = n, i = 0; i < n; i++)
              if (s[i] !== a[i]) {
                u = i;
                break;
              }
            for (var l = [], i = u; i < s.length; i++)
              l.push("..");
            return l = l.concat(a.slice(u)), l.join("/");
          }
          function Ja(e) {
            var r = Ir(e), t4 = r[0], s = r[1];
            return !t4 && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t4 + s);
          }
          function za(e, r) {
            var t4 = Ir(e)[2];
            return r && t4.substr(-1 * r.length) === r && (t4 = t4.substr(0, t4.length - r.length)), t4;
          }
          function Xa(e) {
            return Ir(e)[3];
          }
          function Zn(e, r) {
            if (e.filter)
              return e.filter(r);
            for (var t4 = [], s = 0; s < e.length; s++)
              r(e[s], s, e) && t4.push(e[s]);
            return t4;
          }
          var Na, Ir, qn, Mn, Ka, Ya, QD = ht({ "node-modules-polyfills:path"() {
            ne(), Na = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Ir = function(e) {
              return Na.exec(e).slice(1);
            }, qn = "/", Mn = ":", Ka = { extname: Xa, basename: za, dirname: Ja, sep: qn, delimiter: Mn, relative: Ua, join: Ga, isAbsolute: Qn, normalize: Yn, resolve: wr }, Ya = "ab".substr(-1) === "b" ? function(e, r, t4) {
              return e.substr(r, t4);
            } : function(e, r, t4) {
              return r < 0 && (r = e.length + r), e.substr(r, t4);
            };
          } }), ZD = te({ "node-modules-polyfills-commonjs:path"(e, r) {
            ne();
            var t4 = (QD(), ft(Wa));
            if (t4 && t4.default) {
              r.exports = t4.default;
              for (let s in t4)
                r.exports[s] = t4[s];
            } else
              t4 && (r.exports = t4);
          } }), Qt = te({ "src/common/errors.js"(e, r) {
            "use strict";
            ne();
            var t4 = class extends Error {
            }, s = class extends Error {
            }, a = class extends Error {
            }, n = class extends Error {
            };
            r.exports = { ConfigError: t4, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: n };
          } }), vt = {};
          Kt(vt, { __assign: () => Nr, __asyncDelegator: () => fm, __asyncGenerator: () => pm, __asyncValues: () => Dm, __await: () => Xt, __awaiter: () => sm, __classPrivateFieldGet: () => ym, __classPrivateFieldSet: () => hm, __createBinding: () => am, __decorate: () => rm, __exportStar: () => om, __extends: () => em, __generator: () => im, __importDefault: () => gm, __importStar: () => dm, __makeTemplateObject: () => mm, __metadata: () => um, __param: () => nm, __read: () => Qa, __rest: () => tm, __spread: () => lm, __spreadArrays: () => cm, __values: () => Rn });
          function em(e, r) {
            Br(e, r);
            function t4() {
              this.constructor = e;
            }
            e.prototype = r === null ? Object.create(r) : (t4.prototype = r.prototype, new t4());
          }
          function tm(e, r) {
            var t4 = {};
            for (var s in e)
              Object.prototype.hasOwnProperty.call(e, s) && r.indexOf(s) < 0 && (t4[s] = e[s]);
            if (e != null && typeof Object.getOwnPropertySymbols == "function")
              for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++)
                r.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t4[s[a]] = e[s[a]]);
            return t4;
          }
          function rm(e, r, t4, s) {
            var a = arguments.length, n = a < 3 ? r : s === null ? s = Object.getOwnPropertyDescriptor(r, t4) : s, u;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
              n = Reflect.decorate(e, r, t4, s);
            else
              for (var i = e.length - 1; i >= 0; i--)
                (u = e[i]) && (n = (a < 3 ? u(n) : a > 3 ? u(r, t4, n) : u(r, t4)) || n);
            return a > 3 && n && Object.defineProperty(r, t4, n), n;
          }
          function nm(e, r) {
            return function(t4, s) {
              r(t4, s, e);
            };
          }
          function um(e, r) {
            if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
              return Reflect.metadata(e, r);
          }
          function sm(e, r, t4, s) {
            function a(n) {
              return n instanceof t4 ? n : new t4(function(u) {
                u(n);
              });
            }
            return new (t4 || (t4 = Promise))(function(n, u) {
              function i(y) {
                try {
                  p(s.next(y));
                } catch (h2) {
                  u(h2);
                }
              }
              function l(y) {
                try {
                  p(s.throw(y));
                } catch (h2) {
                  u(h2);
                }
              }
              function p(y) {
                y.done ? n(y.value) : a(y.value).then(i, l);
              }
              p((s = s.apply(e, r || [])).next());
            });
          }
          function im(e, r) {
            var t4 = { label: 0, sent: function() {
              if (n[0] & 1)
                throw n[1];
              return n[1];
            }, trys: [], ops: [] }, s, a, n, u;
            return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
              return this;
            }), u;
            function i(p) {
              return function(y) {
                return l([p, y]);
              };
            }
            function l(p) {
              if (s)
                throw new TypeError("Generator is already executing.");
              for (; t4; )
                try {
                  if (s = 1, a && (n = p[0] & 2 ? a.return : p[0] ? a.throw || ((n = a.return) && n.call(a), 0) : a.next) && !(n = n.call(a, p[1])).done)
                    return n;
                  switch (a = 0, n && (p = [p[0] & 2, n.value]), p[0]) {
                    case 0:
                    case 1:
                      n = p;
                      break;
                    case 4:
                      return t4.label++, { value: p[1], done: false };
                    case 5:
                      t4.label++, a = p[1], p = [0];
                      continue;
                    case 7:
                      p = t4.ops.pop(), t4.trys.pop();
                      continue;
                    default:
                      if (n = t4.trys, !(n = n.length > 0 && n[n.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                        t4 = 0;
                        continue;
                      }
                      if (p[0] === 3 && (!n || p[1] > n[0] && p[1] < n[3])) {
                        t4.label = p[1];
                        break;
                      }
                      if (p[0] === 6 && t4.label < n[1]) {
                        t4.label = n[1], n = p;
                        break;
                      }
                      if (n && t4.label < n[2]) {
                        t4.label = n[2], t4.ops.push(p);
                        break;
                      }
                      n[2] && t4.ops.pop(), t4.trys.pop();
                      continue;
                  }
                  p = r.call(e, t4);
                } catch (y) {
                  p = [6, y], a = 0;
                } finally {
                  s = n = 0;
                }
              if (p[0] & 5)
                throw p[1];
              return { value: p[0] ? p[1] : void 0, done: true };
            }
          }
          function am(e, r, t4, s) {
            s === void 0 && (s = t4), e[s] = r[t4];
          }
          function om(e, r) {
            for (var t4 in e)
              t4 !== "default" && !r.hasOwnProperty(t4) && (r[t4] = e[t4]);
          }
          function Rn(e) {
            var r = typeof Symbol == "function" && Symbol.iterator, t4 = r && e[r], s = 0;
            if (t4)
              return t4.call(e);
            if (e && typeof e.length == "number")
              return { next: function() {
                return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
              } };
            throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }
          function Qa(e, r) {
            var t4 = typeof Symbol == "function" && e[Symbol.iterator];
            if (!t4)
              return e;
            var s = t4.call(e), a, n = [], u;
            try {
              for (; (r === void 0 || r-- > 0) && !(a = s.next()).done; )
                n.push(a.value);
            } catch (i) {
              u = { error: i };
            } finally {
              try {
                a && !a.done && (t4 = s.return) && t4.call(s);
              } finally {
                if (u)
                  throw u.error;
              }
            }
            return n;
          }
          function lm() {
            for (var e = [], r = 0; r < arguments.length; r++)
              e = e.concat(Qa(arguments[r]));
            return e;
          }
          function cm() {
            for (var e = 0, r = 0, t4 = arguments.length; r < t4; r++)
              e += arguments[r].length;
            for (var s = Array(e), a = 0, r = 0; r < t4; r++)
              for (var n = arguments[r], u = 0, i = n.length; u < i; u++, a++)
                s[a] = n[u];
            return s;
          }
          function Xt(e) {
            return this instanceof Xt ? (this.v = e, this) : new Xt(e);
          }
          function pm(e, r, t4) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var s = t4.apply(e, r || []), a, n = [];
            return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
              return this;
            }, a;
            function u(g) {
              s[g] && (a[g] = function(c) {
                return new Promise(function(f, F4) {
                  n.push([g, c, f, F4]) > 1 || i(g, c);
                });
              });
            }
            function i(g, c) {
              try {
                l(s[g](c));
              } catch (f) {
                h2(n[0][3], f);
              }
            }
            function l(g) {
              g.value instanceof Xt ? Promise.resolve(g.value.v).then(p, y) : h2(n[0][2], g);
            }
            function p(g) {
              i("next", g);
            }
            function y(g) {
              i("throw", g);
            }
            function h2(g, c) {
              g(c), n.shift(), n.length && i(n[0][0], n[0][1]);
            }
          }
          function fm(e) {
            var r, t4;
            return r = {}, s("next"), s("throw", function(a) {
              throw a;
            }), s("return"), r[Symbol.iterator] = function() {
              return this;
            }, r;
            function s(a, n) {
              r[a] = e[a] ? function(u) {
                return (t4 = !t4) ? { value: Xt(e[a](u)), done: a === "return" } : n ? n(u) : u;
              } : n;
            }
          }
          function Dm(e) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var r = e[Symbol.asyncIterator], t4;
            return r ? r.call(e) : (e = typeof Rn == "function" ? Rn(e) : e[Symbol.iterator](), t4 = {}, s("next"), s("throw"), s("return"), t4[Symbol.asyncIterator] = function() {
              return this;
            }, t4);
            function s(n) {
              t4[n] = e[n] && function(u) {
                return new Promise(function(i, l) {
                  u = e[n](u), a(i, l, u.done, u.value);
                });
              };
            }
            function a(n, u, i, l) {
              Promise.resolve(l).then(function(p) {
                n({ value: p, done: i });
              }, u);
            }
          }
          function mm(e, r) {
            return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r }) : e.raw = r, e;
          }
          function dm(e) {
            if (e && e.__esModule)
              return e;
            var r = {};
            if (e != null)
              for (var t4 in e)
                Object.hasOwnProperty.call(e, t4) && (r[t4] = e[t4]);
            return r.default = e, r;
          }
          function gm(e) {
            return e && e.__esModule ? e : { default: e };
          }
          function ym(e, r) {
            if (!r.has(e))
              throw new TypeError("attempted to get private field on non-instance");
            return r.get(e);
          }
          function hm(e, r, t4) {
            if (!r.has(e))
              throw new TypeError("attempted to set private field on non-instance");
            return r.set(e, t4), t4;
          }
          var Br, Nr, Et = ht({ "node_modules/tslib/tslib.es6.js"() {
            ne(), Br = function(e, r) {
              return Br = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, s) {
                t4.__proto__ = s;
              } || function(t4, s) {
                for (var a in s)
                  s.hasOwnProperty(a) && (t4[a] = s[a]);
              }, Br(e, r);
            }, Nr = function() {
              return Nr = Object.assign || function(r) {
                for (var t4, s = 1, a = arguments.length; s < a; s++) {
                  t4 = arguments[s];
                  for (var n in t4)
                    Object.prototype.hasOwnProperty.call(t4, n) && (r[n] = t4[n]);
                }
                return r;
              }, Nr.apply(this, arguments);
            };
          } }), Za = te({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (r) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r), value(r) {
              if (r === null || typeof r != "object")
                return JSON.stringify(r);
              if (Array.isArray(r))
                return `[${r.map((s) => e.apiDescriptor.value(s)).join(", ")}]`;
              let t4 = Object.keys(r);
              return t4.length === 0 ? "{}" : `{ ${t4.map((s) => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(r[s])}`).join(", ")} }`;
            }, pair: (r) => {
              let { key: t4, value: s } = r;
              return e.apiDescriptor.value({ [t4]: s });
            } };
          } }), vm = te({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(Za(), e);
          } }), kr = te({ "scripts/build/shims/chalk.cjs"(e, r) {
            "use strict";
            ne();
            var t4 = (s) => s;
            t4.grey = t4, t4.red = t4, t4.bold = t4, t4.yellow = t4, t4.blue = t4, t4.default = t4, r.exports = t4;
          } }), eo = te({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = kr();
            e.commonDeprecatedHandler = (t4, s, a) => {
              let { descriptor: n } = a, u = [`${r.default.yellow(typeof t4 == "string" ? n.key(t4) : n.pair(t4))} is deprecated`];
              return s && u.push(`we now treat it as ${r.default.blue(typeof s == "string" ? n.key(s) : n.pair(s))}`), u.join("; ") + ".";
            };
          } }), Cm = te({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(eo(), e);
          } }), Em = te({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = kr();
            e.commonInvalidHandler = (t4, s, a) => [`Invalid ${r.default.red(a.descriptor.key(t4))} value.`, `Expected ${r.default.blue(a.schemas[t4].expected(a))},`, `but received ${r.default.red(a.descriptor.value(s))}.`].join(" ");
          } }), to = te({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(Em(), e);
          } }), Fm = te({ "node_modules/vnopts/node_modules/leven/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = [], s = [];
            r.exports = function(a, n) {
              if (a === n)
                return 0;
              var u = a;
              a.length > n.length && (a = n, n = u);
              var i = a.length, l = n.length;
              if (i === 0)
                return l;
              if (l === 0)
                return i;
              for (; i > 0 && a.charCodeAt(~-i) === n.charCodeAt(~-l); )
                i--, l--;
              if (i === 0)
                return l;
              for (var p = 0; p < i && a.charCodeAt(p) === n.charCodeAt(p); )
                p++;
              if (i -= p, l -= p, i === 0)
                return l;
              for (var y, h2, g, c, f = 0, F4 = 0; f < i; )
                s[p + f] = a.charCodeAt(p + f), t4[f] = ++f;
              for (; F4 < l; )
                for (y = n.charCodeAt(p + F4), g = F4++, h2 = F4, f = 0; f < i; f++)
                  c = y === s[p + f] ? g : g + 1, g = t4[f], h2 = t4[f] = g > h2 ? c > h2 ? h2 + 1 : c : c > g ? g + 1 : c;
              return h2;
            };
          } }), ro = te({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = kr(), t4 = Fm();
            e.levenUnknownHandler = (s, a, n) => {
              let { descriptor: u, logger: i, schemas: l } = n, p = [`Ignored unknown option ${r.default.yellow(u.pair({ key: s, value: a }))}.`], y = Object.keys(l).sort().find((h2) => t4(s, h2) < 3);
              y && p.push(`Did you mean ${r.default.blue(u.key(y))}?`), i.warn(p.join(" "));
            };
          } }), Am = te({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(ro(), e);
          } }), Sm = te({ "node_modules/vnopts/lib/handlers/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(Cm(), e), r.__exportStar(to(), e), r.__exportStar(Am(), e);
          } }), Ft = te({ "node_modules/vnopts/lib/schema.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
            function t4(n, u) {
              let i = new n(u), l = Object.create(i);
              for (let p of r)
                p in u && (l[p] = a(u[p], i, s.prototype[p].length));
              return l;
            }
            e.createSchema = t4;
            var s = class {
              constructor(n) {
                this.name = n.name;
              }
              static create(n) {
                return t4(this, n);
              }
              default(n) {
              }
              expected(n) {
                return "nothing";
              }
              validate(n, u) {
                return false;
              }
              deprecated(n, u) {
                return false;
              }
              forward(n, u) {
              }
              redirect(n, u) {
              }
              overlap(n, u, i) {
                return n;
              }
              preprocess(n, u) {
                return n;
              }
              postprocess(n, u) {
                return n;
              }
            };
            e.Schema = s;
            function a(n, u, i) {
              return typeof n == "function" ? function() {
                for (var l = arguments.length, p = new Array(l), y = 0; y < l; y++)
                  p[y] = arguments[y];
                return n(...p.slice(0, i - 1), u, ...p.slice(i - 1));
              } : () => n;
            }
          } }), xm = te({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t4 = class extends r.Schema {
              constructor(s) {
                super(s), this._sourceName = s.sourceName;
              }
              expected(s) {
                return s.schemas[this._sourceName].expected(s);
              }
              validate(s, a) {
                return a.schemas[this._sourceName].validate(s, a);
              }
              redirect(s, a) {
                return this._sourceName;
              }
            };
            e.AliasSchema = t4;
          } }), bm = te({ "node_modules/vnopts/lib/schemas/any.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t4 = class extends r.Schema {
              expected() {
                return "anything";
              }
              validate() {
                return true;
              }
            };
            e.AnySchema = t4;
          } }), Tm = te({ "node_modules/vnopts/lib/schemas/array.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt)), t4 = Ft(), s = class extends t4.Schema {
              constructor(n) {
                var { valueSchema: u, name: i = u.name } = n, l = r.__rest(n, ["valueSchema", "name"]);
                super(Object.assign({}, l, { name: i })), this._valueSchema = u;
              }
              expected(n) {
                return `an array of ${this._valueSchema.expected(n)}`;
              }
              validate(n, u) {
                if (!Array.isArray(n))
                  return false;
                let i = [];
                for (let l of n) {
                  let p = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
                  p !== true && i.push(p.value);
                }
                return i.length === 0 ? true : { value: i };
              }
              deprecated(n, u) {
                let i = [];
                for (let l of n) {
                  let p = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
                  p !== false && i.push(...p.map((y) => {
                    let { value: h2 } = y;
                    return { value: [h2] };
                  }));
                }
                return i;
              }
              forward(n, u) {
                let i = [];
                for (let l of n) {
                  let p = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
                  i.push(...p.map(a));
                }
                return i;
              }
              redirect(n, u) {
                let i = [], l = [];
                for (let p of n) {
                  let y = u.normalizeRedirectResult(this._valueSchema.redirect(p, u), p);
                  "remain" in y && i.push(y.remain), l.push(...y.redirect.map(a));
                }
                return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
              }
              overlap(n, u) {
                return n.concat(u);
              }
            };
            e.ArraySchema = s;
            function a(n) {
              let { from: u, to: i } = n;
              return { from: [u], to: i };
            }
          } }), Bm = te({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t4 = class extends r.Schema {
              expected() {
                return "true or false";
              }
              validate(s) {
                return typeof s == "boolean";
              }
            };
            e.BooleanSchema = t4;
          } }), eu = te({ "node_modules/vnopts/lib/utils.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            function r(c, f) {
              let F4 = /* @__PURE__ */ Object.create(null);
              for (let _ of c) {
                let w = _[f];
                if (F4[w])
                  throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
                F4[w] = _;
              }
              return F4;
            }
            e.recordFromArray = r;
            function t4(c, f) {
              let F4 = /* @__PURE__ */ new Map();
              for (let _ of c) {
                let w = _[f];
                if (F4.has(w))
                  throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
                F4.set(w, _);
              }
              return F4;
            }
            e.mapFromArray = t4;
            function s() {
              let c = /* @__PURE__ */ Object.create(null);
              return (f) => {
                let F4 = JSON.stringify(f);
                return c[F4] ? true : (c[F4] = true, false);
              };
            }
            e.createAutoChecklist = s;
            function a(c, f) {
              let F4 = [], _ = [];
              for (let w of c)
                f(w) ? F4.push(w) : _.push(w);
              return [F4, _];
            }
            e.partition = a;
            function n(c) {
              return c === Math.floor(c);
            }
            e.isInt = n;
            function u(c, f) {
              if (c === f)
                return 0;
              let F4 = typeof c, _ = typeof f, w = ["undefined", "object", "boolean", "number", "string"];
              return F4 !== _ ? w.indexOf(F4) - w.indexOf(_) : F4 !== "string" ? Number(c) - Number(f) : c.localeCompare(f);
            }
            e.comparePrimitive = u;
            function i(c) {
              return c === void 0 ? {} : c;
            }
            e.normalizeDefaultResult = i;
            function l(c, f) {
              return c === true ? true : c === false ? { value: f } : c;
            }
            e.normalizeValidateResult = l;
            function p(c, f) {
              let F4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return c === false ? false : c === true ? F4 ? true : [{ value: f }] : "value" in c ? [c] : c.length === 0 ? false : c;
            }
            e.normalizeDeprecatedResult = p;
            function y(c, f) {
              return typeof c == "string" || "key" in c ? { from: f, to: c } : "from" in c ? { from: c.from, to: c.to } : { from: f, to: c.to };
            }
            e.normalizeTransferResult = y;
            function h2(c, f) {
              return c === void 0 ? [] : Array.isArray(c) ? c.map((F4) => y(F4, f)) : [y(c, f)];
            }
            e.normalizeForwardResult = h2;
            function g(c, f) {
              let F4 = h2(typeof c == "object" && "redirect" in c ? c.redirect : c, f);
              return F4.length === 0 ? { remain: f, redirect: F4 } : typeof c == "object" && "remain" in c ? { remain: c.remain, redirect: F4 } : { redirect: F4 };
            }
            e.normalizeRedirectResult = g;
          } }), Nm = te({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t4 = eu(), s = class extends r.Schema {
              constructor(a) {
                super(a), this._choices = t4.mapFromArray(a.choices.map((n) => n && typeof n == "object" ? n : { value: n }), "value");
              }
              expected(a) {
                let { descriptor: n } = a, u = Array.from(this._choices.keys()).map((p) => this._choices.get(p)).filter((p) => !p.deprecated).map((p) => p.value).sort(t4.comparePrimitive).map(n.value), i = u.slice(0, -2), l = u.slice(-2);
                return i.concat(l.join(" or ")).join(", ");
              }
              validate(a) {
                return this._choices.has(a);
              }
              deprecated(a) {
                let n = this._choices.get(a);
                return n && n.deprecated ? { value: a } : false;
              }
              forward(a) {
                let n = this._choices.get(a);
                return n ? n.forward : void 0;
              }
              redirect(a) {
                let n = this._choices.get(a);
                return n ? n.redirect : void 0;
              }
            };
            e.ChoiceSchema = s;
          } }), no = te({ "node_modules/vnopts/lib/schemas/number.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t4 = class extends r.Schema {
              expected() {
                return "a number";
              }
              validate(s, a) {
                return typeof s == "number";
              }
            };
            e.NumberSchema = t4;
          } }), wm = te({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = eu(), t4 = no(), s = class extends t4.NumberSchema {
              expected() {
                return "an integer";
              }
              validate(a, n) {
                return n.normalizeValidateResult(super.validate(a, n), a) === true && r.isInt(a);
              }
            };
            e.IntegerSchema = s;
          } }), _m = te({ "node_modules/vnopts/lib/schemas/string.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t4 = class extends r.Schema {
              expected() {
                return "a string";
              }
              validate(s) {
                return typeof s == "string";
              }
            };
            e.StringSchema = t4;
          } }), Pm = te({ "node_modules/vnopts/lib/schemas/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(xm(), e), r.__exportStar(bm(), e), r.__exportStar(Tm(), e), r.__exportStar(Bm(), e), r.__exportStar(Nm(), e), r.__exportStar(wm(), e), r.__exportStar(no(), e), r.__exportStar(_m(), e);
          } }), Im = te({ "node_modules/vnopts/lib/defaults.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Za(), t4 = eo(), s = to(), a = ro();
            e.defaultDescriptor = r.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t4.commonDeprecatedHandler;
          } }), km = te({ "node_modules/vnopts/lib/normalize.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Im(), t4 = eu();
            e.normalize = (a, n, u) => new s(n, u).normalize(a);
            var s = class {
              constructor(a, n) {
                let { logger: u = console, descriptor: i = r.defaultDescriptor, unknown: l = r.defaultUnknownHandler, invalid: p = r.defaultInvalidHandler, deprecated: y = r.defaultDeprecatedHandler } = n || {};
                this._utils = { descriptor: i, logger: u || { warn: () => {
                } }, schemas: t4.recordFromArray(a, "name"), normalizeDefaultResult: t4.normalizeDefaultResult, normalizeDeprecatedResult: t4.normalizeDeprecatedResult, normalizeForwardResult: t4.normalizeForwardResult, normalizeRedirectResult: t4.normalizeRedirectResult, normalizeValidateResult: t4.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p, this._deprecatedHandler = y, this.cleanHistory();
              }
              cleanHistory() {
                this._hasDeprecationWarned = t4.createAutoChecklist();
              }
              normalize(a) {
                let n = {}, u = [a], i = () => {
                  for (; u.length !== 0; ) {
                    let l = u.shift(), p = this._applyNormalization(l, n);
                    u.push(...p);
                  }
                };
                i();
                for (let l of Object.keys(this._utils.schemas)) {
                  let p = this._utils.schemas[l];
                  if (!(l in n)) {
                    let y = t4.normalizeDefaultResult(p.default(this._utils));
                    "value" in y && u.push({ [l]: y.value });
                  }
                }
                i();
                for (let l of Object.keys(this._utils.schemas)) {
                  let p = this._utils.schemas[l];
                  l in n && (n[l] = p.postprocess(n[l], this._utils));
                }
                return n;
              }
              _applyNormalization(a, n) {
                let u = [], [i, l] = t4.partition(Object.keys(a), (p) => p in this._utils.schemas);
                for (let p of i) {
                  let y = this._utils.schemas[p], h2 = y.preprocess(a[p], this._utils), g = t4.normalizeValidateResult(y.validate(h2, this._utils), h2);
                  if (g !== true) {
                    let { value: w } = g, E = this._invalidHandler(p, w, this._utils);
                    throw typeof E == "string" ? new Error(E) : E;
                  }
                  let c = (w) => {
                    let { from: E, to: N6 } = w;
                    u.push(typeof N6 == "string" ? { [N6]: E } : { [N6.key]: N6.value });
                  }, f = (w) => {
                    let { value: E, redirectTo: N6 } = w, x = t4.normalizeDeprecatedResult(y.deprecated(E, this._utils), h2, true);
                    if (x !== false)
                      if (x === true)
                        this._hasDeprecationWarned(p) || this._utils.logger.warn(this._deprecatedHandler(p, N6, this._utils));
                      else
                        for (let { value: I } of x) {
                          let P = { key: p, value: I };
                          if (!this._hasDeprecationWarned(P)) {
                            let $ = typeof N6 == "string" ? { key: N6, value: I } : N6;
                            this._utils.logger.warn(this._deprecatedHandler(P, $, this._utils));
                          }
                        }
                  };
                  t4.normalizeForwardResult(y.forward(h2, this._utils), h2).forEach(c);
                  let _ = t4.normalizeRedirectResult(y.redirect(h2, this._utils), h2);
                  if (_.redirect.forEach(c), "remain" in _) {
                    let w = _.remain;
                    n[p] = p in n ? y.overlap(n[p], w, this._utils) : w, f({ value: w });
                  }
                  for (let { from: w, to: E } of _.redirect)
                    f({ value: w, redirectTo: E });
                }
                for (let p of l) {
                  let y = a[p], h2 = this._unknownHandler(p, y, this._utils);
                  if (h2)
                    for (let g of Object.keys(h2)) {
                      let c = { [g]: h2[g] };
                      g in this._utils.schemas ? u.push(c) : Object.assign(n, c);
                    }
                }
                return u;
              }
            };
            e.Normalizer = s;
          } }), Lm = te({ "node_modules/vnopts/lib/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(vm(), e), r.__exportStar(Sm(), e), r.__exportStar(Pm(), e), r.__exportStar(km(), e), r.__exportStar(Ft(), e);
          } }), Om = te({ "src/main/options-normalizer.js"(e, r) {
            "use strict";
            ne();
            var t4 = Lm(), s = lt(), a = { key: (g) => g.length === 1 ? `-${g}` : `--${g}`, value: (g) => t4.apiDescriptor.value(g), pair: (g) => {
              let { key: c, value: f } = g;
              return f === false ? `--no-${c}` : f === true ? a.key(c) : f === "" ? `${a.key(c)} without an argument` : `${a.key(c)}=${f}`;
            } }, n = (g) => {
              let { colorsModule: c, levenshteinDistance: f } = g;
              return class extends t4.ChoiceSchema {
                constructor(_) {
                  let { name: w, flags: E } = _;
                  super({ name: w, choices: E }), this._flags = [...E].sort();
                }
                preprocess(_, w) {
                  if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
                    let E = this._flags.find((N6) => f(N6, _) < 3);
                    if (E)
                      return w.logger.warn([`Unknown flag ${c.yellow(w.descriptor.value(_))},`, `did you mean ${c.blue(w.descriptor.value(E))}?`].join(" ")), E;
                  }
                  return _;
                }
                expected() {
                  return "a flag";
                }
              };
            }, u;
            function i(g, c) {
              let { logger: f = false, isCLI: F4 = false, passThrough: _ = false, colorsModule: w = null, levenshteinDistance: E = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N6 = _ ? Array.isArray(_) ? (T, m) => _.includes(T) ? { [T]: m } : void 0 : (T, m) => ({ [T]: m }) : (T, m, C) => {
                let o = C.schemas, { _: d } = o, v = Hn(o, vD);
                return t4.levenUnknownHandler(T, m, Object.assign(Object.assign({}, C), {}, { schemas: v }));
              }, x = F4 ? a : t4.apiDescriptor, I = l(c, { isCLI: F4, colorsModule: w, levenshteinDistance: E }), P = new t4.Normalizer(I, { logger: f, unknown: N6, descriptor: x }), $ = f !== false;
              $ && u && (P._hasDeprecationWarned = u);
              let D = P.normalize(g);
              return $ && (u = P._hasDeprecationWarned), F4 && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
            }
            function l(g, c) {
              let { isCLI: f, colorsModule: F4, levenshteinDistance: _ } = c, w = [];
              f && w.push(t4.AnySchema.create({ name: "_" }));
              for (let E of g)
                w.push(p(E, { isCLI: f, optionInfos: g, colorsModule: F4, levenshteinDistance: _ })), E.alias && f && w.push(t4.AliasSchema.create({ name: E.alias, sourceName: E.name }));
              return w;
            }
            function p(g, c) {
              let { isCLI: f, optionInfos: F4, colorsModule: _, levenshteinDistance: w } = c, { name: E } = g;
              if (E === "plugin-search-dir" || E === "pluginSearchDirs")
                return t4.AnySchema.create({ name: E, preprocess(P) {
                  return P === false || (P = Array.isArray(P) ? P : [P]), P;
                }, validate(P) {
                  return P === false ? true : P.every(($) => typeof $ == "string");
                }, expected() {
                  return "false or paths to plugin search dir";
                } });
              let N6 = { name: E }, x, I = {};
              switch (g.type) {
                case "int":
                  x = t4.IntegerSchema, f && (N6.preprocess = Number);
                  break;
                case "string":
                  x = t4.StringSchema;
                  break;
                case "choice":
                  x = t4.ChoiceSchema, N6.choices = g.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g.name, value: P.redirect } } }) : P);
                  break;
                case "boolean":
                  x = t4.BooleanSchema;
                  break;
                case "flag":
                  x = n({ colorsModule: _, levenshteinDistance: w }), N6.flags = F4.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
                  break;
                case "path":
                  x = t4.StringSchema;
                  break;
                default:
                  throw new Error(`Unexpected type ${g.type}`);
              }
              if (g.exception ? N6.validate = (P, $, D) => g.exception(P) || $.validate(P, D) : N6.validate = (P, $, D) => P === void 0 || $.validate(P, D), g.redirect && (I.redirect = (P) => P ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (I.deprecated = true), f && !g.array) {
                let P = N6.preprocess || (($) => $);
                N6.preprocess = ($, D, T) => D.preprocess(P(Array.isArray($) ? s($) : $), T);
              }
              return g.array ? t4.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I), {}, { valueSchema: x.create(N6) })) : x.create(Object.assign(Object.assign({}, N6), I));
            }
            function y(g, c, f) {
              return i(g, c, f);
            }
            function h2(g, c, f) {
              return i(g, c, Object.assign({ isCLI: true }, f));
            }
            r.exports = { normalizeApiOptions: y, normalizeCliOptions: h2 };
          } }), ut = te({ "src/language-js/loc.js"(e, r) {
            "use strict";
            ne();
            var t4 = Kn();
            function s(l) {
              var p, y;
              let h2 = l.range ? l.range[0] : l.start, g = (p = (y = l.declaration) === null || y === void 0 ? void 0 : y.decorators) !== null && p !== void 0 ? p : l.decorators;
              return t4(g) ? Math.min(s(g[0]), h2) : h2;
            }
            function a(l) {
              return l.range ? l.range[1] : l.end;
            }
            function n(l, p) {
              let y = s(l);
              return Number.isInteger(y) && y === s(p);
            }
            function u(l, p) {
              let y = a(l);
              return Number.isInteger(y) && y === a(p);
            }
            function i(l, p) {
              return n(l, p) && u(l, p);
            }
            r.exports = { locStart: s, locEnd: a, hasSameLocStart: n, hasSameLoc: i };
          } }), jm = te({ "src/main/load-parser.js"(e, r) {
            ne(), r.exports = () => {
            };
          } }), qm = te({ "scripts/build/shims/babel-highlight.cjs"(e, r) {
            "use strict";
            ne();
            var t4 = kr(), s = { shouldHighlight: () => false, getChalk: () => t4 };
            r.exports = s;
          } }), Mm = te({ "node_modules/@babel/code-frame/lib/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
            var r = qm(), t4 = false;
            function s(l) {
              return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
            }
            var a = /\r\n|[\n\r\u2028\u2029]/;
            function n(l, p, y) {
              let h2 = Object.assign({ column: 0, line: -1 }, l.start), g = Object.assign({}, h2, l.end), { linesAbove: c = 2, linesBelow: f = 3 } = y || {}, F4 = h2.line, _ = h2.column, w = g.line, E = g.column, N6 = Math.max(F4 - (c + 1), 0), x = Math.min(p.length, w + f);
              F4 === -1 && (N6 = 0), w === -1 && (x = p.length);
              let I = w - F4, P = {};
              if (I)
                for (let $ = 0; $ <= I; $++) {
                  let D = $ + F4;
                  if (!_)
                    P[D] = true;
                  else if ($ === 0) {
                    let T = p[D - 1].length;
                    P[D] = [_, T - _ + 1];
                  } else if ($ === I)
                    P[D] = [0, E];
                  else {
                    let T = p[D - $].length;
                    P[D] = [0, T];
                  }
                }
              else
                _ === E ? _ ? P[F4] = [_, 0] : P[F4] = true : P[F4] = [_, E - _];
              return { start: N6, end: x, markerLines: P };
            }
            function u(l, p) {
              let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h2 = (y.highlightCode || y.forceColor) && (0, r.shouldHighlight)(y), g = (0, r.getChalk)(y), c = s(g), f = ($, D) => h2 ? $(D) : D, F4 = l.split(a), { start: _, end: w, markerLines: E } = n(p, F4, y), N6 = p.start && typeof p.start.column == "number", x = String(w).length, P = (h2 ? (0, r.default)(l, y) : l).split(a, w).slice(_, w).map(($, D) => {
                let T = _ + 1 + D, C = ` ${` ${T}`.slice(-x)} |`, o = E[T], d = !E[T + 1];
                if (o) {
                  let v = "";
                  if (Array.isArray(o)) {
                    let S = $.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
                    v = [`
 `, f(c.gutter, C.replace(/\d/g, " ")), " ", S, f(c.marker, "^").repeat(b)].join(""), d && y.message && (v += " " + f(c.message, y.message));
                  }
                  return [f(c.marker, ">"), f(c.gutter, C), $.length > 0 ? ` ${$}` : "", v].join("");
                } else
                  return ` ${f(c.gutter, C)}${$.length > 0 ? ` ${$}` : ""}`;
              }).join(`
`);
              return y.message && !N6 && (P = `${" ".repeat(x + 1)}${y.message}
${P}`), h2 ? g.reset(P) : P;
            }
            function i(l, p, y) {
              let h2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
              if (!t4) {
                t4 = true;
                let c = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                if (wt.emitWarning)
                  wt.emitWarning(c, "DeprecationWarning");
                else {
                  let f = new Error(c);
                  f.name = "DeprecationWarning", console.warn(new Error(c));
                }
              }
              return y = Math.max(y, 0), u(l, { start: { column: y, line: p } }, h2);
            }
          } }), tu = te({ "src/main/parser.js"(e, r) {
            "use strict";
            ne();
            var { ConfigError: t4 } = Qt(), s = ut(), a = jm(), { locStart: n, locEnd: u } = s, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
            function p(g) {
              let c = {};
              for (let f of g.plugins)
                if (f.parsers)
                  for (let F4 of i(f.parsers))
                    Object.defineProperty(c, F4, l(f.parsers, F4));
              return c;
            }
            function y(g) {
              let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p(g);
              if (typeof g.parser == "function")
                return { parse: g.parser, astFormat: "estree", locStart: n, locEnd: u };
              if (typeof g.parser == "string") {
                if (Object.prototype.hasOwnProperty.call(c, g.parser))
                  return c[g.parser];
                throw new t4(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`);
              }
            }
            function h2(g, c) {
              let f = p(c), F4 = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((w) => [w, { enumerable: true, get() {
                return f[w].parse;
              } }]))), _ = y(c, f);
              try {
                return _.preprocess && (g = _.preprocess(g, c)), { text: g, ast: _.parse(g, F4, c) };
              } catch (w) {
                let { loc: E } = w;
                if (E) {
                  let { codeFrameColumns: N6 } = Mm();
                  throw w.codeFrame = N6(g, E, { highlightCode: true }), w.message += `
` + w.codeFrame, w;
                }
                throw w;
              }
            }
            r.exports = { parse: h2, resolveParser: y };
          } }), uo = te({ "src/main/options.js"(e, r) {
            "use strict";
            ne();
            var t4 = ZD(), { UndefinedParserError: s } = Qt(), { getSupportInfo: a } = Xn(), n = Om(), { resolveParser: u } = tu(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
            function l(h2) {
              let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = Object.assign({}, h2), f = a({ plugins: h2.plugins, showUnreleased: true, showDeprecated: true }).options, F4 = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((x) => x.default !== void 0).map((x) => [x.name, x.default])));
              if (!c.parser) {
                if (!c.filepath)
                  (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c.parser = "babel";
                else if (c.parser = y(c.filepath, c.plugins), !c.parser)
                  throw new s(`No parser could be inferred for file: ${c.filepath}`);
              }
              let _ = u(n.normalizeApiOptions(c, [f.find((x) => x.name === "parser")], { passThrough: true, logger: false }));
              c.astFormat = _.astFormat, c.locEnd = _.locEnd, c.locStart = _.locStart;
              let w = p(c);
              c.printer = w.printers[c.astFormat];
              let E = Object.fromEntries(f.filter((x) => x.pluginDefaults && x.pluginDefaults[w.name] !== void 0).map((x) => [x.name, x.pluginDefaults[w.name]])), N6 = Object.assign(Object.assign({}, F4), E);
              for (let [x, I] of Object.entries(N6))
                (c[x] === null || c[x] === void 0) && (c[x] = I);
              return c.parser === "json" && (c.trailingComma = "none"), n.normalizeApiOptions(c, f, Object.assign({ passThrough: Object.keys(i) }, g));
            }
            function p(h2) {
              let { astFormat: g } = h2;
              if (!g)
                throw new Error("getPlugin() requires astFormat to be set");
              let c = h2.plugins.find((f) => f.printers && f.printers[g]);
              if (!c)
                throw new Error(`Couldn't find plugin for AST format "${g}"`);
              return c;
            }
            function y(h2, g) {
              let c = t4.basename(h2).toLowerCase(), F4 = a({ plugins: g }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w) => c.endsWith(w)) || _.filenames && _.filenames.some((w) => w.toLowerCase() === c));
              return F4 && F4.parsers[0];
            }
            r.exports = { normalize: l, hiddenDefaults: i, inferParser: y };
          } }), Rm = te({ "src/main/massage-ast.js"(e, r) {
            "use strict";
            ne();
            function t4(s, a, n) {
              if (Array.isArray(s))
                return s.map((p) => t4(p, a, n)).filter(Boolean);
              if (!s || typeof s != "object")
                return s;
              let u = a.printer.massageAstNode, i;
              u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
              let l = {};
              for (let [p, y] of Object.entries(s))
                !i.has(p) && typeof y != "function" && (l[p] = t4(y, a, s));
              if (u) {
                let p = u(s, l, n);
                if (p === null)
                  return;
                if (p)
                  return p;
              }
              return l;
            }
            r.exports = t4;
          } }), Zt = te({ "scripts/build/shims/assert.cjs"(e, r) {
            "use strict";
            ne();
            var t4 = () => {
            };
            t4.ok = t4, t4.strictEqual = t4, r.exports = t4;
          } }), et = te({ "src/main/comments.js"(e, r) {
            "use strict";
            ne();
            var t4 = Zt(), { builders: { line: s, hardline: a, breakParent: n, indent: u, lineSuffix: i, join: l, cursor: p } } = qe(), { hasNewline: y, skipNewline: h2, skipSpaces: g, isPreviousLineEmpty: c, addLeadingComment: f, addDanglingComment: F4, addTrailingComment: _ } = Ue(), w = /* @__PURE__ */ new WeakMap();
            function E(k, M, R4) {
              if (!k)
                return;
              let { printer: q, locStart: J, locEnd: L } = M;
              if (R4) {
                if (q.canAttachComment && q.canAttachComment(k)) {
                  let V;
                  for (V = R4.length - 1; V >= 0 && !(J(R4[V]) <= J(k) && L(R4[V]) <= L(k)); --V)
                    ;
                  R4.splice(V + 1, 0, k);
                  return;
                }
              } else if (w.has(k))
                return w.get(k);
              let Q = q.getCommentChildNodes && q.getCommentChildNodes(k, M) || typeof k == "object" && Object.entries(k).filter((V) => {
                let [j] = V;
                return j !== "enclosingNode" && j !== "precedingNode" && j !== "followingNode" && j !== "tokens" && j !== "comments" && j !== "parent";
              }).map((V) => {
                let [, j] = V;
                return j;
              });
              if (Q) {
                R4 || (R4 = [], w.set(k, R4));
                for (let V of Q)
                  E(V, M, R4);
                return R4;
              }
            }
            function N6(k, M, R4, q) {
              let { locStart: J, locEnd: L } = R4, Q = J(M), V = L(M), j = E(k, R4), Y, ie, ee = 0, ce = j.length;
              for (; ee < ce; ) {
                let W = ee + ce >> 1, K = j[W], de = J(K), ue = L(K);
                if (de <= Q && V <= ue)
                  return N6(K, M, R4, K);
                if (ue <= Q) {
                  Y = K, ee = W + 1;
                  continue;
                }
                if (V <= de) {
                  ie = K, ce = W;
                  continue;
                }
                throw new Error("Comment location overlaps with node location");
              }
              if (q && q.type === "TemplateLiteral") {
                let { quasis: W } = q, K = C(W, M, R4);
                Y && C(W, Y, R4) !== K && (Y = null), ie && C(W, ie, R4) !== K && (ie = null);
              }
              return { enclosingNode: q, precedingNode: Y, followingNode: ie };
            }
            var x = () => false;
            function I(k, M, R4, q) {
              if (!Array.isArray(k))
                return;
              let J = [], { locStart: L, locEnd: Q, printer: { handleComments: V = {} } } = q, { avoidAstMutation: j, ownLine: Y = x, endOfLine: ie = x, remaining: ee = x } = V, ce = k.map((W, K) => Object.assign(Object.assign({}, N6(M, W, q)), {}, { comment: W, text: R4, options: q, ast: M, isLastComment: k.length - 1 === K }));
              for (let [W, K] of ce.entries()) {
                let { comment: de, precedingNode: ue, enclosingNode: Fe, followingNode: z, text: U3, options: Z, ast: se, isLastComment: fe } = K;
                if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                  if (L(de) - L(se) <= 0) {
                    f(se, de);
                    continue;
                  }
                  if (Q(de) - Q(se) >= 0) {
                    _(se, de);
                    continue;
                  }
                }
                let ge;
                if (j ? ge = [K] : (de.enclosingNode = Fe, de.precedingNode = ue, de.followingNode = z, ge = [de, U3, Z, se, fe]), $(U3, Z, ce, W))
                  de.placement = "ownLine", Y(...ge) || (z ? f(z, de) : ue ? _(ue, de) : F4(Fe || se, de));
                else if (D(U3, Z, ce, W))
                  de.placement = "endOfLine", ie(...ge) || (ue ? _(ue, de) : z ? f(z, de) : F4(Fe || se, de));
                else if (de.placement = "remaining", !ee(...ge))
                  if (ue && z) {
                    let he = J.length;
                    he > 0 && J[he - 1].followingNode !== z && T(J, U3, Z), J.push(K);
                  } else
                    ue ? _(ue, de) : z ? f(z, de) : F4(Fe || se, de);
              }
              if (T(J, R4, q), !j)
                for (let W of k)
                  delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
            }
            var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
            function $(k, M, R4, q) {
              let { comment: J, precedingNode: L } = R4[q], { locStart: Q, locEnd: V } = M, j = Q(J);
              if (L)
                for (let Y = q - 1; Y >= 0; Y--) {
                  let { comment: ie, precedingNode: ee } = R4[Y];
                  if (ee !== L || !P(k.slice(V(ie), j)))
                    break;
                  j = Q(ie);
                }
              return y(k, j, { backwards: true });
            }
            function D(k, M, R4, q) {
              let { comment: J, followingNode: L } = R4[q], { locStart: Q, locEnd: V } = M, j = V(J);
              if (L)
                for (let Y = q + 1; Y < R4.length; Y++) {
                  let { comment: ie, followingNode: ee } = R4[Y];
                  if (ee !== L || !P(k.slice(j, Q(ie))))
                    break;
                  j = V(ie);
                }
              return y(k, j);
            }
            function T(k, M, R4) {
              let q = k.length;
              if (q === 0)
                return;
              let { precedingNode: J, followingNode: L, enclosingNode: Q } = k[0], V = R4.printer.getGapRegex && R4.printer.getGapRegex(Q) || /^[\s(]*$/, j = R4.locStart(L), Y;
              for (Y = q; Y > 0; --Y) {
                let { comment: ie, precedingNode: ee, followingNode: ce } = k[Y - 1];
                t4.strictEqual(ee, J), t4.strictEqual(ce, L);
                let W = M.slice(R4.locEnd(ie), j);
                if (V.test(W))
                  j = R4.locStart(ie);
                else
                  break;
              }
              for (let [ie, { comment: ee }] of k.entries())
                ie < Y ? _(J, ee) : f(L, ee);
              for (let ie of [J, L])
                ie.comments && ie.comments.length > 1 && ie.comments.sort((ee, ce) => R4.locStart(ee) - R4.locStart(ce));
              k.length = 0;
            }
            function m(k, M) {
              let R4 = k.getValue();
              return R4.printed = true, M.printer.printComment(k, M);
            }
            function C(k, M, R4) {
              let q = R4.locStart(M) - 1;
              for (let J = 1; J < k.length; ++J)
                if (q < R4.locStart(k[J]))
                  return J - 1;
              return 0;
            }
            function o(k, M) {
              let R4 = k.getValue(), q = [m(k, M)], { printer: J, originalText: L, locStart: Q, locEnd: V } = M;
              if (J.isBlockComment && J.isBlockComment(R4)) {
                let ie = y(L, V(R4)) ? y(L, Q(R4), { backwards: true }) ? a : s : " ";
                q.push(ie);
              } else
                q.push(a);
              let Y = h2(L, g(L, V(R4)));
              return Y !== false && y(L, Y) && q.push(a), q;
            }
            function d(k, M) {
              let R4 = k.getValue(), q = m(k, M), { printer: J, originalText: L, locStart: Q } = M, V = J.isBlockComment && J.isBlockComment(R4);
              if (y(L, Q(R4), { backwards: true })) {
                let Y = c(L, R4, Q);
                return i([a, Y ? a : "", q]);
              }
              let j = [" ", q];
              return V || (j = [i(j), n]), j;
            }
            function v(k, M, R4, q) {
              let J = [], L = k.getValue();
              return !L || !L.comments || (k.each(() => {
                let Q = k.getValue();
                !Q.leading && !Q.trailing && (!q || q(Q)) && J.push(m(k, M));
              }, "comments"), J.length === 0) ? "" : R4 ? l(a, J) : u([a, l(a, J)]);
            }
            function S(k, M, R4) {
              let q = k.getValue();
              if (!q)
                return {};
              let J = q.comments || [];
              R4 && (J = J.filter((j) => !R4.has(j)));
              let L = q === M.cursorNode;
              if (J.length === 0) {
                let j = L ? p : "";
                return { leading: j, trailing: j };
              }
              let Q = [], V = [];
              return k.each(() => {
                let j = k.getValue();
                if (R4 && R4.has(j))
                  return;
                let { leading: Y, trailing: ie } = j;
                Y ? Q.push(o(k, M)) : ie && V.push(d(k, M));
              }, "comments"), L && (Q.unshift(p), V.push(p)), { leading: Q, trailing: V };
            }
            function b(k, M, R4, q) {
              let { leading: J, trailing: L } = S(k, R4, q);
              return !J && !L ? M : [J, M, L];
            }
            function B(k) {
              if (k)
                for (let M of k) {
                  if (!M.printed)
                    throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
                  delete M.printed;
                }
            }
            r.exports = { attach: I, printComments: b, printCommentsSeparately: S, printDanglingComments: v, getSortedChildNodes: E, ensureAllCommentsPrinted: B };
          } }), $m = te({ "src/common/ast-path.js"(e, r) {
            "use strict";
            ne();
            var t4 = lt();
            function s(u, i) {
              let l = a(u.stack, i);
              return l === -1 ? null : u.stack[l];
            }
            function a(u, i) {
              for (let l = u.length - 1; l >= 0; l -= 2) {
                let p = u[l];
                if (p && !Array.isArray(p) && --i < 0)
                  return l;
              }
              return -1;
            }
            var n = class {
              constructor(u) {
                this.stack = [u];
              }
              getName() {
                let { stack: u } = this, { length: i } = u;
                return i > 1 ? u[i - 2] : null;
              }
              getValue() {
                return t4(this.stack);
              }
              getNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u);
              }
              getParentNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u + 1);
              }
              call(u) {
                let { stack: i } = this, { length: l } = i, p = t4(i);
                for (var y = arguments.length, h2 = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                  h2[g - 1] = arguments[g];
                for (let f of h2)
                  p = p[f], i.push(f, p);
                let c = u(this);
                return i.length = l, c;
              }
              callParent(u) {
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a(this.stack, i + 1), p = this.stack.splice(l + 1), y = u(this);
                return this.stack.push(...p), y;
              }
              each(u) {
                let { stack: i } = this, { length: l } = i, p = t4(i);
                for (var y = arguments.length, h2 = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                  h2[g - 1] = arguments[g];
                for (let c of h2)
                  p = p[c], i.push(c, p);
                for (let c = 0; c < p.length; ++c)
                  i.push(c, p[c]), u(this, c, p), i.length -= 2;
                i.length = l;
              }
              map(u) {
                let i = [];
                for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++)
                  p[y - 1] = arguments[y];
                return this.each((h2, g, c) => {
                  i[g] = u(h2, g, c);
                }, ...p), i;
              }
              try(u) {
                let { stack: i } = this, l = [...i];
                try {
                  return u();
                } finally {
                  i.length = 0, i.push(...l);
                }
              }
              match() {
                let u = this.stack.length - 1, i = null, l = this.stack[u--];
                for (var p = arguments.length, y = new Array(p), h2 = 0; h2 < p; h2++)
                  y[h2] = arguments[h2];
                for (let g of y) {
                  if (l === void 0)
                    return false;
                  let c = null;
                  if (typeof i == "number" && (c = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, c))
                    return false;
                  i = this.stack[u--], l = this.stack[u--];
                }
                return true;
              }
              findAncestor(u) {
                let i = this.stack.length - 1, l = null, p = this.stack[i--];
                for (; p; ) {
                  let y = null;
                  if (typeof l == "number" && (y = l, l = this.stack[i--], p = this.stack[i--]), l !== null && u(p, l, y))
                    return p;
                  l = this.stack[i--], p = this.stack[i--];
                }
              }
            };
            r.exports = n;
          } }), Vm = te({ "src/main/multiparser.js"(e, r) {
            "use strict";
            ne();
            var { utils: { stripTrailingHardline: t4 } } = qe(), { normalize: s } = uo(), a = et();
            function n(i, l, p, y) {
              if (p.printer.embed && p.embeddedLanguageFormatting === "auto")
                return p.printer.embed(i, l, (h2, g, c) => u(h2, g, p, y, c), p);
            }
            function u(i, l, p, y) {
              let { stripTrailingHardline: h2 = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s(Object.assign(Object.assign(Object.assign({}, p), l), {}, { parentParser: p.parser, originalText: i }), { passThrough: true }), c = tu().parse(i, g), { ast: f } = c;
              i = c.text;
              let F4 = f.comments;
              delete f.comments, a.attach(F4, f, i, g), g[Symbol.for("comments")] = F4 || [], g[Symbol.for("tokens")] = f.tokens || [];
              let _ = y(f, g);
              return a.ensureAllCommentsPrinted(F4), h2 ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t4(_) : _;
            }
            r.exports = { printSubtree: n };
          } }), Wm = te({ "src/main/ast-to-doc.js"(e, r) {
            "use strict";
            ne();
            var t4 = $m(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: n } } = qe(), { printComments: u } = et(), i = Vm();
            function l(h2, g) {
              let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g;
              f.preprocess && (h2 = f.preprocess(h2, g));
              let F4 = /* @__PURE__ */ new Map(), _ = new t4(h2), w = E();
              return c > 0 && (w = a([s, w], c, g.tabWidth)), n(w), w;
              function E(x, I) {
                return x === void 0 || x === _ ? N6(I) : Array.isArray(x) ? _.call(() => N6(I), ...x) : _.call(() => N6(I), x);
              }
              function N6(x) {
                let I = _.getValue(), P = I && typeof I == "object" && x === void 0;
                if (P && F4.has(I))
                  return F4.get(I);
                let $ = y(_, g, E, x);
                return P && F4.set(I, $), $;
              }
            }
            function p(h2, g) {
              let { originalText: c, [Symbol.for("comments")]: f, locStart: F4, locEnd: _ } = g, w = F4(h2), E = _(h2), N6 = /* @__PURE__ */ new Set();
              for (let x of f)
                F4(x) >= w && _(x) <= E && (x.printed = true, N6.add(x));
              return { doc: c.slice(w, E), printedComments: N6 };
            }
            function y(h2, g, c, f) {
              let F4 = h2.getValue(), { printer: _ } = g, w, E;
              if (_.hasPrettierIgnore && _.hasPrettierIgnore(h2))
                ({ doc: w, printedComments: E } = p(F4, g));
              else {
                if (F4)
                  try {
                    w = i.printSubtree(h2, c, g, l);
                  } catch (N6) {
                    if (globalThis.PRETTIER_DEBUG)
                      throw N6;
                  }
                w || (w = _.print(h2, g, c, f));
              }
              return (!_.willPrintOwnComments || !_.willPrintOwnComments(h2, g)) && (w = u(h2, w, g, E)), w;
            }
            r.exports = l;
          } }), Hm = te({ "src/main/range-util.js"(e, r) {
            "use strict";
            ne();
            var t4 = Zt(), s = et(), a = (f) => {
              let { parser: F4 } = f;
              return F4 === "json" || F4 === "json5" || F4 === "json-stringify";
            };
            function n(f, F4) {
              let _ = [f.node, ...f.parentNodes], w = /* @__PURE__ */ new Set([F4.node, ...F4.parentNodes]);
              return _.find((E) => y.has(E.type) && w.has(E));
            }
            function u(f) {
              let F4 = f.length - 1;
              for (; ; ) {
                let _ = f[F4];
                if (_ && (_.type === "Program" || _.type === "File"))
                  F4--;
                else
                  break;
              }
              return f.slice(0, F4 + 1);
            }
            function i(f, F4, _) {
              let { locStart: w, locEnd: E } = _, N6 = f.node, x = F4.node;
              if (N6 === x)
                return { startNode: N6, endNode: x };
              let I = w(f.node);
              for (let $ of u(F4.parentNodes))
                if (w($) >= I)
                  x = $;
                else
                  break;
              let P = E(F4.node);
              for (let $ of u(f.parentNodes)) {
                if (E($) <= P)
                  N6 = $;
                else
                  break;
                if (N6 === x)
                  break;
              }
              return { startNode: N6, endNode: x };
            }
            function l(f, F4, _, w) {
              let E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N6 = arguments.length > 5 ? arguments[5] : void 0, { locStart: x, locEnd: I } = _, P = x(f), $ = I(f);
              if (!(F4 > $ || F4 < P || N6 === "rangeEnd" && F4 === P || N6 === "rangeStart" && F4 === $)) {
                for (let D of s.getSortedChildNodes(f, _)) {
                  let T = l(D, F4, _, w, [f, ...E], N6);
                  if (T)
                    return T;
                }
                if (!w || w(f, E[0]))
                  return { node: f, parentNodes: E };
              }
            }
            function p(f, F4) {
              return F4 !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
            }
            var y = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h2 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
            function g(f, F4, _) {
              if (!F4)
                return false;
              switch (f.parser) {
                case "flow":
                case "babel":
                case "babel-flow":
                case "babel-ts":
                case "typescript":
                case "acorn":
                case "espree":
                case "meriyah":
                case "__babel_estree":
                  return p(F4.type, _ && _.type);
                case "json":
                case "json5":
                case "json-stringify":
                  return y.has(F4.type);
                case "graphql":
                  return h2.has(F4.kind);
                case "vue":
                  return F4.tag !== "root";
              }
              return false;
            }
            function c(f, F4, _) {
              let { rangeStart: w, rangeEnd: E, locStart: N6, locEnd: x } = F4;
              t4.ok(E > w);
              let I = f.slice(w, E).search(/\S/), P = I === -1;
              if (!P)
                for (w += I; E > w && !/\S/.test(f[E - 1]); --E)
                  ;
              let $ = l(_, w, F4, (C, o) => g(F4, C, o), [], "rangeStart"), D = P ? $ : l(_, E, F4, (C) => g(F4, C), [], "rangeEnd");
              if (!$ || !D)
                return { rangeStart: 0, rangeEnd: 0 };
              let T, m;
              if (a(F4)) {
                let C = n($, D);
                T = C, m = C;
              } else
                ({ startNode: T, endNode: m } = i($, D, F4));
              return { rangeStart: Math.min(N6(T), N6(m)), rangeEnd: Math.max(x(T), x(m)) };
            }
            r.exports = { calculateRange: c, findNodeAtOffset: l };
          } }), Gm = te({ "src/main/core.js"(e, r) {
            "use strict";
            ne();
            var { diffArrays: t4 } = BD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = qe(), { getAlignmentSize: n } = Ue(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: p } = Jn(), y = uo().normalize, h2 = Rm(), g = et(), c = tu(), f = Wm(), F4 = Hm(), _ = "\uFEFF", w = Symbol("cursor");
            function E(m, C, o) {
              let d = C.comments;
              return d && (delete C.comments, g.attach(d, C, m, o)), o[Symbol.for("comments")] = d || [], o[Symbol.for("tokens")] = C.tokens || [], o.originalText = m, d;
            }
            function N6(m, C) {
              let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              if (!m || m.trim().length === 0)
                return { formatted: "", cursorOffset: -1, comments: [] };
              let { ast: d, text: v } = c.parse(m, C);
              if (C.cursorOffset >= 0) {
                let k = F4.findNodeAtOffset(d, C.cursorOffset, C);
                k && k.node && (C.cursorNode = k.node);
              }
              let S = E(v, d, C), b = f(d, C, o), B = s(b, C);
              if (g.ensureAllCommentsPrinted(S), o > 0) {
                let k = B.formatted.trim();
                B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);
              }
              if (C.cursorOffset >= 0) {
                let k, M, R4, q, J;
                if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M = v.slice(k, C.locEnd(C.cursorNode)), R4 = C.cursorOffset - k, q = B.cursorNodeStart, J = B.cursorNodeText) : (k = 0, M = v, R4 = C.cursorOffset, q = 0, J = B.formatted), M === J)
                  return { formatted: B.formatted, cursorOffset: q + R4, comments: S };
                let L = [...M];
                L.splice(R4, 0, w);
                let Q = [...J], V = t4(L, Q), j = q;
                for (let Y of V)
                  if (Y.removed) {
                    if (Y.value.includes(w))
                      break;
                  } else
                    j += Y.count;
                return { formatted: B.formatted, cursorOffset: j, comments: S };
              }
              return { formatted: B.formatted, cursorOffset: -1, comments: S };
            }
            function x(m, C) {
              let { ast: o, text: d } = c.parse(m, C), { rangeStart: v, rangeEnd: S } = F4.calculateRange(d, C, o), b = d.slice(v, S), B = Math.min(v, d.lastIndexOf(`
`, v) + 1), k = d.slice(B, v).match(/^\s*/)[0], M = n(k, C.tabWidth), R4 = N6(b, Object.assign(Object.assign({}, C), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C.cursorOffset > v && C.cursorOffset <= S ? C.cursorOffset - v : -1, endOfLine: "lf" }), M), q = R4.formatted.trimEnd(), { cursorOffset: J } = C;
              J > S ? J += q.length - b.length : R4.cursorOffset >= 0 && (J = R4.cursorOffset + v);
              let L = d.slice(0, v) + q + d.slice(S);
              if (C.endOfLine !== "lf") {
                let Q = i(C.endOfLine);
                J >= 0 && Q === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Q);
              }
              return { formatted: L, cursorOffset: J, comments: R4.comments };
            }
            function I(m, C, o) {
              return typeof C != "number" || Number.isNaN(C) || C < 0 || C > m.length ? o : C;
            }
            function P(m, C) {
              let { cursorOffset: o, rangeStart: d, rangeEnd: v } = C;
              return o = I(m, o, -1), d = I(m, d, 0), v = I(m, v, m.length), Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v });
            }
            function $(m, C) {
              let { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S } = P(m, C), b = m.charAt(0) === _;
              if (b && (m = m.slice(1), o--, d--, v--), S === "auto" && (S = u(m)), m.includes("\r")) {
                let B = (k) => l(m.slice(0, Math.max(k, 0)), `\r
`);
                o -= B(o), d -= B(d), v -= B(v), m = p(m);
              }
              return { hasBOM: b, text: m, options: P(m, Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S })) };
            }
            function D(m, C) {
              let o = c.resolveParser(C);
              return !o.hasPragma || o.hasPragma(m);
            }
            function T(m, C) {
              let { hasBOM: o, text: d, options: v } = $(m, y(C));
              if (v.rangeStart >= v.rangeEnd && d !== "" || v.requirePragma && !D(d, v))
                return { formatted: m, cursorOffset: C.cursorOffset, comments: [] };
              let S;
              return v.rangeStart > 0 || v.rangeEnd < d.length ? S = x(d, v) : (!v.requirePragma && v.insertPragma && v.printer.insertPragma && !D(d, v) && (d = v.printer.insertPragma(d)), S = N6(d, v)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
            }
            r.exports = { formatWithCursor: T, parse(m, C, o) {
              let { text: d, options: v } = $(m, y(C)), S = c.parse(d, v);
              return o && (S.ast = h2(S.ast, v)), S;
            }, formatAST(m, C) {
              C = y(C);
              let o = f(m, C);
              return s(o, C);
            }, formatDoc(m, C) {
              return T(a(m), Object.assign(Object.assign({}, C), {}, { parser: "__js_expression" })).formatted;
            }, printToDoc(m, C) {
              C = y(C);
              let { ast: o, text: d } = c.parse(m, C);
              return E(d, o, C), f(o, C);
            }, printDocToString(m, C) {
              return s(m, y(C));
            } };
          } }), Um = te({ "src/common/util-shared.js"(e, r) {
            "use strict";
            ne();
            var { getMaxContinuousCount: t4, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h2, skipInlineComment: g, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: F4, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N6, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D } = Ue();
            r.exports = { getMaxContinuousCount: t4, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h2, skipInlineComment: g, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: F4, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N6, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D };
          } }), _t = te({ "src/utils/create-language.js"(e, r) {
            "use strict";
            ne(), r.exports = function(t4, s) {
              let { languageId: a } = t4, n = Hn(t4, CD);
              return Object.assign(Object.assign({ linguistLanguageId: a }, n), s(t4));
            };
          } }), Jm = te({ "node_modules/esutils/lib/ast.js"(e, r) {
            ne(), function() {
              "use strict";
              function t4(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "ArrayExpression":
                  case "AssignmentExpression":
                  case "BinaryExpression":
                  case "CallExpression":
                  case "ConditionalExpression":
                  case "FunctionExpression":
                  case "Identifier":
                  case "Literal":
                  case "LogicalExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ObjectExpression":
                  case "SequenceExpression":
                  case "ThisExpression":
                  case "UnaryExpression":
                  case "UpdateExpression":
                    return true;
                }
                return false;
              }
              function s(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "DoWhileStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "WhileStatement":
                    return true;
                }
                return false;
              }
              function a(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "BlockStatement":
                  case "BreakStatement":
                  case "ContinueStatement":
                  case "DebuggerStatement":
                  case "DoWhileStatement":
                  case "EmptyStatement":
                  case "ExpressionStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "IfStatement":
                  case "LabeledStatement":
                  case "ReturnStatement":
                  case "SwitchStatement":
                  case "ThrowStatement":
                  case "TryStatement":
                  case "VariableDeclaration":
                  case "WhileStatement":
                  case "WithStatement":
                    return true;
                }
                return false;
              }
              function n(l) {
                return a(l) || l != null && l.type === "FunctionDeclaration";
              }
              function u(l) {
                switch (l.type) {
                  case "IfStatement":
                    return l.alternate != null ? l.alternate : l.consequent;
                  case "LabeledStatement":
                  case "ForStatement":
                  case "ForInStatement":
                  case "WhileStatement":
                  case "WithStatement":
                    return l.body;
                }
                return null;
              }
              function i(l) {
                var p;
                if (l.type !== "IfStatement" || l.alternate == null)
                  return false;
                p = l.consequent;
                do {
                  if (p.type === "IfStatement" && p.alternate == null)
                    return true;
                  p = u(p);
                } while (p);
                return false;
              }
              r.exports = { isExpression: t4, isStatement: a, isIterationStatement: s, isSourceElement: n, isProblematicIfStatement: i, trailingStatement: u };
            }();
          } }), so = te({ "node_modules/esutils/lib/code.js"(e, r) {
            ne(), function() {
              "use strict";
              var t4, s, a, n, u, i;
              s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t4 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
              function l(E) {
                return 48 <= E && E <= 57;
              }
              function p(E) {
                return 48 <= E && E <= 57 || 97 <= E && E <= 102 || 65 <= E && E <= 70;
              }
              function y(E) {
                return E >= 48 && E <= 55;
              }
              a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
              function h2(E) {
                return E === 32 || E === 9 || E === 11 || E === 12 || E === 160 || E >= 5760 && a.indexOf(E) >= 0;
              }
              function g(E) {
                return E === 10 || E === 13 || E === 8232 || E === 8233;
              }
              function c(E) {
                if (E <= 65535)
                  return String.fromCharCode(E);
                var N6 = String.fromCharCode(Math.floor((E - 65536) / 1024) + 55296), x = String.fromCharCode((E - 65536) % 1024 + 56320);
                return N6 + x;
              }
              for (n = new Array(128), i = 0; i < 128; ++i)
                n[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
              for (u = new Array(128), i = 0; i < 128; ++i)
                u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
              function f(E) {
                return E < 128 ? n[E] : s.NonAsciiIdentifierStart.test(c(E));
              }
              function F4(E) {
                return E < 128 ? u[E] : s.NonAsciiIdentifierPart.test(c(E));
              }
              function _(E) {
                return E < 128 ? n[E] : t4.NonAsciiIdentifierStart.test(c(E));
              }
              function w(E) {
                return E < 128 ? u[E] : t4.NonAsciiIdentifierPart.test(c(E));
              }
              r.exports = { isDecimalDigit: l, isHexDigit: p, isOctalDigit: y, isWhiteSpace: h2, isLineTerminator: g, isIdentifierStartES5: f, isIdentifierPartES5: F4, isIdentifierStartES6: _, isIdentifierPartES6: w };
            }();
          } }), zm = te({ "node_modules/esutils/lib/keyword.js"(e, r) {
            ne(), function() {
              "use strict";
              var t4 = so();
              function s(f) {
                switch (f) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              }
              function a(f, F4) {
                return !F4 && f === "yield" ? false : n(f, F4);
              }
              function n(f, F4) {
                if (F4 && s(f))
                  return true;
                switch (f.length) {
                  case 2:
                    return f === "if" || f === "in" || f === "do";
                  case 3:
                    return f === "var" || f === "for" || f === "new" || f === "try";
                  case 4:
                    return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                  case 5:
                    return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                  case 6:
                    return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                  case 7:
                    return f === "default" || f === "finally" || f === "extends";
                  case 8:
                    return f === "function" || f === "continue" || f === "debugger";
                  case 10:
                    return f === "instanceof";
                  default:
                    return false;
                }
              }
              function u(f, F4) {
                return f === "null" || f === "true" || f === "false" || a(f, F4);
              }
              function i(f, F4) {
                return f === "null" || f === "true" || f === "false" || n(f, F4);
              }
              function l(f) {
                return f === "eval" || f === "arguments";
              }
              function p(f) {
                var F4, _, w;
                if (f.length === 0 || (w = f.charCodeAt(0), !t4.isIdentifierStartES5(w)))
                  return false;
                for (F4 = 1, _ = f.length; F4 < _; ++F4)
                  if (w = f.charCodeAt(F4), !t4.isIdentifierPartES5(w))
                    return false;
                return true;
              }
              function y(f, F4) {
                return (f - 55296) * 1024 + (F4 - 56320) + 65536;
              }
              function h2(f) {
                var F4, _, w, E, N6;
                if (f.length === 0)
                  return false;
                for (N6 = t4.isIdentifierStartES6, F4 = 0, _ = f.length; F4 < _; ++F4) {
                  if (w = f.charCodeAt(F4), 55296 <= w && w <= 56319) {
                    if (++F4, F4 >= _ || (E = f.charCodeAt(F4), !(56320 <= E && E <= 57343)))
                      return false;
                    w = y(w, E);
                  }
                  if (!N6(w))
                    return false;
                  N6 = t4.isIdentifierPartES6;
                }
                return true;
              }
              function g(f, F4) {
                return p(f) && !u(f, F4);
              }
              function c(f, F4) {
                return h2(f) && !i(f, F4);
              }
              r.exports = { isKeywordES5: a, isKeywordES6: n, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: p, isIdentifierNameES6: h2, isIdentifierES5: g, isIdentifierES6: c };
            }();
          } }), Xm = te({ "node_modules/esutils/lib/utils.js"(e) {
            ne(), function() {
              "use strict";
              e.ast = Jm(), e.code = so(), e.keyword = zm();
            }();
          } }), Pt = te({ "src/language-js/utils/is-block-comment.js"(e, r) {
            "use strict";
            ne();
            var t4 = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t4.has(a == null ? void 0 : a.type);
            r.exports = s;
          } }), Km = te({ "src/language-js/utils/is-node-matches.js"(e, r) {
            "use strict";
            ne();
            function t4(a, n) {
              let u = n.split(".");
              for (let i = u.length - 1; i >= 0; i--) {
                let l = u[i];
                if (i === 0)
                  return a.type === "Identifier" && a.name === l;
                if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== l)
                  return false;
                a = a.object;
              }
            }
            function s(a, n) {
              return n.some((u) => t4(a, u));
            }
            r.exports = s;
          } }), Ke = te({ "src/language-js/utils/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = Xm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: n, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ue(), { locStart: p, locEnd: y, hasSameLocStart: h2 } = ut(), g = Pt(), c = Km(), f = "(?:(?=.)\\s)", F4 = new RegExp(`^${f}*:`), _ = new RegExp(`^${f}*::`);
            function w(O) {
              var me, _e;
              return ((me = O.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g((_e = O.trailingComments) === null || _e === void 0 ? void 0 : _e[0]) && F4.test(O.trailingComments[0].value);
            }
            function E(O) {
              let me = O == null ? void 0 : O[0];
              return g(me) && _.test(me.value);
            }
            function N6(O, me) {
              if (!O || typeof O != "object")
                return false;
              if (Array.isArray(O))
                return O.some((He) => N6(He, me));
              let _e = me(O);
              return typeof _e == "boolean" ? _e : Object.values(O).some((He) => N6(He, me));
            }
            function x(O) {
              return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || de(O) || ue(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || st(O) || O.type === "TSNonNullExpression";
            }
            function I(O) {
              var me, _e, He, Ge, it, Qe;
              return O.expressions ? O.expressions[0] : (me = (_e = (He = (Ge = (it = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it !== void 0 ? it : O.callee) !== null && Ge !== void 0 ? Ge : O.object) !== null && He !== void 0 ? He : O.tag) !== null && _e !== void 0 ? _e : O.argument) !== null && me !== void 0 ? me : O.expression;
            }
            function P(O, me) {
              if (me.expressions)
                return ["expressions", 0];
              if (me.left)
                return ["left"];
              if (me.test)
                return ["test"];
              if (me.object)
                return ["object"];
              if (me.callee)
                return ["callee"];
              if (me.tag)
                return ["tag"];
              if (me.argument)
                return ["argument"];
              if (me.expression)
                return ["expression"];
              throw new Error("Unexpected node has no left side.");
            }
            function $(O) {
              return O = new Set(O), (me) => O.has(me == null ? void 0 : me.type);
            }
            var D = $(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
            function m(O) {
              let me = O.getParentNode();
              return O.getName() === "declaration" && T(me) ? me : null;
            }
            var C = $(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
            function o(O) {
              return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
            }
            function d(O) {
              return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && o(O.argument);
            }
            function v(O) {
              return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
            }
            var S = $(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $(["FunctionExpression", "ArrowFunctionExpression"]);
            function B(O) {
              return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
            }
            function k(O) {
              return de(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
            }
            var M = $(["JSXElement", "JSXFragment"]);
            function R4(O, me) {
              if (O.parentParser !== "markdown" && O.parentParser !== "mdx")
                return false;
              let _e = me.getNode();
              if (!_e.expression || !M(_e.expression))
                return false;
              let He = me.getParentNode();
              return He.type === "Program" && He.body.length === 1;
            }
            function q(O) {
              return O.kind === "get" || O.kind === "set";
            }
            function J(O) {
              return q(O) || h2(O, O.value);
            }
            function L(O) {
              return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !J(O);
            }
            function Q(O) {
              return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !h2(O, O.typeAnnotation);
            }
            var V = $(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
            function j(O) {
              return ue(O) || O.type === "BindExpression" && Boolean(O.object);
            }
            var Y = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
            function ie(O) {
              return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Y.has(O.type)) : false;
            }
            function ee(O) {
              let me = /^(?:before|after)(?:Each|All)$/;
              return O.callee.type === "Identifier" && me.test(O.callee.name) && O.arguments.length === 1;
            }
            var ce = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
            function W(O) {
              return c(O, ce);
            }
            function K(O, me) {
              if (O.type !== "CallExpression")
                return false;
              if (O.arguments.length === 1) {
                if (k(O) && me && K(me))
                  return b(O.arguments[0]);
                if (ee(O))
                  return k(O.arguments[0]);
              } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || v(O.arguments[0])) && W(O.callee))
                return O.arguments[2] && !o(O.arguments[2]) ? false : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve(O.arguments[1]).length <= 1) || k(O.arguments[1]);
              return false;
            }
            var de = $(["CallExpression", "OptionalCallExpression"]), ue = $(["MemberExpression", "OptionalMemberExpression"]);
            function Fe(O) {
              let me = "expressions";
              O.type === "TSTemplateLiteralType" && (me = "types");
              let _e = O[me];
              return _e.length === 0 ? false : _e.every((He) => {
                if (Me(He))
                  return false;
                if (He.type === "Identifier" || He.type === "ThisExpression")
                  return true;
                if (ue(He)) {
                  let Ge = He;
                  for (; ue(Ge); )
                    if (Ge.property.type !== "Identifier" && Ge.property.type !== "Literal" && Ge.property.type !== "StringLiteral" && Ge.property.type !== "NumericLiteral" || (Ge = Ge.object, Me(Ge)))
                      return false;
                  return Ge.type === "Identifier" || Ge.type === "ThisExpression";
                }
                return false;
              });
            }
            function z(O, me) {
              return O === "+" || O === "-" ? O + me : me;
            }
            function U3(O, me) {
              let _e = p(me), He = n(O, y(me));
              return He !== false && O.slice(_e, _e + 2) === "/*" && O.slice(He, He + 2) === "*/";
            }
            function Z(O, me) {
              return M(me) ? Oe(me) : Me(me, Te.Leading, (_e) => a(O, y(_e)));
            }
            function se(O, me) {
              return me.parser !== "json" && v(O.key) && oe(O.key).slice(1, -1) === O.key.value && (t4(O.key.value) && !(me.parser === "babel-ts" && O.type === "ClassProperty" || me.parser === "typescript" && O.type === "PropertyDefinition") || fe(O.key.value) && String(Number(O.key.value)) === O.key.value && (me.parser === "babel" || me.parser === "acorn" || me.parser === "espree" || me.parser === "meriyah" || me.parser === "__babel_estree"));
            }
            function fe(O) {
              return /^(?:\d+|\d+\.\d+)$/.test(O);
            }
            function ge(O, me) {
              let _e = /^[fx]?(?:describe|it|test)$/;
              return me.type === "TaggedTemplateExpression" && me.quasi === O && me.tag.type === "MemberExpression" && me.tag.property.type === "Identifier" && me.tag.property.name === "each" && (me.tag.object.type === "Identifier" && _e.test(me.tag.object.name) || me.tag.object.type === "MemberExpression" && me.tag.object.property.type === "Identifier" && (me.tag.object.property.name === "only" || me.tag.object.property.name === "skip") && me.tag.object.object.type === "Identifier" && _e.test(me.tag.object.object.name));
            }
            function he(O) {
              return O.quasis.some((me) => me.value.raw.includes(`
`));
            }
            function we(O, me) {
              return (O.type === "TemplateLiteral" && he(O) || O.type === "TaggedTemplateExpression" && he(O.quasi)) && !a(me, p(O), { backwards: true });
            }
            function ke(O) {
              if (!Me(O))
                return false;
              let me = s(ae(O, Te.Dangling));
              return me && !g(me);
            }
            function Re(O) {
              if (O.length <= 1)
                return false;
              let me = 0;
              for (let _e of O)
                if (b(_e)) {
                  if (me += 1, me > 1)
                    return true;
                } else if (de(_e)) {
                  for (let He of _e.arguments)
                    if (b(He))
                      return true;
                }
              return false;
            }
            function Ne(O) {
              let me = O.getValue(), _e = O.getParentNode();
              return de(me) && de(_e) && _e.callee === me && me.arguments.length > _e.arguments.length && _e.arguments.length > 0;
            }
            function Pe(O, me) {
              if (me >= 2)
                return false;
              let _e = (Qe) => Pe(Qe, me + 1), He = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
              if (He && l(He) > 5)
                return false;
              if (O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import")
                return true;
              if (O.type === "TemplateLiteral")
                return O.quasis.every((Qe) => !Qe.value.raw.includes(`
`)) && O.expressions.every(_e);
              if (O.type === "ObjectExpression")
                return O.properties.every((Qe) => !Qe.computed && (Qe.shorthand || Qe.value && _e(Qe.value)));
              if (O.type === "ArrayExpression")
                return O.elements.every((Qe) => Qe === null || _e(Qe));
              if (tt(O))
                return (O.type === "ImportExpression" || Pe(O.callee, me)) && Ye(O).every(_e);
              if (ue(O))
                return Pe(O.object, me) && Pe(O.property, me);
              let Ge = { "!": true, "-": true, "+": true, "~": true };
              if (O.type === "UnaryExpression" && Ge[O.operator])
                return Pe(O.argument, me);
              let it = { "++": true, "--": true };
              return O.type === "UpdateExpression" && it[O.operator] ? Pe(O.argument, me) : O.type === "TSNonNullExpression" ? Pe(O.expression, me) : false;
            }
            function oe(O) {
              var me, _e;
              return (me = (_e = O.extra) === null || _e === void 0 ? void 0 : _e.raw) !== null && me !== void 0 ? me : O.raw;
            }
            function H(O) {
              return O;
            }
            function pe(O) {
              return O.filepath && /\.tsx$/i.test(O.filepath);
            }
            function X(O) {
              let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
              return O.trailingComma === "es5" && me === "es5" || O.trailingComma === "all" && (me === "all" || me === "es5");
            }
            function le(O, me) {
              switch (O.type) {
                case "BinaryExpression":
                case "LogicalExpression":
                case "AssignmentExpression":
                case "NGPipeExpression":
                  return le(O.left, me);
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return le(O.object, me);
                case "TaggedTemplateExpression":
                  return O.tag.type === "FunctionExpression" ? false : le(O.tag, me);
                case "CallExpression":
                case "OptionalCallExpression":
                  return O.callee.type === "FunctionExpression" ? false : le(O.callee, me);
                case "ConditionalExpression":
                  return le(O.test, me);
                case "UpdateExpression":
                  return !O.prefix && le(O.argument, me);
                case "BindExpression":
                  return O.object && le(O.object, me);
                case "SequenceExpression":
                  return le(O.expressions[0], me);
                case "TSSatisfiesExpression":
                case "TSAsExpression":
                case "TSNonNullExpression":
                  return le(O.expression, me);
                default:
                  return me(O);
              }
            }
            var Ae = { "==": true, "!=": true, "===": true, "!==": true }, Ee = { "*": true, "/": true, "%": true }, De = { ">>": true, ">>>": true, "<<": true };
            function A(O, me) {
              return !(re(me) !== re(O) || O === "**" || Ae[O] && Ae[me] || me === "%" && Ee[O] || O === "%" && Ee[me] || me !== O && Ee[me] && Ee[O] || De[O] && De[me]);
            }
            var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, me) => O.map((_e) => [_e, me])));
            function re(O) {
              return G.get(O);
            }
            function ye(O) {
              return Boolean(De[O]) || O === "|" || O === "^" || O === "&";
            }
            function Ce(O) {
              var me;
              if (O.rest)
                return true;
              let _e = ve(O);
              return ((me = s(_e)) === null || me === void 0 ? void 0 : me.type) === "RestElement";
            }
            var Be = /* @__PURE__ */ new WeakMap();
            function ve(O) {
              if (Be.has(O))
                return Be.get(O);
              let me = [];
              return O.this && me.push(O.this), Array.isArray(O.parameters) ? me.push(...O.parameters) : Array.isArray(O.params) && me.push(...O.params), O.rest && me.push(O.rest), Be.set(O, me), me;
            }
            function ze(O, me) {
              let _e = O.getValue(), He = 0, Ge = (it) => me(it, He++);
              _e.this && O.call(Ge, "this"), Array.isArray(_e.parameters) ? O.each(Ge, "parameters") : Array.isArray(_e.params) && O.each(Ge, "params"), _e.rest && O.call(Ge, "rest");
            }
            var be = /* @__PURE__ */ new WeakMap();
            function Ye(O) {
              if (be.has(O))
                return be.get(O);
              let me = O.arguments;
              return O.type === "ImportExpression" && (me = [O.source], O.attributes && me.push(O.attributes)), be.set(O, me), me;
            }
            function Se(O, me) {
              let _e = O.getValue();
              _e.type === "ImportExpression" ? (O.call((He) => me(He, 0), "source"), _e.attributes && O.call((He) => me(He, 1), "attributes")) : O.each(me, "arguments");
            }
            function Ie(O) {
              return O.value.trim() === "prettier-ignore" && !O.unignore;
            }
            function Oe(O) {
              return O && (O.prettierIgnore || Me(O, Te.PrettierIgnore));
            }
            function Je(O) {
              let me = O.getValue();
              return Oe(me);
            }
            var Te = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je = (O, me) => {
              if (typeof O == "function" && (me = O, O = 0), O || me)
                return (_e, He, Ge) => !(O & Te.Leading && !_e.leading || O & Te.Trailing && !_e.trailing || O & Te.Dangling && (_e.leading || _e.trailing) || O & Te.Block && !g(_e) || O & Te.Line && !D(_e) || O & Te.First && He !== 0 || O & Te.Last && He !== Ge.length - 1 || O & Te.PrettierIgnore && !Ie(_e) || me && !me(_e));
            };
            function Me(O, me, _e) {
              if (!u(O == null ? void 0 : O.comments))
                return false;
              let He = je(me, _e);
              return He ? O.comments.some(He) : true;
            }
            function ae(O, me, _e) {
              if (!Array.isArray(O == null ? void 0 : O.comments))
                return [];
              let He = je(me, _e);
              return He ? O.comments.filter(He) : O.comments;
            }
            var nt = (O, me) => {
              let { originalText: _e } = me;
              return i(_e, y(O));
            };
            function tt(O) {
              return de(O) || O.type === "NewExpression" || O.type === "ImportExpression";
            }
            function Ve(O) {
              return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
            }
            function We(O) {
              return Boolean(O.__isUsingHackPipeline);
            }
            var Xe = Symbol("ifWithoutBlockAndSameLineComment");
            function st(O) {
              return O.type === "TSAsExpression" || O.type === "TSSatisfiesExpression";
            }
            r.exports = { getFunctionParameters: ve, iterateFunctionParametersPath: ze, getCallArguments: Ye, iterateCallArgumentsPath: Se, hasRestParameter: Ce, getLeftSide: I, getLeftSidePathName: P, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: E, hasFlowShorthandAnnotationComment: w, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x, hasNode: N6, hasIgnoreComment: Je, hasNodeIgnoreComment: Oe, identity: H, isBinaryish: V, isCallLikeExpression: tt, isEnabledHackPipeline: We, isLineComment: D, isPrettierIgnoreComment: Ie, isCallExpression: de, isMemberExpression: ue, isExportDeclaration: T, isFlowAnnotationComment: U3, isFunctionCompositionArgs: Re, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q, isJestEachTemplateLiteral: ge, isJsxNode: M, isLiteral: C, isLongCurriedCallExpression: Ne, isSimpleCallArgument: Pe, isMemberish: j, isNumericLiteral: o, isSignedNumericLiteral: d, isObjectProperty: Ve, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie, isSimpleNumber: fe, isSimpleTemplateLiteral: Fe, isStringLiteral: v, isStringPropSafeToUnquote: se, isTemplateOnItsOwnLine: we, isTestCall: K, isTheOnlyJsxElementInMarkdown: R4, isTSXFile: pe, isTypeAnnotationAFunction: Q, isNextLineEmpty: nt, needsHardlineAfterDanglingComment: ke, rawText: oe, shouldPrintComma: X, isBitwiseOperator: ye, shouldFlatten: A, startsWithNoLookaheadToken: le, getPrecedence: re, hasComment: Me, getComments: ae, CommentCheckFlags: Te, markerForIfWithoutBlockAndSameLineComment: Xe, isTSTypeExpression: st };
          } }), jt = te({ "src/language-js/print/template-literal.js"(e, r) {
            "use strict";
            ne();
            var t4 = lt(), { getStringWidth: s, getIndentSize: a } = Ue(), { builders: { join: n, hardline: u, softline: i, group: l, indent: p, align: y, lineSuffixBoundary: h2, addAlignmentToDoc: g }, printer: { printDocToString: c }, utils: { mapDoc: f } } = qe(), { isBinaryish: F4, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w, hasComment: E, isMemberExpression: N6, isTSTypeExpression: x } = Ke();
            function I(C, o, d) {
              let v = C.getValue();
              if (v.type === "TemplateLiteral" && _(v, C.getParentNode())) {
                let R4 = P(C, d, o);
                if (R4)
                  return R4;
              }
              let b = "expressions";
              v.type === "TSTemplateLiteralType" && (b = "types");
              let B = [], k = C.map(o, b), M = w(v);
              return M && (k = k.map((R4) => c(R4, Object.assign(Object.assign({}, d), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(h2, "`"), C.each((R4) => {
                let q = R4.getName();
                if (B.push(o()), q < k.length) {
                  let { tabWidth: J } = d, L = R4.getValue(), Q = a(L.value.raw, J), V = k[q];
                  if (!M) {
                    let Y = v[b][q];
                    (E(Y) || N6(Y) || Y.type === "ConditionalExpression" || Y.type === "SequenceExpression" || x(Y) || F4(Y)) && (V = [p([i, V]), i]);
                  }
                  let j = Q === 0 && L.value.raw.endsWith(`
`) ? y(Number.NEGATIVE_INFINITY, V) : g(V, Q, J);
                  B.push(l(["${", j, h2, "}"]));
                }
              }, "quasis"), B.push("`"), B;
            }
            function P(C, o, d) {
              let v = C.getNode(), S = v.quasis[0].value.raw.trim().split(/\s*\|\s*/);
              if (S.length > 1 || S.some((b) => b.length > 0)) {
                o.__inJestEach = true;
                let b = C.map(d, "expressions");
                o.__inJestEach = false;
                let B = [], k = b.map((L) => "${" + c(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M = [{ hasLineBreak: false, cells: [] }];
                for (let L = 1; L < v.quasis.length; L++) {
                  let Q = t4(M), V = k[L - 1];
                  Q.cells.push(V), V.includes(`
`) && (Q.hasLineBreak = true), v.quasis[L].value.raw.includes(`
`) && M.push({ hasLineBreak: false, cells: [] });
                }
                let R4 = Math.max(S.length, ...M.map((L) => L.cells.length)), q = Array.from({ length: R4 }).fill(0), J = [{ cells: S }, ...M.filter((L) => L.cells.length > 0)];
                for (let { cells: L } of J.filter((Q) => !Q.hasLineBreak))
                  for (let [Q, V] of L.entries())
                    q[Q] = Math.max(q[Q], s(V));
                return B.push(h2, "`", p([u, n(u, J.map((L) => n(" | ", L.cells.map((Q, V) => L.hasLineBreak ? Q : Q + " ".repeat(q[V] - s(Q))))))]), u, "`"), B;
              }
            }
            function $(C, o) {
              let d = C.getValue(), v = o();
              return E(d) && (v = l([p([i, v]), i])), ["${", v, h2, "}"];
            }
            function D(C, o) {
              return C.map((d) => $(d, o), "expressions");
            }
            function T(C, o) {
              return f(C, (d) => typeof d == "string" ? o ? d.replace(/(\\*)`/g, "$1$1\\`") : m(d) : d);
            }
            function m(C) {
              return C.replace(/([\\`]|\${)/g, "\\$1");
            }
            r.exports = { printTemplateLiteral: I, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m };
          } }), Ym = te({ "src/language-js/embed/markdown.js"(e, r) {
            "use strict";
            ne();
            var { builders: { indent: t4, softline: s, literalline: a, dedentToRoot: n } } = qe(), { escapeTemplateCharacters: u } = jt();
            function i(p, y, h2) {
              let c = p.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w, E) => "\\".repeat(E.length / 2) + "`"), f = l(c), F4 = f !== "";
              F4 && (c = c.replace(new RegExp(`^${f}`, "gm"), ""));
              let _ = u(h2(c, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
              return ["`", F4 ? t4([s, _]) : [a, n(_)], s, "`"];
            }
            function l(p) {
              let y = p.match(/^([^\S\n]*)\S/m);
              return y === null ? "" : y[1];
            }
            r.exports = i;
          } }), Qm = te({ "src/language-js/embed/css.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t4 } = Ue(), { builders: { indent: s, hardline: a, softline: n }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe(), { printTemplateExpressions: p } = jt();
            function y(c, f, F4) {
              let _ = c.getValue(), w = _.quasis.map((P) => P.value.raw), E = 0, N6 = w.reduce((P, $, D) => D === 0 ? $ : P + "@prettier-placeholder-" + E++ + "-id" + $, ""), x = F4(N6, { parser: "scss" }, { stripTrailingHardline: true }), I = p(c, f);
              return h2(x, _, I);
            }
            function h2(c, f, F4) {
              if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
                return "``";
              let w = g(c, F4);
              if (!w)
                throw new Error("Couldn't insert all the expressions");
              return ["`", s([a, w]), n, "`"];
            }
            function g(c, f) {
              if (!t4(f))
                return c;
              let F4 = 0, _ = u(l(c), (w) => typeof w != "string" || !w.includes("@prettier-placeholder") ? w : w.split(/@prettier-placeholder-(\d+)-id/).map((E, N6) => N6 % 2 === 0 ? i(E) : (F4++, f[E])));
              return f.length === F4 ? _ : null;
            }
            r.exports = y;
          } }), Zm = te({ "src/language-js/embed/graphql.js"(e, r) {
            "use strict";
            ne();
            var { builders: { indent: t4, join: s, hardline: a } } = qe(), { escapeTemplateCharacters: n, printTemplateExpressions: u } = jt();
            function i(p, y, h2) {
              let g = p.getValue(), c = g.quasis.length;
              if (c === 1 && g.quasis[0].value.raw.trim() === "")
                return "``";
              let f = u(p, y), F4 = [];
              for (let _ = 0; _ < c; _++) {
                let w = g.quasis[_], E = _ === 0, N6 = _ === c - 1, x = w.value.cooked, I = x.split(`
`), P = I.length, $ = f[_], D = P > 2 && I[0].trim() === "" && I[1].trim() === "", T = P > 2 && I[P - 1].trim() === "" && I[P - 2].trim() === "", m = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
                if (!N6 && /#[^\n\r]*$/.test(I[P - 1]))
                  return null;
                let C = null;
                m ? C = l(I) : C = h2(x, { parser: "graphql" }, { stripTrailingHardline: true }), C ? (C = n(C, false), !E && D && F4.push(""), F4.push(C), !N6 && T && F4.push("")) : !E && !N6 && D && F4.push(""), $ && F4.push($);
              }
              return ["`", t4([a, s(a, F4)]), a, "`"];
            }
            function l(p) {
              let y = [], h2 = false, g = p.map((c) => c.trim());
              for (let [c, f] of g.entries())
                f !== "" && (g[c - 1] === "" && h2 ? y.push([a, f]) : y.push(f), h2 = true);
              return y.length === 0 ? null : s(a, y);
            }
            r.exports = i;
          } }), ed = te({ "src/language-js/embed/html.js"(e, r) {
            "use strict";
            ne();
            var { builders: { indent: t4, line: s, hardline: a, group: n }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = jt(), p = 0;
            function y(h2, g, c, f, F4) {
              let { parser: _ } = F4, w = h2.getValue(), E = p;
              p = p + 1 >>> 0;
              let N6 = (d) => `PRETTIER_HTML_PLACEHOLDER_${d}_${E}_IN_JS`, x = w.quasis.map((d, v, S) => v === S.length - 1 ? d.value.cooked : d.value.cooked + N6(v)).join(""), I = i(h2, g);
              if (I.length === 0 && x.trim().length === 0)
                return "``";
              let P = new RegExp(N6("(\\d+)"), "g"), $ = 0, D = c(x, { parser: _, __onHtmlRoot(d) {
                $ = d.children.length;
              } }, { stripTrailingHardline: true }), T = u(D, (d) => {
                if (typeof d != "string")
                  return d;
                let v = [], S = d.split(P);
                for (let b = 0; b < S.length; b++) {
                  let B = S[b];
                  if (b % 2 === 0) {
                    B && (B = l(B), f.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v.push(B));
                    continue;
                  }
                  let k = Number(B);
                  v.push(I[k]);
                }
                return v;
              }), m = /^\s/.test(x) ? " " : "", C = /\s$/.test(x) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? a : m && C ? s : null;
              return n(o ? ["`", t4([o, n(T)]), o, "`"] : ["`", m, $ > 1 ? t4(n(T)) : n(T), C, "`"]);
            }
            r.exports = y;
          } }), td = te({ "src/language-js/embed.js"(e, r) {
            "use strict";
            ne();
            var { hasComment: t4, CommentCheckFlags: s, isObjectProperty: a } = Ke(), n = Ym(), u = Qm(), i = Zm(), l = ed();
            function p(D) {
              if (g(D) || _(D) || w(D) || c(D))
                return "css";
              if (x(D))
                return "graphql";
              if (P(D))
                return "html";
              if (f(D))
                return "angular";
              if (h2(D))
                return "markdown";
            }
            function y(D, T, m, C) {
              let o = D.getValue();
              if (o.type !== "TemplateLiteral" || $(o))
                return;
              let d = p(D);
              if (d) {
                if (d === "markdown")
                  return n(D, T, m);
                if (d === "css")
                  return u(D, T, m);
                if (d === "graphql")
                  return i(D, T, m);
                if (d === "html" || d === "angular")
                  return l(D, T, m, C, { parser: d });
              }
            }
            function h2(D) {
              let T = D.getValue(), m = D.getParentNode();
              return m && m.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
            }
            function g(D) {
              let T = D.getValue(), m = D.getParentNode(), C = D.getParentNode(1);
              return C && T.quasis && m.type === "JSXExpressionContainer" && C.type === "JSXElement" && C.openingElement.name.name === "style" && C.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
            }
            function c(D) {
              return D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "ArrayExpression" && m === "elements", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "styles" && m === "value", ...F4);
            }
            function f(D) {
              return D.match((T) => T.type === "TemplateLiteral", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "template" && m === "value", ...F4);
            }
            var F4 = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
            function _(D) {
              let T = D.getParentNode();
              if (!T || T.type !== "TaggedTemplateExpression")
                return false;
              let m = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
              switch (m.type) {
                case "MemberExpression":
                  return E(m.object) || N6(m);
                case "CallExpression":
                  return E(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (E(m.callee.object.object) || N6(m.callee.object)) || m.callee.object.type === "CallExpression" && E(m.callee.object.callee));
                case "Identifier":
                  return m.name === "css";
                default:
                  return false;
              }
            }
            function w(D) {
              let T = D.getParentNode(), m = D.getParentNode(1);
              return m && T.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
            }
            function E(D) {
              return D.type === "Identifier" && D.name === "styled";
            }
            function N6(D) {
              return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
            }
            function x(D) {
              let T = D.getValue(), m = D.getParentNode();
              return I(T, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
            }
            function I(D, T) {
              return t4(D, s.Block | s.Leading, (m) => {
                let { value: C } = m;
                return C === ` ${T} `;
              });
            }
            function P(D) {
              return I(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m === "quasi");
            }
            function $(D) {
              let { quasis: T } = D;
              return T.some((m) => {
                let { value: { cooked: C } } = m;
                return C === null;
              });
            }
            r.exports = y;
          } }), rd = te({ "src/language-js/clean.js"(e, r) {
            "use strict";
            ne();
            var t4 = Pt(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
              for (let i of u.quasis)
                delete i.value;
            };
            function n(u, i, l) {
              if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
                return null;
              if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((h2) => h2.name.name === "jsx"))
                for (let { type: h2, expression: g } of i.children)
                  h2 === "JSXExpressionContainer" && g.type === "TemplateLiteral" && a(g);
              u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
              let p = u.expression || u.callee;
              if (u.type === "Decorator" && p.type === "CallExpression" && p.callee.name === "Component" && p.arguments.length === 1) {
                let h2 = u.expression.arguments[0].properties;
                for (let [g, c] of i.expression.arguments[0].properties.entries())
                  switch (h2[g].key.name) {
                    case "styles":
                      c.value.type === "ArrayExpression" && a(c.value.elements[0]);
                      break;
                    case "template":
                      c.value.type === "TemplateLiteral" && a(c.value);
                      break;
                  }
              }
              if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
                var y;
                (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some((g) => t4(g) && ["GraphQL", "HTML"].some((c) => g.value === ` ${c} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a(i);
              }
              if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
                return i.types[0];
            }
            n.ignoredProperties = s, r.exports = n;
          } }), io = {};
          Kt(io, { EOL: () => Wn, arch: () => nd, cpus: () => Do, default: () => vo, endianness: () => ao, freemem: () => po, getNetworkInterfaces: () => ho, hostname: () => oo, loadavg: () => lo, networkInterfaces: () => yo, platform: () => ud, release: () => go, tmpDir: () => $n, tmpdir: () => Vn, totalmem: () => fo, type: () => mo, uptime: () => co });
          function ao() {
            if (typeof Tr > "u") {
              var e = new ArrayBuffer(2), r = new Uint8Array(e), t4 = new Uint16Array(e);
              if (r[0] = 1, r[1] = 2, t4[0] === 258)
                Tr = "BE";
              else if (t4[0] === 513)
                Tr = "LE";
              else
                throw new Error("unable to figure out endianess");
            }
            return Tr;
          }
          function oo() {
            return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
          }
          function lo() {
            return [];
          }
          function co() {
            return 0;
          }
          function po() {
            return Number.MAX_VALUE;
          }
          function fo() {
            return Number.MAX_VALUE;
          }
          function Do() {
            return [];
          }
          function mo() {
            return "Browser";
          }
          function go() {
            return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
          }
          function yo() {
          }
          function ho() {
          }
          function nd() {
            return "javascript";
          }
          function ud() {
            return "browser";
          }
          function $n() {
            return "/tmp";
          }
          var Tr, Vn, Wn, vo, sd = ht({ "node-modules-polyfills:os"() {
            ne(), Vn = $n, Wn = `
`, vo = { EOL: Wn, tmpdir: Vn, tmpDir: $n, networkInterfaces: yo, getNetworkInterfaces: ho, release: go, type: mo, cpus: Do, totalmem: fo, freemem: po, uptime: co, loadavg: lo, hostname: oo, endianness: ao };
          } }), id = te({ "node-modules-polyfills-commonjs:os"(e, r) {
            ne();
            var t4 = (sd(), ft(io));
            if (t4 && t4.default) {
              r.exports = t4.default;
              for (let s in t4)
                r.exports[s] = t4[s];
            } else
              t4 && (r.exports = t4);
          } }), ad = te({ "node_modules/detect-newline/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = (s) => {
              if (typeof s != "string")
                throw new TypeError("Expected a string");
              let a = s.match(/(?:\r?\n)/g) || [];
              if (a.length === 0)
                return;
              let n = a.filter((i) => i === `\r
`).length, u = a.length - n;
              return n > u ? `\r
` : `
`;
            };
            r.exports = t4, r.exports.graceful = (s) => typeof s == "string" && t4(s) || `
`;
          } }), od = te({ "node_modules/jest-docblock/build/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = c, e.parse = F4, e.parseWithComments = _, e.print = w, e.strip = f;
            function r() {
              let N6 = id();
              return r = function() {
                return N6;
              }, N6;
            }
            function t4() {
              let N6 = s(ad());
              return t4 = function() {
                return N6;
              }, N6;
            }
            function s(N6) {
              return N6 && N6.__esModule ? N6 : { default: N6 };
            }
            var a = /\*\/$/, n = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h2 = /(\r?\n|^) *\* ?/g, g = [];
            function c(N6) {
              let x = N6.match(u);
              return x ? x[0].trimLeft() : "";
            }
            function f(N6) {
              let x = N6.match(u);
              return x && x[0] ? N6.substring(x[0].length) : N6;
            }
            function F4(N6) {
              return _(N6).pragmas;
            }
            function _(N6) {
              let x = (0, t4().default)(N6) || r().EOL;
              N6 = N6.replace(n, "").replace(a, "").replace(h2, "$1");
              let I = "";
              for (; I !== N6; )
                I = N6, N6 = N6.replace(p, `${x}$1 $2${x}`);
              N6 = N6.replace(l, "").trimRight();
              let P = /* @__PURE__ */ Object.create(null), $ = N6.replace(y, "").replace(l, "").trimRight(), D;
              for (; D = y.exec(N6); ) {
                let T = D[2].replace(i, "");
                typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g.concat(P[D[1]], T) : P[D[1]] = T;
              }
              return { comments: $, pragmas: P };
            }
            function w(N6) {
              let { comments: x = "", pragmas: I = {} } = N6, P = (0, t4().default)(x) || r().EOL, $ = "/**", D = " *", T = " */", m = Object.keys(I), C = m.map((d) => E(d, I[d])).reduce((d, v) => d.concat(v), []).map((d) => `${D} ${d}${P}`).join("");
              if (!x) {
                if (m.length === 0)
                  return "";
                if (m.length === 1 && !Array.isArray(I[m[0]])) {
                  let d = I[m[0]];
                  return `${$} ${E(m[0], d)[0]}${T}`;
                }
              }
              let o = x.split(P).map((d) => `${D} ${d}`).join(P) + P;
              return $ + P + (x ? o : "") + (x && m.length ? D + P : "") + C + T;
            }
            function E(N6, x) {
              return g.concat(x).map((I) => `@${N6} ${I}`.trim());
            }
          } }), ld = te({ "src/language-js/utils/get-shebang.js"(e, r) {
            "use strict";
            ne();
            function t4(s) {
              if (!s.startsWith("#!"))
                return "";
              let a = s.indexOf(`
`);
              return a === -1 ? s : s.slice(0, a);
            }
            r.exports = t4;
          } }), Co = te({ "src/language-js/pragma.js"(e, r) {
            "use strict";
            ne();
            var { parseWithComments: t4, strip: s, extract: a, print: n } = od(), { normalizeEndOfLine: u } = Jn(), i = ld();
            function l(h2) {
              let g = i(h2);
              g && (h2 = h2.slice(g.length + 1));
              let c = a(h2), { pragmas: f, comments: F4 } = t4(c);
              return { shebang: g, text: h2, pragmas: f, comments: F4 };
            }
            function p(h2) {
              let g = Object.keys(l(h2).pragmas);
              return g.includes("prettier") || g.includes("format");
            }
            function y(h2) {
              let { shebang: g, text: c, pragmas: f, comments: F4 } = l(h2), _ = s(c), w = n({ pragmas: Object.assign({ format: "" }, f), comments: F4.trimStart() });
              return (g ? `${g}
` : "") + u(w) + (_.startsWith(`
`) ? `
` : `

`) + _;
            }
            r.exports = { hasPragma: p, insertPragma: y };
          } }), cd = te({ "src/language-js/utils/is-type-cast-comment.js"(e, r) {
            "use strict";
            ne();
            var t4 = Pt();
            function s(a) {
              return t4(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/.test(a.value);
            }
            r.exports = s;
          } }), Eo = te({ "src/language-js/comments.js"(e, r) {
            "use strict";
            ne();
            var { getLast: t4, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: n, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: p, getNextNonSpaceNonCommentCharacterIndex: y, isNonEmptyArray: h2 } = Ue(), { getFunctionParameters: g, isPrettierIgnoreComment: c, isJsxNode: f, hasFlowShorthandAnnotationComment: F4, hasFlowAnnotationComment: _, hasIgnoreComment: w, isCallLikeExpression: E, getCallArguments: N6, isCallExpression: x, isMemberExpression: I, isObjectProperty: P, isLineComment: $, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m } = Ke(), { locStart: C, locEnd: o } = ut(), d = Pt(), v = cd();
            function S(De) {
              return [H, Fe, Q, q, J, L, ie, he, se, ge, we, ke, ce, z, U3].some((A) => A(De));
            }
            function b(De) {
              return [R4, Fe, V, we, q, J, L, ie, z, Z, fe, ge, Pe, U3, X].some((A) => A(De));
            }
            function B(De) {
              return [H, q, J, j, ue, ce, ge, de, K, pe, U3, oe].some((A) => A(De));
            }
            function k(De, A) {
              let G = (De.body || De.properties).find((re) => {
                let { type: ye } = re;
                return ye !== "EmptyStatement";
              });
              G ? i(G, A) : p(De, A);
            }
            function M(De, A) {
              De.type === "BlockStatement" ? k(De, A) : i(De, A);
            }
            function R4(De) {
              let { comment: A, followingNode: G } = De;
              return G && v(A) ? (i(G, A), true) : false;
            }
            function q(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
              if ((re == null ? void 0 : re.type) !== "IfStatement" || !ye)
                return false;
              if (n(Ce, A, o) === ")")
                return l(G, A), true;
              if (G === re.consequent && ye === re.alternate) {
                if (G.type === "BlockStatement")
                  l(G, A);
                else {
                  let ve = A.type === "SingleLine" || A.loc.start.line === A.loc.end.line, ze = A.loc.start.line === G.loc.start.line;
                  ve && ze ? p(G, A, m) : p(re, A);
                }
                return true;
              }
              return ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "IfStatement" ? (M(ye.consequent, A), true) : re.consequent === ye ? (i(ye, A), true) : false;
            }
            function J(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
              return (re == null ? void 0 : re.type) !== "WhileStatement" || !ye ? false : n(Ce, A, o) === ")" ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : re.body === ye ? (i(ye, A), true) : false;
            }
            function L(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              return (re == null ? void 0 : re.type) !== "TryStatement" && (re == null ? void 0 : re.type) !== "CatchClause" || !ye ? false : re.type === "CatchClause" && G ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "TryStatement" ? (M(ye.finalizer, A), true) : ye.type === "CatchClause" ? (M(ye.body, A), true) : false;
            }
            function Q(De) {
              let { comment: A, enclosingNode: G, followingNode: re } = De;
              return I(G) && (re == null ? void 0 : re.type) === "Identifier" ? (i(G, A), true) : false;
            }
            function V(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De, Be = G && !u(Ce, o(G), C(A));
              return (!G || !Be) && ((re == null ? void 0 : re.type) === "ConditionalExpression" || (re == null ? void 0 : re.type) === "TSConditionalType") && ye ? (i(ye, A), true) : false;
            }
            function j(De) {
              let { comment: A, precedingNode: G, enclosingNode: re } = De;
              return P(re) && re.shorthand && re.key === G && re.value.type === "AssignmentPattern" ? (l(re.value.left, A), true) : false;
            }
            var Y = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
            function ie(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              if (Y.has(re == null ? void 0 : re.type)) {
                if (h2(re.decorators) && !(ye && ye.type === "Decorator"))
                  return l(t4(re.decorators), A), true;
                if (re.body && ye === re.body)
                  return k(re.body, A), true;
                if (ye) {
                  if (re.superClass && ye === re.superClass && G && (G === re.id || G === re.typeParameters))
                    return l(G, A), true;
                  for (let Ce of ["implements", "extends", "mixins"])
                    if (re[Ce] && ye === re[Ce][0])
                      return G && (G === re.id || G === re.typeParameters || G === re.superClass) ? l(G, A) : p(re, A, Ce), true;
                }
              }
              return false;
            }
            var ee = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
            function ce(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
              return re && G && n(ye, A, o) === "(" && (re.type === "Property" || re.type === "TSDeclareMethod" || re.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && re.key === G && n(ye, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && ee.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
            }
            var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
            function K(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
              return n(ye, A, o) !== "(" ? false : G && W.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
            }
            function de(De) {
              let { comment: A, enclosingNode: G, text: re } = De;
              if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression")
                return false;
              let ye = y(re, A, o);
              return ye !== false && re.slice(ye, ye + 2) === "=>" ? (p(G, A), true) : false;
            }
            function ue(De) {
              let { comment: A, enclosingNode: G, text: re } = De;
              return n(re, A, o) !== ")" ? false : G && (le(G) && g(G).length === 0 || E(G) && N6(G).length === 0) ? (p(G, A), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g(G.value).length === 0 ? (p(G.value, A), true) : false;
            }
            function Fe(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
              if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (re == null ? void 0 : re.type) === "FunctionTypeAnnotation" && (ye == null ? void 0 : ye.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && re && le(re) && n(Ce, A, o) === ")")
                return l(G, A), true;
              if ((re == null ? void 0 : re.type) === "FunctionDeclaration" && (ye == null ? void 0 : ye.type) === "BlockStatement") {
                let Be = (() => {
                  let ve = g(re);
                  if (ve.length > 0)
                    return a(Ce, o(t4(ve)));
                  let ze = a(Ce, o(re.id));
                  return ze !== false && a(Ce, ze + 1);
                })();
                if (C(A) > Be)
                  return k(ye, A), true;
              }
              return false;
            }
            function z(De) {
              let { comment: A, enclosingNode: G } = De;
              return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, A), true) : false;
            }
            function U3(De) {
              let { comment: A, enclosingNode: G } = De;
              return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, A), true) : false;
            }
            function Z(De) {
              let { comment: A, precedingNode: G, enclosingNode: re } = De;
              return x(re) && G && re.callee === G && re.arguments.length > 0 ? (i(re.arguments[0], A), true) : false;
            }
            function se(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              return (re == null ? void 0 : re.type) === "UnionTypeAnnotation" || (re == null ? void 0 : re.type) === "TSUnionType" ? (c(A) && (ye.prettierIgnore = true, A.unignore = true), G ? (l(G, A), true) : false) : (((ye == null ? void 0 : ye.type) === "UnionTypeAnnotation" || (ye == null ? void 0 : ye.type) === "TSUnionType") && c(A) && (ye.types[0].prettierIgnore = true, A.unignore = true), false);
            }
            function fe(De) {
              let { comment: A, enclosingNode: G } = De;
              return P(G) ? (i(G, A), true) : false;
            }
            function ge(De) {
              let { comment: A, enclosingNode: G, followingNode: re, ast: ye, isLastComment: Ce } = De;
              return ye && ye.body && ye.body.length === 0 ? (Ce ? p(ye, A) : i(ye, A), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !h2(G.directives) ? (Ce ? p(G, A) : i(G, A), true) : (re == null ? void 0 : re.type) === "Program" && (re == null ? void 0 : re.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (p(re, A), true) : false;
            }
            function he(De) {
              let { comment: A, enclosingNode: G } = De;
              return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, A), true) : false;
            }
            function we(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
              if ((re == null ? void 0 : re.type) === "ImportSpecifier" || (re == null ? void 0 : re.type) === "ExportSpecifier")
                return i(re, A), true;
              let Ce = (G == null ? void 0 : G.type) === "ImportSpecifier" && (re == null ? void 0 : re.type) === "ImportDeclaration", Be = (G == null ? void 0 : G.type) === "ExportSpecifier" && (re == null ? void 0 : re.type) === "ExportNamedDeclaration";
              return (Ce || Be) && s(ye, o(A)) ? (l(G, A), true) : false;
            }
            function ke(De) {
              let { comment: A, enclosingNode: G } = De;
              return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, A), true) : false;
            }
            var Re = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
            function Pe(De) {
              let { comment: A, enclosingNode: G, followingNode: re } = De;
              return Re.has(G == null ? void 0 : G.type) && re && (Ne.has(re.type) || d(A)) ? (i(re, A), true) : false;
            }
            function oe(De) {
              let { comment: A, enclosingNode: G, followingNode: re, text: ye } = De;
              return !re && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && n(ye, A, o) === ";" ? (l(G, A), true) : false;
            }
            function H(De) {
              let { comment: A, enclosingNode: G, followingNode: re } = De;
              if (c(A) && (G == null ? void 0 : G.type) === "TSMappedType" && (re == null ? void 0 : re.type) === "TSTypeParameter" && re.constraint)
                return G.prettierIgnore = true, A.unignore = true, true;
            }
            function pe(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              return (re == null ? void 0 : re.type) !== "TSMappedType" ? false : (ye == null ? void 0 : ye.type) === "TSTypeParameter" && ye.name ? (i(ye.name, A), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, A), true) : false;
            }
            function X(De) {
              let { comment: A, enclosingNode: G, followingNode: re } = De;
              return !G || G.type !== "SwitchCase" || G.test || !re || re !== G.consequent[0] ? false : (re.type === "BlockStatement" && $(A) ? k(re, A) : p(G, A), true);
            }
            function le(De) {
              return De.type === "ArrowFunctionExpression" || De.type === "FunctionExpression" || De.type === "FunctionDeclaration" || De.type === "ObjectMethod" || De.type === "ClassMethod" || De.type === "TSDeclareFunction" || De.type === "TSCallSignatureDeclaration" || De.type === "TSConstructSignatureDeclaration" || De.type === "TSMethodSignature" || De.type === "TSConstructorType" || De.type === "TSFunctionType" || De.type === "TSDeclareMethod";
            }
            function Ae(De, A) {
              if ((A.parser === "typescript" || A.parser === "flow" || A.parser === "acorn" || A.parser === "espree" || A.parser === "meriyah" || A.parser === "__babel_estree") && De.type === "MethodDefinition" && De.value && De.value.type === "FunctionExpression" && g(De.value).length === 0 && !De.value.returnType && !h2(De.value.typeParameters) && De.value.body)
                return [...De.decorators || [], De.key, De.value.body];
            }
            function Ee(De) {
              let A = De.getValue(), G = De.getParentNode(), re = (ye) => _(D(ye, T.Leading)) || _(D(ye, T.Trailing));
              return (A && (f(A) || F4(A) || x(G) && re(A)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === A)) && (!w(De) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
            }
            r.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae, willPrintOwnComments: Ee };
          } }), qt = te({ "src/language-js/needs-parens.js"(e, r) {
            "use strict";
            ne();
            var t4 = lt(), s = Kn(), { getFunctionParameters: a, getLeftSidePathName: n, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: p, startsWithNoLookaheadToken: y, shouldFlatten: h2, getPrecedence: g, isCallExpression: c, isMemberExpression: f, isObjectProperty: F4, isTSTypeExpression: _ } = Ke();
            function w(D, T) {
              let m = D.getParentNode();
              if (!m)
                return false;
              let C = D.getName(), o = D.getNode();
              if (T.__isInHtmlInterpolation && !T.bracketSpacing && I(o) && P(D))
                return true;
              if (E(o))
                return false;
              if (T.parser !== "flow" && u(D.getValue()))
                return true;
              if (o.type === "Identifier") {
                if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C === "left" && (o.name === "async" && !m.await || o.name === "let") && m.type === "ForOfStatement")
                  return true;
                if (o.name === "let") {
                  var d;
                  let S = (d = D.findAncestor((b) => b.type === "ForOfStatement")) === null || d === void 0 ? void 0 : d.left;
                  if (S && y(S, (b) => b === o))
                    return true;
                }
                if (C === "object" && o.name === "let" && m.type === "MemberExpression" && m.computed && !m.optional) {
                  let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
                  if (b && y(b, (B) => B === o))
                    return true;
                }
                return false;
              }
              if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
                var v;
                let S = (v = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v === void 0 ? void 0 : v.expression;
                if (S && y(S, (b) => b === o))
                  return true;
              }
              switch (m.type) {
                case "ParenthesizedExpression":
                  return false;
                case "ClassDeclaration":
                case "ClassExpression": {
                  if (C === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression"))
                    return true;
                  break;
                }
                case "ExportDefaultDeclaration":
                  return $(D, T) || o.type === "SequenceExpression";
                case "Decorator": {
                  if (C === "expression") {
                    let S = false, b = false, B = o;
                    for (; B; )
                      switch (B.type) {
                        case "MemberExpression":
                          b = true, B = B.object;
                          break;
                        case "CallExpression":
                          if (b || S)
                            return T.parser !== "typescript";
                          S = true, B = B.callee;
                          break;
                        case "Identifier":
                          return false;
                        case "TaggedTemplateExpression":
                          return T.parser !== "typescript";
                        default:
                          return true;
                      }
                    return true;
                  }
                  break;
                }
                case "ArrowFunctionExpression": {
                  if (C === "body" && o.type !== "SequenceExpression" && y(o, (S) => S.type === "ObjectExpression"))
                    return true;
                  break;
                }
              }
              switch (o.type) {
                case "UpdateExpression":
                  if (m.type === "UnaryExpression")
                    return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
                case "UnaryExpression":
                  switch (m.type) {
                    case "UnaryExpression":
                      return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "TaggedTemplateExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "BinaryExpression":
                      return C === "left" && m.operator === "**";
                    case "TSNonNullExpression":
                      return true;
                    default:
                      return false;
                  }
                case "BinaryExpression": {
                  if (m.type === "UpdateExpression" || o.operator === "in" && N6(D))
                    return true;
                  if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
                    let S = D.getParentNode(1);
                    if (S.type === "BinaryExpression" && S.operator === "|>")
                      return true;
                  }
                }
                case "TSTypeAssertion":
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "LogicalExpression":
                  switch (m.type) {
                    case "TSSatisfiesExpression":
                    case "TSAsExpression":
                      return !_(o);
                    case "ConditionalExpression":
                      return _(o);
                    case "CallExpression":
                    case "NewExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "ClassExpression":
                    case "ClassDeclaration":
                      return C === "superClass";
                    case "TSTypeAssertion":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "JSXSpreadAttribute":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BindExpression":
                    case "AwaitExpression":
                    case "TSNonNullExpression":
                    case "UpdateExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "AssignmentExpression":
                    case "AssignmentPattern":
                      return C === "left" && (o.type === "TSTypeAssertion" || _(o));
                    case "LogicalExpression":
                      if (o.type === "LogicalExpression")
                        return m.operator !== o.operator;
                    case "BinaryExpression": {
                      let { operator: S, type: b } = o;
                      if (!S && b !== "TSTypeAssertion")
                        return true;
                      let B = g(S), k = m.operator, M = g(k);
                      return M > B || C === "right" && M === B || M === B && !h2(k, S) ? true : M < B && S === "%" ? k === "+" || k === "-" : !!p(k);
                    }
                    default:
                      return false;
                  }
                case "SequenceExpression":
                  switch (m.type) {
                    case "ReturnStatement":
                      return false;
                    case "ForStatement":
                      return false;
                    case "ExpressionStatement":
                      return C !== "expression";
                    case "ArrowFunctionExpression":
                      return C !== "body";
                    default:
                      return true;
                  }
                case "YieldExpression":
                  if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || _(m) || m.type === "TSNonNullExpression")
                    return true;
                case "AwaitExpression":
                  switch (m.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "ConditionalExpression":
                      return C === "test";
                    case "BinaryExpression":
                      return !(!o.argument && m.operator === "|>");
                    default:
                      return false;
                  }
                case "TSConditionalType":
                case "TSFunctionType":
                case "TSConstructorType":
                  if (C === "extendsType" && m.type === "TSConditionalType") {
                    if (o.type === "TSConditionalType")
                      return true;
                    let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
                    if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint)
                      return true;
                  }
                  if (C === "checkType" && m.type === "TSConditionalType")
                    return true;
                case "TSUnionType":
                case "TSIntersectionType":
                  if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1))
                    return true;
                case "TSInferType":
                  if (o.type === "TSInferType" && m.type === "TSRestType")
                    return false;
                case "TSTypeOperator":
                  return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || C === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
                case "TSTypeQuery":
                  return C === "objectType" && m.type === "TSIndexedAccessType" || C === "elementType" && m.type === "TSArrayType";
                case "ArrayTypeAnnotation":
                  return m.type === "NullableTypeAnnotation";
                case "IntersectionTypeAnnotation":
                case "UnionTypeAnnotation":
                  return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
                case "NullableTypeAnnotation":
                  return m.type === "ArrayTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
                case "FunctionTypeAnnotation": {
                  let S = m.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m;
                  return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
                }
                case "OptionalIndexedAccessType":
                  return C === "objectType" && m.type === "IndexedAccessType";
                case "TypeofTypeAnnotation":
                  return C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
                case "StringLiteral":
                case "NumericLiteral":
                case "Literal":
                  if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
                    let S = D.getParentNode(1);
                    return S.type === "Program" || S.type === "BlockStatement";
                  }
                  return C === "object" && m.type === "MemberExpression" && typeof o.value == "number";
                case "AssignmentExpression": {
                  let S = D.getParentNode(1);
                  return C === "body" && m.type === "ArrowFunctionExpression" ? true : C === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (C === "init" || C === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m || S.update === m) || C === "value" && m.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m) || m.type === "NGChainedExpression");
                }
                case "ConditionalExpression":
                  switch (m.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "NGPipeExpression":
                    case "ExportDefaultDeclaration":
                    case "AwaitExpression":
                    case "JSXSpreadAttribute":
                    case "TSTypeAssertion":
                    case "TypeCastExpression":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "ConditionalExpression":
                      return C === "test";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    default:
                      return false;
                  }
                case "FunctionExpression":
                  switch (m.type) {
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "TaggedTemplateExpression":
                      return true;
                    default:
                      return false;
                  }
                case "ArrowFunctionExpression":
                  switch (m.type) {
                    case "BinaryExpression":
                      return m.operator !== "|>" || o.extra && o.extra.parenthesized;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "AwaitExpression":
                    case "TSTypeAssertion":
                      return true;
                    case "ConditionalExpression":
                      return C === "test";
                    default:
                      return false;
                  }
                case "ClassExpression":
                  if (s(o.decorators))
                    return true;
                  switch (m.type) {
                    case "NewExpression":
                      return C === "callee";
                    default:
                      return false;
                  }
                case "OptionalMemberExpression":
                case "OptionalCallExpression": {
                  let S = D.getParentNode(1);
                  if (C === "object" && m.type === "MemberExpression" || C === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m)
                    return true;
                }
                case "CallExpression":
                case "MemberExpression":
                case "TaggedTemplateExpression":
                case "TSNonNullExpression":
                  if (C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
                    let S = o;
                    for (; S; )
                      switch (S.type) {
                        case "CallExpression":
                        case "OptionalCallExpression":
                          return true;
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                        case "BindExpression":
                          S = S.object;
                          break;
                        case "TaggedTemplateExpression":
                          S = S.tag;
                          break;
                        case "TSNonNullExpression":
                          S = S.expression;
                          break;
                        default:
                          return false;
                      }
                  }
                  return false;
                case "BindExpression":
                  return C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || C === "object" && f(m);
                case "NGPipeExpression":
                  return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || c(m) && m.arguments[C] === o || C === "right" && m.type === "NGPipeExpression" || C === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
                case "JSXFragment":
                case "JSXElement":
                  return C === "callee" || C === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !c(m) && !F4(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
                case "TypeAnnotation":
                  return C === "returnType" && m.type === "ArrowFunctionExpression" && x(o);
              }
              return false;
            }
            function E(D) {
              return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
            }
            function N6(D) {
              let T = 0, m = D.getValue();
              for (; m; ) {
                let C = D.getParentNode(T++);
                if (C && C.type === "ForStatement" && C.init === m)
                  return true;
                m = C;
              }
              return false;
            }
            function x(D) {
              return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
            }
            function I(D) {
              switch (D.type) {
                case "ObjectExpression":
                  return true;
                default:
                  return false;
              }
            }
            function P(D) {
              let T = D.getValue(), m = D.getParentNode(), C = D.getName();
              switch (m.type) {
                case "NGPipeExpression":
                  if (typeof C == "number" && m.arguments[C] === T && m.arguments.length - 1 === C)
                    return D.callParent(P);
                  break;
                case "ObjectProperty":
                  if (C === "value") {
                    let o = D.getParentNode(1);
                    return t4(o.properties) === m;
                  }
                  break;
                case "BinaryExpression":
                case "LogicalExpression":
                  if (C === "right")
                    return D.callParent(P);
                  break;
                case "ConditionalExpression":
                  if (C === "alternate")
                    return D.callParent(P);
                  break;
                case "UnaryExpression":
                  if (m.prefix)
                    return D.callParent(P);
                  break;
              }
              return false;
            }
            function $(D, T) {
              let m = D.getValue(), C = D.getParentNode();
              return m.type === "FunctionExpression" || m.type === "ClassExpression" ? C.type === "ExportDefaultDeclaration" || !w(D, T) : !i(m) || C.type !== "ExportDefaultDeclaration" && w(D, T) ? false : D.call((o) => $(o, T), ...n(D, m));
            }
            r.exports = w;
          } }), Fo = te({ "src/language-js/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            function t4(s, a) {
              switch (a.parser) {
                case "json":
                case "json5":
                case "json-stringify":
                case "__js_expression":
                case "__vue_expression":
                case "__vue_ts_expression":
                  return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
                default:
                  return s;
              }
            }
            r.exports = t4;
          } }), pd = te({ "src/language-js/print/html-binding.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t4, line: s, group: a, softline: n, indent: u } } = qe();
            function i(p, y, h2) {
              let g = p.getValue();
              if (y.__onHtmlBindingRoot && p.getName() === null && y.__onHtmlBindingRoot(g, y), g.type === "File") {
                if (y.__isVueForBindingLeft)
                  return p.call((c) => {
                    let f = t4([",", s], c.map(h2, "params")), { params: F4 } = c.getValue();
                    return F4.length === 1 ? f : ["(", u([n, a(f)]), n, ")"];
                  }, "program", "body", 0);
                if (y.__isVueBindings)
                  return p.call((c) => t4([",", s], c.map(h2, "params")), "program", "body", 0);
              }
            }
            function l(p) {
              switch (p.type) {
                case "MemberExpression":
                  switch (p.property.type) {
                    case "Identifier":
                    case "NumericLiteral":
                    case "StringLiteral":
                      return l(p.object);
                  }
                  return false;
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            r.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
          } }), ru = te({ "src/language-js/print/binaryish.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t4 } = et(), { getLast: s } = Ue(), { builders: { join: a, line: n, softline: u, group: i, indent: l, align: p, indentIfBreak: y }, utils: { cleanDoc: h2, getDocParts: g, isConcat: c } } = qe(), { hasLeadingOwnLineComment: f, isBinaryish: F4, isJsxNode: _, shouldFlatten: w, hasComment: E, CommentCheckFlags: N6, isCallExpression: x, isMemberExpression: I, isObjectProperty: P, isEnabledHackPipeline: $ } = Ke(), D = 0;
            function T(o, d, v) {
              let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M = $(d) && S.operator === "|>", R4 = m(o, v, d, false, k);
              if (k)
                return R4;
              if (M)
                return i(R4);
              if (x(b) && b.callee === S || b.type === "UnaryExpression" || I(b) && !b.computed)
                return i([l([u, ...R4]), u]);
              let q = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && d.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x(B) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = F4(S.left) && w(S.operator, S.left.operator);
              if (q || C(S) && !L || !C(S) && J)
                return i(R4);
              if (R4.length === 0)
                return "";
              let Q = _(S.right), V = R4.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j = R4.slice(0, V === -1 ? 1 : V + 1), Y = R4.slice(j.length, Q ? -1 : void 0), ie = Symbol("logicalChain-" + ++D), ee = i([...j, l(Y)], { id: ie });
              if (!Q)
                return ee;
              let ce = s(R4);
              return i([ee, y(ce, { groupId: ie })]);
            }
            function m(o, d, v, S, b) {
              let B = o.getValue();
              if (!F4(B))
                return [i(d())];
              let k = [];
              w(B.operator, B.left.operator) ? k = o.call((Y) => m(Y, d, v, true, b), "left") : k.push(i(d("left")));
              let M = C(B), R4 = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v.parser === "__vue_expression") && !f(v.originalText, B.right), q = B.type === "NGPipeExpression" ? "|" : B.operator, J = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i(l([n, ": ", a([n, ": "], o.map(d, "arguments").map((Y) => p(2, i(Y))))])) : "", L;
              if (M)
                L = [q, " ", d("right"), J];
              else {
                let ie = $(v) && q === "|>" ? o.call((ee) => m(ee, d, v, true, b), "right") : d("right");
                L = [R4 ? n : "", q, R4 ? " " : n, ie, J];
              }
              let Q = o.getParentNode(), V = E(B.left, N6.Trailing | N6.Line), j = V || !(b && B.type === "LogicalExpression") && Q.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
              if (k.push(R4 ? "" : " ", j ? i(L, { shouldBreak: V }) : L), S && E(B)) {
                let Y = h2(t4(o, k, v));
                return c(Y) || Y.type === "fill" ? g(Y) : [Y];
              }
              return k;
            }
            function C(o) {
              return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
            }
            r.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C };
          } }), fd = te({ "src/language-js/print/angular.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t4, line: s, group: a } } = qe(), { hasNode: n, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: l } = ru();
            function p(g, c, f) {
              let F4 = g.getValue();
              if (F4.type.startsWith("NG"))
                switch (F4.type) {
                  case "NGRoot":
                    return [f("node"), u(F4.node) ? " //" + i(F4.node)[0].value.trimEnd() : ""];
                  case "NGPipeExpression":
                    return l(g, c, f);
                  case "NGChainedExpression":
                    return a(t4([";", s], g.map((_) => h2(_) ? f() : ["(", f(), ")"], "expressions")));
                  case "NGEmptyExpression":
                    return "";
                  case "NGQuotedExpression":
                    return [F4.prefix, ": ", F4.value.trim()];
                  case "NGMicrosyntax":
                    return g.map((_, w) => [w === 0 ? "" : y(_.getValue(), w, F4) ? " " : [";", s], f()], "body");
                  case "NGMicrosyntaxKey":
                    return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(F4.name) ? F4.name : JSON.stringify(F4.name);
                  case "NGMicrosyntaxExpression":
                    return [f("expression"), F4.alias === null ? "" : [" as ", f("alias")]];
                  case "NGMicrosyntaxKeyedExpression": {
                    let _ = g.getName(), w = g.getParentNode(), E = y(F4, _, w) || (_ === 1 && (F4.key.name === "then" || F4.key.name === "else") || _ === 2 && F4.key.name === "else" && w.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w.body[_ - 1].key.name === "then") && w.body[0].type === "NGMicrosyntaxExpression";
                    return [f("key"), E ? " " : ": ", f("expression")];
                  }
                  case "NGMicrosyntaxLet":
                    return ["let ", f("key"), F4.value === null ? "" : [" = ", f("value")]];
                  case "NGMicrosyntaxAs":
                    return [f("key"), " as ", f("alias")];
                  default:
                    throw new Error(`Unknown Angular node type: ${JSON.stringify(F4.type)}.`);
                }
            }
            function y(g, c, f) {
              return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && c === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
            }
            function h2(g) {
              return n(g.getValue(), (c) => {
                switch (c.type) {
                  case void 0:
                    return false;
                  case "CallExpression":
                  case "OptionalCallExpression":
                  case "AssignmentExpression":
                    return true;
                }
              });
            }
            r.exports = { printAngular: p };
          } }), Dd = te({ "src/language-js/print/jsx.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t4, printDanglingComments: s, printCommentsSeparately: a } = et(), { builders: { line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y, fill: h2, ifBreak: g, lineSuffixBoundary: c, join: f }, utils: { willBreak: F4 } } = qe(), { getLast: _, getPreferredQuote: w } = Ue(), { isJsxNode: E, rawText: N6, isCallExpression: x, isStringLiteral: I, isBinaryish: P, hasComment: $, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke(), m = qt(), { willPrintOwnComments: C } = Eo(), o = (U3) => U3 === "" || U3 === n || U3 === u || U3 === i;
            function d(U3, Z, se) {
              let fe = U3.getValue();
              if (fe.type === "JSXElement" && de(fe))
                return [se("openingElement"), se("closingElement")];
              let ge = fe.type === "JSXElement" ? se("openingElement") : se("openingFragment"), he = fe.type === "JSXElement" ? se("closingElement") : se("closingFragment");
              if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression"))
                return [ge, ...U3.map(se, "children"), he];
              fe.children = fe.children.map((A) => Fe(A) ? { type: "JSXText", value: " ", raw: " " } : A);
              let we = fe.children.some(E), ke = fe.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, Re = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, Ne = F4(ge) || we || Re || ke, Pe = U3.getParentNode().rootMarker === "mdx", oe = Z.singleQuote ? "{' '}" : '{" "}', H = Pe ? " " : g([oe, i], " "), pe = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", X = v(U3, Z, se, H, pe), le = fe.children.some((A) => ue(A));
              for (let A = X.length - 2; A >= 0; A--) {
                let G = X[A] === "" && X[A + 1] === "", re = X[A] === u && X[A + 1] === "" && X[A + 2] === u, ye = (X[A] === i || X[A] === u) && X[A + 1] === "" && X[A + 2] === H, Ce = X[A] === H && X[A + 1] === "" && (X[A + 2] === i || X[A + 2] === u), Be = X[A] === H && X[A + 1] === "" && X[A + 2] === H, ve = X[A] === i && X[A + 1] === "" && X[A + 2] === u || X[A] === u && X[A + 1] === "" && X[A + 2] === i;
                re && le || G || ye || Be || ve ? X.splice(A, 2) : Ce && X.splice(A + 1, 2);
              }
              for (; X.length > 0 && o(_(X)); )
                X.pop();
              for (; X.length > 1 && o(X[0]) && o(X[1]); )
                X.shift(), X.shift();
              let Ae = [];
              for (let [A, G] of X.entries()) {
                if (G === H) {
                  if (A === 1 && X[A - 1] === "") {
                    if (X.length === 2) {
                      Ae.push(oe);
                      continue;
                    }
                    Ae.push([oe, u]);
                    continue;
                  } else if (A === X.length - 1) {
                    Ae.push(oe);
                    continue;
                  } else if (X[A - 1] === "" && X[A - 2] === u) {
                    Ae.push(oe);
                    continue;
                  }
                }
                Ae.push(G), F4(G) && (Ne = true);
              }
              let Ee = le ? h2(Ae) : l(Ae, { shouldBreak: true });
              if (Pe)
                return Ee;
              let De = l([ge, p([u, Ee]), u, he]);
              return Ne ? De : y([l([ge, ...X, he]), De]);
            }
            function v(U3, Z, se, fe, ge) {
              let he = [];
              return U3.each((we, ke, Re) => {
                let Ne = we.getValue();
                if (Ne.type === "JSXText") {
                  let Pe = N6(Ne);
                  if (ue(Ne)) {
                    let oe = Pe.split(ce);
                    if (oe[0] === "") {
                      if (he.push(""), oe.shift(), /\n/.test(oe[0])) {
                        let pe = Re[ke + 1];
                        he.push(b(ge, oe[1], Ne, pe));
                      } else
                        he.push(fe);
                      oe.shift();
                    }
                    let H;
                    if (_(oe) === "" && (oe.pop(), H = oe.pop()), oe.length === 0)
                      return;
                    for (let [pe, X] of oe.entries())
                      pe % 2 === 1 ? he.push(n) : he.push(X);
                    if (H !== void 0)
                      if (/\n/.test(H)) {
                        let pe = Re[ke + 1];
                        he.push(b(ge, _(he), Ne, pe));
                      } else
                        he.push(fe);
                    else {
                      let pe = Re[ke + 1];
                      he.push(S(ge, _(he), Ne, pe));
                    }
                  } else
                    /\n/.test(Pe) ? Pe.match(/\n/g).length > 1 && he.push("", u) : he.push("", fe);
                } else {
                  let Pe = se();
                  he.push(Pe);
                  let oe = Re[ke + 1];
                  if (oe && ue(oe)) {
                    let pe = K(N6(oe)).split(ce)[0];
                    he.push(S(ge, pe, Ne, oe));
                  } else
                    he.push(u);
                }
              }, "children"), he;
            }
            function S(U3, Z, se, fe) {
              return U3 ? "" : se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? i : u : i;
            }
            function b(U3, Z, se, fe) {
              return U3 ? u : Z.length === 1 ? se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? u : i : u;
            }
            function B(U3, Z, se) {
              let fe = U3.getParentNode();
              if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type])
                return Z;
              let he = U3.match(void 0, (ke) => ke.type === "ArrowFunctionExpression", x, (ke) => ke.type === "JSXExpressionContainer"), we = m(U3, se);
              return l([we ? "" : g("("), p([i, Z]), i, we ? "" : g(")")], { shouldBreak: he });
            }
            function k(U3, Z, se) {
              let fe = U3.getValue(), ge = [];
              if (ge.push(se("name")), fe.value) {
                let he;
                if (I(fe.value)) {
                  let ke = N6(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re, quote: Ne, regex: Pe } = w(ke, Z.jsxSingleQuote ? "'" : '"');
                  ke = ke.replace(Pe, Re);
                  let { leading: oe, trailing: H } = U3.call(() => a(U3, Z), "value");
                  he = [oe, Ne, ke, Ne, H];
                } else
                  he = se("value");
                ge.push("=", he);
              }
              return ge;
            }
            function M(U3, Z, se) {
              let fe = U3.getValue(), ge = (he, we) => he.type === "JSXEmptyExpression" || !$(he) && (he.type === "ArrayExpression" || he.type === "ObjectExpression" || he.type === "ArrowFunctionExpression" || he.type === "AwaitExpression" && (ge(he.argument, he) || he.argument.type === "JSXElement") || x(he) || he.type === "FunctionExpression" || he.type === "TemplateLiteral" || he.type === "TaggedTemplateExpression" || he.type === "DoExpression" || E(we) && (he.type === "ConditionalExpression" || P(he)));
              return ge(fe.expression, U3.getParentNode(0)) ? l(["{", se("expression"), c, "}"]) : l(["{", p([i, se("expression")]), i, c, "}"]);
            }
            function R4(U3, Z, se) {
              let fe = U3.getValue(), ge = fe.name && $(fe.name) || fe.typeParameters && $(fe.typeParameters);
              if (fe.selfClosing && fe.attributes.length === 0 && !ge)
                return ["<", se("name"), se("typeParameters"), " />"];
              if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !$(fe.attributes[0]))
                return l(["<", se("name"), se("typeParameters"), " ", ...U3.map(se, "attributes"), fe.selfClosing ? " />" : ">"]);
              let he = fe.attributes && fe.attributes.some((ke) => ke.value && I(ke.value) && ke.value.value.includes(`
`)), we = Z.singleAttributePerLine && fe.attributes.length > 1 ? u : n;
              return l(["<", se("name"), se("typeParameters"), p(U3.map(() => [we, se()], "attributes")), ...q(fe, Z, ge)], { shouldBreak: he });
            }
            function q(U3, Z, se) {
              return U3.selfClosing ? [n, "/>"] : J(U3, Z, se) ? [">"] : [i, ">"];
            }
            function J(U3, Z, se) {
              let fe = U3.attributes.length > 0 && $(_(U3.attributes), D.Trailing);
              return U3.attributes.length === 0 && !se || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se || U3.attributes.length > 0) && !fe;
            }
            function L(U3, Z, se) {
              let fe = U3.getValue(), ge = [];
              ge.push("</");
              let he = se("name");
              return $(fe.name, D.Leading | D.Line) ? ge.push(p([u, he]), u) : $(fe.name, D.Leading | D.Block) ? ge.push(" ", he) : ge.push(he), ge.push(">"), ge;
            }
            function Q(U3, Z) {
              let se = U3.getValue(), fe = $(se), ge = $(se, D.Line), he = se.type === "JSXOpeningFragment";
              return [he ? "<" : "</", p([ge ? u : fe && !he ? " " : "", s(U3, Z, true)]), ge ? u : "", ">"];
            }
            function V(U3, Z, se) {
              let fe = t4(U3, d(U3, Z, se), Z);
              return B(U3, fe, Z);
            }
            function j(U3, Z) {
              let se = U3.getValue(), fe = $(se, D.Line);
              return [s(U3, Z, !fe), fe ? u : ""];
            }
            function Y(U3, Z, se) {
              let fe = U3.getValue();
              return ["{", U3.call((ge) => {
                let he = ["...", se()], we = ge.getValue();
                return !$(we) || !C(ge) ? he : [p([i, t4(ge, he, Z)]), i];
              }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
            }
            function ie(U3, Z, se) {
              let fe = U3.getValue();
              if (fe.type.startsWith("JSX"))
                switch (fe.type) {
                  case "JSXAttribute":
                    return k(U3, Z, se);
                  case "JSXIdentifier":
                    return String(fe.name);
                  case "JSXNamespacedName":
                    return f(":", [se("namespace"), se("name")]);
                  case "JSXMemberExpression":
                    return f(".", [se("object"), se("property")]);
                  case "JSXSpreadAttribute":
                    return Y(U3, Z, se);
                  case "JSXSpreadChild":
                    return Y(U3, Z, se);
                  case "JSXExpressionContainer":
                    return M(U3, Z, se);
                  case "JSXFragment":
                  case "JSXElement":
                    return V(U3, Z, se);
                  case "JSXOpeningElement":
                    return R4(U3, Z, se);
                  case "JSXClosingElement":
                    return L(U3, Z, se);
                  case "JSXOpeningFragment":
                  case "JSXClosingFragment":
                    return Q(U3, Z);
                  case "JSXEmptyExpression":
                    return j(U3, Z);
                  case "JSXText":
                    throw new Error("JSXText should be handled by JSXElement");
                  default:
                    throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
                }
            }
            var ee = ` 
\r	`, ce = new RegExp("([" + ee + "]+)"), W = new RegExp("[^" + ee + "]"), K = (U3) => U3.replace(new RegExp("(?:^" + ce.source + "|" + ce.source + "$)"), "");
            function de(U3) {
              if (U3.children.length === 0)
                return true;
              if (U3.children.length > 1)
                return false;
              let Z = U3.children[0];
              return Z.type === "JSXText" && !ue(Z);
            }
            function ue(U3) {
              return U3.type === "JSXText" && (W.test(N6(U3)) || !/\n/.test(N6(U3)));
            }
            function Fe(U3) {
              return U3.type === "JSXExpressionContainer" && I(U3.expression) && U3.expression.value === " " && !$(U3.expression);
            }
            function z(U3) {
              let Z = U3.getValue(), se = U3.getParentNode();
              if (!se || !Z || !E(Z) || !E(se))
                return false;
              let fe = se.children.indexOf(Z), ge = null;
              for (let he = fe; he > 0; he--) {
                let we = se.children[he - 1];
                if (!(we.type === "JSXText" && !ue(we))) {
                  ge = we;
                  break;
                }
              }
              return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && T(ge.expression);
            }
            r.exports = { hasJsxIgnoreComment: z, printJsx: ie };
          } }), ct = te({ "src/language-js/print/misc.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t4 } = Ue(), { builders: { indent: s, join: a, line: n } } = qe(), { isFlowAnnotationComment: u } = Ke();
            function i(_) {
              let w = _.getValue();
              return !w.optional || w.type === "Identifier" && w === _.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
            }
            function l(_) {
              return _.getValue().definite || _.match(void 0, (w, E) => E === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
            }
            function p(_, w, E) {
              let N6 = _.getValue();
              return N6.typeArguments ? E("typeArguments") : N6.typeParameters ? E("typeParameters") : "";
            }
            function y(_, w, E) {
              let N6 = _.getValue();
              if (!N6.typeAnnotation)
                return "";
              let x = _.getParentNode(), I = x.type === "DeclareFunction" && x.id === N6;
              return u(w.originalText, N6.typeAnnotation) ? [" /*: ", E("typeAnnotation"), " */"] : [I ? "" : ": ", E("typeAnnotation")];
            }
            function h2(_, w, E) {
              return ["::", E("callee")];
            }
            function g(_, w, E) {
              let N6 = _.getValue();
              return t4(N6.modifiers) ? [a(" ", _.map(E, "modifiers")), " "] : "";
            }
            function c(_, w, E) {
              return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || E ? [" ", w] : s([n, w]);
            }
            function f(_, w, E) {
              return ["...", E("argument"), y(_, w, E)];
            }
            function F4(_, w) {
              let E = _.slice(1, -1);
              if (E.includes('"') || E.includes("'"))
                return _;
              let N6 = w.singleQuote ? "'" : '"';
              return N6 + E + N6;
            }
            r.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: p, printBindExpressionCallee: h2, printTypeScriptModifiers: g, printTypeAnnotation: y, printRestSpread: f, adjustClause: c, printDirective: F4 };
          } }), er = te({ "src/language-js/print/array.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t4 } = et(), { builders: { line: s, softline: a, hardline: n, group: u, indent: i, ifBreak: l, fill: p } } = qe(), { getLast: y, hasNewline: h2 } = Ue(), { shouldPrintComma: g, hasComment: c, CommentCheckFlags: f, isNextLineEmpty: F4, isNumericLiteral: _, isSignedNumericLiteral: w } = Ke(), { locStart: E } = ut(), { printOptionalToken: N6, printTypeAnnotation: x } = ct();
            function I(T, m, C) {
              let o = T.getValue(), d = [], v = o.type === "TupleExpression" ? "#[" : "[", S = "]";
              if (o.elements.length === 0)
                c(o, f.Dangling) ? d.push(u([v, t4(T, m), a, S])) : d.push(v, S);
              else {
                let b = y(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M = Symbol("array"), R4 = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q, V) => {
                  let j = L && L.type;
                  if (j !== "ArrayExpression" && j !== "ObjectExpression")
                    return false;
                  let Y = V[Q + 1];
                  if (Y && j !== Y.type)
                    return false;
                  let ie = j === "ArrayExpression" ? "elements" : "properties";
                  return L[ie] && L[ie].length > 1;
                }), q = P(o, m), J = B ? k ? "," : g(m) ? q ? l(",", "", { groupId: M }) : l(",") : "" : "";
                d.push(u([v, i([a, q ? D(T, m, C, J) : [$(T, m, "elements", C), J], t4(T, m, true)]), a, S], { shouldBreak: R4, id: M }));
              }
              return d.push(N6(T), x(T, m, C)), d;
            }
            function P(T, m) {
              return T.elements.length > 1 && T.elements.every((C) => C && (_(C) || w(C) && !c(C.argument)) && !c(C, f.Trailing | f.Line, (o) => !h2(m.originalText, E(o), { backwards: true })));
            }
            function $(T, m, C, o) {
              let d = [], v = [];
              return T.each((S) => {
                d.push(v, u(o())), v = [",", s], S.getValue() && F4(S.getValue(), m) && v.push(a);
              }, C), d;
            }
            function D(T, m, C, o) {
              let d = [];
              return T.each((v, S, b) => {
                let B = S === b.length - 1;
                d.push([C(), B ? o : ","]), B || d.push(F4(v.getValue(), m) ? [n, n] : c(b[S + 1], f.Leading | f.Line) ? n : s);
              }, "elements"), p(d);
            }
            r.exports = { printArray: I, printArrayItems: $, isConciselyPrintedArray: P };
          } }), Ao = te({ "src/language-js/print/call-arguments.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t4 } = et(), { getLast: s, getPenultimate: a } = Ue(), { getFunctionParameters: n, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: p, isLongCurriedCallExpression: y, shouldPrintComma: h2, getCallArguments: g, iterateCallArgumentsPath: c, isNextLineEmpty: f, isCallExpression: F4, isStringLiteral: _, isObjectProperty: w, isTSTypeExpression: E } = Ke(), { builders: { line: N6, hardline: x, softline: I, group: P, indent: $, conditionalGroup: D, ifBreak: T, breakParent: m }, utils: { willBreak: C } } = qe(), { ArgExpansionBailout: o } = Qt(), { isConciselyPrintedArray: d } = er();
            function v(q, J, L) {
              let Q = q.getValue(), V = Q.type === "ImportExpression", j = g(Q);
              if (j.length === 0)
                return ["(", t4(q, J, true), ")"];
              if (k(j))
                return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
              let Y = false, ie = false, ee = j.length - 1, ce = [];
              c(q, (z, U3) => {
                let Z = z.getNode(), se = [L()];
                U3 === ee || (f(Z, J) ? (U3 === 0 && (ie = true), Y = true, se.push(",", x, x)) : se.push(",", N6)), ce.push(se);
              });
              let W = !(V || Q.callee && Q.callee.type === "Import") && h2(J, "all") ? "," : "";
              function K() {
                return P(["(", $([N6, ...ce]), W, N6, ")"], { shouldBreak: true });
              }
              if (Y || q.getParentNode().type !== "Decorator" && l(j))
                return K();
              let de = B(j), ue = b(j, J);
              if (de || ue) {
                if (de ? ce.slice(1).some(C) : ce.slice(0, -1).some(C))
                  return K();
                let z = [];
                try {
                  q.try(() => {
                    c(q, (U3, Z) => {
                      de && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce.length > 1 ? "," : "", ie ? x : N6, ie ? x : ""], ...ce.slice(1)]), ue && Z === ee && (z = [...ce.slice(0, -1), L([], { expandLastArg: true })]);
                    });
                  });
                } catch (U3) {
                  if (U3 instanceof o)
                    return K();
                  throw U3;
                }
                return [ce.some(C) ? m : "", D([["(", ...z, ")"], de ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce.slice(0, -1), P(s(z), { shouldBreak: true }), ")"], K()])];
              }
              let Fe = ["(", $([I, ...ce]), T(W), I, ")"];
              return y(q) ? Fe : P(Fe, { shouldBreak: ce.some(C) || Y });
            }
            function S(q) {
              let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              return q.type === "ObjectExpression" && (q.properties.length > 0 || u(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u(q)) || q.type === "TSTypeAssertion" && S(q.expression) || E(q) && S(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || M(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && S(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J && (F4(q.body) || q.body.type === "ConditionalExpression") || p(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
            }
            function b(q, J) {
              let L = s(q), Q = a(q);
              return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q || Q.type !== L.type) && (q.length !== 2 || Q.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q.length > 1 && L.type === "ArrayExpression" && d(L, J));
            }
            function B(q) {
              if (q.length !== 2)
                return false;
              let [J, L] = q;
              return J.type === "ModuleExpression" && R4(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
            }
            function k(q) {
              return q.length === 2 && q[0].type === "ArrowFunctionExpression" && n(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J) => u(J));
            }
            function M(q) {
              return q.type === "BlockStatement" && (q.body.some((J) => J.type !== "EmptyStatement") || u(q, i.Dangling));
            }
            function R4(q) {
              return q.type === "ObjectExpression" && q.properties.length === 1 && w(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && _(q.properties[0].value) && q.properties[0].value.value === "module";
            }
            r.exports = v;
          } }), So = te({ "src/language-js/print/member.js"(e, r) {
            "use strict";
            ne();
            var { builders: { softline: t4, group: s, indent: a, label: n } } = qe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke(), { printOptionalToken: p } = ct();
            function y(g, c, f) {
              let F4 = g.getValue(), _ = g.getParentNode(), w, E = 0;
              do
                w = g.getParentNode(E), E++;
              while (w && (i(w) || w.type === "TSNonNullExpression"));
              let N6 = f("object"), x = h2(g, c, f), I = w && (w.type === "NewExpression" || w.type === "BindExpression" || w.type === "AssignmentExpression" && w.left.type !== "Identifier") || F4.computed || F4.object.type === "Identifier" && F4.property.type === "Identifier" && !i(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(F4.object) && F4.object.arguments.length > 0 || F4.object.type === "TSNonNullExpression" && l(F4.object.expression) && F4.object.expression.arguments.length > 0 || N6.label === "member-chain");
              return n(N6.label === "member-chain" ? "member-chain" : "member", [N6, I ? x : s(a([t4, x]))]);
            }
            function h2(g, c, f) {
              let F4 = f("property"), _ = g.getValue(), w = p(g);
              return _.computed ? !_.property || u(_.property) ? [w, "[", F4, "]"] : s([w, "[", a([t4, F4]), t4, "]"]) : [w, ".", F4];
            }
            r.exports = { printMemberExpression: y, printMemberLookup: h2 };
          } }), md = te({ "src/language-js/print/member-chain.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t4 } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: n } = Ue(), u = qt(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: p, isLongCurriedCallExpression: y, isMemberish: h2, isNumericLiteral: g, isSimpleCallArgument: c, hasComment: f, CommentCheckFlags: F4, isNextLineEmpty: _ } = Ke(), { locEnd: w } = ut(), { builders: { join: E, hardline: N6, group: x, indent: I, conditionalGroup: P, breakParent: $, label: D }, utils: { willBreak: T } } = qe(), m = Ao(), { printMemberLookup: C } = So(), { printOptionalToken: o, printFunctionTypeParameters: d, printBindExpressionCallee: v } = ct();
            function S(b, B, k) {
              let M = b.getParentNode(), R4 = !M || M.type === "ExpressionStatement", q = [];
              function J(Ne) {
                let { originalText: Pe } = B, oe = n(Pe, Ne, w);
                return Pe.charAt(oe) === ")" ? oe !== false && a(Pe, oe + 1) : _(Ne, B);
              }
              function L(Ne) {
                let Pe = Ne.getValue();
                i(Pe) && (h2(Pe.callee) || i(Pe.callee)) ? (q.unshift({ node: Pe, printed: [t4(Ne, [o(Ne), d(Ne, B, k), m(Ne, B, k)], B), J(Pe) ? N6 : ""] }), Ne.call((oe) => L(oe), "callee")) : h2(Pe) ? (q.unshift({ node: Pe, needsParens: u(Ne, B), printed: t4(Ne, l(Pe) ? C(Ne, B, k) : v(Ne, B, k), B) }), Ne.call((oe) => L(oe), "object")) : Pe.type === "TSNonNullExpression" ? (q.unshift({ node: Pe, printed: t4(Ne, "!", B) }), Ne.call((oe) => L(oe), "expression")) : q.unshift({ node: Pe, printed: k() });
              }
              let Q = b.getValue();
              q.unshift({ node: Q, printed: [o(b), d(b, B, k), m(b, B, k)] }), Q.callee && b.call((Ne) => L(Ne), "callee");
              let V = [], j = [q[0]], Y = 1;
              for (; Y < q.length && (q[Y].node.type === "TSNonNullExpression" || i(q[Y].node) || l(q[Y].node) && q[Y].node.computed && g(q[Y].node.property)); ++Y)
                j.push(q[Y]);
              if (!i(q[0].node))
                for (; Y + 1 < q.length && (h2(q[Y].node) && h2(q[Y + 1].node)); ++Y)
                  j.push(q[Y]);
              V.push(j), j = [];
              let ie = false;
              for (; Y < q.length; ++Y) {
                if (ie && h2(q[Y].node)) {
                  if (q[Y].node.computed && g(q[Y].node.property)) {
                    j.push(q[Y]);
                    continue;
                  }
                  V.push(j), j = [], ie = false;
                }
                (i(q[Y].node) || q[Y].node.type === "ImportExpression") && (ie = true), j.push(q[Y]), f(q[Y].node, F4.Trailing) && (V.push(j), j = [], ie = false);
              }
              j.length > 0 && V.push(j);
              function ee(Ne) {
                return /^[A-Z]|^[$_]+$/.test(Ne);
              }
              function ce(Ne) {
                return Ne.length <= B.tabWidth;
              }
              function W(Ne) {
                let Pe = Ne[1].length > 0 && Ne[1][0].node.computed;
                if (Ne[0].length === 1) {
                  let H = Ne[0][0].node;
                  return H.type === "ThisExpression" || H.type === "Identifier" && (ee(H.name) || R4 && ce(H.name) || Pe);
                }
                let oe = s(Ne[0]).node;
                return l(oe) && oe.property.type === "Identifier" && (ee(oe.property.name) || Pe);
              }
              let K = V.length >= 2 && !f(V[1][0].node) && W(V);
              function de(Ne) {
                let Pe = Ne.map((oe) => oe.printed);
                return Ne.length > 0 && s(Ne).needsParens ? ["(", ...Pe, ")"] : Pe;
              }
              function ue(Ne) {
                return Ne.length === 0 ? "" : I(x([N6, E(N6, Ne.map(de))]));
              }
              let Fe = V.map(de), z = Fe, U3 = K ? 3 : 2, Z = V.flat(), se = Z.slice(1, -1).some((Ne) => f(Ne.node, F4.Leading)) || Z.slice(0, -1).some((Ne) => f(Ne.node, F4.Trailing)) || V[U3] && f(V[U3][0].node, F4.Leading);
              if (V.length <= U3 && !se)
                return y(b) ? z : x(z);
              let fe = s(V[K ? 1 : 0]).node, ge = !i(fe) && J(fe), he = [de(V[0]), K ? V.slice(1, 2).map(de) : "", ge ? N6 : "", ue(V.slice(K ? 2 : 1))], we = q.map((Ne) => {
                let { node: Pe } = Ne;
                return Pe;
              }).filter(i);
              function ke() {
                let Ne = s(s(V)).node, Pe = s(Fe);
                return i(Ne) && T(Pe) && we.slice(0, -1).some((oe) => oe.arguments.some(p));
              }
              let Re;
              return se || we.length > 2 && we.some((Ne) => !Ne.arguments.every((Pe) => c(Pe, 0))) || Fe.slice(0, -1).some(T) || ke() ? Re = x(he) : Re = [T(z) || ge ? $ : "", P([z, he])], D("member-chain", Re);
            }
            r.exports = S;
          } }), xo = te({ "src/language-js/print/call-expression.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t4, group: s } } = qe(), a = qt(), { getCallArguments: n, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: p, isTemplateOnItsOwnLine: y, isTestCall: h2, iterateCallArgumentsPath: g } = Ke(), c = md(), f = Ao(), { printOptionalToken: F4, printFunctionTypeParameters: _ } = ct();
            function w(N6, x, I) {
              let P = N6.getValue(), $ = N6.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m = F4(N6), C = n(P);
              if (C.length > 0 && (!T && !D && E(P, $) || C.length === 1 && y(C[0], x.originalText) || !D && h2(P, $))) {
                let v = [];
                return g(N6, () => {
                  v.push(I());
                }), [D ? "new " : "", I("callee"), m, _(N6, x, I), "(", t4(", ", v), ")"];
              }
              let o = (x.parser === "babel" || x.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
              if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N6.call((v) => a(v, x), "callee"))
                return c(N6, x, I);
              let d = [D ? "new " : "", T ? "import" : I("callee"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N6, x, I), f(N6, x, I)];
              return T || i(P.callee) ? s(d) : d;
            }
            function E(N6, x) {
              if (N6.callee.type !== "Identifier")
                return false;
              if (N6.callee.name === "require")
                return true;
              if (N6.callee.name === "define") {
                let I = n(N6);
                return x.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && p(I[0]) && I[1].type === "ArrayExpression");
              }
              return false;
            }
            r.exports = { printCallExpression: w };
          } }), tr = te({ "src/language-js/print/assignment.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t4, getStringWidth: s } = Ue(), { builders: { line: a, group: n, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: p, willBreak: y, canBreak: h2 } } = qe(), { hasLeadingOwnLineComment: g, isBinaryish: c, isStringLiteral: f, isLiteral: F4, isNumericLiteral: _, isCallExpression: w, isMemberExpression: E, getCallArguments: N6, rawText: x, hasComment: I, isSignedNumericLiteral: P, isObjectProperty: $ } = Ke(), { shouldInlineLogicalExpression: D } = ru(), { printCallExpression: T } = xo();
            function m(W, K, de, ue, Fe, z) {
              let U3 = d(W, K, de, ue, z), Z = de(z, { assignmentLayout: U3 });
              switch (U3) {
                case "break-after-operator":
                  return n([n(ue), Fe, n(u([a, Z]))]);
                case "never-break-after-operator":
                  return n([n(ue), Fe, " ", Z]);
                case "fluid": {
                  let se = Symbol("assignment");
                  return n([n(ue), Fe, n(u(a), { id: se }), l, i(Z, { groupId: se })]);
                }
                case "break-lhs":
                  return n([ue, Fe, " ", n(Z)]);
                case "chain":
                  return [n(ue), Fe, a, Z];
                case "chain-tail":
                  return [n(ue), Fe, u([a, Z])];
                case "chain-tail-arrow-chain":
                  return [n(ue), Fe, Z];
                case "only-left":
                  return ue;
              }
            }
            function C(W, K, de) {
              let ue = W.getValue();
              return m(W, K, de, de("left"), [" ", ue.operator], "right");
            }
            function o(W, K, de) {
              return m(W, K, de, de("id"), " =", "init");
            }
            function d(W, K, de, ue, Fe) {
              let z = W.getValue(), U3 = z[Fe];
              if (!U3)
                return "only-left";
              let Z = !b(U3);
              if (W.match(b, B, (he) => !Z || he.type !== "ExpressionStatement" && he.type !== "VariableDeclaration"))
                return Z ? U3.type === "ArrowFunctionExpression" && U3.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
              if (!Z && b(U3.right) || g(K.originalText, U3))
                return "break-after-operator";
              if (U3.type === "CallExpression" && U3.callee.name === "require" || K.parser === "json5" || K.parser === "json")
                return "never-break-after-operator";
              if (S(z) || k(z) || q(z) || J(z) && h2(ue))
                return "break-lhs";
              let ge = ie(z, ue, K);
              return W.call(() => v(W, K, de, ge), Fe) ? "break-after-operator" : ge || U3.type === "TemplateLiteral" || U3.type === "TaggedTemplateExpression" || U3.type === "BooleanLiteral" || _(U3) || U3.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
            }
            function v(W, K, de, ue) {
              let Fe = W.getValue();
              if (c(Fe) && !D(Fe))
                return true;
              switch (Fe.type) {
                case "StringLiteralTypeAnnotation":
                case "SequenceExpression":
                  return true;
                case "ConditionalExpression": {
                  let { test: Z } = Fe;
                  return c(Z) && !D(Z);
                }
                case "ClassExpression":
                  return t4(Fe.decorators);
              }
              if (ue)
                return false;
              let z = Fe, U3 = [];
              for (; ; )
                if (z.type === "UnaryExpression")
                  z = z.argument, U3.push("argument");
                else if (z.type === "TSNonNullExpression")
                  z = z.expression, U3.push("expression");
                else
                  break;
              return !!(f(z) || W.call(() => V(W, K, de), ...U3));
            }
            function S(W) {
              if (B(W)) {
                let K = W.left || W.id;
                return K.type === "ObjectPattern" && K.properties.length > 2 && K.properties.some((de) => $(de) && (!de.shorthand || de.value && de.value.type === "AssignmentPattern"));
              }
              return false;
            }
            function b(W) {
              return W.type === "AssignmentExpression";
            }
            function B(W) {
              return b(W) || W.type === "VariableDeclarator";
            }
            function k(W) {
              let K = M(W);
              if (t4(K)) {
                let de = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
                if (K.length > 1 && K.some((ue) => ue[de] || ue.default))
                  return true;
              }
              return false;
            }
            function M(W) {
              return R4(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
            }
            function R4(W) {
              return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
            }
            function q(W) {
              if (W.type !== "VariableDeclarator")
                return false;
              let { typeAnnotation: K } = W.id;
              if (!K || !K.typeAnnotation)
                return false;
              let de = L(K.typeAnnotation);
              return t4(de) && de.length > 1 && de.some((ue) => t4(L(ue)) || ue.type === "TSConditionalType");
            }
            function J(W) {
              return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
            }
            function L(W) {
              return Q(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
            }
            function Q(W) {
              return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
            }
            function V(W, K, de) {
              let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe = W.getValue(), z = () => V(W, K, de, true);
              if (Fe.type === "TSNonNullExpression")
                return W.call(z, "expression");
              if (w(Fe)) {
                if (T(W, K, de).label === "member-chain")
                  return false;
                let Z = N6(Fe);
                return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K)) || ee(Fe, de) ? false : W.call(z, "callee");
              }
              return E(Fe) ? W.call(z, "object") : ue && (Fe.type === "Identifier" || Fe.type === "ThisExpression");
            }
            var j = 0.25;
            function Y(W, K) {
              let { printWidth: de } = K;
              if (I(W))
                return false;
              let ue = de * j;
              if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue || P(W) && !I(W.argument))
                return true;
              let Fe = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
              return Fe ? Fe.length <= ue : f(W) ? x(W).length <= ue : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue && !W.quasis[0].value.raw.includes(`
`) : F4(W);
            }
            function ie(W, K, de) {
              if (!$(W))
                return false;
              K = p(K);
              let ue = 3;
              return typeof K == "string" && s(K) < de.tabWidth + ue;
            }
            function ee(W, K) {
              let de = ce(W);
              if (t4(de)) {
                if (de.length > 1)
                  return true;
                if (de.length === 1) {
                  let Fe = de[0];
                  if (Fe.type === "TSUnionType" || Fe.type === "UnionTypeAnnotation" || Fe.type === "TSIntersectionType" || Fe.type === "IntersectionTypeAnnotation" || Fe.type === "TSTypeLiteral" || Fe.type === "ObjectTypeAnnotation")
                    return true;
                }
                let ue = W.typeParameters ? "typeParameters" : "typeArguments";
                if (y(K(ue)))
                  return true;
              }
              return false;
            }
            function ce(W) {
              return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
            }
            r.exports = { printVariableDeclarator: o, printAssignmentExpression: C, printAssignment: m, isArrowFunctionVariableDeclarator: J };
          } }), Lr = te({ "src/language-js/print/function-parameters.js"(e, r) {
            "use strict";
            ne();
            var { getNextNonSpaceNonCommentCharacter: t4 } = Ue(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p }, utils: { removeLines: y, willBreak: h2 } } = qe(), { getFunctionParameters: g, iterateFunctionParametersPath: c, isSimpleType: f, isTestCall: F4, isTypeAnnotationAFunction: _, isObjectType: w, isObjectTypePropertyAFunction: E, hasRestParameter: N6, shouldPrintComma: x, hasComment: I, isNextLineEmpty: P } = Ke(), { locEnd: $ } = ut(), { ArgExpansionBailout: D } = Qt(), { printFunctionTypeParameters: T } = ct();
            function m(v, S, b, B, k) {
              let M = v.getValue(), R4 = g(M), q = k ? T(v, b, S) : "";
              if (R4.length === 0)
                return [q, "(", s(v, b, true, (ie) => t4(b.originalText, ie, $) === ")"), ")"];
              let J = v.getParentNode(), L = F4(J), Q = C(M), V = [];
              if (c(v, (ie, ee) => {
                let ce = ee === R4.length - 1;
                ce && M.rest && V.push("..."), V.push(S()), !ce && (V.push(","), L || Q ? V.push(" ") : P(R4[ee], b) ? V.push(n, n) : V.push(a));
              }), B) {
                if (h2(q) || h2(V))
                  throw new D();
                return i([y(q), "(", y(V), ")"]);
              }
              let j = R4.every((ie) => !ie.decorators);
              return Q && j ? [q, "(", ...V, ")"] : L ? [q, "(", ...V, ")"] : (E(J) || _(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === M) && R4.length === 1 && R4[0].name === null && M.this !== R4[0] && R4[0].typeAnnotation && M.typeParameters === null && f(R4[0].typeAnnotation) && !M.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l([u, ...V]), p(!N6(M) && x(b, "all") ? "," : ""), u, ")"];
            }
            function C(v) {
              if (!v)
                return false;
              let S = g(v);
              if (S.length !== 1)
                return false;
              let [b] = S;
              return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
            }
            function o(v) {
              let S;
              return v.returnType ? (S = v.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v.typeAnnotation && (S = v.typeAnnotation), S;
            }
            function d(v, S) {
              let b = o(v);
              if (!b)
                return false;
              let B = v.typeParameters && v.typeParameters.params;
              if (B) {
                if (B.length > 1)
                  return false;
                if (B.length === 1) {
                  let k = B[0];
                  if (k.constraint || k.default)
                    return false;
                }
              }
              return g(v).length === 1 && (w(b) || h2(S));
            }
            r.exports = { printFunctionParameters: m, shouldHugFunctionParameters: C, shouldGroupFunctionParameters: d };
          } }), Or = te({ "src/language-js/print/type-annotation.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t4, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ue(), { builders: { group: n, join: u, line: i, softline: l, indent: p, align: y, ifBreak: h2 } } = qe(), g = qt(), { locStart: c } = ut(), { isSimpleType: f, isObjectType: F4, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w, shouldPrintComma: E } = Ke(), { printAssignment: N6 } = tr(), { printFunctionParameters: x, shouldGroupFunctionParameters: I } = Lr(), { printArrayItems: P } = er();
            function $(b) {
              if (f(b) || F4(b))
                return true;
              if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
                let B = b.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, k = b.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
                if (b.types.length - 1 === B && k)
                  return true;
              }
              return false;
            }
            function D(b, B, k) {
              let M = B.semi ? ";" : "", R4 = b.getValue(), q = [];
              return q.push("opaque type ", k("id"), k("typeParameters")), R4.supertype && q.push(": ", k("supertype")), R4.impltype && q.push(" = ", k("impltype")), q.push(M), q;
            }
            function T(b, B, k) {
              let M = B.semi ? ";" : "", R4 = b.getValue(), q = [];
              R4.declare && q.push("declare "), q.push("type ", k("id"), k("typeParameters"));
              let J = R4.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
              return [N6(b, B, k, q, " =", J), M];
            }
            function m(b, B, k) {
              let M = b.getValue(), R4 = b.map(k, "types"), q = [], J = false;
              for (let L = 0; L < R4.length; ++L)
                L === 0 ? q.push(R4[L]) : F4(M.types[L - 1]) && F4(M.types[L]) ? q.push([" & ", J ? p(R4[L]) : R4[L]]) : !F4(M.types[L - 1]) && !F4(M.types[L]) ? q.push(p([" &", i, R4[L]])) : (L > 1 && (J = true), q.push(" & ", L > 1 ? p(R4[L]) : R4[L]));
              return n(q);
            }
            function C(b, B, k) {
              let M = b.getValue(), R4 = b.getParentNode(), q = R4.type !== "TypeParameterInstantiation" && R4.type !== "TSTypeParameterInstantiation" && R4.type !== "GenericTypeAnnotation" && R4.type !== "TSTypeReference" && R4.type !== "TSTypeAssertion" && R4.type !== "TupleTypeAnnotation" && R4.type !== "TSTupleType" && !(R4.type === "FunctionTypeParam" && !R4.name && b.getParentNode(1).this !== R4) && !((R4.type === "TypeAlias" || R4.type === "VariableDeclarator" || R4.type === "TSTypeAliasDeclaration") && _(B.originalText, M)), J = $(M), L = b.map((j) => {
                let Y = k();
                return J || (Y = y(2, Y)), t4(j, Y, B);
              }, "types");
              if (J)
                return u(" | ", L);
              let Q = q && !_(B.originalText, M), V = [h2([Q ? i : "", "| "]), u([i, "| "], L)];
              return g(b, B) ? n([p(V), l]) : R4.type === "TupleTypeAnnotation" && R4.types.length > 1 || R4.type === "TSTupleType" && R4.elementTypes.length > 1 ? n([p([h2(["(", l]), V]), l, h2(")")]) : n(q ? p(V) : V);
            }
            function o(b, B, k) {
              let M = b.getValue(), R4 = [], q = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Q = M.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && c(q) === c(M) || q.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), j = V && Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
              w(q) && (Q = true, V = true), j && R4.push("(");
              let Y = x(b, k, B, false, true), ie = M.returnType || M.predicate || M.typeAnnotation ? [Q ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee = I(M, ie);
              return R4.push(ee ? n(Y) : Y), ie && R4.push(ie), j && R4.push(")"), n(R4);
            }
            function d(b, B, k) {
              let M = b.getValue(), R4 = M.type === "TSTupleType" ? "elementTypes" : "types", q = M[R4], J = a(q), L = J ? l : "";
              return n(["[", p([L, P(b, B, R4, k)]), h2(J && E(B, "all") ? "," : ""), s(b, B, true), L, "]"]);
            }
            function v(b, B, k) {
              let M = b.getValue(), R4 = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
              return [k("objectType"), R4, k("indexType"), "]"];
            }
            function S(b, B, k) {
              let M = b.getValue();
              return [M.postfix ? "" : k, B("typeAnnotation"), M.postfix ? k : ""];
            }
            r.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m, printUnionType: C, printFunctionType: o, printTupleType: d, printIndexedAccessType: v, shouldHugType: $, printJSDocType: S };
          } }), jr = te({ "src/language-js/print/type-parameters.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t4 } = et(), { builders: { join: s, line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p } } = qe(), { isTestCall: y, hasComment: h2, CommentCheckFlags: g, isTSXFile: c, shouldPrintComma: f, getFunctionParameters: F4, isObjectType: _, getTypeScriptMappedTypeModifier: w } = Ke(), { createGroupIdMapper: E } = Ue(), { shouldHugType: N6 } = Or(), { isArrowFunctionVariableDeclarator: x } = tr(), I = E("typeParameters");
            function P(T, m, C, o) {
              let d = T.getValue();
              if (!d[o])
                return "";
              if (!Array.isArray(d[o]))
                return C(o);
              let v = T.getNode(2), S = v && y(v), b = T.match((M) => !(M[o].length === 1 && _(M[o][0])), void 0, (M, R4) => R4 === "typeAnnotation", (M) => M.type === "Identifier", x);
              if (d[o].length === 0 || !b && (S || d[o].length === 1 && (d[o][0].type === "NullableTypeAnnotation" || N6(d[o][0]))))
                return ["<", s(", ", T.map(C, o)), $(T, m), ">"];
              let k = d.type === "TSTypeParameterInstantiation" ? "" : F4(d).length === 1 && c(m) && !d[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f(m, "all") ? p(",") : "";
              return i(["<", l([u, s([",", a], T.map(C, o))]), k, u, ">"], { id: I(d) });
            }
            function $(T, m) {
              let C = T.getValue();
              if (!h2(C, g.Dangling))
                return "";
              let o = !h2(C, g.Line), d = t4(T, m, o);
              return o ? d : [d, n];
            }
            function D(T, m, C) {
              let o = T.getValue(), d = [], v = T.getParentNode();
              return v.type === "TSMappedType" ? (v.readonly && d.push(w(v.readonly, "readonly"), " "), d.push("[", C("name")), o.constraint && d.push(" in ", C("constraint")), v.nameType && d.push(" as ", T.callParent(() => C("nameType"))), d.push("]"), d) : (o.variance && d.push(C("variance")), o.in && d.push("in "), o.out && d.push("out "), d.push(C("name")), o.bound && d.push(": ", C("bound")), o.constraint && d.push(" extends ", C("constraint")), o.default && d.push(" = ", C("default")), d);
            }
            r.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I };
          } }), rr = te({ "src/language-js/print/property.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t4 } = et(), { printString: s, printNumber: a } = Ue(), { isNumericLiteral: n, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: p } = Ke(), { printAssignment: y } = tr(), h2 = /* @__PURE__ */ new WeakMap();
            function g(f, F4, _) {
              let w = f.getNode();
              if (w.computed)
                return ["[", _("key"), "]"];
              let E = f.getParentNode(), { key: N6 } = w;
              if (F4.quoteProps === "consistent" && !h2.has(E)) {
                let x = (E.properties || E.body || E.members).some((I) => !I.computed && I.key && i(I.key) && !l(I, F4));
                h2.set(E, x);
              }
              if ((N6.type === "Identifier" || n(N6) && u(a(p(N6))) && String(N6.value) === a(p(N6)) && !(F4.parser === "typescript" || F4.parser === "babel-ts")) && (F4.parser === "json" || F4.quoteProps === "consistent" && h2.get(E))) {
                let x = s(JSON.stringify(N6.type === "Identifier" ? N6.name : N6.value.toString()), F4);
                return f.call((I) => t4(I, x, F4), "key");
              }
              return l(w, F4) && (F4.quoteProps === "as-needed" || F4.quoteProps === "consistent" && !h2.get(E)) ? f.call((x) => t4(x, /^\d/.test(N6.value) ? a(N6.value) : N6.value, F4), "key") : _("key");
            }
            function c(f, F4, _) {
              return f.getValue().shorthand ? _("value") : y(f, F4, _, g(f, F4, _), ":", "value");
            }
            r.exports = { printProperty: c, printPropertyKey: g };
          } }), qr = te({ "src/language-js/print/function.js"(e, r) {
            "use strict";
            ne();
            var t4 = Zt(), { printDanglingComments: s, printCommentsSeparately: a } = et(), n = lt(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue(), { builders: { line: i, softline: l, group: p, indent: y, ifBreak: h2, hardline: g, join: c, indentIfBreak: f }, utils: { removeLines: F4, willBreak: _ } } = qe(), { ArgExpansionBailout: w } = Qt(), { getFunctionParameters: E, hasLeadingOwnLineComment: N6, isFlowAnnotationComment: x, isJsxNode: I, isTemplateOnItsOwnLine: P, shouldPrintComma: $, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m, hasComment: C, getComments: o, CommentCheckFlags: d, isCallLikeExpression: v, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke(), { locEnd: M } = ut(), { printFunctionParameters: R4, shouldGroupFunctionParameters: q } = Lr(), { printPropertyKey: J } = rr(), { printFunctionTypeParameters: L } = ct();
            function Q(U3, Z, se, fe) {
              let ge = U3.getValue(), he = false;
              if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
                let Pe = U3.getParentNode();
                S(Pe) && b(Pe).length > 1 && (he = true);
              }
              let we = [];
              ge.type === "TSDeclareFunction" && ge.declare && we.push("declare "), ge.async && we.push("async "), ge.generator ? we.push("function* ") : we.push("function "), ge.id && we.push(Z("id"));
              let ke = R4(U3, Z, se, he), Re = K(U3, Z, se), Ne = q(ge, Re);
              return we.push(L(U3, se, Z), p([Ne ? p(ke) : ke, Re]), ge.body ? " " : "", Z("body")), se.semi && (ge.declare || !ge.body) && we.push(";"), we;
            }
            function V(U3, Z, se) {
              let fe = U3.getNode(), { kind: ge } = fe, he = fe.value || fe, we = [];
              return !ge || ge === "init" || ge === "method" || ge === "constructor" ? he.async && we.push("async ") : (t4.ok(ge === "get" || ge === "set"), we.push(ge, " ")), he.generator && we.push("*"), we.push(J(U3, Z, se), fe.optional || fe.key.optional ? "?" : ""), fe === he ? we.push(j(U3, Z, se)) : he.type === "FunctionExpression" ? we.push(U3.call((ke) => j(ke, Z, se), "value")) : we.push(se("value")), we;
            }
            function j(U3, Z, se) {
              let fe = U3.getNode(), ge = R4(U3, se, Z), he = K(U3, se, Z), we = q(fe, he), ke = [L(U3, Z, se), p([we ? p(ge) : ge, he])];
              return fe.body ? ke.push(" ", se("body")) : ke.push(Z.semi ? ";" : ""), ke;
            }
            function Y(U3, Z, se, fe) {
              let ge = U3.getValue(), he = [];
              if (ge.async && he.push("async "), W(U3, Z))
                he.push(se(["params", 0]));
              else {
                let ke = fe && (fe.expandLastArg || fe.expandFirstArg), Re = K(U3, se, Z);
                if (ke) {
                  if (_(Re))
                    throw new w();
                  Re = p(F4(Re));
                }
                he.push(p([R4(U3, se, Z, ke, true), Re]));
              }
              let we = s(U3, Z, true, (ke) => {
                let Re = u(Z.originalText, ke, M);
                return Re !== false && Z.originalText.slice(Re, Re + 2) === "=>";
              });
              return we && he.push(" ", we), he;
            }
            function ie(U3, Z, se, fe, ge, he) {
              let we = U3.getName(), ke = U3.getParentNode(), Re = v(ke) && we === "callee", Ne = Boolean(Z && Z.assignmentLayout), Pe = he.body.type !== "BlockStatement" && he.body.type !== "ObjectExpression" && he.body.type !== "SequenceExpression", oe = Re && Pe || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
              return he.body.type === "SequenceExpression" && (ge = p(["(", y([l, ge]), l, ")"])), p([p(y([Re || Ne ? l : "", p(c([" =>", i], se), { shouldBreak: fe })]), { id: H, shouldBreak: oe }), " =>", f(Pe ? y([i, ge]) : [" ", ge], { groupId: H }), Re ? h2(l, "", { groupId: H }) : ""]);
            }
            function ee(U3, Z, se, fe) {
              let ge = U3.getValue(), he = [], we = [], ke = false;
              if (function H() {
                let pe = Y(U3, Z, se, fe);
                if (he.length === 0)
                  he.push(pe);
                else {
                  let { leading: X, trailing: le } = a(U3, Z);
                  he.push([X, pe]), we.unshift(le);
                }
                ke = ke || ge.returnType && E(ge).length > 0 || ge.typeParameters || E(ge).some((X) => X.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? we.unshift(se("body", fe)) : (ge = ge.body, U3.call(H, "body"));
              }(), he.length > 1)
                return ie(U3, fe, he, ke, we, ge);
              let Re = he;
              if (Re.push(" =>"), !N6(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression"))
                return p([...Re, " ", we]);
              if (ge.body.type === "SequenceExpression")
                return p([...Re, p([" (", y([l, we]), l, ")"])]);
              let Ne = (fe && fe.expandLastArg || U3.getParentNode().type === "JSXExpressionContainer") && !C(ge), Pe = fe && fe.expandLastArg && $(Z, "all"), oe = ge.body.type === "ConditionalExpression" && !D(ge.body, (H) => H.type === "ObjectExpression");
              return p([...Re, p([y([i, oe ? h2("", "(") : "", we, oe ? h2("", ")") : ""]), Ne ? [h2(Pe ? "," : ""), l] : ""])]);
            }
            function ce(U3) {
              let Z = E(U3);
              return Z.length === 1 && !U3.typeParameters && !C(U3, d.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U3.predicate && !U3.returnType;
            }
            function W(U3, Z) {
              if (Z.arrowParens === "always")
                return false;
              if (Z.arrowParens === "avoid") {
                let se = U3.getValue();
                return ce(se);
              }
              return false;
            }
            function K(U3, Z, se) {
              let fe = U3.getValue(), ge = Z("returnType");
              if (fe.returnType && x(se.originalText, fe.returnType))
                return [" /*: ", ge, " */"];
              let he = [ge];
              return fe.returnType && fe.returnType.typeAnnotation && he.unshift(": "), fe.predicate && he.push(fe.returnType ? " " : ": ", Z("predicate")), he;
            }
            function de(U3, Z, se) {
              let fe = U3.getValue(), ge = Z.semi ? ";" : "", he = [];
              fe.argument && (z(Z, fe.argument) ? he.push([" (", y([g, se("argument")]), g, ")"]) : T(fe.argument) || fe.argument.type === "SequenceExpression" ? he.push(p([h2(" (", " "), y([l, se("argument")]), l, h2(")")])) : he.push(" ", se("argument")));
              let we = o(fe), ke = n(we), Re = ke && m(ke);
              return Re && he.push(ge), C(fe, d.Dangling) && he.push(" ", s(U3, Z, true)), Re || he.push(ge), he;
            }
            function ue(U3, Z, se) {
              return ["return", de(U3, Z, se)];
            }
            function Fe(U3, Z, se) {
              return ["throw", de(U3, Z, se)];
            }
            function z(U3, Z) {
              if (N6(U3.originalText, Z))
                return true;
              if (B(Z)) {
                let se = Z, fe;
                for (; fe = k(se); )
                  if (se = fe, N6(U3.originalText, se))
                    return true;
              }
              return false;
            }
            r.exports = { printFunction: Q, printArrowFunction: ee, printMethod: V, printReturnStatement: ue, printThrowStatement: Fe, printMethodInternal: j, shouldPrintParamsWithoutParens: W };
          } }), nu = te({ "src/language-js/print/decorators.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t4, hasNewline: s } = Ue(), { builders: { line: a, hardline: n, join: u, breakParent: i, group: l } } = qe(), { locStart: p, locEnd: y } = ut(), { getParentExportDeclaration: h2 } = Ke();
            function g(w, E, N6) {
              let x = w.getValue();
              return l([u(a, w.map(N6, "decorators")), F4(x, E) ? n : a]);
            }
            function c(w, E, N6) {
              return [u(n, w.map(N6, "declaration", "decorators")), n];
            }
            function f(w, E, N6) {
              let x = w.getValue(), { decorators: I } = x;
              if (!t4(I) || _(w.getParentNode()))
                return;
              let P = x.type === "ClassExpression" || x.type === "ClassDeclaration" || F4(x, E);
              return [h2(w) ? n : P ? i : "", u(a, w.map(N6, "decorators")), a];
            }
            function F4(w, E) {
              return w.decorators.some((N6) => s(E.originalText, y(N6)));
            }
            function _(w) {
              if (w.type !== "ExportDefaultDeclaration" && w.type !== "ExportNamedDeclaration" && w.type !== "DeclareExportDeclaration")
                return false;
              let E = w.declaration && w.declaration.decorators;
              return t4(E) && p(w) === p(E[0]);
            }
            r.exports = { printDecorators: f, printClassMemberDecorators: g, printDecoratorsBeforeExport: c, hasDecoratorsBeforeExport: _ };
          } }), nr = te({ "src/language-js/print/class.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t4, createGroupIdMapper: s } = Ue(), { printComments: a, printDanglingComments: n } = et(), { builders: { join: u, line: i, hardline: l, softline: p, group: y, indent: h2, ifBreak: g } } = qe(), { hasComment: c, CommentCheckFlags: f } = Ke(), { getTypeParametersGroupId: F4 } = jr(), { printMethod: _ } = qr(), { printOptionalToken: w, printTypeAnnotation: E, printDefiniteToken: N6 } = ct(), { printPropertyKey: x } = rr(), { printAssignment: I } = tr(), { printClassMemberDecorators: P } = nu();
            function $(b, B, k) {
              let M = b.getValue(), R4 = [];
              M.declare && R4.push("declare "), M.abstract && R4.push("abstract "), R4.push("class");
              let q = M.id && c(M.id, f.Trailing) || M.typeParameters && c(M.typeParameters, f.Trailing) || M.superClass && c(M.superClass) || t4(M.extends) || t4(M.mixins) || t4(M.implements), J = [], L = [];
              if (M.id && J.push(" ", k("id")), J.push(k("typeParameters")), M.superClass) {
                let Q = [d(b, B, k), k("superTypeParameters")], V = b.call((j) => ["extends ", a(j, Q, B)], "superClass");
                q ? L.push(i, y(V)) : L.push(" ", V);
              } else
                L.push(o(b, B, k, "extends"));
              if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q) {
                let Q;
                C(M) ? Q = [...J, h2(L)] : Q = h2([...J, L]), R4.push(y(Q, { id: D(M) }));
              } else
                R4.push(...J, ...L);
              return R4.push(" ", k("body")), R4;
            }
            var D = s("heritageGroup");
            function T(b) {
              return g(l, "", { groupId: D(b) });
            }
            function m(b) {
              return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
            }
            function C(b) {
              return b.typeParameters && !c(b.typeParameters, f.Trailing | f.Line) && !m(b);
            }
            function o(b, B, k, M) {
              let R4 = b.getValue();
              if (!t4(R4[M]))
                return "";
              let q = n(b, B, true, (J) => {
                let { marker: L } = J;
                return L === M;
              });
              return [C(R4) ? g(" ", i, { groupId: F4(R4.typeParameters) }) : i, q, q && l, M, y(h2([i, u([",", i], b.map(k, M))]))];
            }
            function d(b, B, k) {
              let M = k("superClass");
              return b.getParentNode().type === "AssignmentExpression" ? y(g(["(", h2([p, M]), p, ")"], M)) : M;
            }
            function v(b, B, k) {
              let M = b.getValue(), R4 = [];
              return t4(M.decorators) && R4.push(P(b, B, k)), M.accessibility && R4.push(M.accessibility + " "), M.readonly && R4.push("readonly "), M.declare && R4.push("declare "), M.static && R4.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && R4.push("abstract "), M.override && R4.push("override "), R4.push(_(b, B, k)), R4;
            }
            function S(b, B, k) {
              let M = b.getValue(), R4 = [], q = B.semi ? ";" : "";
              return t4(M.decorators) && R4.push(P(b, B, k)), M.accessibility && R4.push(M.accessibility + " "), M.declare && R4.push("declare "), M.static && R4.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.type === "TSAbstractAccessorProperty" || M.abstract) && R4.push("abstract "), M.override && R4.push("override "), M.readonly && R4.push("readonly "), M.variance && R4.push(k("variance")), (M.type === "ClassAccessorProperty" || M.type === "AccessorProperty" || M.type === "TSAbstractAccessorProperty") && R4.push("accessor "), R4.push(x(b, B, k), w(b), N6(b), E(b, B, k)), [I(b, B, k, R4, " =", "value"), q];
            }
            r.exports = { printClass: $, printClassMethod: v, printClassProperty: S, printHardlineAfterHeritage: T };
          } }), bo = te({ "src/language-js/print/interface.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t4 } = Ue(), { builders: { join: s, line: a, group: n, indent: u, ifBreak: i } } = qe(), { hasComment: l, identity: p, CommentCheckFlags: y } = Ke(), { getTypeParametersGroupId: h2 } = jr(), { printTypeScriptModifiers: g } = ct();
            function c(f, F4, _) {
              let w = f.getValue(), E = [];
              w.declare && E.push("declare "), w.type === "TSInterfaceDeclaration" && E.push(w.abstract ? "abstract " : "", g(f, F4, _)), E.push("interface");
              let N6 = [], x = [];
              w.type !== "InterfaceTypeAnnotation" && N6.push(" ", _("id"), _("typeParameters"));
              let I = w.typeParameters && !l(w.typeParameters, y.Trailing | y.Line);
              return t4(w.extends) && x.push(I ? i(" ", a, { groupId: h2(w.typeParameters) }) : a, "extends ", (w.extends.length === 1 ? p : u)(s([",", a], f.map(_, "extends")))), w.id && l(w.id, y.Trailing) || t4(w.extends) ? I ? E.push(n([...N6, u(x)])) : E.push(n(u([...N6, ...x]))) : E.push(...N6, ...x), E.push(" ", _("body")), n(E);
            }
            r.exports = { printInterface: c };
          } }), To = te({ "src/language-js/print/module.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t4 } = Ue(), { builders: { softline: s, group: a, indent: n, join: u, line: i, ifBreak: l, hardline: p } } = qe(), { printDanglingComments: y } = et(), { hasComment: h2, CommentCheckFlags: g, shouldPrintComma: c, needsHardlineAfterDanglingComment: f, isStringLiteral: F4, rawText: _ } = Ke(), { locStart: w, hasSameLoc: E } = ut(), { hasDecoratorsBeforeExport: N6, printDecoratorsBeforeExport: x } = nu();
            function I(S, b, B) {
              let k = S.getValue(), M = b.semi ? ";" : "", R4 = [], { importKind: q } = k;
              return R4.push("import"), q && q !== "value" && R4.push(" ", q), R4.push(m(S, b, B), T(S, b, B), o(S, b, B), M), R4;
            }
            function P(S, b, B) {
              let k = S.getValue(), M = [];
              N6(k) && M.push(x(S, b, B));
              let { type: R4, exportKind: q, declaration: J } = k;
              return M.push("export"), (k.default || R4 === "ExportDefaultDeclaration") && M.push(" default"), h2(k, g.Dangling) && (M.push(" ", y(S, b, true)), f(k) && M.push(p)), J ? M.push(" ", B("declaration")) : M.push(q === "type" ? " type" : "", m(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M.push(";"), M;
            }
            function $(S, b, B) {
              let k = S.getValue(), M = b.semi ? ";" : "", R4 = [], { exportKind: q, exported: J } = k;
              return R4.push("export"), q === "type" && R4.push(" type"), R4.push(" *"), J && R4.push(" as ", B("exported")), R4.push(T(S, b, B), o(S, b, B), M), R4;
            }
            function D(S, b) {
              if (!b.semi)
                return false;
              let { type: B, declaration: k } = S, M = S.default || B === "ExportDefaultDeclaration";
              if (!k)
                return true;
              let { type: R4 } = k;
              return !!(M && R4 !== "ClassDeclaration" && R4 !== "FunctionDeclaration" && R4 !== "TSInterfaceDeclaration" && R4 !== "DeclareClass" && R4 !== "DeclareFunction" && R4 !== "TSDeclareFunction" && R4 !== "EnumDeclaration");
            }
            function T(S, b, B) {
              let k = S.getValue();
              if (!k.source)
                return "";
              let M = [];
              return C(k, b) || M.push(" from"), M.push(" ", B("source")), M;
            }
            function m(S, b, B) {
              let k = S.getValue();
              if (C(k, b))
                return "";
              let M = [" "];
              if (t4(k.specifiers)) {
                let R4 = [], q = [];
                S.each(() => {
                  let J = S.getValue().type;
                  if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier")
                    R4.push(B());
                  else if (J === "ExportSpecifier" || J === "ImportSpecifier")
                    q.push(B());
                  else
                    throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
                }, "specifiers"), M.push(u(", ", R4)), q.length > 0 && (R4.length > 0 && M.push(", "), q.length > 1 || R4.length > 0 || k.specifiers.some((L) => h2(L)) ? M.push(a(["{", n([b.bracketSpacing ? i : s, u([",", i], q)]), l(c(b) ? "," : ""), b.bracketSpacing ? i : s, "}"])) : M.push(["{", b.bracketSpacing ? " " : "", ...q, b.bracketSpacing ? " " : "", "}"]));
              } else
                M.push("{}");
              return M;
            }
            function C(S, b) {
              let { type: B, importKind: k, source: M, specifiers: R4 } = S;
              return B !== "ImportDeclaration" || t4(R4) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w(S), w(M)));
            }
            function o(S, b, B) {
              let k = S.getNode();
              return t4(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
            }
            function d(S, b, B) {
              let k = S.getNode(), { type: M } = k, R4 = [], q = M === "ImportSpecifier" ? k.importKind : k.exportKind;
              q && q !== "value" && R4.push(q, " ");
              let J = M.startsWith("Import"), L = J ? "imported" : "local", Q = J ? "local" : "exported", V = k[L], j = k[Q], Y = "", ie = "";
              return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Y = "*" : V && (Y = B(L)), j && !v(k) && (ie = B(Q)), R4.push(Y, Y && ie ? " as " : "", ie), R4;
            }
            function v(S) {
              if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier")
                return false;
              let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
              if (b.type !== B.type || !E(b, B))
                return false;
              if (F4(b))
                return b.value === B.value && _(b) === _(B);
              switch (b.type) {
                case "Identifier":
                  return b.name === B.name;
                default:
                  return false;
              }
            }
            r.exports = { printImportDeclaration: I, printExportDeclaration: P, printExportAllDeclaration: $, printModuleSpecifier: d };
          } }), uu = te({ "src/language-js/print/object.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t4 } = et(), { builders: { line: s, softline: a, group: n, indent: u, ifBreak: i, hardline: l } } = qe(), { getLast: p, hasNewlineInRange: y, hasNewline: h2, isNonEmptyArray: g } = Ue(), { shouldPrintComma: c, hasComment: f, getComments: F4, CommentCheckFlags: _, isNextLineEmpty: w } = Ke(), { locStart: E, locEnd: N6 } = ut(), { printOptionalToken: x, printTypeAnnotation: I } = ct(), { shouldHugFunctionParameters: P } = Lr(), { shouldHugType: $ } = Or(), { printHardlineAfterHeritage: D } = nr();
            function T(m, C, o) {
              let d = C.semi ? ";" : "", v = m.getValue(), S;
              v.type === "TSTypeLiteral" ? S = "members" : v.type === "TSInterfaceBody" ? S = "body" : S = "properties";
              let b = v.type === "ObjectTypeAnnotation", B = [S];
              b && B.push("indexers", "callProperties", "internalSlots");
              let k = B.map((W) => v[W][0]).sort((W, K) => E(W) - E(K))[0], M = m.getParentNode(0), R4 = b && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && m.getName() === "body", q = v.type === "TSInterfaceBody" || R4 || v.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && v.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v.type !== "ObjectPattern" && k && y(C.originalText, E(v), E(k)), J = R4 ? ";" : v.type === "TSInterfaceBody" || v.type === "TSTypeLiteral" ? i(d, ";") : ",", L = v.type === "RecordExpression" ? "#{" : v.exact ? "{|" : "{", Q = v.exact ? "|}" : "}", V = [];
              for (let W of B)
                m.each((K) => {
                  let de = K.getValue();
                  V.push({ node: de, printed: o(), loc: E(de) });
                }, W);
              B.length > 1 && V.sort((W, K) => W.loc - K.loc);
              let j = [], Y = V.map((W) => {
                let K = [...j, n(W.printed)];
                return j = [J, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K;
              });
              if (v.inexact) {
                let W;
                if (f(v, _.Dangling)) {
                  let K = f(v, _.Line);
                  W = [t4(m, C, true), K || h2(C.originalText, N6(p(F4(v)))) ? l : s, "..."];
                } else
                  W = ["..."];
                Y.push([...j, ...W]);
              }
              let ie = p(v[S]), ee = !(v.inexact || ie && ie.type === "RestElement" || ie && (ie.type === "TSPropertySignature" || ie.type === "TSCallSignatureDeclaration" || ie.type === "TSMethodSignature" || ie.type === "TSConstructSignatureDeclaration") && f(ie, _.PrettierIgnore)), ce;
              if (Y.length === 0) {
                if (!f(v, _.Dangling))
                  return [L, Q, I(m, C, o)];
                ce = n([L, t4(m, C), a, Q, x(m), I(m, C, o)]);
              } else
                ce = [R4 && g(v.properties) ? D(M) : "", L, u([C.bracketSpacing ? s : a, ...Y]), i(ee && (J !== "," || c(C)) ? J : ""), C.bracketSpacing ? s : a, Q, x(m), I(m, C, o)];
              return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || m.match($, (W, K) => K === "typeAnnotation", (W, K) => K === "typeAnnotation", (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || !q && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce : n(ce, { shouldBreak: q });
            }
            r.exports = { printObject: T };
          } }), dd = te({ "src/language-js/print/flow.js"(e, r) {
            "use strict";
            ne();
            var t4 = Zt(), { printDanglingComments: s } = et(), { printString: a, printNumber: n } = Ue(), { builders: { hardline: u, softline: i, group: l, indent: p } } = qe(), { getParentExportDeclaration: y, isFunctionNotation: h2, isGetterOrSetter: g, rawText: c, shouldPrintComma: f } = Ke(), { locStart: F4, locEnd: _ } = ut(), { replaceTextEndOfLine: w } = Yt(), { printClass: E } = nr(), { printOpaqueType: N6, printTypeAlias: x, printIntersectionType: I, printUnionType: P, printFunctionType: $, printTupleType: D, printIndexedAccessType: T } = Or(), { printInterface: m } = bo(), { printTypeParameter: C, printTypeParameters: o } = jr(), { printExportDeclaration: d, printExportAllDeclaration: v } = To(), { printArrayItems: S } = er(), { printObject: b } = uu(), { printPropertyKey: B } = rr(), { printOptionalToken: k, printTypeAnnotation: M, printRestSpread: R4 } = ct();
            function q(L, Q, V) {
              let j = L.getValue(), Y = Q.semi ? ";" : "", ie = [];
              switch (j.type) {
                case "DeclareClass":
                  return J(L, E(L, Q, V));
                case "DeclareFunction":
                  return J(L, ["function ", V("id"), j.predicate ? " " : "", V("predicate"), Y]);
                case "DeclareModule":
                  return J(L, ["module ", V("id"), " ", V("body")]);
                case "DeclareModuleExports":
                  return J(L, ["module.exports", ": ", V("typeAnnotation"), Y]);
                case "DeclareVariable":
                  return J(L, ["var ", V("id"), Y]);
                case "DeclareOpaqueType":
                  return J(L, N6(L, Q, V));
                case "DeclareInterface":
                  return J(L, m(L, Q, V));
                case "DeclareTypeAlias":
                  return J(L, x(L, Q, V));
                case "DeclareExportDeclaration":
                  return J(L, d(L, Q, V));
                case "DeclareExportAllDeclaration":
                  return J(L, v(L, Q, V));
                case "OpaqueType":
                  return N6(L, Q, V);
                case "TypeAlias":
                  return x(L, Q, V);
                case "IntersectionTypeAnnotation":
                  return I(L, Q, V);
                case "UnionTypeAnnotation":
                  return P(L, Q, V);
                case "FunctionTypeAnnotation":
                  return $(L, Q, V);
                case "TupleTypeAnnotation":
                  return D(L, Q, V);
                case "GenericTypeAnnotation":
                  return [V("id"), o(L, Q, V, "typeParameters")];
                case "IndexedAccessType":
                case "OptionalIndexedAccessType":
                  return T(L, Q, V);
                case "TypeAnnotation":
                  return V("typeAnnotation");
                case "TypeParameter":
                  return C(L, Q, V);
                case "TypeofTypeAnnotation":
                  return ["typeof ", V("argument")];
                case "ExistsTypeAnnotation":
                  return "*";
                case "EmptyTypeAnnotation":
                  return "empty";
                case "MixedTypeAnnotation":
                  return "mixed";
                case "ArrayTypeAnnotation":
                  return [V("elementType"), "[]"];
                case "BooleanLiteralTypeAnnotation":
                  return String(j.value);
                case "EnumDeclaration":
                  return ["enum ", V("id"), " ", V("body")];
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody": {
                  if (j.type === "EnumSymbolBody" || j.explicitType) {
                    let ee = null;
                    switch (j.type) {
                      case "EnumBooleanBody":
                        ee = "boolean";
                        break;
                      case "EnumNumberBody":
                        ee = "number";
                        break;
                      case "EnumStringBody":
                        ee = "string";
                        break;
                      case "EnumSymbolBody":
                        ee = "symbol";
                        break;
                    }
                    ie.push("of ", ee, " ");
                  }
                  if (j.members.length === 0 && !j.hasUnknownMembers)
                    ie.push(l(["{", s(L, Q), i, "}"]));
                  else {
                    let ee = j.members.length > 0 ? [u, S(L, Q, "members", V), j.hasUnknownMembers || f(Q) ? "," : ""] : [];
                    ie.push(l(["{", p([...ee, ...j.hasUnknownMembers ? [u, "..."] : []]), s(L, Q, true), u, "}"]));
                  }
                  return ie;
                }
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                  return [V("id"), " = ", typeof j.init == "object" ? V("init") : String(j.init)];
                case "EnumDefaultedMember":
                  return V("id");
                case "FunctionTypeParam": {
                  let ee = j.name ? V("name") : L.getParentNode().this === j ? "this" : "";
                  return [ee, k(L), ee ? ": " : "", V("typeAnnotation")];
                }
                case "InterfaceDeclaration":
                case "InterfaceTypeAnnotation":
                  return m(L, Q, V);
                case "ClassImplements":
                case "InterfaceExtends":
                  return [V("id"), V("typeParameters")];
                case "NullableTypeAnnotation":
                  return ["?", V("typeAnnotation")];
                case "Variance": {
                  let { kind: ee } = j;
                  return t4.ok(ee === "plus" || ee === "minus"), ee === "plus" ? "+" : "-";
                }
                case "ObjectTypeCallProperty":
                  return j.static && ie.push("static "), ie.push(V("value")), ie;
                case "ObjectTypeIndexer":
                  return [j.static ? "static " : "", j.variance ? V("variance") : "", "[", V("id"), j.id ? ": " : "", V("key"), "]: ", V("value")];
                case "ObjectTypeProperty": {
                  let ee = "";
                  return j.proto ? ee = "proto " : j.static && (ee = "static "), [ee, g(j) ? j.kind + " " : "", j.variance ? V("variance") : "", B(L, Q, V), k(L), h2(j) ? "" : ": ", V("value")];
                }
                case "ObjectTypeAnnotation":
                  return b(L, Q, V);
                case "ObjectTypeInternalSlot":
                  return [j.static ? "static " : "", "[[", V("id"), "]]", k(L), j.method ? "" : ": ", V("value")];
                case "ObjectTypeSpreadProperty":
                  return R4(L, Q, V);
                case "QualifiedTypeofIdentifier":
                case "QualifiedTypeIdentifier":
                  return [V("qualification"), ".", V("id")];
                case "StringLiteralTypeAnnotation":
                  return w(a(c(j), Q));
                case "NumberLiteralTypeAnnotation":
                  t4.strictEqual(typeof j.value, "number");
                case "BigIntLiteralTypeAnnotation":
                  return j.extra ? n(j.extra.raw) : n(j.raw);
                case "TypeCastExpression":
                  return ["(", V("expression"), M(L, Q, V), ")"];
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation": {
                  let ee = o(L, Q, V, "params");
                  if (Q.parser === "flow") {
                    let ce = F4(j), W = _(j), K = Q.originalText.lastIndexOf("/*", ce), de = Q.originalText.indexOf("*/", W);
                    if (K !== -1 && de !== -1) {
                      let ue = Q.originalText.slice(K + 2, de).trim();
                      if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/"))
                        return ["/*:: ", ee, " */"];
                    }
                  }
                  return ee;
                }
                case "InferredPredicate":
                  return "%checks";
                case "DeclaredPredicate":
                  return ["%checks(", V("value"), ")"];
                case "AnyTypeAnnotation":
                  return "any";
                case "BooleanTypeAnnotation":
                  return "boolean";
                case "BigIntTypeAnnotation":
                  return "bigint";
                case "NullLiteralTypeAnnotation":
                  return "null";
                case "NumberTypeAnnotation":
                  return "number";
                case "SymbolTypeAnnotation":
                  return "symbol";
                case "StringTypeAnnotation":
                  return "string";
                case "VoidTypeAnnotation":
                  return "void";
                case "ThisTypeAnnotation":
                  return "this";
                case "Node":
                case "Printable":
                case "SourceLocation":
                case "Position":
                case "Statement":
                case "Function":
                case "Pattern":
                case "Expression":
                case "Declaration":
                case "Specifier":
                case "NamedSpecifier":
                case "Comment":
                case "MemberTypeAnnotation":
                case "Type":
                  throw new Error("unprintable type: " + JSON.stringify(j.type));
              }
            }
            function J(L, Q) {
              let V = y(L);
              return V ? (t4.strictEqual(V.type, "DeclareExportDeclaration"), Q) : ["declare ", Q];
            }
            r.exports = { printFlow: q };
          } }), gd = te({ "src/language-js/utils/is-ts-keyword-type.js"(e, r) {
            "use strict";
            ne();
            function t4(s) {
              let { type: a } = s;
              return a.startsWith("TS") && a.endsWith("Keyword");
            }
            r.exports = t4;
          } }), Bo = te({ "src/language-js/print/ternary.js"(e, r) {
            "use strict";
            ne();
            var { hasNewlineInRange: t4 } = Ue(), { isJsxNode: s, getComments: a, isCallExpression: n, isMemberExpression: u, isTSTypeExpression: i } = Ke(), { locStart: l, locEnd: p } = ut(), y = Pt(), { builders: { line: h2, softline: g, group: c, indent: f, align: F4, ifBreak: _, dedent: w, breakParent: E } } = qe();
            function N6(D) {
              let T = [D];
              for (let m = 0; m < T.length; m++) {
                let C = T[m];
                for (let o of ["test", "consequent", "alternate"]) {
                  let d = C[o];
                  if (s(d))
                    return true;
                  d.type === "ConditionalExpression" && T.push(d);
                }
              }
              return false;
            }
            function x(D, T, m) {
              let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "alternate" : "falseType", v = D.getParentNode(), S = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
              return v.type === C.type && v[d] === C ? F4(2, S) : S;
            }
            var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
            function P(D) {
              let T = D.getValue();
              if (T.type !== "ConditionalExpression")
                return false;
              let m, C = T;
              for (let o = 0; !m; o++) {
                let d = D.getParentNode(o);
                if (n(d) && d.callee === C || u(d) && d.object === C || d.type === "TSNonNullExpression" && d.expression === C) {
                  C = d;
                  continue;
                }
                d.type === "NewExpression" && d.callee === C || i(d) && d.expression === C ? (m = D.getParentNode(o + 1), C = d) : m = d;
              }
              return C === T ? false : m[I.get(m.type)] === C;
            }
            function $(D, T, m) {
              let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "consequent" : "trueType", v = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C[d], B = C[v], k = [], M = false, R4 = D.getParentNode(), q = R4.type === C.type && S.some((ue) => R4[ue] === C), J = R4.type === C.type && !q, L, Q, V = 0;
              do
                Q = L || C, L = D.getParentNode(V), V++;
              while (L && L.type === C.type && S.every((ue) => L[ue] !== Q));
              let j = L || R4, Y = Q;
              if (o && (s(C[S[0]]) || s(b) || s(B) || N6(Y))) {
                M = true, J = true;
                let ue = (z) => [_("("), f([g, z]), g, _(")")], Fe = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
                k.push(" ? ", Fe(b) ? m(d) : ue(m(d)), " : ", B.type === C.type || Fe(B) ? m(v) : ue(m(v)));
              } else {
                let ue = [h2, "? ", b.type === C.type ? _("", "(") : "", F4(2, m(d)), b.type === C.type ? _("", ")") : "", h2, ": ", B.type === C.type ? m(v) : F4(2, m(v))];
                k.push(R4.type !== C.type || R4[v] === C || q ? ue : T.useTabs ? w(f(ue)) : F4(Math.max(0, T.tabWidth - 2), ue));
              }
              let ee = [...S.map((ue) => a(C[ue])), a(b), a(B)].flat().some((ue) => y(ue) && t4(T.originalText, l(ue), p(ue))), ce = (ue) => R4 === j ? c(ue, { shouldBreak: ee }) : ee ? [ue, E] : ue, W = !M && (u(R4) || R4.type === "NGPipeExpression" && R4.left === C) && !R4.computed, K = P(D), de = ce([x(D, T, m), J ? k : f(k), o && W && !K ? g : ""]);
              return q || K ? c([f([g, de]), g]) : de;
            }
            r.exports = { printTernary: $ };
          } }), No = te({ "src/language-js/print/statement.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t4 } } = qe(), s = qt(), { getLeftSidePathName: a, hasNakedLeftSide: n, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: p, isNextLineEmpty: y } = Ke(), { shouldPrintParamsWithoutParens: h2 } = qr();
            function g(x, I, P, $) {
              let D = x.getValue(), T = [], m = D.type === "ClassBody", C = c(D[$]);
              return x.each((o, d, v) => {
                let S = o.getValue();
                if (S.type === "EmptyStatement")
                  return;
                let b = P();
                !I.semi && !m && !i(I, o) && f(o, I) ? l(S, p.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I.semi && m && E(S) && N6(S, v[d + 1]) && T.push(";"), S !== C && (T.push(t4), y(S, I) && T.push(t4));
              }, $), T;
            }
            function c(x) {
              for (let I = x.length - 1; I >= 0; I--) {
                let P = x[I];
                if (P.type !== "EmptyStatement")
                  return P;
              }
            }
            function f(x, I) {
              return x.getNode().type !== "ExpressionStatement" ? false : x.call(($) => F4($, I), "expression");
            }
            function F4(x, I) {
              let P = x.getValue();
              switch (P.type) {
                case "ParenthesizedExpression":
                case "TypeCastExpression":
                case "ArrayExpression":
                case "ArrayPattern":
                case "TemplateLiteral":
                case "TemplateElement":
                case "RegExpLiteral":
                  return true;
                case "ArrowFunctionExpression": {
                  if (!h2(x, I))
                    return true;
                  break;
                }
                case "UnaryExpression": {
                  let { prefix: $, operator: D } = P;
                  if ($ && (D === "+" || D === "-"))
                    return true;
                  break;
                }
                case "BindExpression": {
                  if (!P.object)
                    return true;
                  break;
                }
                case "Literal": {
                  if (P.regex)
                    return true;
                  break;
                }
                default:
                  if (u(P))
                    return true;
              }
              return s(x, I) ? true : n(P) ? x.call(($) => F4($, I), ...a(x, P)) : false;
            }
            function _(x, I, P) {
              return g(x, I, P, "body");
            }
            function w(x, I, P) {
              return g(x, I, P, "consequent");
            }
            var E = (x) => {
              let { type: I } = x;
              return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty" || I === "AccessorProperty" || I === "TSAbstractPropertyDefinition" || I === "TSAbstractAccessorProperty";
            };
            function N6(x, I) {
              let { type: P, name: $ } = x.key;
              if (!x.computed && P === "Identifier" && ($ === "static" || $ === "get" || $ === "set" || $ === "accessor") && !x.value && !x.typeAnnotation)
                return true;
              if (!I || I.static || I.accessibility)
                return false;
              if (!I.computed) {
                let D = I.key && I.key.name;
                if (D === "in" || D === "instanceof")
                  return true;
              }
              if (E(I) && I.variance && !I.static && !I.declare)
                return true;
              switch (I.type) {
                case "ClassProperty":
                case "PropertyDefinition":
                case "TSAbstractPropertyDefinition":
                  return I.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod": {
                  if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
                    return false;
                  let T = I.value ? I.value.generator : I.generator;
                  return !!(I.computed || T);
                }
                case "TSIndexSignature":
                  return true;
              }
              return false;
            }
            r.exports = { printBody: _, printSwitchCaseConsequent: w };
          } }), wo = te({ "src/language-js/print/block.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t4 } = et(), { isNonEmptyArray: s } = Ue(), { builders: { hardline: a, indent: n } } = qe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke(), { printHardlineAfterHeritage: p } = nr(), { printBody: y } = No();
            function h2(c, f, F4) {
              let _ = c.getValue(), w = [];
              if (_.type === "StaticBlock" && w.push("static "), _.type === "ClassBody" && s(_.body)) {
                let N6 = c.getParentNode();
                w.push(p(N6));
              }
              w.push("{");
              let E = g(c, f, F4);
              if (E)
                w.push(n([a, E]), a);
              else {
                let N6 = c.getParentNode(), x = c.getParentNode(1);
                N6.type === "ArrowFunctionExpression" || N6.type === "FunctionExpression" || N6.type === "FunctionDeclaration" || N6.type === "ObjectMethod" || N6.type === "ClassMethod" || N6.type === "ClassPrivateMethod" || N6.type === "ForStatement" || N6.type === "WhileStatement" || N6.type === "DoWhileStatement" || N6.type === "DoExpression" || N6.type === "CatchClause" && !x.finalizer || N6.type === "TSModuleDeclaration" || N6.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w.push(a);
              }
              return w.push("}"), w;
            }
            function g(c, f, F4) {
              let _ = c.getValue(), w = s(_.directives), E = _.body.some((I) => I.type !== "EmptyStatement"), N6 = u(_, i.Dangling);
              if (!w && !E && !N6)
                return "";
              let x = [];
              if (w && c.each((I, P, $) => {
                x.push(F4()), (P < $.length - 1 || E || N6) && (x.push(a), l(I.getValue(), f) && x.push(a));
              }, "directives"), E && x.push(y(c, f, F4)), N6 && x.push(t4(c, f, true)), _.type === "Program") {
                let I = c.getParentNode();
                (!I || I.type !== "ModuleExpression") && x.push(a);
              }
              return x;
            }
            r.exports = { printBlock: h2, printBlockBody: g };
          } }), yd = te({ "src/language-js/print/typescript.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t4 } = et(), { hasNewlineInRange: s } = Ue(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y, ifBreak: h2 } } = qe(), { isStringLiteral: g, getTypeScriptMappedTypeModifier: c, shouldPrintComma: f, isCallExpression: F4, isMemberExpression: _ } = Ke(), w = gd(), { locStart: E, locEnd: N6 } = ut(), { printOptionalToken: x, printTypeScriptModifiers: I } = ct(), { printTernary: P } = Bo(), { printFunctionParameters: $, shouldGroupFunctionParameters: D } = Lr(), { printTemplateLiteral: T } = jt(), { printArrayItems: m } = er(), { printObject: C } = uu(), { printClassProperty: o, printClassMethod: d } = nr(), { printTypeParameter: v, printTypeParameters: S } = jr(), { printPropertyKey: b } = rr(), { printFunction: B, printMethodInternal: k } = qr(), { printInterface: M } = bo(), { printBlock: R4 } = wo(), { printTypeAlias: q, printIntersectionType: J, printUnionType: L, printFunctionType: Q, printTupleType: V, printIndexedAccessType: j, printJSDocType: Y } = Or();
            function ie(ee, ce, W) {
              let K = ee.getValue();
              if (!K.type.startsWith("TS"))
                return;
              if (w(K))
                return K.type.slice(2, -7).toLowerCase();
              let de = ce.semi ? ";" : "", ue = [];
              switch (K.type) {
                case "TSThisType":
                  return "this";
                case "TSTypeAssertion": {
                  let Fe = !(K.expression.type === "ArrayExpression" || K.expression.type === "ObjectExpression"), z = l(["<", p([i, W("typeAnnotation")]), i, ">"]), U3 = [h2("("), p([i, W("expression")]), i, h2(")")];
                  return Fe ? y([[z, W("expression")], [z, l(U3, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
                }
                case "TSDeclareFunction":
                  return B(ee, W, ce);
                case "TSExportAssignment":
                  return ["export = ", W("expression"), de];
                case "TSModuleBlock":
                  return R4(ee, ce, W);
                case "TSInterfaceBody":
                case "TSTypeLiteral":
                  return C(ee, ce, W);
                case "TSTypeAliasDeclaration":
                  return q(ee, ce, W);
                case "TSQualifiedName":
                  return a(".", [W("left"), W("right")]);
                case "TSAbstractMethodDefinition":
                case "TSDeclareMethod":
                  return d(ee, ce, W);
                case "TSAbstractAccessorProperty":
                case "TSAbstractPropertyDefinition":
                  return o(ee, ce, W);
                case "TSInterfaceHeritage":
                case "TSExpressionWithTypeArguments":
                  return ue.push(W("expression")), K.typeParameters && ue.push(W("typeParameters")), ue;
                case "TSTemplateLiteralType":
                  return T(ee, W, ce);
                case "TSNamedTupleMember":
                  return [W("label"), K.optional ? "?" : "", ": ", W("elementType")];
                case "TSRestType":
                  return ["...", W("typeAnnotation")];
                case "TSOptionalType":
                  return [W("typeAnnotation"), "?"];
                case "TSInterfaceDeclaration":
                  return M(ee, ce, W);
                case "TSClassImplements":
                  return [W("expression"), W("typeParameters")];
                case "TSTypeParameterDeclaration":
                case "TSTypeParameterInstantiation":
                  return S(ee, ce, W, "params");
                case "TSTypeParameter":
                  return v(ee, ce, W);
                case "TSSatisfiesExpression":
                case "TSAsExpression": {
                  let Fe = K.type === "TSAsExpression" ? "as" : "satisfies";
                  ue.push(W("expression"), ` ${Fe} `, W("typeAnnotation"));
                  let z = ee.getParentNode();
                  return F4(z) && z.callee === K || _(z) && z.object === K ? l([p([i, ...ue]), i]) : ue;
                }
                case "TSArrayType":
                  return [W("elementType"), "[]"];
                case "TSPropertySignature":
                  return K.readonly && ue.push("readonly "), ue.push(b(ee, ce, W), x(ee)), K.typeAnnotation && ue.push(": ", W("typeAnnotation")), K.initializer && ue.push(" = ", W("initializer")), ue;
                case "TSParameterProperty":
                  return K.accessibility && ue.push(K.accessibility + " "), K.export && ue.push("export "), K.static && ue.push("static "), K.override && ue.push("override "), K.readonly && ue.push("readonly "), ue.push(W("parameter")), ue;
                case "TSTypeQuery":
                  return ["typeof ", W("exprName"), W("typeParameters")];
                case "TSIndexSignature": {
                  let Fe = ee.getParentNode(), z = K.parameters.length > 1 ? h2(f(ce) ? "," : "") : "", U3 = l([p([i, a([", ", i], ee.map(W, "parameters"))]), z, i]);
                  return [K.export ? "export " : "", K.accessibility ? [K.accessibility, " "] : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.declare ? "declare " : "", "[", K.parameters ? U3 : "", K.typeAnnotation ? "]: " : "]", K.typeAnnotation ? W("typeAnnotation") : "", Fe.type === "ClassBody" ? de : ""];
                }
                case "TSTypePredicate":
                  return [K.asserts ? "asserts " : "", W("parameterName"), K.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
                case "TSNonNullExpression":
                  return [W("expression"), "!"];
                case "TSImportType":
                  return [K.isTypeOf ? "typeof " : "", "import(", W(K.parameter ? "parameter" : "argument"), ")", K.qualifier ? [".", W("qualifier")] : "", S(ee, ce, W, "typeParameters")];
                case "TSLiteralType":
                  return W("literal");
                case "TSIndexedAccessType":
                  return j(ee, ce, W);
                case "TSConstructSignatureDeclaration":
                case "TSCallSignatureDeclaration":
                case "TSConstructorType": {
                  if (K.type === "TSConstructorType" && K.abstract && ue.push("abstract "), K.type !== "TSCallSignatureDeclaration" && ue.push("new "), ue.push(l($(ee, W, ce, false, true))), K.returnType || K.typeAnnotation) {
                    let Fe = K.type === "TSConstructorType";
                    ue.push(Fe ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                  }
                  return ue;
                }
                case "TSTypeOperator":
                  return [K.operator, " ", W("typeAnnotation")];
                case "TSMappedType": {
                  let Fe = s(ce.originalText, E(K), N6(K));
                  return l(["{", p([ce.bracketSpacing ? n : i, W("typeParameter"), K.optional ? c(K.optional, "?") : "", K.typeAnnotation ? ": " : "", W("typeAnnotation"), h2(de)]), t4(ee, ce, true), ce.bracketSpacing ? n : i, "}"], { shouldBreak: Fe });
                }
                case "TSMethodSignature": {
                  let Fe = K.kind && K.kind !== "method" ? `${K.kind} ` : "";
                  ue.push(K.accessibility ? [K.accessibility, " "] : "", Fe, K.export ? "export " : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.abstract ? "abstract " : "", K.declare ? "declare " : "", K.computed ? "[" : "", W("key"), K.computed ? "]" : "", x(ee));
                  let z = $(ee, W, ce, false, true), U3 = K.returnType ? "returnType" : "typeAnnotation", Z = K[U3], se = Z ? W(U3) : "", fe = D(K, se);
                  return ue.push(fe ? l(z) : z), Z && ue.push(": ", l(se)), l(ue);
                }
                case "TSNamespaceExportDeclaration":
                  return ue.push("export as namespace ", W("id")), ce.semi && ue.push(";"), l(ue);
                case "TSEnumDeclaration":
                  return K.declare && ue.push("declare "), K.modifiers && ue.push(I(ee, ce, W)), K.const && ue.push("const "), ue.push("enum ", W("id"), " "), K.members.length === 0 ? ue.push(l(["{", t4(ee, ce), i, "}"])) : ue.push(l(["{", p([u, m(ee, ce, "members", W), f(ce, "es5") ? "," : ""]), t4(ee, ce, true), u, "}"])), ue;
                case "TSEnumMember":
                  return K.computed ? ue.push("[", W("id"), "]") : ue.push(W("id")), K.initializer && ue.push(" = ", W("initializer")), ue;
                case "TSImportEqualsDeclaration":
                  return K.isExport && ue.push("export "), ue.push("import "), K.importKind && K.importKind !== "value" && ue.push(K.importKind, " "), ue.push(W("id"), " = ", W("moduleReference")), ce.semi && ue.push(";"), l(ue);
                case "TSExternalModuleReference":
                  return ["require(", W("expression"), ")"];
                case "TSModuleDeclaration": {
                  let Fe = ee.getParentNode(), z = g(K.id), U3 = Fe.type === "TSModuleDeclaration", Z = K.body && K.body.type === "TSModuleDeclaration";
                  if (U3)
                    ue.push(".");
                  else {
                    K.declare && ue.push("declare "), ue.push(I(ee, ce, W));
                    let se = ce.originalText.slice(E(K), E(K.id));
                    K.id.type === "Identifier" && K.id.name === "global" && !/namespace|module/.test(se) || ue.push(z || /(?:^|\s)module(?:\s|$)/.test(se) ? "module " : "namespace ");
                  }
                  return ue.push(W("id")), Z ? ue.push(W("body")) : K.body ? ue.push(" ", l(W("body"))) : ue.push(de), ue;
                }
                case "TSConditionalType":
                  return P(ee, ce, W);
                case "TSInferType":
                  return ["infer", " ", W("typeParameter")];
                case "TSIntersectionType":
                  return J(ee, ce, W);
                case "TSUnionType":
                  return L(ee, ce, W);
                case "TSFunctionType":
                  return Q(ee, ce, W);
                case "TSTupleType":
                  return V(ee, ce, W);
                case "TSTypeReference":
                  return [W("typeName"), S(ee, ce, W, "typeParameters")];
                case "TSTypeAnnotation":
                  return W("typeAnnotation");
                case "TSEmptyBodyFunctionExpression":
                  return k(ee, ce, W);
                case "TSJSDocAllType":
                  return "*";
                case "TSJSDocUnknownType":
                  return "?";
                case "TSJSDocNullableType":
                  return Y(ee, W, "?");
                case "TSJSDocNonNullableType":
                  return Y(ee, W, "!");
                case "TSInstantiationExpression":
                  return [W("expression"), W("typeParameters")];
                default:
                  throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`);
              }
            }
            r.exports = { printTypescript: ie };
          } }), hd = te({ "src/language-js/print/comment.js"(e, r) {
            "use strict";
            ne();
            var { hasNewline: t4 } = Ue(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: n } } = qe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: l } = ut(), p = Pt();
            function y(c, f) {
              let F4 = c.getValue();
              if (u(F4))
                return f.originalText.slice(i(F4), l(F4)).trimEnd();
              if (p(F4)) {
                if (h2(F4)) {
                  let E = g(F4);
                  return F4.trailing && !t4(f.originalText, i(F4), { backwards: true }) ? [a, E] : E;
                }
                let _ = l(F4), w = f.originalText.slice(_ - 3, _) === "*-/";
                return ["/*", n(F4.value), w ? "*-/" : "*/"];
              }
              throw new Error("Not a comment: " + JSON.stringify(F4));
            }
            function h2(c) {
              let f = `*${c.value}*`.split(`
`);
              return f.length > 1 && f.every((F4) => F4.trim()[0] === "*");
            }
            function g(c) {
              let f = c.value.split(`
`);
              return ["/*", s(a, f.map((F4, _) => _ === 0 ? F4.trimEnd() : " " + (_ < f.length - 1 ? F4.trim() : F4.trimStart()))), "*/"];
            }
            r.exports = { printComment: y };
          } }), vd = te({ "src/language-js/print/literal.js"(e, r) {
            "use strict";
            ne();
            var { printString: t4, printNumber: s } = Ue(), { replaceTextEndOfLine: a } = Yt(), { printDirective: n } = ct();
            function u(y, h2) {
              let g = y.getNode();
              switch (g.type) {
                case "RegExpLiteral":
                  return p(g);
                case "BigIntLiteral":
                  return l(g.bigint || g.extra.raw);
                case "NumericLiteral":
                  return s(g.extra.raw);
                case "StringLiteral":
                  return a(t4(g.extra.raw, h2));
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return String(g.value);
                case "DecimalLiteral":
                  return s(g.value) + "m";
                case "Literal": {
                  if (g.regex)
                    return p(g.regex);
                  if (g.bigint)
                    return l(g.raw);
                  if (g.decimal)
                    return s(g.decimal) + "m";
                  let { value: c } = g;
                  return typeof c == "number" ? s(g.raw) : typeof c == "string" ? i(y) ? n(g.raw, h2) : a(t4(g.raw, h2)) : String(c);
                }
              }
            }
            function i(y) {
              if (y.getName() !== "expression")
                return;
              let h2 = y.getParentNode();
              return h2.type === "ExpressionStatement" && h2.directive;
            }
            function l(y) {
              return y.toLowerCase();
            }
            function p(y) {
              let { pattern: h2, flags: g } = y;
              return g = [...g].sort().join(""), `/${h2}/${g}`;
            }
            r.exports = { printLiteral: u };
          } }), Cd = te({ "src/language-js/printer-estree.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t4 } = et(), { hasNewline: s } = Ue(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p }, utils: { replaceTextEndOfLine: y } } = qe(), h2 = td(), g = rd(), { insertPragma: c } = Co(), f = Eo(), F4 = qt(), _ = Fo(), { hasFlowShorthandAnnotationComment: w, hasComment: E, CommentCheckFlags: N6, isTheOnlyJsxElementInMarkdown: x, isLineComment: I, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m, markerForIfWithoutBlockAndSameLineComment: C } = Ke(), { locStart: o, locEnd: d } = ut(), v = Pt(), { printHtmlBinding: S, isVueEventBindingExpression: b } = pd(), { printAngular: B } = fd(), { printJsx: k, hasJsxIgnoreComment: M } = Dd(), { printFlow: R4 } = dd(), { printTypescript: q } = yd(), { printOptionalToken: J, printBindExpressionCallee: L, printTypeAnnotation: Q, adjustClause: V, printRestSpread: j, printDefiniteToken: Y, printDirective: ie } = ct(), { printImportDeclaration: ee, printExportDeclaration: ce, printExportAllDeclaration: W, printModuleSpecifier: K } = To(), { printTernary: de } = Bo(), { printTemplateLiteral: ue } = jt(), { printArray: Fe } = er(), { printObject: z } = uu(), { printClass: U3, printClassMethod: Z, printClassProperty: se } = nr(), { printProperty: fe } = rr(), { printFunction: ge, printArrowFunction: he, printMethod: we, printReturnStatement: ke, printThrowStatement: Re } = qr(), { printCallExpression: Ne } = xo(), { printVariableDeclarator: Pe, printAssignmentExpression: oe } = tr(), { printBinaryishExpression: H } = ru(), { printSwitchCaseConsequent: pe } = No(), { printMemberExpression: X } = So(), { printBlock: le, printBlockBody: Ae } = wo(), { printComment: Ee } = hd(), { printLiteral: De } = vd(), { printDecorators: A } = nu();
            function G(Ce, Be, ve, ze) {
              let be = re(Ce, Be, ve, ze);
              if (!be)
                return "";
              let Ye = Ce.getValue(), { type: Se } = Ye;
              if (Se === "ClassMethod" || Se === "ClassPrivateMethod" || Se === "ClassProperty" || Se === "ClassAccessorProperty" || Se === "AccessorProperty" || Se === "TSAbstractAccessorProperty" || Se === "PropertyDefinition" || Se === "TSAbstractPropertyDefinition" || Se === "ClassPrivateProperty" || Se === "MethodDefinition" || Se === "TSAbstractMethodDefinition" || Se === "TSDeclareMethod")
                return be;
              let Ie = [be], Oe = A(Ce, Be, ve), Je = Ye.type === "ClassExpression" && Oe;
              if (Oe && (Ie = [...Oe, be], !Je))
                return l(Ie);
              if (!F4(Ce, Be))
                return ze && ze.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === be ? be : Ie;
              if (Je && (Ie = [p([n, ...Ie])]), Ie.unshift("("), ze && ze.needsSemi && Ie.unshift(";"), w(Ye)) {
                let [je] = Ye.trailingComments;
                Ie.push(" /*", je.value.trimStart(), "*/"), je.printed = true;
              }
              return Je && Ie.push(n), Ie.push(")"), Ie;
            }
            function re(Ce, Be, ve, ze) {
              let be = Ce.getValue(), Ye = Be.semi ? ";" : "";
              if (!be)
                return "";
              if (typeof be == "string")
                return be;
              for (let Ie of [De, S, B, k, R4, q]) {
                let Oe = Ie(Ce, Be, ve);
                if (typeof Oe < "u")
                  return Oe;
              }
              let Se = [];
              switch (be.type) {
                case "JsExpressionRoot":
                  return ve("node");
                case "JsonRoot":
                  return [ve("node"), u];
                case "File":
                  return be.program && be.program.interpreter && Se.push(ve(["program", "interpreter"])), Se.push(ve("program")), Se;
                case "Program":
                  return Ae(Ce, Be, ve);
                case "EmptyStatement":
                  return "";
                case "ExpressionStatement": {
                  if (Be.parser === "__vue_event_binding" || Be.parser === "__vue_ts_event_binding") {
                    let Oe = Ce.getParentNode();
                    if (Oe.type === "Program" && Oe.body.length === 1 && Oe.body[0] === be)
                      return [ve("expression"), b(be.expression) ? ";" : ""];
                  }
                  let Ie = t4(Ce, Be, true, (Oe) => {
                    let { marker: Je } = Oe;
                    return Je === C;
                  });
                  return [ve("expression"), x(Be, Ce) ? "" : Ye, Ie ? [" ", Ie] : ""];
                }
                case "ParenthesizedExpression":
                  return !E(be.expression) && (be.expression.type === "ObjectExpression" || be.expression.type === "ArrayExpression") ? ["(", ve("expression"), ")"] : l(["(", p([i, ve("expression")]), i, ")"]);
                case "AssignmentExpression":
                  return oe(Ce, Be, ve);
                case "VariableDeclarator":
                  return Pe(Ce, Be, ve);
                case "BinaryExpression":
                case "LogicalExpression":
                  return H(Ce, Be, ve);
                case "AssignmentPattern":
                  return [ve("left"), " = ", ve("right")];
                case "OptionalMemberExpression":
                case "MemberExpression":
                  return X(Ce, Be, ve);
                case "MetaProperty":
                  return [ve("meta"), ".", ve("property")];
                case "BindExpression":
                  return be.object && Se.push(ve("object")), Se.push(l(p([i, L(Ce, Be, ve)]))), Se;
                case "Identifier":
                  return [be.name, J(Ce), Y(Ce), Q(Ce, Be, ve)];
                case "V8IntrinsicIdentifier":
                  return ["%", be.name];
                case "SpreadElement":
                case "SpreadElementPattern":
                case "SpreadProperty":
                case "SpreadPropertyPattern":
                case "RestElement":
                  return j(Ce, Be, ve);
                case "FunctionDeclaration":
                case "FunctionExpression":
                  return ge(Ce, ve, Be, ze);
                case "ArrowFunctionExpression":
                  return he(Ce, Be, ve, ze);
                case "YieldExpression":
                  return Se.push("yield"), be.delegate && Se.push("*"), be.argument && Se.push(" ", ve("argument")), Se;
                case "AwaitExpression": {
                  if (Se.push("await"), be.argument) {
                    Se.push(" ", ve("argument"));
                    let Ie = Ce.getParentNode();
                    if (T(Ie) && Ie.callee === be || m(Ie) && Ie.object === be) {
                      Se = [p([i, ...Se]), i];
                      let Oe = Ce.findAncestor((Je) => Je.type === "AwaitExpression" || Je.type === "BlockStatement");
                      if (!Oe || Oe.type !== "AwaitExpression")
                        return l(Se);
                    }
                  }
                  return Se;
                }
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                  return ce(Ce, Be, ve);
                case "ExportAllDeclaration":
                  return W(Ce, Be, ve);
                case "ImportDeclaration":
                  return ee(Ce, Be, ve);
                case "ImportSpecifier":
                case "ExportSpecifier":
                case "ImportNamespaceSpecifier":
                case "ExportNamespaceSpecifier":
                case "ImportDefaultSpecifier":
                case "ExportDefaultSpecifier":
                  return K(Ce, Be, ve);
                case "ImportAttribute":
                  return [ve("key"), ": ", ve("value")];
                case "Import":
                  return "import";
                case "BlockStatement":
                case "StaticBlock":
                case "ClassBody":
                  return le(Ce, Be, ve);
                case "ThrowStatement":
                  return Re(Ce, Be, ve);
                case "ReturnStatement":
                  return ke(Ce, Be, ve);
                case "NewExpression":
                case "ImportExpression":
                case "OptionalCallExpression":
                case "CallExpression":
                  return Ne(Ce, Be, ve);
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  return z(Ce, Be, ve);
                case "ObjectProperty":
                case "Property":
                  return be.method || be.kind === "get" || be.kind === "set" ? we(Ce, Be, ve) : fe(Ce, Be, ve);
                case "ObjectMethod":
                  return we(Ce, Be, ve);
                case "Decorator":
                  return ["@", ve("expression")];
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  return Fe(Ce, Be, ve);
                case "SequenceExpression": {
                  let Ie = Ce.getParentNode(0);
                  if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
                    let Oe = [];
                    return Ce.each((Je, Te) => {
                      Te === 0 ? Oe.push(ve()) : Oe.push(",", p([n, ve()]));
                    }, "expressions"), l(Oe);
                  }
                  return l(a([",", n], Ce.map(ve, "expressions")));
                }
                case "ThisExpression":
                  return "this";
                case "Super":
                  return "super";
                case "Directive":
                  return [ve("value"), Ye];
                case "DirectiveLiteral":
                  return ie(be.extra.raw, Be);
                case "UnaryExpression":
                  return Se.push(be.operator), /[a-z]$/.test(be.operator) && Se.push(" "), E(be.argument) ? Se.push(l(["(", p([i, ve("argument")]), i, ")"])) : Se.push(ve("argument")), Se;
                case "UpdateExpression":
                  return Se.push(ve("argument"), be.operator), be.prefix && Se.reverse(), Se;
                case "ConditionalExpression":
                  return de(Ce, Be, ve);
                case "VariableDeclaration": {
                  let Ie = Ce.map(ve, "declarations"), Oe = Ce.getParentNode(), Je = Oe.type === "ForStatement" || Oe.type === "ForInStatement" || Oe.type === "ForOfStatement", Te = be.declarations.some((Me) => Me.init), je;
                  return Ie.length === 1 && !E(be.declarations[0]) ? je = Ie[0] : Ie.length > 0 && (je = p(Ie[0])), Se = [be.declare ? "declare " : "", be.kind, je ? [" ", je] : "", p(Ie.slice(1).map((Me) => [",", Te && !Je ? u : n, Me]))], Je && Oe.body !== be || Se.push(Ye), l(Se);
                }
                case "WithStatement":
                  return l(["with (", ve("object"), ")", V(be.body, ve("body"))]);
                case "IfStatement": {
                  let Ie = V(be.consequent, ve("consequent")), Oe = l(["if (", l([p([i, ve("test")]), i]), ")", Ie]);
                  if (Se.push(Oe), be.alternate) {
                    let Je = E(be.consequent, N6.Trailing | N6.Line) || $(be), Te = be.consequent.type === "BlockStatement" && !Je;
                    Se.push(Te ? " " : u), E(be, N6.Dangling) && Se.push(t4(Ce, Be, true), Je ? u : " "), Se.push("else", l(V(be.alternate, ve("alternate"), be.alternate.type === "IfStatement")));
                  }
                  return Se;
                }
                case "ForStatement": {
                  let Ie = V(be.body, ve("body")), Oe = t4(Ce, Be, true), Je = Oe ? [Oe, i] : "";
                  return !be.init && !be.test && !be.update ? [Je, l(["for (;;)", Ie])] : [Je, l(["for (", l([p([i, ve("init"), ";", n, ve("test"), ";", n, ve("update")]), i]), ")", Ie])];
                }
                case "WhileStatement":
                  return l(["while (", l([p([i, ve("test")]), i]), ")", V(be.body, ve("body"))]);
                case "ForInStatement":
                  return l(["for (", ve("left"), " in ", ve("right"), ")", V(be.body, ve("body"))]);
                case "ForOfStatement":
                  return l(["for", be.await ? " await" : "", " (", ve("left"), " of ", ve("right"), ")", V(be.body, ve("body"))]);
                case "DoWhileStatement": {
                  let Ie = V(be.body, ve("body"));
                  return Se = [l(["do", Ie])], be.body.type === "BlockStatement" ? Se.push(" ") : Se.push(u), Se.push("while (", l([p([i, ve("test")]), i]), ")", Ye), Se;
                }
                case "DoExpression":
                  return [be.async ? "async " : "", "do ", ve("body")];
                case "BreakStatement":
                  return Se.push("break"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
                case "ContinueStatement":
                  return Se.push("continue"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
                case "LabeledStatement":
                  return be.body.type === "EmptyStatement" ? [ve("label"), ":;"] : [ve("label"), ": ", ve("body")];
                case "TryStatement":
                  return ["try ", ve("block"), be.handler ? [" ", ve("handler")] : "", be.finalizer ? [" finally ", ve("finalizer")] : ""];
                case "CatchClause":
                  if (be.param) {
                    let Ie = E(be.param, (Je) => !v(Je) || Je.leading && s(Be.originalText, d(Je)) || Je.trailing && s(Be.originalText, o(Je), { backwards: true })), Oe = ve("param");
                    return ["catch ", Ie ? ["(", p([i, Oe]), i, ") "] : ["(", Oe, ") "], ve("body")];
                  }
                  return ["catch ", ve("body")];
                case "SwitchStatement":
                  return [l(["switch (", p([i, ve("discriminant")]), i, ")"]), " {", be.cases.length > 0 ? p([u, a(u, Ce.map((Ie, Oe, Je) => {
                    let Te = Ie.getValue();
                    return [ve(), Oe !== Je.length - 1 && P(Te, Be) ? u : ""];
                  }, "cases"))]) : "", u, "}"];
                case "SwitchCase": {
                  be.test ? Se.push("case ", ve("test"), ":") : Se.push("default:"), E(be, N6.Dangling) && Se.push(" ", t4(Ce, Be, true));
                  let Ie = be.consequent.filter((Oe) => Oe.type !== "EmptyStatement");
                  if (Ie.length > 0) {
                    let Oe = pe(Ce, Be, ve);
                    Se.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [" ", Oe] : p([u, Oe]));
                  }
                  return Se;
                }
                case "DebuggerStatement":
                  return ["debugger", Ye];
                case "ClassDeclaration":
                case "ClassExpression":
                  return U3(Ce, Be, ve);
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "MethodDefinition":
                  return Z(Ce, Be, ve);
                case "ClassProperty":
                case "PropertyDefinition":
                case "ClassPrivateProperty":
                case "ClassAccessorProperty":
                case "AccessorProperty":
                  return se(Ce, Be, ve);
                case "TemplateElement":
                  return y(be.value.raw);
                case "TemplateLiteral":
                  return ue(Ce, ve, Be);
                case "TaggedTemplateExpression":
                  return [ve("tag"), ve("typeParameters"), ve("quasi")];
                case "PrivateIdentifier":
                  return ["#", ve("name")];
                case "PrivateName":
                  return ["#", ve("id")];
                case "InterpreterDirective":
                  return Se.push("#!", be.value, u), P(be, Be) && Se.push(u), Se;
                case "TopicReference":
                  return "%";
                case "ArgumentPlaceholder":
                  return "?";
                case "ModuleExpression": {
                  Se.push("module {");
                  let Ie = ve("body");
                  return Ie && Se.push(p([u, Ie]), u), Se.push("}"), Se;
                }
                default:
                  throw new Error("unknown type: " + JSON.stringify(be.type));
              }
            }
            function ye(Ce) {
              return Ce.type && !v(Ce) && !I(Ce) && Ce.type !== "EmptyStatement" && Ce.type !== "TemplateElement" && Ce.type !== "Import" && Ce.type !== "TSEmptyBodyFunctionExpression";
            }
            r.exports = { preprocess: _, print: G, embed: h2, insertPragma: c, massageAstNode: g, hasPrettierIgnore(Ce) {
              return D(Ce) || M(Ce);
            }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: ye, printComment: Ee, isBlockComment: v, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
          } }), Ed = te({ "src/language-js/printer-estree-json.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t4, indent: s, join: a } } = qe(), n = Fo();
            function u(y, h2, g) {
              let c = y.getValue();
              switch (c.type) {
                case "JsonRoot":
                  return [g("node"), t4];
                case "ArrayExpression": {
                  if (c.elements.length === 0)
                    return "[]";
                  let f = y.map(() => y.getValue() === null ? "null" : g(), "elements");
                  return ["[", s([t4, a([",", t4], f)]), t4, "]"];
                }
                case "ObjectExpression":
                  return c.properties.length === 0 ? "{}" : ["{", s([t4, a([",", t4], y.map(g, "properties"))]), t4, "}"];
                case "ObjectProperty":
                  return [g("key"), ": ", g("value")];
                case "UnaryExpression":
                  return [c.operator === "+" ? "" : c.operator, g("argument")];
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return c.value ? "true" : "false";
                case "StringLiteral":
                  return JSON.stringify(c.value);
                case "NumericLiteral":
                  return i(y) ? JSON.stringify(String(c.value)) : JSON.stringify(c.value);
                case "Identifier":
                  return i(y) ? JSON.stringify(c.name) : c.name;
                case "TemplateLiteral":
                  return g(["quasis", 0]);
                case "TemplateElement":
                  return JSON.stringify(c.value.cooked);
                default:
                  throw new Error("unknown type: " + JSON.stringify(c.type));
              }
            }
            function i(y) {
              return y.getName() === "key" && y.getParentNode().type === "ObjectProperty";
            }
            var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
            function p(y, h2) {
              let { type: g } = y;
              if (g === "ObjectProperty") {
                let { key: c } = y;
                c.type === "Identifier" ? h2.key = { type: "StringLiteral", value: c.name } : c.type === "NumericLiteral" && (h2.key = { type: "StringLiteral", value: String(c.value) });
                return;
              }
              if (g === "UnaryExpression" && y.operator === "+")
                return h2.argument;
              if (g === "ArrayExpression") {
                for (let [c, f] of y.elements.entries())
                  f === null && h2.elements.splice(c, 0, { type: "NullLiteral" });
                return;
              }
              if (g === "TemplateLiteral")
                return { type: "StringLiteral", value: y.quasis[0].value.cooked };
            }
            p.ignoredProperties = l, r.exports = { preprocess: n, print: u, massageAstNode: p };
          } }), Mt = te({ "src/common/common-options.js"(e, r) {
            "use strict";
            ne();
            var t4 = "Common";
            r.exports = { bracketSpacing: { since: "0.0.0", category: t4, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t4, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t4, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t4, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t4, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
          } }), Fd = te({ "src/language-js/options.js"(e, r) {
            "use strict";
            ne();
            var t4 = Mt(), s = "JavaScript";
            r.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t4.bracketSameLine, bracketSpacing: t4.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t4.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t4.singleAttributePerLine };
          } }), Ad = te({ "src/language-js/parse/parsers.js"() {
            ne();
          } }), Ln = te({ "node_modules/linguist-languages/data/JavaScript.json"(e, r) {
            r.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
          } }), Sd = te({ "node_modules/linguist-languages/data/TypeScript.json"(e, r) {
            r.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
          } }), xd = te({ "node_modules/linguist-languages/data/TSX.json"(e, r) {
            r.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
          } }), wa = te({ "node_modules/linguist-languages/data/JSON.json"(e, r) {
            r.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
          } }), bd = te({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, r) {
            r.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
          } }), Td = te({ "node_modules/linguist-languages/data/JSON5.json"(e, r) {
            r.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
          } }), Bd = te({ "src/language-js/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = _t(), s = Cd(), a = Ed(), n = Fd(), u = Ad(), i = [t4(Ln(), (p) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p.interpreters, "zx"], extensions: [...p.extensions.filter((y) => y !== ".jsx"), ".wxs"] })), t4(Ln(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t4(Ln(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t4(Sd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t4(xd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t4(wa(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t4(wa(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p.extensions.filter((y) => y !== ".jsonl") })), t4(bd(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p.filenames, ".eslintrc", ".swcrc"] })), t4(Td(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a };
            r.exports = { languages: i, options: n, printers: l, parsers: u };
          } }), Nd = te({ "src/language-css/clean.js"(e, r) {
            "use strict";
            ne();
            var { isFrontMatterNode: t4 } = Ue(), s = lt(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
            function n(i, l, p) {
              if (t4(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && p.type === "css-root" && p.nodes.length > 0 && ((p.nodes[0] === i || t4(p.nodes[0]) && p.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || p.type === "css-root" && s(p.nodes) === i))
                return null;
              if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y, h2, g) => {
                let c = Number(h2);
                return Number.isNaN(c) ? y : c + g.toLowerCase();
              })), i.type === "selector-tag") {
                let y = i.value.toLowerCase();
                ["from", "to"].includes(y) && (l.value = y);
              }
              if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
                let y = i.groups.findIndex((h2) => h2.type === "value-number" && h2.unit === "...");
                y !== -1 && (l.groups[y].unit = "", l.groups.splice(y + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
              }
              if (i.type === "value-comma_group" && i.groups.some((y) => y.type === "value-atword" && y.value.endsWith("[") || y.type === "value-word" && y.value.startsWith("]")))
                return { type: "value-atword", value: i.groups.map((y) => y.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
            }
            n.ignoredProperties = a;
            function u(i) {
              return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
            }
            r.exports = n;
          } }), su = te({ "src/utils/front-matter/print.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t4, markAsRoot: s } } = qe();
            function a(n, u) {
              if (n.lang === "yaml") {
                let i = n.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
                return s([n.startDelimiter, t4, l, l ? t4 : "", n.endDelimiter]);
              }
            }
            r.exports = a;
          } }), wd = te({ "src/language-css/embed.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t4 } } = qe(), s = su();
            function a(n, u, i) {
              let l = n.getValue();
              if (l.type === "front-matter") {
                let p = s(l, i);
                return p ? [p, t4] : "";
              }
            }
            r.exports = a;
          } }), _o = te({ "src/utils/front-matter/parse.js"(e, r) {
            "use strict";
            ne();
            var t4 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
            function s(a) {
              let n = a.match(t4);
              if (!n)
                return { content: a };
              let { startDelimiter: u, language: i, value: l = "", endDelimiter: p } = n.groups, y = i.trim() || "yaml";
              if (u === "+++" && (y = "toml"), y !== "yaml" && u !== p)
                return { content: a };
              let [h2] = n;
              return { frontMatter: { type: "front-matter", lang: y, value: l, startDelimiter: u, endDelimiter: p, raw: h2.replace(/\n$/, "") }, content: h2.replace(/[^\n]/g, " ") + a.slice(h2.length) };
            }
            r.exports = s;
          } }), _d = te({ "src/language-css/pragma.js"(e, r) {
            "use strict";
            ne();
            var t4 = Co(), s = _o();
            function a(u) {
              return t4.hasPragma(s(u).content);
            }
            function n(u) {
              let { frontMatter: i, content: l } = s(u);
              return (i ? i.raw + `

` : "") + t4.insertPragma(l);
            }
            r.exports = { hasPragma: a, insertPragma: n };
          } }), Pd = te({ "src/language-css/utils/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
            function s(z, U3) {
              let Z = Array.isArray(U3) ? U3 : [U3], se = -1, fe;
              for (; fe = z.getParentNode(++se); )
                if (Z.includes(fe.type))
                  return se;
              return -1;
            }
            function a(z, U3) {
              let Z = s(z, U3);
              return Z === -1 ? null : z.getParentNode(Z);
            }
            function n(z) {
              var U3;
              let Z = a(z, "css-decl");
              return Z == null || (U3 = Z.prop) === null || U3 === void 0 ? void 0 : U3.toLowerCase();
            }
            var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
            function i(z) {
              return u.has(z.toLowerCase());
            }
            function l(z, U3) {
              let Z = a(z, "css-atrule");
              return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U3.toLowerCase());
            }
            function p(z) {
              return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
            }
            function y(z, U3) {
              var Z;
              let se = a(z, "value-func");
              return (se == null || (Z = se.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U3;
            }
            function h2(z) {
              var U3;
              let Z = a(z, "css-rule"), se = Z == null || (U3 = Z.raws) === null || U3 === void 0 ? void 0 : U3.selector;
              return se && (se.startsWith(":import") || se.startsWith(":export"));
            }
            function g(z, U3) {
              let Z = Array.isArray(U3) ? U3 : [U3], se = a(z, "css-atrule");
              return se && Z.includes(se.name.toLowerCase());
            }
            function c(z) {
              let U3 = z.getValue(), Z = a(z, "css-atrule");
              return (Z == null ? void 0 : Z.name) === "import" && U3.groups[0].value === "url" && U3.groups.length === 2;
            }
            function f(z) {
              return z.type === "value-func" && z.value.toLowerCase() === "url";
            }
            function F4(z, U3) {
              var Z;
              let se = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
              return se && se.indexOf(U3) === se.length - 1;
            }
            function _(z) {
              let { selector: U3 } = z;
              return U3 ? typeof U3 == "string" && /^@.+:.*$/.test(U3) || U3.value && /^@.+:.*$/.test(U3.value) : false;
            }
            function w(z) {
              return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
            }
            function E(z) {
              return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
            }
            function N6(z) {
              return z.type === "value-word" && z.value === "in";
            }
            function x(z) {
              return z.type === "value-operator" && z.value === "*";
            }
            function I(z) {
              return z.type === "value-operator" && z.value === "/";
            }
            function P(z) {
              return z.type === "value-operator" && z.value === "+";
            }
            function $(z) {
              return z.type === "value-operator" && z.value === "-";
            }
            function D(z) {
              return z.type === "value-operator" && z.value === "%";
            }
            function T(z) {
              return x(z) || I(z) || P(z) || $(z) || D(z);
            }
            function m(z) {
              return z.type === "value-word" && ["==", "!="].includes(z.value);
            }
            function C(z) {
              return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
            }
            function o(z) {
              return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
            }
            function d(z) {
              var U3;
              return ((U3 = z.raws) === null || U3 === void 0 ? void 0 : U3.params) && /^\(\s*\)$/.test(z.raws.params);
            }
            function v(z) {
              return z.name.startsWith("prettier-placeholder");
            }
            function S(z) {
              return z.prop.startsWith("@prettier-placeholder");
            }
            function b(z, U3) {
              return z.value === "$$" && z.type === "value-func" && (U3 == null ? void 0 : U3.type) === "value-word" && !U3.raws.before;
            }
            function B(z) {
              var U3, Z;
              return ((U3 = z.value) === null || U3 === void 0 ? void 0 : U3.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
            }
            function k(z) {
              var U3, Z, se;
              return ((U3 = z.value) === null || U3 === void 0 || (Z = U3.group) === null || Z === void 0 || (se = Z.group) === null || se === void 0 ? void 0 : se.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
            }
            function M(z) {
              var U3;
              return ((U3 = z.raws) === null || U3 === void 0 ? void 0 : U3.before) === "";
            }
            function R4(z) {
              var U3, Z;
              return z.type === "value-comma_group" && ((U3 = z.groups) === null || U3 === void 0 || (Z = U3[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
            }
            function q(z) {
              var U3;
              return z.type === "value-paren_group" && ((U3 = z.groups) === null || U3 === void 0 ? void 0 : U3[0]) && R4(z.groups[0]);
            }
            function J(z) {
              var U3;
              let Z = z.getValue();
              if (Z.groups.length === 0)
                return false;
              let se = z.getParentNode(1);
              if (!q(Z) && !(se && q(se)))
                return false;
              let fe = a(z, "css-decl");
              return !!(fe != null && (U3 = fe.prop) !== null && U3 !== void 0 && U3.startsWith("$") || q(se) || se.type === "value-func");
            }
            function L(z) {
              return z.type === "value-comment" && z.inline;
            }
            function Q(z) {
              return z.type === "value-word" && z.value === "#";
            }
            function V(z) {
              return z.type === "value-word" && z.value === "{";
            }
            function j(z) {
              return z.type === "value-word" && z.value === "}";
            }
            function Y(z) {
              return ["value-word", "value-atword"].includes(z.type);
            }
            function ie(z) {
              return (z == null ? void 0 : z.type) === "value-colon";
            }
            function ee(z, U3) {
              if (!R4(U3))
                return false;
              let { groups: Z } = U3, se = Z.indexOf(z);
              return se === -1 ? false : ie(Z[se + 1]);
            }
            function ce(z) {
              return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
            }
            function W(z) {
              return z.type !== "value-func" ? false : t4.has(z.value.toLowerCase());
            }
            function K(z) {
              return /\/\//.test(z.split(/[\n\r]/).pop());
            }
            function de(z) {
              return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
            }
            function ue(z, U3) {
              var Z, se;
              if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se = z.close) === null || se === void 0 ? void 0 : se.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group"))
                return false;
              if (U3.type === "value-comma_group") {
                let fe = U3.groups.indexOf(z) - 1, ge = U3.groups[fe];
                if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with")
                  return true;
              }
              return false;
            }
            function Fe(z) {
              var U3, Z;
              return z.type === "value-paren_group" && ((U3 = z.open) === null || U3 === void 0 ? void 0 : U3.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
            }
            r.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: n, maybeToLowerCase: p, insideValueFunctionNode: y, insideICSSRuleNode: h2, insideAtRuleNode: g, insideURLFunctionInImportAtRuleNode: c, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: F4, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C, isEqualityOperatorNode: m, isMultiplicationNode: x, isDivisionNode: I, isAdditionNode: P, isSubtractionNode: $, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N6, isForKeywordNode: w, isURLFunctionNode: f, isIfElseKeywordNode: E, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M, isDetachedRulesetCallNode: d, isTemplatePlaceholderNode: v, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R4, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: ee, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Q, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j, isWordNode: Y, isColonNode: ie, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K, isAtWordPlaceholderNode: de, isConfigurationNode: ue, isParenGroupNode: Fe };
          } }), Id = te({ "src/utils/line-column-to-index.js"(e, r) {
            "use strict";
            ne(), r.exports = function(t4, s) {
              let a = 0;
              for (let n = 0; n < t4.line - 1; ++n)
                a = s.indexOf(`
`, a) + 1;
              return a + t4.column;
            };
          } }), kd = te({ "src/language-css/loc.js"(e, r) {
            "use strict";
            ne();
            var { skipEverythingButNewLine: t4 } = Pr(), s = lt(), a = Id();
            function n(c, f) {
              return typeof c.sourceIndex == "number" ? c.sourceIndex : c.source ? a(c.source.start, f) - 1 : null;
            }
            function u(c, f) {
              if (c.type === "css-comment" && c.inline)
                return t4(f, c.source.startOffset);
              let F4 = c.nodes && s(c.nodes);
              return F4 && c.source && !c.source.end && (c = F4), c.source && c.source.end ? a(c.source.end, f) : null;
            }
            function i(c, f) {
              c.source && (c.source.startOffset = n(c, f), c.source.endOffset = u(c, f));
              for (let F4 in c) {
                let _ = c[F4];
                F4 === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p(c), _.text || _.value) : i(_, f));
              }
            }
            function l(c, f, F4) {
              c.source && (c.source.startOffset = n(c, F4) + f, c.source.endOffset = u(c, F4) + f);
              for (let _ in c) {
                let w = c[_];
                _ === "source" || !w || typeof w != "object" || l(w, f, F4);
              }
            }
            function p(c) {
              let f = c.source.startOffset;
              return typeof c.prop == "string" && (f += c.prop.length), c.type === "css-atrule" && typeof c.name == "string" && (f += 1 + c.name.length + c.raws.afterName.match(/^\s*:?\s*/)[0].length), c.type !== "css-atrule" && c.raws && typeof c.raws.between == "string" && (f += c.raws.between.length), f;
            }
            function y(c) {
              let f = "initial", F4 = "initial", _, w = false, E = [];
              for (let N6 = 0; N6 < c.length; N6++) {
                let x = c[N6];
                switch (f) {
                  case "initial":
                    if (x === "'") {
                      f = "single-quotes";
                      continue;
                    }
                    if (x === '"') {
                      f = "double-quotes";
                      continue;
                    }
                    if ((x === "u" || x === "U") && c.slice(N6, N6 + 4).toLowerCase() === "url(") {
                      f = "url", N6 += 3;
                      continue;
                    }
                    if (x === "*" && c[N6 - 1] === "/") {
                      f = "comment-block";
                      continue;
                    }
                    if (x === "/" && c[N6 - 1] === "/") {
                      f = "comment-inline", _ = N6 - 1;
                      continue;
                    }
                    continue;
                  case "single-quotes":
                    if (x === "'" && c[N6 - 1] !== "\\" && (f = F4, F4 = "initial"), x === `
` || x === "\r")
                      return c;
                    continue;
                  case "double-quotes":
                    if (x === '"' && c[N6 - 1] !== "\\" && (f = F4, F4 = "initial"), x === `
` || x === "\r")
                      return c;
                    continue;
                  case "url":
                    if (x === ")" && (f = "initial"), x === `
` || x === "\r")
                      return c;
                    if (x === "'") {
                      f = "single-quotes", F4 = "url";
                      continue;
                    }
                    if (x === '"') {
                      f = "double-quotes", F4 = "url";
                      continue;
                    }
                    continue;
                  case "comment-block":
                    x === "/" && c[N6 - 1] === "*" && (f = "initial");
                    continue;
                  case "comment-inline":
                    (x === '"' || x === "'" || x === "*") && (w = true), (x === `
` || x === "\r") && (w && E.push([_, N6]), f = "initial", w = false);
                    continue;
                }
              }
              for (let [N6, x] of E)
                c = c.slice(0, N6) + c.slice(N6, x).replace(/["'*]/g, " ") + c.slice(x);
              return c;
            }
            function h2(c) {
              return c.source.startOffset;
            }
            function g(c) {
              return c.source.endOffset;
            }
            r.exports = { locStart: h2, locEnd: g, calculateLoc: i, replaceQuotesInInlineComments: y };
          } }), Ld = te({ "src/language-css/utils/is-less-parser.js"(e, r) {
            "use strict";
            ne();
            function t4(s) {
              return s.parser === "css" || s.parser === "less";
            }
            r.exports = t4;
          } }), Od = te({ "src/language-css/utils/is-scss.js"(e, r) {
            "use strict";
            ne();
            function t4(s, a) {
              return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
            }
            r.exports = t4;
          } }), jd = te({ "src/language-css/utils/css-units.evaluate.js"(e, r) {
            r.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
          } }), qd = te({ "src/language-css/utils/print-unit.js"(e, r) {
            "use strict";
            ne();
            var t4 = jd();
            function s(a) {
              let n = a.toLowerCase();
              return Object.prototype.hasOwnProperty.call(t4, n) ? t4[n] : a;
            }
            r.exports = s;
          } }), Md = te({ "src/language-css/printer-postcss.js"(e, r) {
            "use strict";
            ne();
            var t4 = lt(), { printNumber: s, printString: a, hasNewline: n, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ue(), { builders: { join: p, line: y, hardline: h2, softline: g, group: c, fill: f, indent: F4, dedent: _, ifBreak: w, breakParent: E }, utils: { removeLines: N6, getDocParts: x } } = qe(), I = Nd(), P = wd(), { insertPragma: $ } = _d(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m, insideValueFunctionNode: C, insideICSSRuleNode: o, insideAtRuleNode: d, insideURLFunctionInImportAtRuleNode: v, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: R4, isEqualityOperatorNode: q, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Q, isSubtractionNode: V, isMathOperatorNode: j, isEachKeywordNode: Y, isForKeywordNode: ie, isURLFunctionNode: ee, isIfElseKeywordNode: ce, hasComposesNode: W, hasParensAroundNode: K, hasEmptyRawBefore: de, isKeyValuePairNode: ue, isKeyInValuePairNode: Fe, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U3, isTemplatePropNode: Z, isPostcssSimpleVarNode: se, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: he, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: ke, isWordNode: Re, isColonNode: Ne, isMediaAndSupportsKeywords: Pe, isColorAdjusterFuncNode: oe, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe, isConfigurationNode: X, isParenGroupNode: le } = Pd(), { locStart: Ae, locEnd: Ee } = kd(), De = Ld(), A = Od(), G = qd();
            function re(Te) {
              return Te.trailingComma === "es5" || Te.trailingComma === "all";
            }
            function ye(Te, je, Me) {
              let ae = Te.getValue();
              if (!ae)
                return "";
              if (typeof ae == "string")
                return ae;
              switch (ae.type) {
                case "front-matter":
                  return [ae.raw, h2];
                case "css-root": {
                  let Ve = Ce(Te, je, Me), We = ae.raws.after.trim();
                  return We.startsWith(";") && (We = We.slice(1).trim()), [Ve, We ? ` ${We}` : "", x(Ve).length > 0 ? h2 : ""];
                }
                case "css-comment": {
                  let Ve = ae.inline || ae.raws.inline, We = je.originalText.slice(Ae(ae), Ee(ae));
                  return Ve ? We.trimEnd() : We;
                }
                case "css-rule":
                  return [Me("selector"), ae.important ? " !important" : "", ae.nodes ? [ae.selector && ae.selector.type === "selector-unknown" && H(ae.selector.value) ? y : " ", "{", ae.nodes.length > 0 ? F4([h2, Ce(Te, je, Me)]) : "", h2, "}", M(ae) ? ";" : ""] : ";"];
                case "css-decl": {
                  let Ve = Te.getParentNode(), { between: We } = ae.raws, Xe = We.trim(), st = Xe === ":", O = W(ae) ? N6(Me("value")) : Me("value");
                  return !st && H(Xe) && (O = F4([h2, _(O)])), [ae.raws.before.replace(/[\s;]/g, ""), Ve.type === "css-atrule" && Ve.variable || o(Te) ? ae.prop : m(ae.prop), Xe.startsWith("//") ? " " : "", Xe, ae.extend ? "" : " ", De(je) && ae.extend && ae.selector ? ["extend(", Me("selector"), ")"] : "", O, ae.raws.important ? ae.raws.important.replace(/\s*!\s*important/i, " !important") : ae.important ? " !important" : "", ae.raws.scssDefault ? ae.raws.scssDefault.replace(/\s*!default/i, " !default") : ae.scssDefault ? " !default" : "", ae.raws.scssGlobal ? ae.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae.scssGlobal ? " !global" : "", ae.nodes ? [" {", F4([g, Ce(Te, je, Me)]), g, "}"] : Z(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";" ? "" : je.__isHTMLStyleAttribute && B(Te, ae) ? w(";") : ";"];
                }
                case "css-atrule": {
                  let Ve = Te.getParentNode(), We = U3(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";";
                  if (De(je)) {
                    if (ae.mixin)
                      return [Me("selector"), ae.important ? " !important" : "", We ? "" : ";"];
                    if (ae.function)
                      return [ae.name, Me("params"), We ? "" : ";"];
                    if (ae.variable)
                      return ["@", ae.name, ": ", ae.value ? Me("value") : "", ae.raws.between.trim() ? ae.raws.between.trim() + " " : "", ae.nodes ? ["{", F4([ae.nodes.length > 0 ? g : "", Ce(Te, je, Me)]), g, "}"] : "", We ? "" : ";"];
                  }
                  return ["@", z(ae) || ae.name.endsWith(":") ? ae.name : m(ae.name), ae.params ? [z(ae) ? "" : U3(ae) ? ae.raws.afterName === "" ? "" : ae.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae.raws.afterName) ? [h2, h2] : /^\s*\n/.test(ae.raws.afterName) ? h2 : " " : " ", Me("params")] : "", ae.selector ? F4([" ", Me("selector")]) : "", ae.value ? c([" ", Me("value"), k(ae) ? K(ae) ? " " : y : ""]) : ae.name === "else" ? " " : "", ae.nodes ? [k(ae) ? "" : ae.selector && !ae.selector.nodes && typeof ae.selector.value == "string" && H(ae.selector.value) || !ae.selector && typeof ae.params == "string" && H(ae.params) ? y : " ", "{", F4([ae.nodes.length > 0 ? g : "", Ce(Te, je, Me)]), g, "}"] : We ? "" : ";"];
                }
                case "media-query-list": {
                  let Ve = [];
                  return Te.each((We) => {
                    let Xe = We.getValue();
                    Xe.type === "media-query" && Xe.value === "" || Ve.push(Me());
                  }, "nodes"), c(F4(p(y, Ve)));
                }
                case "media-query":
                  return [p(" ", Te.map(Me, "nodes")), B(Te, ae) ? "" : ","];
                case "media-type":
                  return Oe(Se(ae.value, je));
                case "media-feature-expression":
                  return ae.nodes ? ["(", ...Te.map(Me, "nodes"), ")"] : ae.value;
                case "media-feature":
                  return m(Se(ae.value.replace(/ +/g, " "), je));
                case "media-colon":
                  return [ae.value, " "];
                case "media-value":
                  return Oe(Se(ae.value, je));
                case "media-keyword":
                  return Se(ae.value, je);
                case "media-url":
                  return Se(ae.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je);
                case "media-unknown":
                  return ae.value;
                case "selector-root":
                  return c([d(Te, "custom-selector") ? [D(Te, "css-atrule").customSelector, y] : "", p([",", d(Te, ["extend", "custom-selector", "nest"]) ? y : h2], Te.map(Me, "nodes"))]);
                case "selector-selector":
                  return c(F4(Te.map(Me, "nodes")));
                case "selector-comment":
                  return ae.value;
                case "selector-string":
                  return Se(ae.value, je);
                case "selector-tag": {
                  let Ve = Te.getParentNode(), We = Ve && Ve.nodes.indexOf(ae), Xe = We && Ve.nodes[We - 1];
                  return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ae.value : Oe(S(Te, ae.value) ? ae.value.toLowerCase() : ae.value)];
                }
                case "selector-id":
                  return ["#", ae.value];
                case "selector-class":
                  return [".", Oe(Se(ae.value, je))];
                case "selector-attribute": {
                  var nt;
                  return ["[", ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.attribute.trim(), (nt = ae.operator) !== null && nt !== void 0 ? nt : "", ae.value ? Ie(Se(ae.value.trim(), je), je) : "", ae.insensitive ? " i" : "", "]"];
                }
                case "selector-combinator": {
                  if (ae.value === "+" || ae.value === ">" || ae.value === "~" || ae.value === ">>>") {
                    let Xe = Te.getParentNode();
                    return [Xe.type === "selector-selector" && Xe.nodes[0] === ae ? "" : y, ae.value, B(Te, ae) ? "" : " "];
                  }
                  let Ve = ae.value.trim().startsWith("(") ? y : "", We = Oe(Se(ae.value.trim(), je)) || y;
                  return [Ve, We];
                }
                case "selector-universal":
                  return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.value];
                case "selector-pseudo":
                  return [m(ae.value), l(ae.nodes) ? c(["(", F4([g, p([",", y], Te.map(Me, "nodes"))]), g, ")"]) : ""];
                case "selector-nesting":
                  return ae.value;
                case "selector-unknown": {
                  let Ve = D(Te, "css-rule");
                  if (Ve && Ve.isSCSSNesterProperty)
                    return Oe(Se(m(ae.value), je));
                  let We = Te.getParentNode();
                  if (We.raws && We.raws.selector) {
                    let st = Ae(We), O = st + We.raws.selector.length;
                    return je.originalText.slice(st, O).trim();
                  }
                  let Xe = Te.getParentNode(1);
                  if (We.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
                    let st = Ee(We.open) + 1, O = Ae(We.close), me = je.originalText.slice(st, O).trim();
                    return H(me) ? [E, me] : me;
                  }
                  return ae.value;
                }
                case "value-value":
                case "value-root":
                  return Me("group");
                case "value-comment":
                  return je.originalText.slice(Ae(ae), Ee(ae));
                case "value-comma_group": {
                  let Ve = Te.getParentNode(), We = Te.getParentNode(1), Xe = T(Te), st = Xe && Ve.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), O = D(Te, "css-atrule"), me = O && k(O), _e = ae.groups.some((at) => ge(at)), He = Te.map(Me, "groups"), Ge = [], it = C(Te, "url"), Qe = false, rt = false;
                  for (let at = 0; at < ae.groups.length; ++at) {
                    var tt;
                    Ge.push(He[at]);
                    let Ze = ae.groups[at - 1], Le = ae.groups[at], $e = ae.groups[at + 1], sr = ae.groups[at + 2];
                    if (it) {
                      ($e && Q($e) || Q(Le)) && Ge.push(" ");
                      continue;
                    }
                    if (d(Te, "forward") && Le.type === "value-word" && Le.value && Ze !== void 0 && Ze.type === "value-word" && Ze.value === "as" && $e.type === "value-operator" && $e.value === "*" || !$e || Le.type === "value-word" && Le.value.endsWith("-") && pe($e))
                      continue;
                    if (Le.type === "value-string" && Le.quoted) {
                      let $r = Le.value.lastIndexOf("#{"), Vr = Le.value.lastIndexOf("}");
                      $r !== -1 && Vr !== -1 ? Qe = $r > Vr : $r !== -1 ? Qe = true : Vr !== -1 && (Qe = false);
                    }
                    if (Qe || Ne(Le) || Ne($e) || Le.type === "value-atword" && (Le.value === "" || Le.value.endsWith("[")) || $e.type === "value-word" && $e.value.startsWith("]") || Le.value === "~" || Le.value && Le.value.includes("\\") && $e && $e.type !== "value-comment" || Ze && Ze.value && Ze.value.indexOf("\\") === Ze.value.length - 1 && Le.type === "value-operator" && Le.value === "/" || Le.value === "\\" || se(Le, $e) || he(Le) || we(Le) || ke($e) || we($e) && de($e) || ke(Le) && de($e) || Le.value === "--" && he($e))
                      continue;
                    let Rr = j(Le), ou = j($e);
                    if ((Rr && he($e) || ou && ke(Le)) && de($e) || !Ze && L(Le) || C(Te, "calc") && (Q(Le) || Q($e) || V(Le) || V($e)) && de($e))
                      continue;
                    let qo = (Q(Le) || V(Le)) && at === 0 && ($e.type === "value-number" || $e.isHex) && We && oe(We) && !de($e), lu = sr && sr.type === "value-func" || sr && Re(sr) || Le.type === "value-func" || Re(Le), cu = $e.type === "value-func" || Re($e) || Ze && Ze.type === "value-func" || Ze && Re(Ze);
                    if (!(!(J($e) || J(Le)) && !C(Te, "calc") && !qo && (L($e) && !lu || L(Le) && !cu || Q($e) && !lu || Q(Le) && !cu || V($e) || V(Le)) && (de($e) || Rr && (!Ze || Ze && j(Ze)))) && !((je.parser === "scss" || je.parser === "less") && Rr && Le.value === "-" && le($e) && Ee(Le) === Ae($e.open) && $e.open.value === "(")) {
                      if (ge(Le)) {
                        if (Ve.type === "value-paren_group") {
                          Ge.push(_(h2));
                          continue;
                        }
                        Ge.push(h2);
                        continue;
                      }
                      if (me && (q($e) || R4($e) || ce($e) || Y(Le) || ie(Le))) {
                        Ge.push(" ");
                        continue;
                      }
                      if (O && O.name.toLowerCase() === "namespace") {
                        Ge.push(" ");
                        continue;
                      }
                      if (st) {
                        Le.source && $e.source && Le.source.start.line !== $e.source.start.line ? (Ge.push(h2), rt = true) : Ge.push(" ");
                        continue;
                      }
                      if (ou) {
                        Ge.push(" ");
                        continue;
                      }
                      if (!($e && $e.value === "...") && !(pe(Le) && pe($e) && Ee(Le) === Ae($e))) {
                        if (pe(Le) && le($e) && Ee(Le) === Ae($e.open)) {
                          Ge.push(g);
                          continue;
                        }
                        if (Le.value === "with" && le($e)) {
                          Ge.push(" ");
                          continue;
                        }
                        (tt = Le.value) !== null && tt !== void 0 && tt.endsWith("#") && $e.value === "{" && le($e.group) || Ge.push(y);
                      }
                    }
                  }
                  return _e && Ge.push(E), rt && Ge.unshift(h2), me ? c(F4(Ge)) : v(Te) ? c(f(Ge)) : c(F4(f(Ge)));
                }
                case "value-paren_group": {
                  let Ve = Te.getParentNode();
                  if (Ve && ee(Ve) && (ae.groups.length === 1 || ae.groups.length > 0 && ae.groups[0].type === "value-comma_group" && ae.groups[0].groups.length > 0 && ae.groups[0].groups[0].type === "value-word" && ae.groups[0].groups[0].value.startsWith("data:")))
                    return [ae.open ? Me("open") : "", p(",", Te.map(Me, "groups")), ae.close ? Me("close") : ""];
                  if (!ae.open) {
                    let it = Te.map(Me, "groups"), Qe = [];
                    for (let rt = 0; rt < it.length; rt++)
                      rt !== 0 && Qe.push([",", y]), Qe.push(it[rt]);
                    return c(F4(f(Qe)));
                  }
                  let We = fe(Te), Xe = t4(ae.groups), st = Xe && Xe.type === "value-comment", O = Fe(ae, Ve), me = X(ae, Ve), _e = me || We && !O, He = me || O, Ge = c([ae.open ? Me("open") : "", F4([g, p([y], Te.map((it, Qe) => {
                    let rt = it.getValue(), at = Qe === ae.groups.length - 1, Ze = [Me(), at ? "" : ","];
                    if (ue(rt) && rt.type === "value-comma_group" && rt.groups && rt.groups[0].type !== "value-paren_group" && rt.groups[2] && rt.groups[2].type === "value-paren_group") {
                      let Le = x(Ze[0].contents.contents);
                      Le[1] = c(Le[1]), Ze = [c(_(Ze))];
                    }
                    if (!at && rt.type === "value-comma_group" && l(rt.groups)) {
                      let Le = t4(rt.groups);
                      !Le.source && Le.close && (Le = Le.close), Le.source && i(je.originalText, Le, Ee) && Ze.push(h2);
                    }
                    return Ze;
                  }, "groups"))]), w(!st && A(je.parser, je.originalText) && We && re(je) ? "," : ""), g, ae.close ? Me("close") : ""], { shouldBreak: _e });
                  return He ? _(Ge) : Ge;
                }
                case "value-func":
                  return [ae.value, d(Te, "supports") && Pe(ae) ? " " : "", Me("group")];
                case "value-paren":
                  return ae.value;
                case "value-number":
                  return [Je(ae.value), G(ae.unit)];
                case "value-operator":
                  return ae.value;
                case "value-word":
                  return ae.isColor && ae.isHex || b(ae.value) ? ae.value.toLowerCase() : ae.value;
                case "value-colon": {
                  let Ve = Te.getParentNode(), We = Ve && Ve.groups.indexOf(ae), Xe = We && Ve.groups[We - 1];
                  return [ae.value, Xe && typeof Xe.value == "string" && t4(Xe.value) === "\\" || C(Te, "url") ? "" : y];
                }
                case "value-comma":
                  return [ae.value, " "];
                case "value-string":
                  return a(ae.raws.quote + ae.value + ae.raws.quote, je);
                case "value-atword":
                  return ["@", ae.value];
                case "value-unicode-range":
                  return ae.value;
                case "value-unknown":
                  return ae.value;
                default:
                  throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`);
              }
            }
            function Ce(Te, je, Me) {
              let ae = [];
              return Te.each((nt, tt, Ve) => {
                let We = Ve[tt - 1];
                if (We && We.type === "css-comment" && We.text.trim() === "prettier-ignore") {
                  let Xe = nt.getValue();
                  ae.push(je.originalText.slice(Ae(Xe), Ee(Xe)));
                } else
                  ae.push(Me());
                tt !== Ve.length - 1 && (Ve[tt + 1].type === "css-comment" && !n(je.originalText, Ae(Ve[tt + 1]), { backwards: true }) && !u(Ve[tt]) || Ve[tt + 1].type === "css-atrule" && Ve[tt + 1].name === "else" && Ve[tt].type !== "css-comment" ? ae.push(" ") : (ae.push(je.__isHTMLStyleAttribute ? y : h2), i(je.originalText, nt.getValue(), Ee) && !u(Ve[tt]) && ae.push(h2)));
              }, "nodes"), ae;
            }
            var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, be = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye = new RegExp(Be.source + `|(${be.source})?(${ve.source})(${ze.source})?`, "g");
            function Se(Te, je) {
              return Te.replace(Be, (Me) => a(Me, je));
            }
            function Ie(Te, je) {
              let Me = je.singleQuote ? "'" : '"';
              return Te.includes('"') || Te.includes("'") ? Te : Me + Te + Me;
            }
            function Oe(Te) {
              return Te.replace(Ye, (je, Me, ae, nt, tt) => !ae && nt ? Je(nt) + m(tt || "") : je);
            }
            function Je(Te) {
              return s(Te).replace(/\.0(?=$|e)/, "");
            }
            r.exports = { print: ye, embed: P, insertPragma: $, massageAstNode: I };
          } }), Rd = te({ "src/language-css/options.js"(e, r) {
            "use strict";
            ne();
            var t4 = Mt();
            r.exports = { singleQuote: t4.singleQuote };
          } }), $d = te({ "src/language-css/parsers.js"() {
            ne();
          } }), Vd = te({ "node_modules/linguist-languages/data/CSS.json"(e, r) {
            r.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
          } }), Wd = te({ "node_modules/linguist-languages/data/PostCSS.json"(e, r) {
            r.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
          } }), Hd = te({ "node_modules/linguist-languages/data/Less.json"(e, r) {
            r.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
          } }), Gd = te({ "node_modules/linguist-languages/data/SCSS.json"(e, r) {
            r.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
          } }), Ud = te({ "src/language-css/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = _t(), s = Md(), a = Rd(), n = $d(), u = [t4(Vd(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t4(Wd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t4(Hd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t4(Gd(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
            r.exports = { languages: u, options: a, printers: i, parsers: n };
          } }), Jd = te({ "src/language-handlebars/loc.js"(e, r) {
            "use strict";
            ne();
            function t4(a) {
              return a.loc.start.offset;
            }
            function s(a) {
              return a.loc.end.offset;
            }
            r.exports = { locStart: t4, locEnd: s };
          } }), zd = te({ "src/language-handlebars/clean.js"(e, r) {
            "use strict";
            ne();
            function t4(s, a) {
              if (s.type === "TextNode") {
                let n = s.chars.trim();
                if (!n)
                  return null;
                a.chars = n.replace(/[\t\n\f\r ]+/g, " ");
              }
              s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
            }
            t4.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r.exports = t4;
          } }), Xd = te({ "src/language-handlebars/html-void-elements.evaluate.js"(e, r) {
            r.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
          } }), Kd = te({ "src/language-handlebars/utils.js"(e, r) {
            "use strict";
            ne();
            var t4 = lt(), s = Xd();
            function a(x) {
              let I = x.getValue(), P = x.getParentNode(0);
              return !!(g(x, ["ElementNode"]) && t4(P.children) === I || g(x, ["Block"]) && t4(P.body) === I);
            }
            function n(x) {
              return x.toUpperCase() === x;
            }
            function u(x) {
              return h2(x, ["ElementNode"]) && typeof x.tag == "string" && !x.tag.startsWith(":") && (n(x.tag[0]) || x.tag.includes("."));
            }
            var i = new Set(s);
            function l(x) {
              return i.has(x.toLowerCase()) && !n(x[0]);
            }
            function p(x) {
              return x.selfClosing === true || l(x.tag) || u(x) && x.children.every((I) => y(I));
            }
            function y(x) {
              return h2(x, ["TextNode"]) && !/\S/.test(x.chars);
            }
            function h2(x, I) {
              return x && I.includes(x.type);
            }
            function g(x, I) {
              let P = x.getParentNode(0);
              return h2(P, I);
            }
            function c(x, I) {
              let P = _(x);
              return h2(P, I);
            }
            function f(x, I) {
              let P = w(x);
              return h2(P, I);
            }
            function F4(x, I) {
              var P, $, D, T;
              let m = x.getValue(), C = (P = x.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($ = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $ !== void 0 ? $ : [], d = o.indexOf(m);
              return d !== -1 && o[d + I];
            }
            function _(x) {
              let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
              return F4(x, -I);
            }
            function w(x) {
              return F4(x, 1);
            }
            function E(x) {
              return h2(x, ["MustacheCommentStatement"]) && typeof x.value == "string" && x.value.trim() === "prettier-ignore";
            }
            function N6(x) {
              let I = x.getValue(), P = _(x, 2);
              return E(I) || E(P);
            }
            r.exports = { getNextNode: w, getPreviousNode: _, hasPrettierIgnore: N6, isLastNodeOfSiblings: a, isNextNodeOfSomeType: f, isNodeOfSomeType: h2, isParentOfSomeType: g, isPreviousNodeOfSomeType: c, isVoid: p, isWhitespaceNode: y };
          } }), Yd = te({ "src/language-handlebars/printer-glimmer.js"(e, r) {
            "use strict";
            ne();
            var { builders: { dedent: t4, fill: s, group: a, hardline: n, ifBreak: u, indent: i, join: l, line: p, softline: y }, utils: { getDocParts: h2, replaceTextEndOfLine: g } } = qe(), { getPreferredQuote: c, isNonEmptyArray: f } = Ue(), { locStart: F4, locEnd: _ } = Jd(), w = zd(), { getNextNode: E, getPreviousNode: N6, hasPrettierIgnore: x, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P, isNodeOfSomeType: $, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m, isWhitespaceNode: C } = Kd(), o = 2;
            function d(H, pe, X) {
              let le = H.getValue();
              if (!le)
                return "";
              if (x(H))
                return pe.originalText.slice(F4(le), _(le));
              let Ae = pe.singleQuote ? "'" : '"';
              switch (le.type) {
                case "Block":
                case "Program":
                case "Template":
                  return a(H.map(X, "body"));
                case "ElementNode": {
                  let Ee = a(S(H, X)), De = pe.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? y : "";
                  if (m(le))
                    return [Ee, De];
                  let A = ["</", le.tag, ">"];
                  return le.children.length === 0 ? [Ee, i(A), De] : pe.htmlWhitespaceSensitivity === "ignore" ? [Ee, i(b(H, pe, X)), n, i(A), De] : [Ee, i(a(b(H, pe, X))), i(A), De];
                }
                case "BlockStatement": {
                  let Ee = H.getParentNode(1);
                  return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe), ue(H, X, pe)] : [j(H, X), a([de(H, X, pe), ue(H, X, pe), ee(H, X, pe)])];
                }
                case "ElementModifierStatement":
                  return a(["{{", Re(H, X), "}}"]);
                case "MustacheStatement":
                  return a([k(le), Re(H, X), M(le)]);
                case "SubExpression":
                  return a(["(", ke(H, X), y, ")"]);
                case "AttrNode": {
                  let Ee = le.value.type === "TextNode";
                  if (Ee && le.value.chars === "" && F4(le.value) === _(le.value))
                    return le.name;
                  let A = Ee ? c(le.value.chars, Ae).quote : le.value.type === "ConcatStatement" ? c(le.value.parts.filter((re) => re.type === "TextNode").map((re) => re.chars).join(""), Ae).quote : "", G = X("value");
                  return [le.name, "=", A, le.name === "class" && A ? a(i(G)) : G, A];
                }
                case "ConcatStatement":
                  return H.map(X, "parts");
                case "Hash":
                  return l(p, H.map(X, "pairs"));
                case "HashPair":
                  return [le.key, "=", X("value")];
                case "TextNode": {
                  let Ee = le.chars.replace(/{{/g, "\\{{"), De = U3(H);
                  if (De) {
                    if (De === "class") {
                      let Ye = Ee.trim().split(/\s+/).join(" "), Se = false, Ie = false;
                      return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee) && (Se = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee) && Ye !== "" && (Ie = true)), [Se ? p : "", Ye, Ie ? p : ""];
                    }
                    return g(Ee);
                  }
                  let G = /^[\t\n\f\r ]*$/.test(Ee), re = !N6(H), ye = !E(H);
                  if (pe.htmlWhitespaceSensitivity !== "ignore") {
                    let Ye = /^[\t\n\f\r ]*/, Se = /[\t\n\f\r ]*$/, Ie = ye && D(H, ["Template"]), Oe = re && D(H, ["Template"]);
                    if (G) {
                      if (Oe || Ie)
                        return "";
                      let ae = [p], nt = Z(Ee);
                      return nt && (ae = ge(nt)), I(H) && (ae = ae.map((tt) => t4(tt))), ae;
                    }
                    let [Je] = Ee.match(Ye), [Te] = Ee.match(Se), je = [];
                    if (Je) {
                      je = [p];
                      let ae = Z(Je);
                      ae && (je = ge(ae)), Ee = Ee.replace(Ye, "");
                    }
                    let Me = [];
                    if (Te) {
                      if (!Ie) {
                        Me = [p];
                        let ae = Z(Te);
                        ae && (Me = ge(ae)), I(H) && (Me = Me.map((nt) => t4(nt)));
                      }
                      Ee = Ee.replace(Se, "");
                    }
                    return [...je, s(Fe(Ee)), ...Me];
                  }
                  let Ce = Z(Ee), Be = se(Ee), ve = fe(Ee);
                  if ((re || ye) && G && D(H, ["Block", "ElementNode", "Template"]))
                    return "";
                  G && Ce ? (Be = Math.min(Ce, o), ve = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve = Math.max(ve, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                  let ze = "", be = "";
                  return ve === 0 && P(H, ["MustacheStatement"]) && (be = " "), Be === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re && (Be = 0, ze = ""), ye && (ve = 0, be = ""), Ee = Ee.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, be), [...ge(Be), s(Fe(Ee)), ...ge(ve)];
                }
                case "MustacheCommentStatement": {
                  let Ee = F4(le), De = _(le), A = pe.originalText.charAt(Ee + 2) === "~", G = pe.originalText.charAt(De - 3) === "~", re = le.value.includes("}}") ? "--" : "";
                  return ["{{", A ? "~" : "", "!", re, le.value, re, G ? "~" : "", "}}"];
                }
                case "PathExpression":
                  return le.original;
                case "BooleanLiteral":
                  return String(le.value);
                case "CommentStatement":
                  return ["<!--", le.value, "-->"];
                case "StringLiteral": {
                  if (we(H)) {
                    let Ee = pe.singleQuote ? '"' : "'";
                    return he(le.value, Ee);
                  }
                  return he(le.value, Ae);
                }
                case "NumberLiteral":
                  return String(le.value);
                case "UndefinedLiteral":
                  return "undefined";
                case "NullLiteral":
                  return "null";
                default:
                  throw new Error("unknown glimmer type: " + JSON.stringify(le.type));
              }
            }
            function v(H, pe) {
              return F4(H) - F4(pe);
            }
            function S(H, pe) {
              let X = H.getValue(), le = ["attributes", "modifiers", "comments"].filter((Ee) => f(X[Ee])), Ae = le.flatMap((Ee) => X[Ee]).sort(v);
              for (let Ee of le)
                H.each((De) => {
                  let A = Ae.indexOf(De.getValue());
                  Ae.splice(A, 1, [p, pe()]);
                }, Ee);
              return f(X.blockParams) && Ae.push(p, oe(X)), ["<", X.tag, i(Ae), B(X)];
            }
            function b(H, pe, X) {
              let Ae = H.getValue().children.every((Ee) => C(Ee));
              return pe.htmlWhitespaceSensitivity === "ignore" && Ae ? "" : H.map((Ee, De) => {
                let A = X();
                return De === 0 && pe.htmlWhitespaceSensitivity === "ignore" ? [y, A] : A;
              }, "children");
            }
            function B(H) {
              return m(H) ? u([y, "/>"], [" />", y]) : u([y, ">"], ">");
            }
            function k(H) {
              let pe = H.escaped === false ? "{{{" : "{{", X = H.strip && H.strip.open ? "~" : "";
              return [pe, X];
            }
            function M(H) {
              let pe = H.escaped === false ? "}}}" : "}}";
              return [H.strip && H.strip.close ? "~" : "", pe];
            }
            function R4(H) {
              let pe = k(H), X = H.openStrip.open ? "~" : "";
              return [pe, X, "#"];
            }
            function q(H) {
              let pe = M(H);
              return [H.openStrip.close ? "~" : "", pe];
            }
            function J(H) {
              let pe = k(H), X = H.closeStrip.open ? "~" : "";
              return [pe, X, "/"];
            }
            function L(H) {
              let pe = M(H);
              return [H.closeStrip.close ? "~" : "", pe];
            }
            function Q(H) {
              let pe = k(H), X = H.inverseStrip.open ? "~" : "";
              return [pe, X];
            }
            function V(H) {
              let pe = M(H);
              return [H.inverseStrip.close ? "~" : "", pe];
            }
            function j(H, pe) {
              let X = H.getValue(), le = [], Ae = Pe(H, pe);
              return Ae && le.push(a(Ae)), f(X.program.blockParams) && le.push(oe(X.program)), a([R4(X), Ne(H, pe), le.length > 0 ? i([p, l(p, le)]) : "", y, q(X)]);
            }
            function Y(H, pe) {
              return [pe.htmlWhitespaceSensitivity === "ignore" ? n : "", Q(H), "else", V(H)];
            }
            function ie(H, pe, X) {
              let le = H.getValue(), Ae = H.getParentNode(1);
              return a([Q(Ae), ["else", " ", X], i([p, a(Pe(H, pe)), ...f(le.program.blockParams) ? [p, oe(le.program)] : []]), y, V(Ae)]);
            }
            function ee(H, pe, X) {
              let le = H.getValue();
              return X.htmlWhitespaceSensitivity === "ignore" ? [ce(le) ? y : n, J(le), pe("path"), L(le)] : [J(le), pe("path"), L(le)];
            }
            function ce(H) {
              return $(H, ["BlockStatement"]) && H.program.body.every((pe) => C(pe));
            }
            function W(H) {
              return K(H) && H.inverse.body.length === 1 && $(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
            }
            function K(H) {
              return $(H, ["BlockStatement"]) && H.inverse;
            }
            function de(H, pe, X) {
              let le = H.getValue();
              if (ce(le))
                return "";
              let Ae = pe("program");
              return X.htmlWhitespaceSensitivity === "ignore" ? i([n, Ae]) : i(Ae);
            }
            function ue(H, pe, X) {
              let le = H.getValue(), Ae = pe("inverse"), Ee = X.htmlWhitespaceSensitivity === "ignore" ? [n, Ae] : Ae;
              return W(le) ? Ee : K(le) ? [Y(le, X), i(Ee)] : "";
            }
            function Fe(H) {
              return h2(l(p, z(H)));
            }
            function z(H) {
              return H.split(/[\t\n\f\r ]+/);
            }
            function U3(H) {
              for (let pe = 0; pe < 2; pe++) {
                let X = H.getParentNode(pe);
                if (X && X.type === "AttrNode")
                  return X.name.toLowerCase();
              }
            }
            function Z(H) {
              return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
            }
            function se(H) {
              H = typeof H == "string" ? H : "";
              let pe = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
              return Z(pe);
            }
            function fe(H) {
              H = typeof H == "string" ? H : "";
              let pe = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
              return Z(pe);
            }
            function ge() {
              let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return Array.from({ length: Math.min(H, o) }).fill(n);
            }
            function he(H, pe) {
              let { quote: X, regex: le } = c(H, pe);
              return [X, H.replace(le, `\\${X}`), X];
            }
            function we(H) {
              let pe = 0, X = H.getParentNode(pe);
              for (; X && $(X, ["SubExpression"]); )
                pe++, X = H.getParentNode(pe);
              return !!(X && $(H.getParentNode(pe + 1), ["ConcatStatement"]) && $(H.getParentNode(pe + 2), ["AttrNode"]));
            }
            function ke(H, pe) {
              let X = Ne(H, pe), le = Pe(H, pe);
              return le ? i([X, p, a(le)]) : X;
            }
            function Re(H, pe) {
              let X = Ne(H, pe), le = Pe(H, pe);
              return le ? [i([X, p, le]), y] : X;
            }
            function Ne(H, pe) {
              return pe("path");
            }
            function Pe(H, pe) {
              let X = H.getValue(), le = [];
              if (X.params.length > 0) {
                let Ae = H.map(pe, "params");
                le.push(...Ae);
              }
              if (X.hash && X.hash.pairs.length > 0) {
                let Ae = pe("hash");
                le.push(Ae);
              }
              return le.length === 0 ? "" : l(p, le);
            }
            function oe(H) {
              return ["as |", H.blockParams.join(" "), "|"];
            }
            r.exports = { print: d, massageAstNode: w };
          } }), Qd = te({ "src/language-handlebars/parsers.js"() {
            ne();
          } }), Zd = te({ "node_modules/linguist-languages/data/Handlebars.json"(e, r) {
            r.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
          } }), eg = te({ "src/language-handlebars/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = _t(), s = Yd(), a = Qd(), n = [t4(Zd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
            r.exports = { languages: n, printers: u, parsers: a };
          } }), tg = te({ "src/language-graphql/pragma.js"(e, r) {
            "use strict";
            ne();
            function t4(a) {
              return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
            }
            function s(a) {
              return `# @format

` + a;
            }
            r.exports = { hasPragma: t4, insertPragma: s };
          } }), rg = te({ "src/language-graphql/loc.js"(e, r) {
            "use strict";
            ne();
            function t4(a) {
              return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
            }
            function s(a) {
              return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
            }
            r.exports = { locStart: t4, locEnd: s };
          } }), ng = te({ "src/language-graphql/printer-graphql.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t4, hardline: s, line: a, softline: n, group: u, indent: i, ifBreak: l } } = qe(), { isNextLineEmpty: p, isNonEmptyArray: y } = Ue(), { insertPragma: h2 } = tg(), { locStart: g, locEnd: c } = rg();
            function f(P, $, D) {
              let T = P.getValue();
              if (!T)
                return "";
              if (typeof T == "string")
                return T;
              switch (T.kind) {
                case "Document": {
                  let m = [];
                  return P.each((C, o, d) => {
                    m.push(D()), o !== d.length - 1 && (m.push(s), p($.originalText, C.getValue(), c) && m.push(s));
                  }, "definitions"), [...m, s];
                }
                case "OperationDefinition": {
                  let m = $.originalText[g(T)] !== "{", C = Boolean(T.name);
                  return [m ? T.operation : "", m && C ? [" ", D("name")] : "", m && !C && y(T.variableDefinitions) ? " " : "", y(T.variableDefinitions) ? u(["(", i([n, t4([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", F4(P, D, T), T.selectionSet ? !m && !C ? "" : " " : "", D("selectionSet")];
                }
                case "FragmentDefinition":
                  return ["fragment ", D("name"), y(T.variableDefinitions) ? u(["(", i([n, t4([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", " on ", D("typeCondition"), F4(P, D, T), " ", D("selectionSet")];
                case "SelectionSet":
                  return ["{", i([s, t4(s, _(P, $, D, "selections"))]), s, "}"];
                case "Field":
                  return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t4([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", F4(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
                case "Name":
                  return T.value;
                case "StringValue": {
                  if (T.block) {
                    let m = T.value.replace(/"""/g, "\\$&").split(`
`);
                    return m.length === 1 && (m[0] = m[0].trim()), m.every((C) => C === "") && (m.length = 0), t4(s, ['"""', ...m, '"""']);
                  }
                  return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
                }
                case "IntValue":
                case "FloatValue":
                case "EnumValue":
                  return T.value;
                case "BooleanValue":
                  return T.value ? "true" : "false";
                case "NullValue":
                  return "null";
                case "Variable":
                  return ["$", D("name")];
                case "ListValue":
                  return u(["[", i([n, t4([l("", ", "), n], P.map(D, "values"))]), n, "]"]);
                case "ObjectValue":
                  return u(["{", $.bracketSpacing && T.fields.length > 0 ? " " : "", i([n, t4([l("", ", "), n], P.map(D, "fields"))]), n, l("", $.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
                case "ObjectField":
                case "Argument":
                  return [D("name"), ": ", D("value")];
                case "Directive":
                  return ["@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t4([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : ""];
                case "NamedType":
                  return D("name");
                case "VariableDefinition":
                  return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F4(P, D, T)];
                case "ObjectTypeExtension":
                case "ObjectTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N6(P, $, D)] : "", F4(P, D, T), T.fields.length > 0 ? [" {", i([s, t4(s, _(P, $, D, "fields"))]), s, "}"] : ""];
                case "FieldDefinition":
                  return [D("description"), T.description ? s : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t4([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", ": ", D("type"), F4(P, D, T)];
                case "DirectiveDefinition":
                  return [D("description"), T.description ? s : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t4([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t4(" | ", P.map(D, "locations"))];
                case "EnumTypeExtension":
                case "EnumTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), F4(P, D, T), T.values.length > 0 ? [" {", i([s, t4(s, _(P, $, D, "values"))]), s, "}"] : ""];
                case "EnumValueDefinition":
                  return [D("description"), T.description ? s : "", D("name"), F4(P, D, T)];
                case "InputValueDefinition":
                  return [D("description"), T.description ? T.description.block ? s : a : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F4(P, D, T)];
                case "InputObjectTypeExtension":
                case "InputObjectTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), F4(P, D, T), T.fields.length > 0 ? [" {", i([s, t4(s, _(P, $, D, "fields"))]), s, "}"] : ""];
                case "SchemaExtension":
                  return ["extend schema", F4(P, D, T), ...T.operationTypes.length > 0 ? [" {", i([s, t4(s, _(P, $, D, "operationTypes"))]), s, "}"] : []];
                case "SchemaDefinition":
                  return [D("description"), T.description ? s : "", "schema", F4(P, D, T), " {", T.operationTypes.length > 0 ? i([s, t4(s, _(P, $, D, "operationTypes"))]) : "", s, "}"];
                case "OperationTypeDefinition":
                  return [D("operation"), ": ", D("type")];
                case "InterfaceTypeExtension":
                case "InterfaceTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N6(P, $, D)] : "", F4(P, D, T), T.fields.length > 0 ? [" {", i([s, t4(s, _(P, $, D, "fields"))]), s, "}"] : ""];
                case "FragmentSpread":
                  return ["...", D("name"), F4(P, D, T)];
                case "InlineFragment":
                  return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", F4(P, D, T), " ", D("selectionSet")];
                case "UnionTypeExtension":
                case "UnionTypeDefinition":
                  return u([D("description"), T.description ? s : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), F4(P, D, T), T.types.length > 0 ? [" =", l("", " "), i([l([a, "  "]), t4([a, "| "], P.map(D, "types"))])] : ""])]);
                case "ScalarTypeExtension":
                case "ScalarTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), F4(P, D, T)];
                case "NonNullType":
                  return [D("type"), "!"];
                case "ListType":
                  return ["[", D("type"), "]"];
                default:
                  throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
              }
            }
            function F4(P, $, D) {
              if (D.directives.length === 0)
                return "";
              let T = t4(a, P.map($, "directives"));
              return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a, T]) : [" ", u(i([n, T]))];
            }
            function _(P, $, D, T) {
              return P.map((m, C, o) => {
                let d = D();
                return C < o.length - 1 && p($.originalText, m.getValue(), c) ? [d, s] : d;
              }, T);
            }
            function w(P) {
              return P.kind && P.kind !== "Comment";
            }
            function E(P) {
              let $ = P.getValue();
              if ($.kind === "Comment")
                return "#" + $.value.trimEnd();
              throw new Error("Not a comment: " + JSON.stringify($));
            }
            function N6(P, $, D) {
              let T = P.getNode(), m = [], { interfaces: C } = T, o = P.map((d) => D(d), "interfaces");
              for (let d = 0; d < C.length; d++) {
                let v = C[d];
                m.push(o[d]);
                let S = C[d + 1];
                if (S) {
                  let b = $.originalText.slice(v.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
                  m.push(k === "," ? "," : " &", B ? a : " ");
                }
              }
              return m;
            }
            function x(P, $) {
              P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($.value = $.value.trim());
            }
            x.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
            function I(P) {
              var $;
              let D = P.getValue();
              return D == null || ($ = D.comments) === null || $ === void 0 ? void 0 : $.some((T) => T.value.trim() === "prettier-ignore");
            }
            r.exports = { print: f, massageAstNode: x, hasPrettierIgnore: I, insertPragma: h2, printComment: E, canAttachComment: w };
          } }), ug = te({ "src/language-graphql/options.js"(e, r) {
            "use strict";
            ne();
            var t4 = Mt();
            r.exports = { bracketSpacing: t4.bracketSpacing };
          } }), sg = te({ "src/language-graphql/parsers.js"() {
            ne();
          } }), ig = te({ "node_modules/linguist-languages/data/GraphQL.json"(e, r) {
            r.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
          } }), ag = te({ "src/language-graphql/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = _t(), s = ng(), a = ug(), n = sg(), u = [t4(ig(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
            r.exports = { languages: u, options: a, printers: i, parsers: n };
          } }), Po = te({ "node_modules/collapse-white-space/index.js"(e, r) {
            "use strict";
            ne(), r.exports = t4;
            function t4(s) {
              return String(s).replace(/\s+/g, " ");
            }
          } }), Io = te({ "src/language-markdown/loc.js"(e, r) {
            "use strict";
            ne();
            function t4(a) {
              return a.position.start.offset;
            }
            function s(a) {
              return a.position.end.offset;
            }
            r.exports = { locStart: t4, locEnd: s };
          } }), og = te({ "src/language-markdown/constants.evaluate.js"(e, r) {
            r.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
          } }), iu = te({ "src/language-markdown/utils.js"(e, r) {
            "use strict";
            ne();
            var { getLast: t4 } = Ue(), { locStart: s, locEnd: a } = Io(), { cjkPattern: n, kPattern: u, punctuationPattern: i } = og(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p = [...l, "tableCell", "paragraph", "heading"], y = new RegExp(u), h2 = new RegExp(i);
            function g(E, N6) {
              let x = "non-cjk", I = "cj-letter", P = "k-letter", $ = "cjk-punctuation", D = [], T = (N6.proseWrap === "preserve" ? E : E.replace(new RegExp(`(${n})
(${n})`, "g"), "$1$2")).split(/([\t\n ]+)/);
              for (let [C, o] of T.entries()) {
                if (C % 2 === 1) {
                  D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                  continue;
                }
                if ((C === 0 || C === T.length - 1) && o === "")
                  continue;
                let d = o.split(new RegExp(`(${n})`));
                for (let [v, S] of d.entries())
                  if (!((v === 0 || v === d.length - 1) && S === "")) {
                    if (v % 2 === 0) {
                      S !== "" && m({ type: "word", value: S, kind: x, hasLeadingPunctuation: h2.test(S[0]), hasTrailingPunctuation: h2.test(t4(S)) });
                      continue;
                    }
                    m(h2.test(S) ? { type: "word", value: S, kind: $, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: y.test(S) ? P : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                  }
              }
              return D;
              function m(C) {
                let o = t4(D);
                o && o.type === "word" && (o.kind === x && C.kind === I && !o.hasTrailingPunctuation || o.kind === I && C.kind === x && !C.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !d(x, $) && ![o.value, C.value].some((v) => /\u3000/.test(v)) && D.push({ type: "whitespace", value: "" })), D.push(C);
                function d(v, S) {
                  return o.kind === v && C.kind === S || o.kind === S && C.kind === v;
                }
              }
            }
            function c(E, N6) {
              let [, x, I, P] = N6.slice(E.position.start.offset, E.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
              return { numberText: x, marker: I, leadingSpaces: P };
            }
            function f(E, N6) {
              if (!E.ordered || E.children.length < 2)
                return false;
              let x = Number(c(E.children[0], N6.originalText).numberText), I = Number(c(E.children[1], N6.originalText).numberText);
              if (x === 0 && E.children.length > 2) {
                let P = Number(c(E.children[2], N6.originalText).numberText);
                return I === 1 && P === 1;
              }
              return I === 1;
            }
            function F4(E, N6) {
              let { value: x } = E;
              return E.position.end.offset === N6.length && x.endsWith(`
`) && N6.endsWith(`
`) ? x.slice(0, -1) : x;
            }
            function _(E, N6) {
              return function x(I, P, $) {
                let D = Object.assign({}, N6(I, P, $));
                return D.children && (D.children = D.children.map((T, m) => x(T, m, [D, ...$]))), D;
              }(E, null, []);
            }
            function w(E) {
              if ((E == null ? void 0 : E.type) !== "link" || E.children.length !== 1)
                return false;
              let [N6] = E.children;
              return s(E) === s(N6) && a(E) === a(N6);
            }
            r.exports = { mapAst: _, splitText: g, punctuationPattern: i, getFencedCodeBlockValue: F4, getOrderedListItemInfo: c, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p, isAutolink: w };
          } }), lg = te({ "src/language-markdown/embed.js"(e, r) {
            "use strict";
            ne();
            var { inferParserByLanguage: t4, getMaxContinuousCount: s } = Ue(), { builders: { hardline: a, markAsRoot: n }, utils: { replaceEndOfLine: u } } = qe(), i = su(), { getFencedCodeBlockValue: l } = iu();
            function p(y, h2, g, c) {
              let f = y.getValue();
              if (f.type === "code" && f.lang !== null) {
                let F4 = t4(f.lang, c);
                if (F4) {
                  let _ = c.__inJsTemplate ? "~" : "`", w = _.repeat(Math.max(3, s(f.value, _) + 1)), E = { parser: F4 };
                  f.lang === "tsx" && (E.filepath = "dummy.tsx");
                  let N6 = g(l(f, c.originalText), E, { stripTrailingHardline: true });
                  return n([w, f.lang, f.meta ? " " + f.meta : "", a, u(N6), a, w]);
                }
              }
              switch (f.type) {
                case "front-matter":
                  return i(f, g);
                case "importExport":
                  return [g(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
                case "jsx":
                  return g(`<$>${f.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
              }
              return null;
            }
            r.exports = p;
          } }), ko = te({ "src/language-markdown/pragma.js"(e, r) {
            "use strict";
            ne();
            var t4 = _o(), s = ["format", "prettier"];
            function a(n) {
              let u = `@(${s.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n.match(i);
              return (l == null ? void 0 : l.index) === 0;
            }
            r.exports = { startWithPragma: a, hasPragma: (n) => a(t4(n).content.trimStart()), insertPragma: (n) => {
              let u = t4(n), i = `<!-- @${s[0]} -->`;
              return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
            } };
          } }), cg = te({ "src/language-markdown/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            var t4 = lt(), { getOrderedListItemInfo: s, mapAst: a, splitText: n } = iu(), u = /^.$/su;
            function i(w, E) {
              return w = y(w, E), w = c(w), w = p(w, E), w = F4(w, E), w = _(w, E), w = f(w, E), w = l(w), w = h2(w), w;
            }
            function l(w) {
              return a(w, (E) => E.type !== "import" && E.type !== "export" ? E : Object.assign(Object.assign({}, E), {}, { type: "importExport" }));
            }
            function p(w, E) {
              return a(w, (N6) => N6.type !== "inlineCode" || E.proseWrap === "preserve" ? N6 : Object.assign(Object.assign({}, N6), {}, { value: N6.value.replace(/\s+/g, " ") }));
            }
            function y(w, E) {
              return a(w, (N6) => N6.type !== "text" || N6.value === "*" || N6.value === "_" || !u.test(N6.value) || N6.position.end.offset - N6.position.start.offset === N6.value.length ? N6 : Object.assign(Object.assign({}, N6), {}, { value: E.originalText.slice(N6.position.start.offset, N6.position.end.offset) }));
            }
            function h2(w) {
              return g(w, (E, N6) => E.type === "importExport" && N6.type === "importExport", (E, N6) => ({ type: "importExport", value: E.value + `

` + N6.value, position: { start: E.position.start, end: N6.position.end } }));
            }
            function g(w, E, N6) {
              return a(w, (x) => {
                if (!x.children)
                  return x;
                let I = x.children.reduce((P, $) => {
                  let D = t4(P);
                  return D && E(D, $) ? P.splice(-1, 1, N6(D, $)) : P.push($), P;
                }, []);
                return Object.assign(Object.assign({}, x), {}, { children: I });
              });
            }
            function c(w) {
              return g(w, (E, N6) => E.type === "text" && N6.type === "text", (E, N6) => ({ type: "text", value: E.value + N6.value, position: { start: E.position.start, end: N6.position.end } }));
            }
            function f(w, E) {
              return a(w, (N6, x, I) => {
                let [P] = I;
                if (N6.type !== "text")
                  return N6;
                let { value: $ } = N6;
                return P.type === "paragraph" && (x === 0 && ($ = $.trimStart()), x === P.children.length - 1 && ($ = $.trimEnd())), { type: "sentence", position: N6.position, children: n($, E) };
              });
            }
            function F4(w, E) {
              return a(w, (N6, x, I) => {
                if (N6.type === "code") {
                  let P = /^\n?(?: {4,}|\t)/.test(E.originalText.slice(N6.position.start.offset, N6.position.end.offset));
                  if (N6.isIndented = P, P)
                    for (let $ = 0; $ < I.length; $++) {
                      let D = I[$];
                      if (D.hasIndentedCodeblock)
                        break;
                      D.type === "list" && (D.hasIndentedCodeblock = true);
                    }
                }
                return N6;
              });
            }
            function _(w, E) {
              return a(w, (I, P, $) => {
                if (I.type === "list" && I.children.length > 0) {
                  for (let D = 0; D < $.length; D++) {
                    let T = $[D];
                    if (T.type === "list" && !T.isAligned)
                      return I.isAligned = false, I;
                  }
                  I.isAligned = x(I);
                }
                return I;
              });
              function N6(I) {
                return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
              }
              function x(I) {
                if (!I.ordered)
                  return true;
                let [P, $] = I.children;
                if (s(P, E.originalText).leadingSpaces.length > 1)
                  return true;
                let T = N6(P);
                if (T === -1)
                  return false;
                if (I.children.length === 1)
                  return T % E.tabWidth === 0;
                let m = N6($);
                return T !== m ? false : T % E.tabWidth === 0 ? true : s($, E.originalText).leadingSpaces.length > 1;
              }
            }
            r.exports = i;
          } }), pg = te({ "src/language-markdown/clean.js"(e, r) {
            "use strict";
            ne();
            var t4 = Po(), { isFrontMatterNode: s } = Ue(), { startWithPragma: a } = ko(), n = /* @__PURE__ */ new Set(["position", "raw"]);
            function u(i, l, p) {
              if ((i.type === "front-matter" || i.type === "code" || i.type === "yaml" || i.type === "import" || i.type === "export" || i.type === "jsx") && delete l.value, i.type === "list" && delete l.isAligned, (i.type === "list" || i.type === "listItem") && (delete l.spread, delete l.loose), i.type === "text" || (i.type === "inlineCode" && (l.value = i.value.replace(/[\t\n ]+/g, " ")), i.type === "wikiLink" && (l.value = i.value.trim().replace(/[\t\n]+/g, " ")), (i.type === "definition" || i.type === "linkReference" || i.type === "imageReference") && (l.label = t4(i.label)), (i.type === "definition" || i.type === "link" || i.type === "image") && i.title && (l.title = i.title.replace(/\\(["')])/g, "$1")), p && p.type === "root" && p.children.length > 0 && (p.children[0] === i || s(p.children[0]) && p.children[1] === i) && i.type === "html" && a(i.value)))
                return null;
            }
            u.ignoredProperties = n, r.exports = u;
          } }), fg = te({ "src/language-markdown/printer-markdown.js"(e, r) {
            "use strict";
            ne();
            var t4 = Po(), { getLast: s, getMinNotPresentContinuousCount: a, getMaxContinuousCount: n, getStringWidth: u, isNonEmptyArray: i } = Ue(), { builders: { breakParent: l, join: p, line: y, literalline: h2, markAsRoot: g, hardline: c, softline: f, ifBreak: F4, fill: _, align: w, indent: E, group: N6, hardlineWithoutBreakParent: x }, utils: { normalizeDoc: I, replaceTextEndOfLine: P }, printer: { printDocToString: $ } } = qe(), D = lg(), { insertPragma: T } = ko(), { locStart: m, locEnd: C } = Io(), o = cg(), d = pg(), { getFencedCodeBlockValue: v, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M, isAutolink: R4 } = iu(), q = /* @__PURE__ */ new Set(["importExport"]), J = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
            function Q(oe, H, pe) {
              let X = oe.getValue();
              if (ge(oe))
                return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map((le) => le.type === "word" ? le.value : le.value === "" ? "" : W(oe, le.value, H));
              switch (X.type) {
                case "front-matter":
                  return H.originalText.slice(X.position.start.offset, X.position.end.offset);
                case "root":
                  return X.children.length === 0 ? "" : [I(de(oe, H, pe)), q.has(z(X).type) ? "" : c];
                case "paragraph":
                  return ue(oe, H, pe, { postprocessor: _ });
                case "sentence":
                  return ue(oe, H, pe);
                case "word": {
                  let le = X.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De, A, G, re, ye) => (G ? `${A}${G}` : `${re}${ye}`).replace(/_/g, "\\_")), Ae = (De, A, G) => De.type === "sentence" && G === 0, Ee = (De, A, G) => R4(De.children[G - 1]);
                  return le !== X.value && (oe.match(void 0, Ae, Ee) || oe.match(void 0, Ae, (De, A, G) => De.type === "emphasis" && G === 0, Ee)) && (le = le.replace(/^(\\?[*_])+/, (De) => De.replace(/\\/g, ""))), le;
                }
                case "whitespace": {
                  let le = oe.getParentNode(), Ae = le.children.indexOf(X), Ee = le.children[Ae + 1], De = Ee && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee.value) ? "never" : H.proseWrap;
                  return W(oe, X.value, { proseWrap: De });
                }
                case "emphasis": {
                  let le;
                  if (R4(X.children[0]))
                    le = H.originalText[X.position.start.offset];
                  else {
                    let Ae = oe.getParentNode(), Ee = Ae.children.indexOf(X), De = Ae.children[Ee - 1], A = Ae.children[Ee + 1];
                    le = De && De.type === "sentence" && De.children.length > 0 && s(De.children).type === "word" && !s(De.children).hasTrailingPunctuation || A && A.type === "sentence" && A.children.length > 0 && A.children[0].type === "word" && !A.children[0].hasLeadingPunctuation || ce(oe, "emphasis") ? "*" : "_";
                  }
                  return [le, ue(oe, H, pe), le];
                }
                case "strong":
                  return ["**", ue(oe, H, pe), "**"];
                case "delete":
                  return ["~~", ue(oe, H, pe), "~~"];
                case "inlineCode": {
                  let le = a(X.value, "`"), Ae = "`".repeat(le || 1), Ee = le && !/^\s/.test(X.value) ? " " : "";
                  return [Ae, Ee, X.value, Ee, Ae];
                }
                case "wikiLink": {
                  let le = "";
                  return H.proseWrap === "preserve" ? le = X.value : le = X.value.replace(/[\t\n]+/g, " "), ["[[", le, "]]"];
                }
                case "link":
                  switch (H.originalText[X.position.start.offset]) {
                    case "<": {
                      let le = "mailto:";
                      return ["<", X.url.startsWith(le) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le.length) !== le ? X.url.slice(le.length) : X.url, ">"];
                    }
                    case "[":
                      return ["[", ue(oe, H, pe), "](", he(X.url, ")"), we(X.title, H), ")"];
                    default:
                      return H.originalText.slice(X.position.start.offset, X.position.end.offset);
                  }
                case "image":
                  return ["![", X.alt || "", "](", he(X.url, ")"), we(X.title, H), ")"];
                case "blockquote":
                  return ["> ", w("> ", ue(oe, H, pe))];
                case "heading":
                  return ["#".repeat(X.depth) + " ", ue(oe, H, pe)];
                case "code": {
                  if (X.isIndented) {
                    let Ee = " ".repeat(4);
                    return w(Ee, [Ee, ...P(X.value, c)]);
                  }
                  let le = H.__inJsTemplate ? "~" : "`", Ae = le.repeat(Math.max(3, n(X.value, le) + 1));
                  return [Ae, X.lang || "", X.meta ? " " + X.meta : "", c, ...P(v(X, H.originalText), c), c, Ae];
                }
                case "html": {
                  let le = oe.getParentNode(), Ae = le.type === "root" && s(le.children) === X ? X.value.trimEnd() : X.value, Ee = /^<!--.*-->$/s.test(Ae);
                  return P(Ae, Ee ? c : g(h2));
                }
                case "list": {
                  let le = Y(X, oe.getParentNode()), Ae = S(X, H);
                  return ue(oe, H, pe, { processor: (Ee, De) => {
                    let A = re(), G = Ee.getValue();
                    if (G.children.length === 2 && G.children[1].type === "html" && G.children[0].position.start.column !== G.children[1].position.start.column)
                      return [A, V(Ee, H, pe, A)];
                    return [A, w(" ".repeat(A.length), V(Ee, H, pe, A))];
                    function re() {
                      let ye = X.ordered ? (De === 0 ? X.start : Ae ? 1 : X.start + De) + (le % 2 === 0 ? ". " : ") ") : le % 2 === 0 ? "- " : "* ";
                      return X.isAligned || X.hasIndentedCodeblock ? j(ye, H) : ye;
                    }
                  } });
                }
                case "thematicBreak": {
                  let le = ee(oe, "list");
                  return le === -1 ? "---" : Y(oe.getParentNode(le), oe.getParentNode(le + 1)) % 2 === 0 ? "***" : "---";
                }
                case "linkReference":
                  return ["[", ue(oe, H, pe), "]", X.referenceType === "full" ? Ne(X) : X.referenceType === "collapsed" ? "[]" : ""];
                case "imageReference":
                  switch (X.referenceType) {
                    case "full":
                      return ["![", X.alt || "", "]", Ne(X)];
                    default:
                      return ["![", X.alt, "]", X.referenceType === "collapsed" ? "[]" : ""];
                  }
                case "definition": {
                  let le = H.proseWrap === "always" ? y : " ";
                  return N6([Ne(X), ":", E([le, he(X.url), X.title === null ? "" : [le, we(X.title, H, false)]])]);
                }
                case "footnote":
                  return ["[^", ue(oe, H, pe), "]"];
                case "footnoteReference":
                  return Pe(X);
                case "footnoteDefinition": {
                  let le = oe.getParentNode().children[oe.getName() + 1], Ae = X.children.length === 1 && X.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X.children[0].position.start.line === X.children[0].position.end.line);
                  return [Pe(X), ": ", Ae ? ue(oe, H, pe) : N6([w(" ".repeat(4), ue(oe, H, pe, { processor: (Ee, De) => De === 0 ? N6([f, pe()]) : pe() })), le && le.type === "footnoteDefinition" ? f : ""])];
                }
                case "table":
                  return K(oe, H, pe);
                case "tableCell":
                  return ue(oe, H, pe);
                case "break":
                  return /\s/.test(H.originalText[X.position.start.offset]) ? ["  ", g(h2)] : ["\\", c];
                case "liquidNode":
                  return P(X.value, c);
                case "importExport":
                  return [X.value, c];
                case "esComment":
                  return ["{/* ", X.value, " */}"];
                case "jsx":
                  return X.value;
                case "math":
                  return ["$$", c, X.value ? [...P(X.value, c), c] : "", "$$"];
                case "inlineMath":
                  return H.originalText.slice(m(X), C(X));
                case "tableRow":
                case "listItem":
                default:
                  throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);
              }
            }
            function V(oe, H, pe, X) {
              let le = oe.getValue(), Ae = le.checked === null ? "" : le.checked ? "[x] " : "[ ] ";
              return [Ae, ue(oe, H, pe, { processor: (Ee, De) => {
                if (De === 0 && Ee.getValue().type !== "list")
                  return w(" ".repeat(Ae.length), pe());
                let A = " ".repeat(ke(H.tabWidth - X.length, 0, 3));
                return [A, w(A, pe())];
              } })];
            }
            function j(oe, H) {
              let pe = X();
              return oe + " ".repeat(pe >= 4 ? 0 : pe);
              function X() {
                let le = oe.length % H.tabWidth;
                return le === 0 ? 0 : H.tabWidth - le;
              }
            }
            function Y(oe, H) {
              return ie(oe, H, (pe) => pe.ordered === oe.ordered);
            }
            function ie(oe, H, pe) {
              let X = -1;
              for (let le of H.children)
                if (le.type === oe.type && pe(le) ? X++ : X = -1, le === oe)
                  return X;
            }
            function ee(oe, H) {
              let pe = Array.isArray(H) ? H : [H], X = -1, le;
              for (; le = oe.getParentNode(++X); )
                if (pe.includes(le.type))
                  return X;
              return -1;
            }
            function ce(oe, H) {
              let pe = ee(oe, H);
              return pe === -1 ? null : oe.getParentNode(pe);
            }
            function W(oe, H, pe) {
              if (pe.proseWrap === "preserve" && H === `
`)
                return c;
              let X = pe.proseWrap === "always" && !ce(oe, J);
              return H !== "" ? X ? y : " " : X ? f : "";
            }
            function K(oe, H, pe) {
              let X = oe.getValue(), le = [], Ae = oe.map((ye) => ye.map((Ce, Be) => {
                let ve = $(pe(), H).formatted, ze = u(ve);
                return le[Be] = Math.max(le[Be] || 3, ze), { text: ve, width: ze };
              }, "children"), "children"), Ee = A(false);
              if (H.proseWrap !== "never")
                return [l, Ee];
              let De = A(true);
              return [l, N6(F4(De, Ee))];
              function A(ye) {
                let Ce = [re(Ae[0], ye), G(ye)];
                return Ae.length > 1 && Ce.push(p(x, Ae.slice(1).map((Be) => re(Be, ye)))), p(x, Ce);
              }
              function G(ye) {
                return `| ${le.map((Be, ve) => {
                  let ze = X.align[ve], be = ze === "center" || ze === "left" ? ":" : "-", Ye = ze === "center" || ze === "right" ? ":" : "-", Se = ye ? "-" : "-".repeat(Be - 2);
                  return `${be}${Se}${Ye}`;
                }).join(" | ")} |`;
              }
              function re(ye, Ce) {
                return `| ${ye.map((ve, ze) => {
                  let { text: be, width: Ye } = ve;
                  if (Ce)
                    return be;
                  let Se = le[ze] - Ye, Ie = X.align[ze], Oe = 0;
                  Ie === "right" ? Oe = Se : Ie === "center" && (Oe = Math.floor(Se / 2));
                  let Je = Se - Oe;
                  return `${" ".repeat(Oe)}${be}${" ".repeat(Je)}`;
                }).join(" | ")} |`;
              }
            }
            function de(oe, H, pe) {
              let X = [], le = null, { children: Ae } = oe.getValue();
              for (let [Ee, De] of Ae.entries())
                switch (U3(De)) {
                  case "start":
                    le === null && (le = { index: Ee, offset: De.position.end.offset });
                    break;
                  case "end":
                    le !== null && (X.push({ start: le, end: { index: Ee, offset: De.position.start.offset } }), le = null);
                    break;
                  default:
                    break;
                }
              return ue(oe, H, pe, { processor: (Ee, De) => {
                if (X.length > 0) {
                  let A = X[0];
                  if (De === A.start.index)
                    return [Fe(Ae[A.start.index]), H.originalText.slice(A.start.offset, A.end.offset), Fe(Ae[A.end.index])];
                  if (A.start.index < De && De < A.end.index)
                    return false;
                  if (De === A.end.index)
                    return X.shift(), false;
                }
                return pe();
              } });
            }
            function ue(oe, H, pe) {
              let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le } = X, Ae = X.processor || (() => pe()), Ee = oe.getValue(), De = [], A;
              return oe.each((G, re) => {
                let ye = G.getValue(), Ce = Ae(G, re);
                if (Ce !== false) {
                  let Be = { parts: De, prevNode: A, parentNode: Ee, options: H };
                  Z(ye, Be) && (De.push(c), A && q.has(A.type) || (se(ye, Be) || fe(ye, Be)) && De.push(c), fe(ye, Be) && De.push(c)), De.push(Ce), A = ye;
                }
              }, "children"), le ? le(De) : De;
            }
            function Fe(oe) {
              if (oe.type === "html")
                return oe.value;
              if (oe.type === "paragraph" && Array.isArray(oe.children) && oe.children.length === 1 && oe.children[0].type === "esComment")
                return ["{/* ", oe.children[0].value, " */}"];
            }
            function z(oe) {
              let H = oe;
              for (; i(H.children); )
                H = s(H.children);
              return H;
            }
            function U3(oe) {
              let H;
              if (oe.type === "html")
                H = oe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
              else {
                let pe;
                oe.type === "esComment" ? pe = oe : oe.type === "paragraph" && oe.children.length === 1 && oe.children[0].type === "esComment" && (pe = oe.children[0]), pe && (H = pe.value.match(/^prettier-ignore(?:-(start|end))?$/));
              }
              return H ? H[1] || "next" : false;
            }
            function Z(oe, H) {
              let pe = H.parts.length === 0, X = k.includes(oe.type), le = oe.type === "html" && M.includes(H.parentNode.type);
              return !pe && !X && !le;
            }
            function se(oe, H) {
              var pe, X, le;
              let Ee = (H.prevNode && H.prevNode.type) === oe.type && L.has(oe.type), De = H.parentNode.type === "listItem" && !H.parentNode.loose, A = ((pe = H.prevNode) === null || pe === void 0 ? void 0 : pe.type) === "listItem" && H.prevNode.loose, G = U3(H.prevNode) === "next", re = oe.type === "html" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === "html" && H.prevNode.position.end.line + 1 === oe.position.start.line, ye = oe.type === "html" && H.parentNode.type === "listItem" && ((le = H.prevNode) === null || le === void 0 ? void 0 : le.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe.position.start.line;
              return A || !(Ee || De || G || re || ye);
            }
            function fe(oe, H) {
              let pe = H.prevNode && H.prevNode.type === "list", X = oe.type === "code" && oe.isIndented;
              return pe && X;
            }
            function ge(oe) {
              let H = ce(oe, ["linkReference", "imageReference"]);
              return H && (H.type !== "linkReference" || H.referenceType !== "full");
            }
            function he(oe) {
              let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe = [" ", ...Array.isArray(H) ? H : [H]];
              return new RegExp(pe.map((X) => `\\${X}`).join("|")).test(oe) ? `<${oe}>` : oe;
            }
            function we(oe, H) {
              let pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
              if (!oe)
                return "";
              if (pe)
                return " " + we(oe, H, false);
              if (oe = oe.replace(/\\(["')])/g, "$1"), oe.includes('"') && oe.includes("'") && !oe.includes(")"))
                return `(${oe})`;
              let X = oe.split("'").length - 1, le = oe.split('"').length - 1, Ae = X > le ? '"' : le > X || H.singleQuote ? "'" : '"';
              return oe = oe.replace(/\\/, "\\\\"), oe = oe.replace(new RegExp(`(${Ae})`, "g"), "\\$1"), `${Ae}${oe}${Ae}`;
            }
            function ke(oe, H, pe) {
              return oe < H ? H : oe > pe ? pe : oe;
            }
            function Re(oe) {
              let H = Number(oe.getName());
              if (H === 0)
                return false;
              let pe = oe.getParentNode().children[H - 1];
              return U3(pe) === "next";
            }
            function Ne(oe) {
              return `[${t4(oe.label)}]`;
            }
            function Pe(oe) {
              return `[^${oe.label}]`;
            }
            r.exports = { preprocess: o, print: Q, embed: D, massageAstNode: d, hasPrettierIgnore: Re, insertPragma: T };
          } }), Dg = te({ "src/language-markdown/options.js"(e, r) {
            "use strict";
            ne();
            var t4 = Mt();
            r.exports = { proseWrap: t4.proseWrap, singleQuote: t4.singleQuote };
          } }), mg = te({ "src/language-markdown/parsers.js"() {
            ne();
          } }), _a = te({ "node_modules/linguist-languages/data/Markdown.json"(e, r) {
            r.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
          } }), dg = te({ "src/language-markdown/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = _t(), s = fg(), a = Dg(), n = mg(), u = [t4(_a(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p) => p !== ".mdx") })), t4(_a(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
            r.exports = { languages: u, options: a, printers: i, parsers: n };
          } }), gg = te({ "src/language-html/clean.js"(e, r) {
            "use strict";
            ne();
            var { isFrontMatterNode: t4 } = Ue(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
            function a(n, u) {
              if (n.type === "text" || n.type === "comment" || t4(n) || n.type === "yaml" || n.type === "toml")
                return null;
              n.type === "attribute" && delete u.value, n.type === "docType" && delete u.value;
            }
            a.ignoredProperties = s, r.exports = a;
          } }), yg = te({ "src/language-html/constants.evaluate.js"(e, r) {
            r.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
          } }), hg = te({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
            "use strict";
            ne();
            function t4(s) {
              return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
            }
            r.exports = t4;
          } }), Rt = te({ "src/language-html/utils/index.js"(e, r) {
            "use strict";
            ne();
            var { inferParserByLanguage: t4, isFrontMatterNode: s } = Ue(), { builders: { line: a, hardline: n, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: p, CSS_DISPLAY_DEFAULT: y, CSS_WHITE_SPACE_TAGS: h2, CSS_WHITE_SPACE_DEFAULT: g } = yg(), c = hg(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), F4 = (A) => A.replace(/^[\t\n\f\r ]+/, ""), _ = (A) => A.replace(/[\t\n\f\r ]+$/, ""), w = (A) => F4(_(A)), E = (A) => A.replace(/^[\t\f\r ]*\n/g, ""), N6 = (A) => E(_(A)), x = (A) => A.split(/[\t\n\f\r ]+/), I = (A) => A.match(/^[\t\n\f\r ]*/)[0], P = (A) => {
              let [, G, re, ye] = A.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
              return { leadingWhitespace: G, trailingWhitespace: ye, text: re };
            }, $ = (A) => /[\t\n\f\r ]/.test(A);
            function D(A, G) {
              return !!(A.type === "ieConditionalComment" && A.lastChild && !A.lastChild.isSelfClosing && !A.lastChild.endSourceSpan || A.type === "ieConditionalComment" && !A.complete || se(A) && A.children.some((re) => re.type !== "text" && re.type !== "interpolation") || X(A, G) && !o(A) && A.type !== "interpolation");
            }
            function T(A) {
              return A.type === "attribute" || !A.parent || !A.prev ? false : m(A.prev);
            }
            function m(A) {
              return A.type === "comment" && A.value.trim() === "prettier-ignore";
            }
            function C(A) {
              return A.type === "text" || A.type === "comment";
            }
            function o(A) {
              return A.type === "element" && (A.fullName === "script" || A.fullName === "style" || A.fullName === "svg:style" || c(A) && (A.name === "script" || A.name === "style"));
            }
            function d(A) {
              return A.children && !o(A);
            }
            function v(A) {
              return o(A) || A.type === "interpolation" || S(A);
            }
            function S(A) {
              return we(A).startsWith("pre");
            }
            function b(A, G) {
              let re = ye();
              if (re && !A.prev && A.parent && A.parent.tagDefinition && A.parent.tagDefinition.ignoreFirstLf)
                return A.type === "interpolation";
              return re;
              function ye() {
                return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.prev && (A.prev.type === "text" || A.prev.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.prev && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !ue(A.parent.cssDisplay)) || A.prev && !U3(A.prev.cssDisplay));
              }
            }
            function B(A, G) {
              return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.next && (A.next.type === "text" || A.next.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.next && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !Fe(A.parent.cssDisplay)) || A.next && !z(A.next.cssDisplay));
            }
            function k(A) {
              return Z(A.cssDisplay) && !o(A);
            }
            function M(A) {
              return s(A) || A.next && A.sourceSpan.end && A.sourceSpan.end.line + 1 < A.next.sourceSpan.start.line;
            }
            function R4(A) {
              return q(A) || A.type === "element" && A.children.length > 0 && (["body", "script", "style"].includes(A.name) || A.children.some((G) => ee(G))) || A.firstChild && A.firstChild === A.lastChild && A.firstChild.type !== "text" && V(A.firstChild) && (!A.lastChild.isTrailingSpaceSensitive || j(A.lastChild));
            }
            function q(A) {
              return A.type === "element" && A.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A.name) || A.cssDisplay.startsWith("table") && A.cssDisplay !== "table-cell");
            }
            function J(A) {
              return Y(A) || A.prev && L(A.prev) || Q(A);
            }
            function L(A) {
              return Y(A) || A.type === "element" && A.fullName === "br" || Q(A);
            }
            function Q(A) {
              return V(A) && j(A);
            }
            function V(A) {
              return A.hasLeadingSpaces && (A.prev ? A.prev.sourceSpan.end.line < A.sourceSpan.start.line : A.parent.type === "root" || A.parent.startSourceSpan.end.line < A.sourceSpan.start.line);
            }
            function j(A) {
              return A.hasTrailingSpaces && (A.next ? A.next.sourceSpan.start.line > A.sourceSpan.end.line : A.parent.type === "root" || A.parent.endSourceSpan && A.parent.endSourceSpan.start.line > A.sourceSpan.end.line);
            }
            function Y(A) {
              switch (A.type) {
                case "ieConditionalComment":
                case "comment":
                case "directive":
                  return true;
                case "element":
                  return ["script", "select"].includes(A.name);
              }
              return false;
            }
            function ie(A) {
              return A.lastChild ? ie(A.lastChild) : A;
            }
            function ee(A) {
              return A.children && A.children.some((G) => G.type !== "text");
            }
            function ce(A) {
              let { type: G, lang: re } = A.attrMap;
              if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || re === "jsx")
                return "babel";
              if (G === "application/x-typescript" || re === "ts" || re === "tsx")
                return "typescript";
              if (G === "text/markdown")
                return "markdown";
              if (G === "text/html")
                return "html";
              if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules")
                return "json";
              if (G === "text/x-handlebars-template")
                return "glimmer";
            }
            function W(A, G) {
              let { lang: re } = A.attrMap;
              if (!re || re === "postcss" || re === "css")
                return "css";
              if (re === "scss")
                return "scss";
              if (re === "less")
                return "less";
              if (re === "stylus")
                return t4("stylus", G);
            }
            function K(A, G) {
              if (A.name === "script" && !A.attrMap.src)
                return !A.attrMap.lang && !A.attrMap.type ? "babel" : ce(A);
              if (A.name === "style")
                return W(A, G);
              if (G && X(A, G))
                return ce(A) || !("src" in A.attrMap) && t4(A.attrMap.lang, G);
            }
            function de(A) {
              return A === "block" || A === "list-item" || A.startsWith("table");
            }
            function ue(A) {
              return !de(A) && A !== "inline-block";
            }
            function Fe(A) {
              return !de(A) && A !== "inline-block";
            }
            function z(A) {
              return !de(A);
            }
            function U3(A) {
              return !de(A);
            }
            function Z(A) {
              return !de(A) && A !== "inline-block";
            }
            function se(A) {
              return we(A).startsWith("pre");
            }
            function fe(A, G) {
              let re = 0;
              for (let ye = A.stack.length - 1; ye >= 0; ye--) {
                let Ce = A.stack[ye];
                Ce && typeof Ce == "object" && !Array.isArray(Ce) && G(Ce) && re++;
              }
              return re;
            }
            function ge(A, G) {
              let re = A;
              for (; re; ) {
                if (G(re))
                  return true;
                re = re.parent;
              }
              return false;
            }
            function he(A, G) {
              if (A.prev && A.prev.type === "comment") {
                let ye = A.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
                if (ye)
                  return ye[1];
              }
              let re = false;
              if (A.type === "element" && A.namespace === "svg")
                if (ge(A, (ye) => ye.fullName === "svg:foreignObject"))
                  re = true;
                else
                  return A.name === "svg" ? "inline-block" : "block";
              switch (G.htmlWhitespaceSensitivity) {
                case "strict":
                  return "inline";
                case "ignore":
                  return "block";
                default:
                  return G.parser === "vue" && A.parent && A.parent.type === "root" ? "block" : A.type === "element" && (!A.namespace || re || c(A)) && p[A.name] || y;
              }
            }
            function we(A) {
              return A.type === "element" && (!A.namespace || c(A)) && h2[A.name] || g;
            }
            function ke(A) {
              let G = Number.POSITIVE_INFINITY;
              for (let re of A.split(`
`)) {
                if (re.length === 0)
                  continue;
                if (!f.has(re[0]))
                  return 0;
                let ye = I(re).length;
                re.length !== ye && ye < G && (G = ye);
              }
              return G === Number.POSITIVE_INFINITY ? 0 : G;
            }
            function Re(A) {
              let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke(A);
              return G === 0 ? A : A.split(`
`).map((re) => re.slice(G)).join(`
`);
            }
            function Ne(A, G) {
              let re = 0;
              for (let ye = 0; ye < A.length; ye++)
                A[ye] === G && re++;
              return re;
            }
            function Pe(A) {
              return A.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
            }
            var oe = /* @__PURE__ */ new Set(["template", "style", "script"]);
            function H(A, G) {
              return pe(A, G) && !oe.has(A.fullName);
            }
            function pe(A, G) {
              return G.parser === "vue" && A.type === "element" && A.parent.type === "root" && A.fullName.toLowerCase() !== "html";
            }
            function X(A, G) {
              return pe(A, G) && (H(A, G) || A.attrMap.lang && A.attrMap.lang !== "html");
            }
            function le(A) {
              let G = A.fullName;
              return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
            }
            function Ae(A, G) {
              let re = A.parent;
              if (!pe(re, G))
                return false;
              let ye = re.fullName, Ce = A.fullName;
              return ye === "script" && Ce === "setup" || ye === "style" && Ce === "vars";
            }
            function Ee(A) {
              let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.value;
              return A.parent.isWhitespaceSensitive ? A.parent.isIndentationSensitive ? l(G) : l(Re(N6(G)), n) : i(u(a, x(G)));
            }
            function De(A, G) {
              return pe(A, G) && A.name === "script";
            }
            r.exports = { htmlTrim: w, htmlTrimPreserveIndentation: N6, hasHtmlWhitespace: $, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: d, countChars: Ne, countParents: fe, dedentString: Re, forceBreakChildren: q, forceBreakContent: R4, forceNextEmptyLine: M, getLastDescendant: ie, getNodeCssStyleDisplay: he, getNodeCssStyleWhiteSpace: we, hasPrettierIgnore: T, inferScriptParser: K, isVueCustomBlock: H, isVueNonHtmlBlock: X, isVueScriptTag: De, isVueSlotAttribute: le, isVueSfcBindingsAttribute: Ae, isVueSfcBlock: pe, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se, isScriptLikeTag: o, isTextLikeNode: C, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v, isUnknownNamespace: c, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe, getTextValueParts: Ee };
          } }), vg = te({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
            function r(i) {
              return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
            }
            e.isWhitespace = r;
            function t4(i) {
              return e.$0 <= i && i <= e.$9;
            }
            e.isDigit = t4;
            function s(i) {
              return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
            }
            e.isAsciiLetter = s;
            function a(i) {
              return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t4(i);
            }
            e.isAsciiHexDigit = a;
            function n(i) {
              return i === e.$LF || i === e.$CR;
            }
            e.isNewLine = n;
            function u(i) {
              return e.$0 <= i && i <= e.$7;
            }
            e.isOctalDigit = u;
          } }), Cg = te({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = class {
              constructor(s, a, n) {
                this.filePath = s, this.name = a, this.members = n;
              }
              assertNoMembers() {
                if (this.members.length)
                  throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
              }
            };
            e.StaticSymbol = r;
            var t4 = class {
              constructor() {
                this.cache = /* @__PURE__ */ new Map();
              }
              get(s, a, n) {
                n = n || [];
                let u = n.length ? `.${n.join(".")}` : "", i = `"${s}".${a}${u}`, l = this.cache.get(i);
                return l || (l = new r(s, a, n), this.cache.set(i, l)), l;
              }
            };
            e.StaticSymbolCache = t4;
          } }), Eg = te({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = /-+([a-z0-9])/g;
            function t4(o) {
              return o.replace(r, function() {
                for (var d = arguments.length, v = new Array(d), S = 0; S < d; S++)
                  v[S] = arguments[S];
                return v[1].toUpperCase();
              });
            }
            e.dashCaseToCamelCase = t4;
            function s(o, d) {
              return n(o, ":", d);
            }
            e.splitAtColon = s;
            function a(o, d) {
              return n(o, ".", d);
            }
            e.splitAtPeriod = a;
            function n(o, d, v) {
              let S = o.indexOf(d);
              return S == -1 ? v : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
            }
            function u(o, d, v) {
              return Array.isArray(o) ? d.visitArray(o, v) : E(o) ? d.visitStringMap(o, v) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d.visitPrimitive(o, v) : d.visitOther(o, v);
            }
            e.visitValue = u;
            function i(o) {
              return o != null;
            }
            e.isDefined = i;
            function l(o) {
              return o === void 0 ? null : o;
            }
            e.noUndefined = l;
            var p = class {
              visitArray(o, d) {
                return o.map((v) => u(v, this, d));
              }
              visitStringMap(o, d) {
                let v = {};
                return Object.keys(o).forEach((S) => {
                  v[S] = u(o[S], this, d);
                }), v;
              }
              visitPrimitive(o, d) {
                return o;
              }
              visitOther(o, d) {
                return o;
              }
            };
            e.ValueTransformer = p, e.SyncAsync = { assertSync: (o) => {
              if (P(o))
                throw new Error("Illegal state: value cannot be a promise");
              return o;
            }, then: (o, d) => P(o) ? o.then(d) : d(o), all: (o) => o.some(P) ? Promise.all(o) : o };
            function y(o) {
              throw new Error(`Internal Error: ${o}`);
            }
            e.error = y;
            function h2(o, d) {
              let v = Error(o);
              return v[g] = true, d && (v[c] = d), v;
            }
            e.syntaxError = h2;
            var g = "ngSyntaxError", c = "ngParseErrors";
            function f(o) {
              return o[g];
            }
            e.isSyntaxError = f;
            function F4(o) {
              return o[c] || [];
            }
            e.getParseErrors = F4;
            function _(o) {
              return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
            }
            e.escapeRegExp = _;
            var w = Object.getPrototypeOf({});
            function E(o) {
              return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w;
            }
            function N6(o) {
              let d = "";
              for (let v = 0; v < o.length; v++) {
                let S = o.charCodeAt(v);
                if (S >= 55296 && S <= 56319 && o.length > v + 1) {
                  let b = o.charCodeAt(v + 1);
                  b >= 56320 && b <= 57343 && (v++, S = (S - 55296 << 10) + b - 56320 + 65536);
                }
                S <= 127 ? d += String.fromCharCode(S) : S <= 2047 ? d += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? d += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (d += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
              }
              return d;
            }
            e.utf8Encode = N6;
            function x(o) {
              if (typeof o == "string")
                return o;
              if (o instanceof Array)
                return "[" + o.map(x).join(", ") + "]";
              if (o == null)
                return "" + o;
              if (o.overriddenName)
                return `${o.overriddenName}`;
              if (o.name)
                return `${o.name}`;
              if (!o.toString)
                return "object";
              let d = o.toString();
              if (d == null)
                return "" + d;
              let v = d.indexOf(`
`);
              return v === -1 ? d : d.substring(0, v);
            }
            e.stringify = x;
            function I(o) {
              return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
            }
            e.resolveForwardRef = I;
            function P(o) {
              return !!o && typeof o.then == "function";
            }
            e.isPromise = P;
            var $ = class {
              constructor(o) {
                this.full = o;
                let d = o.split(".");
                this.major = d[0], this.minor = d[1], this.patch = d.slice(2).join(".");
              }
            };
            e.Version = $;
            var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, C = m || D || T;
            e.global = C;
          } }), Fg = te({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Cg(), t4 = Eg(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
            function a(v) {
              return v.replace(/\W/g, "_");
            }
            e.sanitizeIdentifier = a;
            var n = 0;
            function u(v) {
              if (!v || !v.reference)
                return null;
              let S = v.reference;
              if (S instanceof r.StaticSymbol)
                return S.name;
              if (S.__anonymousType)
                return S.__anonymousType;
              let b = t4.stringify(S);
              return b.indexOf("(") >= 0 ? (b = `anonymous_${n++}`, S.__anonymousType = b) : b = a(b), b;
            }
            e.identifierName = u;
            function i(v) {
              let S = v.reference;
              return S instanceof r.StaticSymbol ? S.filePath : `./${t4.stringify(S)}`;
            }
            e.identifierModuleUrl = i;
            function l(v, S) {
              return `View_${u({ reference: v })}_${S}`;
            }
            e.viewClassName = l;
            function p(v) {
              return `RenderType_${u({ reference: v })}`;
            }
            e.rendererTypeName = p;
            function y(v) {
              return `HostView_${u({ reference: v })}`;
            }
            e.hostViewClassName = y;
            function h2(v) {
              return `${u({ reference: v })}NgFactory`;
            }
            e.componentFactoryName = h2;
            var g;
            (function(v) {
              v[v.Pipe = 0] = "Pipe", v[v.Directive = 1] = "Directive", v[v.NgModule = 2] = "NgModule", v[v.Injectable = 3] = "Injectable";
            })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
            function c(v) {
              return v.value != null ? a(v.value) : u(v.identifier);
            }
            e.tokenName = c;
            function f(v) {
              return v.identifier != null ? v.identifier.reference : v.value;
            }
            e.tokenReference = f;
            var F4 = class {
              constructor() {
                let { moduleUrl: v, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.moduleUrl = v || null, this.styles = P(S), this.styleUrls = P(b);
              }
            };
            e.CompileStylesheetMetadata = F4;
            var _ = class {
              constructor(v) {
                let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M, styleUrls: R4, externalStylesheets: q, animations: J, ngContentSelectors: L, interpolation: Q, isInline: V, preserveWhitespaces: j } = v;
                if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M), this.styleUrls = P(R4), this.externalStylesheets = P(q), this.animations = J ? D(J) : [], this.ngContentSelectors = L || [], Q && Q.length != 2)
                  throw new Error("'interpolation' should have a start and an end symbol.");
                this.interpolation = Q, this.isInline = V, this.preserveWhitespaces = j;
              }
              toSummary() {
                return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
              }
            };
            e.CompileTemplateMetadata = _;
            var w = class {
              static create(v) {
                let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R4, inputs: q, outputs: J, host: L, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de } = v, ue = {}, Fe = {}, z = {};
                L != null && Object.keys(L).forEach((se) => {
                  let fe = L[se], ge = se.match(s);
                  ge === null ? z[se] = fe : ge[1] != null ? Fe[ge[1]] = fe : ge[2] != null && (ue[ge[2]] = fe);
                });
                let U3 = {};
                q != null && q.forEach((se) => {
                  let fe = t4.splitAtColon(se, [se, se]);
                  U3[fe[0]] = fe[1];
                });
                let Z = {};
                return J != null && J.forEach((se) => {
                  let fe = t4.splitAtColon(se, [se, se]);
                  Z[fe[0]] = fe[1];
                }), new w({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M, changeDetection: R4, inputs: U3, outputs: Z, hostListeners: ue, hostProperties: Fe, hostAttributes: z, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de });
              }
              constructor(v) {
                let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R4, inputs: q, outputs: J, hostListeners: L, hostProperties: Q, hostAttributes: V, providers: j, viewProviders: Y, queries: ie, guards: ee, viewQueries: ce, entryComponents: W, template: K, componentViewType: de, rendererType: ue, componentFactory: Fe } = v;
                this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M, this.changeDetection = R4, this.inputs = q, this.outputs = J, this.hostListeners = L, this.hostProperties = Q, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie), this.guards = ee, this.viewQueries = P(ce), this.entryComponents = P(W), this.template = K, this.componentViewType = de, this.rendererType = ue, this.componentFactory = Fe;
              }
              toSummary() {
                return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
              }
            };
            e.CompileDirectiveMetadata = w;
            var E = class {
              constructor(v) {
                let { type: S, name: b, pure: B } = v;
                this.type = S, this.name = b, this.pure = !!B;
              }
              toSummary() {
                return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
              }
            };
            e.CompilePipeMetadata = E;
            var N6 = class {
            };
            e.CompileShallowModuleMetadata = N6;
            var x = class {
              constructor(v) {
                let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M, exportedPipes: R4, entryComponents: q, bootstrapComponents: J, importedModules: L, exportedModules: Q, schemas: V, transitiveModule: j, id: Y } = v;
                this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M), this.exportedPipes = P(R4), this.providers = P(b), this.entryComponents = P(q), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Q), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;
              }
              toSummary() {
                let v = this.transitiveModule;
                return { summaryKind: g.NgModule, type: this.type, entryComponents: v.entryComponents, providers: v.providers, modules: v.modules, exportedDirectives: v.exportedDirectives, exportedPipes: v.exportedPipes };
              }
            };
            e.CompileNgModuleMetadata = x;
            var I = class {
              constructor() {
                this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
              }
              addProvider(v, S) {
                this.providers.push({ provider: v, module: S });
              }
              addDirective(v) {
                this.directivesSet.has(v.reference) || (this.directivesSet.add(v.reference), this.directives.push(v));
              }
              addExportedDirective(v) {
                this.exportedDirectivesSet.has(v.reference) || (this.exportedDirectivesSet.add(v.reference), this.exportedDirectives.push(v));
              }
              addPipe(v) {
                this.pipesSet.has(v.reference) || (this.pipesSet.add(v.reference), this.pipes.push(v));
              }
              addExportedPipe(v) {
                this.exportedPipesSet.has(v.reference) || (this.exportedPipesSet.add(v.reference), this.exportedPipes.push(v));
              }
              addModule(v) {
                this.modulesSet.has(v.reference) || (this.modulesSet.add(v.reference), this.modules.push(v));
              }
              addEntryComponent(v) {
                this.entryComponentsSet.has(v.componentType) || (this.entryComponentsSet.add(v.componentType), this.entryComponents.push(v));
              }
            };
            e.TransitiveCompileNgModuleMetadata = I;
            function P(v) {
              return v || [];
            }
            var $ = class {
              constructor(v, S) {
                let { useClass: b, useValue: B, useExisting: k, useFactory: M, deps: R4, multi: q } = S;
                this.token = v, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M || null, this.dependencies = R4 || null, this.multi = !!q;
              }
            };
            e.ProviderMeta = $;
            function D(v) {
              return v.reduce((S, b) => {
                let B = Array.isArray(b) ? D(b) : b;
                return S.concat(B);
              }, []);
            }
            e.flatten = D;
            function T(v) {
              return v.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
            }
            function m(v, S, b) {
              let B;
              return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);
            }
            e.templateSourceUrl = m;
            function C(v, S) {
              let b = v.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
              return T(`css/${S}${B}.ngstyle.js`);
            }
            e.sharedStylesheetJitUrl = C;
            function o(v) {
              return T(`${u(v.type)}/module.ngfactory.js`);
            }
            e.ngModuleJitUrl = o;
            function d(v, S) {
              return T(`${u(v)}/${u(S.type)}.ngfactory.js`);
            }
            e.templateJitUrl = d;
          } }), Ag = te({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = vg(), t4 = Fg(), s = class {
              constructor(y, h2, g, c) {
                this.file = y, this.offset = h2, this.line = g, this.col = c;
              }
              toString() {
                return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
              }
              moveBy(y) {
                let h2 = this.file.content, g = h2.length, c = this.offset, f = this.line, F4 = this.col;
                for (; c > 0 && y < 0; )
                  if (c--, y++, h2.charCodeAt(c) == r.$LF) {
                    f--;
                    let w = h2.substr(0, c - 1).lastIndexOf(String.fromCharCode(r.$LF));
                    F4 = w > 0 ? c - w : c;
                  } else
                    F4--;
                for (; c < g && y > 0; ) {
                  let _ = h2.charCodeAt(c);
                  c++, y--, _ == r.$LF ? (f++, F4 = 0) : F4++;
                }
                return new s(this.file, c, f, F4);
              }
              getContext(y, h2) {
                let g = this.file.content, c = this.offset;
                if (c != null) {
                  c > g.length - 1 && (c = g.length - 1);
                  let f = c, F4 = 0, _ = 0;
                  for (; F4 < y && c > 0 && (c--, F4++, !(g[c] == `
` && ++_ == h2)); )
                    ;
                  for (F4 = 0, _ = 0; F4 < y && f < g.length - 1 && (f++, F4++, !(g[f] == `
` && ++_ == h2)); )
                    ;
                  return { before: g.substring(c, this.offset), after: g.substring(this.offset, f + 1) };
                }
                return null;
              }
            };
            e.ParseLocation = s;
            var a = class {
              constructor(y, h2) {
                this.content = y, this.url = h2;
              }
            };
            e.ParseSourceFile = a;
            var n = class {
              constructor(y, h2) {
                let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                this.start = y, this.end = h2, this.details = g;
              }
              toString() {
                return this.start.file.content.substring(this.start.offset, this.end.offset);
              }
            };
            e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
            var u;
            (function(y) {
              y[y.WARNING = 0] = "WARNING", y[y.ERROR = 1] = "ERROR";
            })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
            var i = class {
              constructor(y, h2) {
                let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
                this.span = y, this.msg = h2, this.level = g;
              }
              contextualMessage() {
                let y = this.span.start.getContext(100, 3);
                return y ? `${this.msg} ("${y.before}[${u[this.level]} ->]${y.after}")` : this.msg;
              }
              toString() {
                let y = this.span.details ? `, ${this.span.details}` : "";
                return `${this.contextualMessage()}: ${this.span.start}${y}`;
              }
            };
            e.ParseError = i;
            function l(y, h2) {
              let g = t4.identifierModuleUrl(h2), c = g != null ? `in ${y} ${t4.identifierName(h2)} in ${g}` : `in ${y} ${t4.identifierName(h2)}`, f = new a("", c);
              return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
            }
            e.typeSourceSpan = l;
            function p(y, h2, g) {
              let c = `in ${y} ${h2} in ${g}`, f = new a("", c);
              return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
            }
            e.r3JitTypeSourceSpan = p;
          } }), Sg = te({ "src/language-html/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            var { ParseSourceSpan: t4 } = Ag(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: n, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p, isLeadingSpaceSensitiveNode: y, isTrailingSpaceSensitiveNode: h2, isWhitespaceSensitiveNode: g, isVueScriptTag: c } = Rt(), f = [_, w, N6, I, P, T, $, D, m, x, C];
            function F4(o, d) {
              for (let v of f)
                v(o, d);
              return o;
            }
            function _(o) {
              o.walk((d) => {
                if (d.type === "element" && d.tagDefinition.ignoreFirstLf && d.children.length > 0 && d.children[0].type === "text" && d.children[0].value[0] === `
`) {
                  let v = d.children[0];
                  v.value.length === 1 ? d.removeChild(v) : v.value = v.value.slice(1);
                }
              });
            }
            function w(o) {
              let d = (v) => v.type === "element" && v.prev && v.prev.type === "ieConditionalStartComment" && v.prev.sourceSpan.end.offset === v.startSourceSpan.start.offset && v.firstChild && v.firstChild.type === "ieConditionalEndComment" && v.firstChild.sourceSpan.start.offset === v.startSourceSpan.end.offset;
              o.walk((v) => {
                if (v.children)
                  for (let S = 0; S < v.children.length; S++) {
                    let b = v.children[S];
                    if (!d(b))
                      continue;
                    let B = b.prev, k = b.firstChild;
                    v.removeChild(B), S--;
                    let M = new t4(B.sourceSpan.start, k.sourceSpan.end), R4 = new t4(M.start, b.sourceSpan.end);
                    b.condition = B.condition, b.sourceSpan = R4, b.startSourceSpan = M, b.removeChild(k);
                  }
              });
            }
            function E(o, d, v) {
              o.walk((S) => {
                if (S.children)
                  for (let b = 0; b < S.children.length; b++) {
                    let B = S.children[b];
                    if (B.type !== "text" && !d(B))
                      continue;
                    B.type !== "text" && (B.type = "text", B.value = v(B));
                    let k = B.prev;
                    !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t4(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
                  }
              });
            }
            function N6(o) {
              return E(o, (d) => d.type === "cdata", (d) => `<![CDATA[${d.value}]]>`);
            }
            function x(o) {
              let d = (v) => v.type === "element" && v.attrs.length === 0 && v.children.length === 1 && v.firstChild.type === "text" && !n(v.children[0].value) && !v.firstChild.hasLeadingSpaces && !v.firstChild.hasTrailingSpaces && v.isLeadingSpaceSensitive && !v.hasLeadingSpaces && v.isTrailingSpaceSensitive && !v.hasTrailingSpaces && v.prev && v.prev.type === "text" && v.next && v.next.type === "text";
              o.walk((v) => {
                if (v.children)
                  for (let S = 0; S < v.children.length; S++) {
                    let b = v.children[S];
                    if (!d(b))
                      continue;
                    let B = b.prev, k = b.next;
                    B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t4(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v.removeChild(b), S--, v.removeChild(k);
                  }
              });
            }
            function I(o, d) {
              if (d.parser === "html")
                return;
              let v = /{{(.+?)}}/s;
              o.walk((S) => {
                if (u(S))
                  for (let b of S.children) {
                    if (b.type !== "text")
                      continue;
                    let B = b.sourceSpan.start, k = null, M = b.value.split(v);
                    for (let R4 = 0; R4 < M.length; R4++, B = k) {
                      let q = M[R4];
                      if (R4 % 2 === 0) {
                        k = B.moveBy(q.length), q.length > 0 && S.insertChildBefore(b, { type: "text", value: q, sourceSpan: new t4(B, k) });
                        continue;
                      }
                      k = B.moveBy(q.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t4(B, k), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t4(B.moveBy(2), k.moveBy(-2)) }] });
                    }
                    S.removeChild(b);
                  }
              });
            }
            function P(o) {
              o.walk((d) => {
                if (!d.children)
                  return;
                if (d.children.length === 0 || d.children.length === 1 && d.children[0].type === "text" && s(d.children[0].value).length === 0) {
                  d.hasDanglingSpaces = d.children.length > 0, d.children = [];
                  return;
                }
                let v = g(d), S = p(d);
                if (!v)
                  for (let b = 0; b < d.children.length; b++) {
                    let B = d.children[b];
                    if (B.type !== "text")
                      continue;
                    let { leadingWhitespace: k, text: M, trailingWhitespace: R4 } = a(B.value), q = B.prev, J = B.next;
                    M ? (B.value = M, B.sourceSpan = new t4(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R4.length)), k && (q && (q.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R4 && (B.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (d.removeChild(B), b--, (k || R4) && (q && (q.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
                  }
                d.isWhitespaceSensitive = v, d.isIndentationSensitive = S;
              });
            }
            function $(o) {
              o.walk((d) => {
                d.isSelfClosing = !d.children || d.type === "element" && (d.tagDefinition.isVoid || d.startSourceSpan === d.endSourceSpan);
              });
            }
            function D(o, d) {
              o.walk((v) => {
                v.type === "element" && (v.hasHtmComponentClosingTag = v.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d.originalText.slice(v.endSourceSpan.start.offset, v.endSourceSpan.end.offset)));
              });
            }
            function T(o, d) {
              o.walk((v) => {
                v.cssDisplay = i(v, d);
              });
            }
            function m(o, d) {
              o.walk((v) => {
                let { children: S } = v;
                if (S) {
                  if (S.length === 0) {
                    v.isDanglingSpaceSensitive = l(v);
                    return;
                  }
                  for (let b of S)
                    b.isLeadingSpaceSensitive = y(b, d), b.isTrailingSpaceSensitive = h2(b, d);
                  for (let b = 0; b < S.length; b++) {
                    let B = S[b];
                    B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
                  }
                }
              });
            }
            function C(o, d) {
              if (d.parser === "vue") {
                let v = o.children.find((b) => c(b, d));
                if (!v)
                  return;
                let { lang: S } = v.attrMap;
                (S === "ts" || S === "typescript") && (d.__should_parse_vue_template_with_ts = true);
              }
            }
            r.exports = F4;
          } }), xg = te({ "src/language-html/pragma.js"(e, r) {
            "use strict";
            ne();
            function t4(a) {
              return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
            }
            function s(a) {
              return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
            }
            r.exports = { hasPragma: t4, insertPragma: s };
          } }), au = te({ "src/language-html/loc.js"(e, r) {
            "use strict";
            ne();
            function t4(a) {
              return a.sourceSpan.start.offset;
            }
            function s(a) {
              return a.sourceSpan.end.offset;
            }
            r.exports = { locStart: t4, locEnd: s };
          } }), ur = te({ "src/language-html/print/tag.js"(e, r) {
            "use strict";
            ne();
            var t4 = Zt(), { isNonEmptyArray: s } = Ue(), { builders: { indent: a, join: n, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: p } } = qe(), { locStart: y, locEnd: h2 } = au(), { isTextLikeNode: g, getLastDescendant: c, isPreLikeNode: f, hasPrettierIgnore: F4, shouldPreserveContent: _, isVueSfcBlock: w } = Rt();
            function E(L, Q) {
              return [L.isSelfClosing ? "" : N6(L, Q), x(L, Q)];
            }
            function N6(L, Q) {
              return L.lastChild && o(L.lastChild) ? "" : [I(L, Q), $(L, Q)];
            }
            function x(L, Q) {
              return (L.next ? m(L.next) : C(L.parent)) ? "" : [D(L, Q), P(L, Q)];
            }
            function I(L, Q) {
              return C(L) ? D(L.lastChild, Q) : "";
            }
            function P(L, Q) {
              return o(L) ? $(L.parent, Q) : d(L) ? q(L.next) : "";
            }
            function $(L, Q) {
              if (t4(!L.isSelfClosing), T(L, Q))
                return "";
              switch (L.type) {
                case "ieConditionalComment":
                  return "<!";
                case "element":
                  if (L.hasHtmComponentClosingTag)
                    return "<//";
                default:
                  return `</${L.rawName}`;
              }
            }
            function D(L, Q) {
              if (T(L, Q))
                return "";
              switch (L.type) {
                case "ieConditionalComment":
                case "ieConditionalEndComment":
                  return "[endif]-->";
                case "ieConditionalStartComment":
                  return "]><!-->";
                case "interpolation":
                  return "}}";
                case "element":
                  if (L.isSelfClosing)
                    return "/>";
                default:
                  return ">";
              }
            }
            function T(L, Q) {
              return !L.isSelfClosing && !L.endSourceSpan && (F4(L) || _(L.parent, Q));
            }
            function m(L) {
              return L.prev && L.prev.type !== "docType" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
            }
            function C(L) {
              return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(c(L.lastChild)) && !f(L);
            }
            function o(L) {
              return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(c(L));
            }
            function d(L) {
              return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
            }
            function v(L) {
              let Q = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
              return Q ? Q[1] ? Q[1].split(/\s+/) : true : false;
            }
            function S(L) {
              return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
            }
            function b(L, Q, V) {
              let j = L.getValue();
              if (!s(j.attrs))
                return j.isSelfClosing ? " " : "";
              let Y = j.prev && j.prev.type === "comment" && v(j.prev.value), ie = typeof Y == "boolean" ? () => Y : Array.isArray(Y) ? (ue) => Y.includes(ue.rawName) : () => false, ee = L.map((ue) => {
                let Fe = ue.getValue();
                return ie(Fe) ? p(Q.originalText.slice(y(Fe), h2(Fe))) : V();
              }, "attrs"), ce = j.type === "element" && j.fullName === "script" && j.attrs.length === 1 && j.attrs[0].fullName === "src" && j.children.length === 0, K = Q.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q) ? l : u, de = [a([ce ? " " : u, n(K, ee)])];
              return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce ? de.push(j.isSelfClosing ? " " : "") : de.push(Q.bracketSameLine ? j.isSelfClosing ? " " : "" : j.isSelfClosing ? u : i), de;
            }
            function B(L) {
              return L.firstChild && S(L.firstChild) ? "" : J(L);
            }
            function k(L, Q, V) {
              let j = L.getValue();
              return [M(j, Q), b(L, Q, V), j.isSelfClosing ? "" : B(j)];
            }
            function M(L, Q) {
              return L.prev && d(L.prev) ? "" : [R4(L, Q), q(L)];
            }
            function R4(L, Q) {
              return S(L) ? J(L.parent) : m(L) ? D(L.prev, Q) : "";
            }
            function q(L) {
              switch (L.type) {
                case "ieConditionalComment":
                case "ieConditionalStartComment":
                  return `<!--[if ${L.condition}`;
                case "ieConditionalEndComment":
                  return "<!--<!";
                case "interpolation":
                  return "{{";
                case "docType":
                  return "<!DOCTYPE";
                case "element":
                  if (L.condition)
                    return `<!--[if ${L.condition}]><!--><${L.rawName}`;
                default:
                  return `<${L.rawName}`;
              }
            }
            function J(L) {
              switch (t4(!L.isSelfClosing), L.type) {
                case "ieConditionalComment":
                  return "]>";
                case "element":
                  if (L.condition)
                    return "><!--<![endif]-->";
                default:
                  return ">";
              }
            }
            r.exports = { printClosingTag: E, printClosingTagStart: N6, printClosingTagStartMarker: $, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x, needsToBorrowLastChildClosingTagEndMarker: C, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: M, printOpeningTagPrefix: R4, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: d, needsToBorrowParentOpeningTagEndMarker: S };
          } }), bg = te({ "node_modules/parse-srcset/src/parse-srcset.js"(e, r) {
            ne(), function(t4, s) {
              typeof define == "function" && define.amd ? define([], s) : typeof r == "object" && r.exports ? r.exports = s() : t4.parseSrcset = s();
            }(e, function() {
              return function(t4, s) {
                var a = s && s.logger || console;
                function n($) {
                  return $ === " " || $ === "	" || $ === `
` || $ === "\f" || $ === "\r";
                }
                function u($) {
                  var D, T = $.exec(t4.substring(N6));
                  if (T)
                    return D = T[0], N6 += D.length, D;
                }
                for (var i = t4.length, l = /^[ \t\n\r\u000c]+/, p = /^[, \t\n\r\u000c]+/, y = /^[^ \t\n\r\u000c]+/, h2 = /[,]+$/, g = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, F4, _, w, E, N6 = 0, x = []; ; ) {
                  if (u(p), N6 >= i)
                    return x;
                  f = u(y), F4 = [], f.slice(-1) === "," ? (f = f.replace(h2, ""), P()) : I();
                }
                function I() {
                  for (u(l), _ = "", w = "in descriptor"; ; ) {
                    if (E = t4.charAt(N6), w === "in descriptor")
                      if (n(E))
                        _ && (F4.push(_), _ = "", w = "after descriptor");
                      else if (E === ",") {
                        N6 += 1, _ && F4.push(_), P();
                        return;
                      } else if (E === "(")
                        _ = _ + E, w = "in parens";
                      else if (E === "") {
                        _ && F4.push(_), P();
                        return;
                      } else
                        _ = _ + E;
                    else if (w === "in parens")
                      if (E === ")")
                        _ = _ + E, w = "in descriptor";
                      else if (E === "") {
                        F4.push(_), P();
                        return;
                      } else
                        _ = _ + E;
                    else if (w === "after descriptor" && !n(E))
                      if (E === "") {
                        P();
                        return;
                      } else
                        w = "in descriptor", N6 -= 1;
                    N6 += 1;
                  }
                }
                function P() {
                  var $ = false, D, T, m, C, o = {}, d, v, S, b, B;
                  for (C = 0; C < F4.length; C++)
                    d = F4[C], v = d[d.length - 1], S = d.substring(0, d.length - 1), b = parseInt(S, 10), B = parseFloat(S), g.test(S) && v === "w" ? ((D || T) && ($ = true), b === 0 ? $ = true : D = b) : c.test(S) && v === "x" ? ((D || T || m) && ($ = true), B < 0 ? $ = true : T = B) : g.test(S) && v === "h" ? ((m || T) && ($ = true), b === 0 ? $ = true : m = b) : $ = true;
                  $ ? a && a.error && a.error("Invalid srcset descriptor found in '" + t4 + "' at '" + d + "'.") : (o.url = f, D && (o.w = D), T && (o.d = T), m && (o.h = m), x.push(o));
                }
              };
            });
          } }), Tg = te({ "src/language-html/syntax-attribute.js"(e, r) {
            "use strict";
            ne();
            var t4 = bg(), { builders: { ifBreak: s, join: a, line: n } } = qe();
            function u(l) {
              let p = t4(l, { logger: { error(I) {
                throw new Error(I);
              } } }), y = p.some((I) => {
                let { w: P } = I;
                return P;
              }), h2 = p.some((I) => {
                let { h: P } = I;
                return P;
              }), g = p.some((I) => {
                let { d: P } = I;
                return P;
              });
              if (y + h2 + g > 1)
                throw new Error("Mixed descriptor in srcset is not supported");
              let c = y ? "w" : h2 ? "h" : "d", f = y ? "w" : h2 ? "h" : "x", F4 = (I) => Math.max(...I), _ = p.map((I) => I.url), w = F4(_.map((I) => I.length)), E = p.map((I) => I[c]).map((I) => I ? I.toString() : ""), N6 = E.map((I) => {
                let P = I.indexOf(".");
                return P === -1 ? I.length : P;
              }), x = F4(N6);
              return a([",", n], _.map((I, P) => {
                let $ = [I], D = E[P];
                if (D) {
                  let T = w - I.length + 1, m = x - N6[P], C = " ".repeat(T + m);
                  $.push(s(C, " "), D + f);
                }
                return $;
              }));
            }
            function i(l) {
              return l.trim().split(/\s+/).join(" ");
            }
            r.exports = { printImgSrcset: u, printClassNames: i };
          } }), Bg = te({ "src/language-html/syntax-vue.js"(e, r) {
            "use strict";
            ne();
            var { builders: { group: t4 } } = qe();
            function s(i, l) {
              let { left: p, operator: y, right: h2 } = a(i);
              return [t4(l(`function _(${p}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y, " ", l(h2, { parser: "__js_expression" }, { stripTrailingHardline: true })];
            }
            function a(i) {
              let l = /(.*?)\s+(in|of)\s+(.*)/s, p = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y = /^\(|\)$/g, h2 = i.match(l);
              if (!h2)
                return;
              let g = {};
              if (g.for = h2[3].trim(), !g.for)
                return;
              let c = h2[1].trim().replace(y, ""), f = c.match(p);
              f ? (g.alias = c.replace(p, ""), g.iterator1 = f[1].trim(), f[2] && (g.iterator2 = f[2].trim())) : g.alias = c;
              let F4 = [g.alias, g.iterator1, g.iterator2];
              if (!F4.some((_, w) => !_ && (w === 0 || F4.slice(w + 1).some(Boolean))))
                return { left: F4.filter(Boolean).join(","), operator: h2[2], right: g.for };
            }
            function n(i, l) {
              return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
            }
            function u(i) {
              let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y = i.trim();
              return l.test(y) || p.test(y);
            }
            r.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: n };
          } }), Lo = te({ "src/language-html/get-node-content.js"(e, r) {
            "use strict";
            ne();
            var { needsToBorrowParentClosingTagStartMarker: t4, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: n, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = ur();
            function l(p, y) {
              let h2 = p.startSourceSpan.end.offset;
              p.firstChild && u(p.firstChild) && (h2 -= i(p).length);
              let g = p.endSourceSpan.start.offset;
              return p.lastChild && t4(p.lastChild) ? g += s(p, y).length : a(p) && (g -= n(p.lastChild, y).length), y.originalText.slice(h2, g);
            }
            r.exports = l;
          } }), Ng = te({ "src/language-html/embed.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t4, group: s, hardline: a, indent: n, line: u, fill: i, softline: l }, utils: { mapDoc: p, replaceTextEndOfLine: y } } = qe(), h2 = su(), { printClosingTag: g, printClosingTagSuffix: c, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: F4, printOpeningTag: _ } = ur(), { printImgSrcset: w, printClassNames: E } = Tg(), { printVueFor: N6, printVueBindings: x, isVueEventBindingExpression: I } = Bg(), { isScriptLikeTag: P, isVueNonHtmlBlock: $, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m, unescapeQuoteEntities: C, isVueSlotAttribute: o, isVueSfcBindingsAttribute: d, getTextValueParts: v } = Rt(), S = Lo();
            function b(k, M, R4) {
              let q = (ee) => new RegExp(ee.join("|")).test(k.fullName), J = () => C(k.value), L = false, Q = (ee, ce) => {
                let W = ee.type === "NGRoot" ? ee.node.type === "NGMicrosyntax" && ee.node.body.length === 1 && ee.node.body[0].type === "NGMicrosyntaxExpression" ? ee.node.body[0].expression : ee.node : ee.type === "JsExpressionRoot" ? ee.node : ee;
                W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
              }, V = (ee) => s(ee), j = function(ee) {
                let ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                return s([n([l, ee]), ce ? l : ""]);
              }, Y = (ee) => L ? V(ee) : j(ee), ie = (ee, ce) => M(ee, Object.assign({ __onHtmlBindingRoot: Q, __embeddedInHtml: true }, ce));
              if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source"))
                return j(w(J()));
              if (k.fullName === "class" && !R4.parentParser) {
                let ee = J();
                if (!ee.includes("{{"))
                  return E(ee);
              }
              if (k.fullName === "style" && !R4.parentParser) {
                let ee = J();
                if (!ee.includes("{{"))
                  return j(ie(ee, { parser: "css", __isHTMLStyleAttribute: true }));
              }
              if (R4.parser === "vue") {
                if (k.fullName === "v-for")
                  return N6(J(), ie);
                if (o(k) || d(k, R4))
                  return x(J(), ie);
                let ee = ["^@", "^v-on:"], ce = ["^:", "^v-bind:"], W = ["^v-"];
                if (q(ee)) {
                  let K = J(), de = I(K) ? "__js_expression" : R4.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                  return Y(ie(K, { parser: de }));
                }
                if (q(ce))
                  return Y(ie(J(), { parser: "__vue_expression" }));
                if (q(W))
                  return Y(ie(J(), { parser: "__js_expression" }));
              }
              if (R4.parser === "angular") {
                let ee = (z, U3) => ie(z, Object.assign(Object.assign({}, U3), {}, { trailingComma: "none" })), ce = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de = ["^i18n(-.+)?$"];
                if (q(W))
                  return Y(ee(J(), { parser: "__ng_action" }));
                if (q(K))
                  return Y(ee(J(), { parser: "__ng_binding" }));
                if (q(de)) {
                  let z = J().trim();
                  return j(i(v(k, z)), !z.includes("@@"));
                }
                if (q(ce))
                  return Y(ee(J(), { parser: "__ng_directive" }));
                let ue = /{{(.+?)}}/s, Fe = J();
                if (ue.test(Fe)) {
                  let z = [];
                  for (let [U3, Z] of Fe.split(ue).entries())
                    if (U3 % 2 === 0)
                      z.push(y(Z));
                    else
                      try {
                        z.push(s(["{{", n([u, ee(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                      } catch {
                        z.push("{{", y(Z), "}}");
                      }
                  return s(z);
                }
              }
              return null;
            }
            function B(k, M, R4, q) {
              let J = k.getValue();
              switch (J.type) {
                case "element": {
                  if (P(J) || J.type === "interpolation")
                    return;
                  if (!J.isSelfClosing && $(J, q)) {
                    let L = D(J, q);
                    if (!L)
                      return;
                    let Q = S(J, q), V = /^\s*$/.test(Q), j = "";
                    return V || (j = R4(T(Q), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j === ""), [F4(J, q), s(_(k, q, M)), V ? "" : a, j, V ? "" : a, g(J, q), c(J, q)];
                  }
                  break;
                }
                case "text": {
                  if (P(J.parent)) {
                    let L = D(J.parent, q);
                    if (L) {
                      let Q = L === "markdown" ? m(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
                      if (q.parser === "html" && L === "babel") {
                        let j = "script", { attrMap: Y } = J.parent;
                        Y && (Y.type === "module" || Y.type === "text/babel" && Y["data-type"] === "module") && (j = "module"), V.__babelSourceType = j;
                      }
                      return [t4, F4(J, q), R4(Q, V, { stripTrailingHardline: true }), c(J, q)];
                    }
                  } else if (J.parent.type === "interpolation") {
                    let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                    return q.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q.parser === "vue" ? L.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n([u, R4(J.value, L, { stripTrailingHardline: true })]), J.parent.next && f(J.parent.next) ? " " : u];
                  }
                  break;
                }
                case "attribute": {
                  if (!J.value)
                    break;
                  if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                    return [J.rawName, "=", J.value];
                  if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                    return [J.rawName, "=", J.value];
                  let L = b(J, (Q, V) => R4(Q, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
                  if (L)
                    return [J.rawName, '="', s(p(L, (Q) => typeof Q == "string" ? Q.replace(/"/g, "&quot;") : Q)), '"'];
                  break;
                }
                case "front-matter":
                  return h2(J, R4);
              }
            }
            r.exports = B;
          } }), Oo = te({ "src/language-html/print/children.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t4, group: s, ifBreak: a, line: n, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: p, locEnd: y } = au(), { forceBreakChildren: h2, forceNextEmptyLine: g, isTextLikeNode: c, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: F4 } = Rt(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w, printOpeningTagStartMarker: E, needsToBorrowPrevClosingTagEndMarker: N6, printClosingTagEndMarker: x, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P } = ur();
            function $(m, C, o) {
              let d = m.getValue();
              return f(d) ? [_(d, C), ...l(C.originalText.slice(p(d) + (d.prev && w(d.prev) ? E(d).length : 0), y(d) - (d.next && N6(d.next) ? x(d, C).length : 0))), I(d, C)] : o();
            }
            function D(m, C) {
              return c(m) && c(C) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? F4(C) ? i : n : "" : F4(C) ? i : u : w(m) && (f(C) || C.firstChild || C.isSelfClosing || C.type === "element" && C.attrs.length > 0) || m.type === "element" && m.isSelfClosing && N6(C) ? "" : !C.isLeadingSpaceSensitive || F4(C) || N6(C) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n : u;
            }
            function T(m, C, o) {
              let d = m.getValue();
              if (h2(d))
                return [t4, ...m.map((S) => {
                  let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
                  return [B ? [B, g(b.prev) ? i : ""] : "", $(S, C, o)];
                }, "children")];
              let v = d.children.map(() => Symbol(""));
              return m.map((S, b) => {
                let B = S.getValue();
                if (c(B)) {
                  if (B.prev && c(B.prev)) {
                    let Q = D(B.prev, B);
                    if (Q)
                      return g(B.prev) ? [i, i, $(S, C, o)] : [Q, $(S, C, o)];
                  }
                  return $(S, C, o);
                }
                let k = [], M = [], R4 = [], q = [], J = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
                return J && (g(B.prev) ? k.push(i, i) : J === i ? k.push(i) : c(B.prev) ? M.push(J) : M.push(a("", u, { groupId: v[b - 1] }))), L && (g(B) ? c(B.next) && q.push(i, i) : L === i ? c(B.next) && q.push(i) : R4.push(L)), [...k, s([...M, s([$(S, C, o), ...R4], { id: v[b] })]), ...q];
              }, "children");
            }
            r.exports = { printChildren: T };
          } }), wg = te({ "src/language-html/print/element.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t4, dedentToRoot: s, group: a, ifBreak: n, indentIfBreak: u, indent: i, line: l, softline: p }, utils: { replaceTextEndOfLine: y } } = qe(), h2 = Lo(), { shouldPreserveContent: g, isScriptLikeTag: c, isVueCustomBlock: f, countParents: F4, forceBreakContent: _ } = Rt(), { printOpeningTagPrefix: w, printOpeningTag: E, printClosingTagSuffix: N6, printClosingTag: x, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P } = ur(), { printChildren: $ } = Oo();
            function D(T, m, C) {
              let o = T.getValue();
              if (g(o, m))
                return [w(o, m), a(E(T, m, C)), ...y(h2(o, m)), ...x(o, m), N6(o, m)];
              let d = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v = Symbol("element-attr-group-id"), S = (M) => a([a(E(T, m, C), { id: v }), M, x(o, m)]), b = (M) => d ? u(M, { groupId: v }) : (c(o) || f(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? M : i(M), B = () => d ? n(p, "", { groupId: v }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(p) : p, k = () => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : d ? n(p, "", { groupId: v }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * F4(T, (R4) => R4.parent && R4.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p;
              return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t4 : "", b([B(), $(T, m, C)]), k()]);
            }
            r.exports = { printElement: D };
          } }), _g = te({ "src/language-html/printer-html.js"(e, r) {
            "use strict";
            ne();
            var { builders: { fill: t4, group: s, hardline: a, literalline: n }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: p } } = qe(), y = gg(), { countChars: h2, unescapeQuoteEntities: g, getTextValueParts: c } = Rt(), f = Sg(), { insertPragma: F4 } = xg(), { locStart: _, locEnd: w } = au(), E = Ng(), { printClosingTagSuffix: N6, printClosingTagEnd: x, printOpeningTagPrefix: I, printOpeningTagStart: P } = ur(), { printElement: $ } = wg(), { printChildren: D } = Oo();
            function T(m, C, o) {
              let d = m.getValue();
              switch (d.type) {
                case "front-matter":
                  return p(d.raw);
                case "root":
                  return C.__onHtmlRoot && C.__onHtmlRoot(d), [s(D(m, C, o)), a];
                case "element":
                case "ieConditionalComment":
                  return $(m, C, o);
                case "ieConditionalStartComment":
                case "ieConditionalEndComment":
                  return [P(d), x(d)];
                case "interpolation":
                  return [P(d, C), ...m.map(o, "children"), x(d, C)];
                case "text": {
                  if (d.parent.type === "interpolation") {
                    let S = /\n[^\S\n]*$/, b = S.test(d.value), B = b ? d.value.replace(S, "") : d.value;
                    return [...p(B), b ? a : ""];
                  }
                  let v = u([I(d, C), ...c(d), N6(d, C)]);
                  return l(v) || v.type === "fill" ? t4(i(v)) : v;
                }
                case "docType":
                  return [s([P(d, C), " ", d.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x(d, C)];
                case "comment":
                  return [I(d, C), ...p(C.originalText.slice(_(d), w(d)), n), N6(d, C)];
                case "attribute": {
                  if (d.value === null)
                    return d.rawName;
                  let v = g(d.value), S = h2(v, "'"), b = h2(v, '"'), B = S < b ? "'" : '"';
                  return [d.rawName, "=", B, ...p(B === '"' ? v.replace(/"/g, "&quot;") : v.replace(/'/g, "&apos;")), B];
                }
                default:
                  throw new Error(`Unexpected node type ${d.type}`);
              }
            }
            r.exports = { preprocess: f, print: T, insertPragma: F4, massageAstNode: y, embed: E };
          } }), Pg = te({ "src/language-html/options.js"(e, r) {
            "use strict";
            ne();
            var t4 = Mt(), s = "HTML";
            r.exports = { bracketSameLine: t4.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t4.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
          } }), Ig = te({ "src/language-html/parsers.js"() {
            ne();
          } }), On = te({ "node_modules/linguist-languages/data/HTML.json"(e, r) {
            r.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
          } }), kg = te({ "node_modules/linguist-languages/data/Vue.json"(e, r) {
            r.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
          } }), Lg = te({ "src/language-html/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = _t(), s = _g(), a = Pg(), n = Ig(), u = [t4(On(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t4(On(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t4(On(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t4(kg(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
            r.exports = { languages: u, printers: i, options: a, parsers: n };
          } }), Og = te({ "src/language-yaml/pragma.js"(e, r) {
            "use strict";
            ne();
            function t4(n) {
              return /^\s*@(?:prettier|format)\s*$/.test(n);
            }
            function s(n) {
              return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n);
            }
            function a(n) {
              return `# @format

${n}`;
            }
            r.exports = { isPragma: t4, hasPragma: s, insertPragma: a };
          } }), jg = te({ "src/language-yaml/loc.js"(e, r) {
            "use strict";
            ne();
            function t4(a) {
              return a.position.start.offset;
            }
            function s(a) {
              return a.position.end.offset;
            }
            r.exports = { locStart: t4, locEnd: s };
          } }), qg = te({ "src/language-yaml/embed.js"(e, r) {
            "use strict";
            ne();
            function t4(s, a, n, u) {
              if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))
                return n(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
            }
            r.exports = t4;
          } }), $t = te({ "src/language-yaml/utils.js"(e, r) {
            "use strict";
            ne();
            var { getLast: t4, isNonEmptyArray: s } = Ue();
            function a(D, T) {
              let m = 0, C = D.stack.length - 1;
              for (let o = 0; o < C; o++) {
                let d = D.stack[o];
                n(d) && T(d) && m++;
              }
              return m;
            }
            function n(D, T) {
              return D && typeof D.type == "string" && (!T || T.includes(D.type));
            }
            function u(D, T, m) {
              return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C) => u(C, T, D)) }) : D, m);
            }
            function i(D, T, m) {
              Object.defineProperty(D, T, { get: m, enumerable: false });
            }
            function l(D, T) {
              let m = 0, C = T.length;
              for (let o = D.position.end.offset - 1; o < C; o++) {
                let d = T[o];
                if (d === `
` && m++, m === 1 && /\S/.test(d))
                  return false;
                if (m === 2)
                  return true;
              }
              return false;
            }
            function p(D) {
              switch (D.getValue().type) {
                case "tag":
                case "anchor":
                case "comment":
                  return false;
              }
              let m = D.stack.length;
              for (let C = 1; C < m; C++) {
                let o = D.stack[C], d = D.stack[C - 1];
                if (Array.isArray(d) && typeof o == "number" && o !== d.length - 1)
                  return false;
              }
              return true;
            }
            function y(D) {
              return s(D.children) ? y(t4(D.children)) : D;
            }
            function h2(D) {
              return D.value.trim() === "prettier-ignore";
            }
            function g(D) {
              let T = D.getValue();
              if (T.type === "documentBody") {
                let m = D.getParentNode();
                return N6(m.head) && h2(t4(m.head.endComments));
              }
              return F4(T) && h2(t4(T.leadingComments));
            }
            function c(D) {
              return !s(D.children) && !f(D);
            }
            function f(D) {
              return F4(D) || _(D) || w(D) || E(D) || N6(D);
            }
            function F4(D) {
              return s(D == null ? void 0 : D.leadingComments);
            }
            function _(D) {
              return s(D == null ? void 0 : D.middleComments);
            }
            function w(D) {
              return D == null ? void 0 : D.indicatorComment;
            }
            function E(D) {
              return D == null ? void 0 : D.trailingComment;
            }
            function N6(D) {
              return s(D == null ? void 0 : D.endComments);
            }
            function x(D) {
              let T = [], m;
              for (let C of D.split(/( +)/))
                C !== " " ? m === " " ? T.push(C) : T.push((T.pop() || "") + C) : m === void 0 && T.unshift(""), m = C;
              return m === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
            }
            function I(D, T, m) {
              let C = T.split(`
`).map((o, d, v) => d === 0 && d === v.length - 1 ? o : d !== 0 && d !== v.length - 1 ? o.trim() : d === 0 ? o.trimEnd() : o.trimStart());
              return m.proseWrap === "preserve" ? C.map((o) => o.length === 0 ? [] : [o]) : C.map((o) => o.length === 0 ? [] : x(o)).reduce((o, d, v) => v !== 0 && C[v - 1].length > 0 && d.length > 0 && !(D === "quoteDouble" && t4(t4(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t4(o), ...d]] : [...o, d], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
            }
            function P(D, T) {
              let { parentIndent: m, isLastDescendant: C, options: o } = T, d = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v;
              if (D.indent === null) {
                let B = d.match(/^(?<leadingSpace> *)[^\n\r ]/m);
                v = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
              } else
                v = D.indent - 1 + m;
              let S = d.split(`
`).map((B) => B.slice(v));
              if (o.proseWrap === "preserve" || D.type === "blockLiteral")
                return b(S.map((B) => B.length === 0 ? [] : [B]));
              return b(S.map((B) => B.length === 0 ? [] : x(B)).reduce((B, k, M) => M !== 0 && S[M - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t4(B)) ? [...B.slice(0, -1), [...t4(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M) => k.length > 0 && /\s$/.test(t4(k)) ? [...k.slice(0, -1), t4(k) + " " + M] : [...k, M], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
              function b(B) {
                if (D.chomping === "keep")
                  return t4(B).length === 0 ? B.slice(0, -1) : B;
                let k = 0;
                for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--)
                  k++;
                return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);
              }
            }
            function $(D) {
              if (!D)
                return true;
              switch (D.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                case "alias":
                case "flowMapping":
                case "flowSequence":
                  return true;
                default:
                  return false;
              }
            }
            r.exports = { getLast: t4, getAncestorCount: a, isNode: n, isEmptyNode: c, isInlineNode: $, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: p, getBlockValueLineContents: P, getFlowScalarLineContents: I, getLastDescendantNode: y, hasPrettierIgnore: g, hasLeadingComments: F4, hasMiddleComments: _, hasIndicatorComment: w, hasTrailingComment: E, hasEndComments: N6 };
          } }), Mg = te({ "src/language-yaml/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            var { defineShortcut: t4, mapNode: s } = $t();
            function a(u) {
              return s(u, n);
            }
            function n(u) {
              switch (u.type) {
                case "document":
                  t4(u, "head", () => u.children[0]), t4(u, "body", () => u.children[1]);
                  break;
                case "documentBody":
                case "sequenceItem":
                case "flowSequenceItem":
                case "mappingKey":
                case "mappingValue":
                  t4(u, "content", () => u.children[0]);
                  break;
                case "mappingItem":
                case "flowMappingItem":
                  t4(u, "key", () => u.children[0]), t4(u, "value", () => u.children[1]);
                  break;
              }
              return u;
            }
            r.exports = a;
          } }), Mr = te({ "src/language-yaml/print/misc.js"(e, r) {
            "use strict";
            ne();
            var { builders: { softline: t4, align: s } } = qe(), { hasEndComments: a, isNextLineEmpty: n, isNode: u } = $t(), i = /* @__PURE__ */ new WeakMap();
            function l(h2, g) {
              let c = h2.getValue(), f = h2.stack[0], F4;
              return i.has(f) ? F4 = i.get(f) : (F4 = /* @__PURE__ */ new Set(), i.set(f, F4)), !F4.has(c.position.end.line) && (F4.add(c.position.end.line), n(c, g) && !p(h2.getParentNode())) ? t4 : "";
            }
            function p(h2) {
              return a(h2) && !u(h2, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
            }
            function y(h2, g) {
              return s(" ".repeat(h2), g);
            }
            r.exports = { alignWithSpaces: y, shouldPrintEndComments: p, printNextEmptyLine: l };
          } }), Rg = te({ "src/language-yaml/print/flow-mapping-sequence.js"(e, r) {
            "use strict";
            ne();
            var { builders: { ifBreak: t4, line: s, softline: a, hardline: n, join: u } } = qe(), { isEmptyNode: i, getLast: l, hasEndComments: p } = $t(), { printNextEmptyLine: y, alignWithSpaces: h2 } = Mr();
            function g(f, F4, _) {
              let w = f.getValue(), E = w.type === "flowMapping", N6 = E ? "{" : "[", x = E ? "}" : "]", I = a;
              E && w.children.length > 0 && _.bracketSpacing && (I = s);
              let P = l(w.children), $ = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
              return [N6, h2(_.tabWidth, [I, c(f, F4, _), _.trailingComma === "none" ? "" : t4(","), p(w) ? [n, u(n, f.map(F4, "endComments"))] : ""]), $ ? "" : I, x];
            }
            function c(f, F4, _) {
              let w = f.getValue();
              return f.map((N6, x) => [F4(), x === w.children.length - 1 ? "" : [",", s, w.children[x].position.start.line !== w.children[x + 1].position.start.line ? y(N6, _.originalText) : ""]], "children");
            }
            r.exports = { printFlowMapping: g, printFlowSequence: g };
          } }), $g = te({ "src/language-yaml/print/mapping-item.js"(e, r) {
            "use strict";
            ne();
            var { builders: { conditionalGroup: t4, group: s, hardline: a, ifBreak: n, join: u, line: i } } = qe(), { hasLeadingComments: l, hasMiddleComments: p, hasTrailingComment: y, hasEndComments: h2, isNode: g, isEmptyNode: c, isInlineNode: f } = $t(), { alignWithSpaces: F4 } = Mr();
            function _(x, I, P, $, D) {
              let { key: T, value: m } = x, C = c(T), o = c(m);
              if (C && o)
                return ": ";
              let d = $("key"), v = E(x) ? " " : "";
              if (o)
                return x.type === "flowMappingItem" && I.type === "flowMapping" ? d : x.type === "mappingItem" && w(T.content, D) && !y(T.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [d, v, ":"] : ["? ", F4(2, d)];
              let S = $("value");
              if (C)
                return [": ", F4(2, S)];
              if (l(m) || !f(T.content))
                return ["? ", F4(2, d), a, u("", P.map($, "value", "leadingComments").map((q) => [q, a])), ": ", F4(2, S)];
              if (N6(T.content) && !l(T.content) && !p(T.content) && !y(T.content) && !h2(T) && !l(m.content) && !p(m.content) && !h2(m) && w(m.content, D))
                return [d, v, ": ", S];
              let b = Symbol("mappingKey"), B = s([n("? "), s(F4(2, d), { id: b })]), k = [a, ": ", F4(2, S)], M = [v, ":"];
              l(m.content) || h2(m) && m.content && !g(m.content, ["mapping", "sequence"]) || I.type === "mapping" && y(T.content) && f(m.content) || g(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? M.push(a) : m.content && M.push(i), M.push(S);
              let R4 = F4(D.tabWidth, M);
              return w(T.content, D) && !l(T.content) && !p(T.content) && !h2(T) ? t4([[d, R4]]) : t4([[B, n(k, R4, { groupId: b })]]);
            }
            function w(x, I) {
              if (!x)
                return true;
              switch (x.type) {
                case "plain":
                case "quoteSingle":
                case "quoteDouble":
                  break;
                case "alias":
                  return true;
                default:
                  return false;
              }
              if (I.proseWrap === "preserve")
                return x.position.start.line === x.position.end.line;
              if (/\\$/m.test(I.originalText.slice(x.position.start.offset, x.position.end.offset)))
                return false;
              switch (I.proseWrap) {
                case "never":
                  return !x.value.includes(`
`);
                case "always":
                  return !/[\n ]/.test(x.value);
                default:
                  return false;
              }
            }
            function E(x) {
              return x.key.content && x.key.content.type === "alias";
            }
            function N6(x) {
              if (!x)
                return true;
              switch (x.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                  return x.position.start.line === x.position.end.line;
                case "alias":
                  return true;
                default:
                  return false;
              }
            }
            r.exports = _;
          } }), Vg = te({ "src/language-yaml/print/block.js"(e, r) {
            "use strict";
            ne();
            var { builders: { dedent: t4, dedentToRoot: s, fill: a, hardline: n, join: u, line: i, literalline: l, markAsRoot: p }, utils: { getDocParts: y } } = qe(), { getAncestorCount: h2, getBlockValueLineContents: g, hasIndicatorComment: c, isLastDescendantNode: f, isNode: F4 } = $t(), { alignWithSpaces: _ } = Mr();
            function w(E, N6, x) {
              let I = E.getValue(), P = h2(E, (C) => F4(C, ["sequence", "mapping"])), $ = f(E), D = [I.type === "blockFolded" ? ">" : "|"];
              I.indent !== null && D.push(I.indent.toString()), I.chomping !== "clip" && D.push(I.chomping === "keep" ? "+" : "-"), c(I) && D.push(" ", N6("indicatorComment"));
              let T = g(I, { parentIndent: P, isLastDescendant: $, options: x }), m = [];
              for (let [C, o] of T.entries())
                C === 0 && m.push(n), m.push(a(y(u(i, o)))), C !== T.length - 1 ? m.push(o.length === 0 ? n : p(l)) : I.chomping === "keep" && $ && m.push(s(o.length === 0 ? n : l));
              return I.indent === null ? D.push(t4(_(x.tabWidth, m))) : D.push(s(_(I.indent - 1 + P, m))), D;
            }
            r.exports = w;
          } }), Wg = te({ "src/language-yaml/printer-yaml.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t4, fill: s, group: a, hardline: n, join: u, line: i, lineSuffix: l, literalline: p }, utils: { getDocParts: y, replaceTextEndOfLine: h2 } } = qe(), { isPreviousLineEmpty: g } = Ue(), { insertPragma: c, isPragma: f } = Og(), { locStart: F4 } = jg(), _ = qg(), { getFlowScalarLineContents: w, getLastDescendantNode: E, hasLeadingComments: N6, hasMiddleComments: x, hasTrailingComment: I, hasEndComments: P, hasPrettierIgnore: $, isLastDescendantNode: D, isNode: T, isInlineNode: m } = $t(), C = Mg(), { alignWithSpaces: o, printNextEmptyLine: d, shouldPrintEndComments: v } = Mr(), { printFlowMapping: S, printFlowSequence: b } = Rg(), B = $g(), k = Vg();
            function M(j, Y, ie) {
              let ee = j.getValue(), ce = [];
              ee.type !== "mappingValue" && N6(ee) && ce.push([u(n, j.map(ie, "leadingComments")), n]);
              let { tag: W, anchor: K } = ee;
              W && ce.push(ie("tag")), W && K && ce.push(" "), K && ce.push(ie("anchor"));
              let de = "";
              T(ee, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j) && (de = d(j, Y.originalText)), (W || K) && (T(ee, ["sequence", "mapping"]) && !x(ee) ? ce.push(n) : ce.push(" ")), x(ee) && ce.push([ee.middleComments.length === 1 ? "" : n, u(n, j.map(ie, "middleComments")), n]);
              let ue = j.getParentNode();
              return $(j) ? ce.push(h2(Y.originalText.slice(ee.position.start.offset, ee.position.end.offset).trimEnd(), p)) : ce.push(a(R4(ee, ue, j, Y, ie))), I(ee) && !T(ee, ["document", "documentHead"]) && ce.push(l([ee.type === "mappingValue" && !ee.content ? "" : " ", ue.type === "mappingKey" && j.getParentNode(2).type === "mapping" && m(ee) ? "" : t4, ie("trailingComment")])), v(ee) && ce.push(o(ee.type === "sequenceItem" ? 2 : 0, [n, u(n, j.map((Fe) => [g(Y.originalText, Fe.getValue(), F4) ? n : "", ie()], "endComments"))])), ce.push(de), ce;
            }
            function R4(j, Y, ie, ee, ce) {
              switch (j.type) {
                case "root": {
                  let { children: W } = j, K = [];
                  ie.each((ue, Fe) => {
                    let z = W[Fe], U3 = W[Fe + 1];
                    Fe !== 0 && K.push(n), K.push(ce()), J(z, U3) ? (K.push(n, "..."), I(z) && K.push(" ", ce("trailingComment"))) : U3 && !I(U3.head) && K.push(n, "---");
                  }, "children");
                  let de = E(j);
                  return (!T(de, ["blockLiteral", "blockFolded"]) || de.chomping !== "keep") && K.push(n), K;
                }
                case "document": {
                  let W = Y.children[ie.getName() + 1], K = [];
                  return L(j, W, Y, ee) === "head" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K.push(ce("head")), I(j.head) ? K.push(["---", " ", ce(["head", "trailingComment"])]) : K.push("---")), q(j) && K.push(ce("body")), u(n, K);
                }
                case "documentHead":
                  return u(n, [...ie.map(ce, "children"), ...ie.map(ce, "endComments")]);
                case "documentBody": {
                  let { children: W, endComments: K } = j, de = "";
                  if (W.length > 0 && K.length > 0) {
                    let ue = E(j);
                    T(ue, ["blockFolded", "blockLiteral"]) ? ue.chomping !== "keep" && (de = [n, n]) : de = n;
                  }
                  return [u(n, ie.map(ce, "children")), de, u(n, ie.map(ce, "endComments"))];
                }
                case "directive":
                  return ["%", u(" ", [j.name, ...j.parameters])];
                case "comment":
                  return ["#", j.value];
                case "alias":
                  return ["*", j.value];
                case "tag":
                  return ee.originalText.slice(j.position.start.offset, j.position.end.offset);
                case "anchor":
                  return ["&", j.value];
                case "plain":
                  return Q(j.type, ee.originalText.slice(j.position.start.offset, j.position.end.offset), ee);
                case "quoteDouble":
                case "quoteSingle": {
                  let W = "'", K = '"', de = ee.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);
                  if (j.type === "quoteSingle" && de.includes("\\") || j.type === "quoteDouble" && /\\[^"]/.test(de)) {
                    let Fe = j.type === "quoteDouble" ? K : W;
                    return [Fe, Q(j.type, de, ee), Fe];
                  }
                  if (de.includes(K))
                    return [W, Q(j.type, j.type === "quoteDouble" ? de.replace(/\\"/g, K).replace(/'/g, W.repeat(2)) : de, ee), W];
                  if (de.includes(W))
                    return [K, Q(j.type, j.type === "quoteSingle" ? de.replace(/''/g, W) : de, ee), K];
                  let ue = ee.singleQuote ? W : K;
                  return [ue, Q(j.type, de, ee), ue];
                }
                case "blockFolded":
                case "blockLiteral":
                  return k(ie, ce, ee);
                case "mapping":
                case "sequence":
                  return u(n, ie.map(ce, "children"));
                case "sequenceItem":
                  return ["- ", o(2, j.content ? ce("content") : "")];
                case "mappingKey":
                case "mappingValue":
                  return j.content ? ce("content") : "";
                case "mappingItem":
                case "flowMappingItem":
                  return B(j, Y, ie, ce, ee);
                case "flowMapping":
                  return S(ie, ce, ee);
                case "flowSequence":
                  return b(ie, ce, ee);
                case "flowSequenceItem":
                  return ce("content");
                default:
                  throw new Error(`Unexpected node type ${j.type}`);
              }
            }
            function q(j) {
              return j.body.children.length > 0 || P(j.body);
            }
            function J(j, Y) {
              return I(j) || Y && (Y.head.children.length > 0 || P(Y.head));
            }
            function L(j, Y, ie, ee) {
              return ie.children[0] === j && /---(?:\s|$)/.test(ee.originalText.slice(F4(j), F4(j) + 4)) || j.head.children.length > 0 || P(j.head) || I(j.head) ? "head" : J(j, Y) ? false : Y ? "root" : false;
            }
            function Q(j, Y, ie) {
              let ee = w(j, Y, ie);
              return u(n, ee.map((ce) => s(y(u(i, ce)))));
            }
            function V(j, Y) {
              if (T(Y))
                switch (delete Y.position, Y.type) {
                  case "comment":
                    if (f(Y.value))
                      return null;
                    break;
                  case "quoteDouble":
                  case "quoteSingle":
                    Y.type = "quote";
                    break;
                }
            }
            r.exports = { preprocess: C, embed: _, print: M, massageAstNode: V, insertPragma: c };
          } }), Hg = te({ "src/language-yaml/options.js"(e, r) {
            "use strict";
            ne();
            var t4 = Mt();
            r.exports = { bracketSpacing: t4.bracketSpacing, singleQuote: t4.singleQuote, proseWrap: t4.proseWrap };
          } }), Gg = te({ "src/language-yaml/parsers.js"() {
            ne();
          } }), Ug = te({ "node_modules/linguist-languages/data/YAML.json"(e, r) {
            r.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
          } }), Jg = te({ "src/language-yaml/index.js"(e, r) {
            "use strict";
            ne();
            var t4 = _t(), s = Wg(), a = Hg(), n = Gg(), u = [t4(Ug(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
            r.exports = { languages: u, printers: { yaml: s }, options: a, parsers: n };
          } }), zg = te({ "src/languages.js"(e, r) {
            "use strict";
            ne(), r.exports = [Bd(), Ud(), eg(), ag(), dg(), Lg(), Jg()];
          } });
          ne();
          var { version: Xg } = Ia(), Ot = Gm(), { getSupportInfo: Kg } = Xn(), Yg = Um(), Qg = zg(), Zg = qe();
          function Nt(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return function() {
              for (var t4 = arguments.length, s = new Array(t4), a = 0; a < t4; a++)
                s[a] = arguments[a];
              let n = s[r] || {}, u = n.plugins || [];
              return s[r] = Object.assign(Object.assign({}, n), {}, { plugins: [...Qg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
            };
          }
          var jn = Nt(Ot.formatWithCursor);
          jo.exports = { formatWithCursor: jn, format(e, r) {
            return jn(e, r).formatted;
          }, check(e, r) {
            let { formatted: t4 } = jn(e, r);
            return t4 === e;
          }, doc: Zg, getSupportInfo: Nt(Kg, 0), version: Xg, util: Yg, __debug: { parse: Nt(Ot.parse), formatAST: Nt(Ot.formatAST), formatDoc: Nt(Ot.formatDoc), printToDoc: Nt(Ot.printToDoc), printDocToString: Nt(Ot.printDocToString) } };
        });
        return e0();
      });
    }
  });

  // node_modules/prettier/parser-babel.js
  var require_parser_babel = __commonJS({
    "node_modules/prettier/parser-babel.js"(exports, module) {
      (function(e) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.babel = e();
        }
      })(function() {
        "use strict";
        var v = (l, h2) => () => (h2 || l((h2 = { exports: {} }).exports, h2), h2.exports);
        var le = v((md, oi) => {
          var St = function(l) {
            return l && l.Math == Math && l;
          };
          oi.exports = St(typeof globalThis == "object" && globalThis) || St(typeof window == "object" && window) || St(typeof self == "object" && self) || St(typeof global == "object" && global) || function() {
            return this;
          }() || Function("return this")();
        });
        var he = v((yd, li) => {
          li.exports = function(l) {
            try {
              return !!l();
            } catch {
              return true;
            }
          };
        });
        var ve = v((xd, hi) => {
          var Nh = he();
          hi.exports = !Nh(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        });
        var wt = v((gd, ui) => {
          var kh = he();
          ui.exports = !kh(function() {
            var l = function() {
            }.bind();
            return typeof l != "function" || l.hasOwnProperty("prototype");
          });
        });
        var Nt = v((Pd, ci) => {
          var Dh = wt(), It = Function.prototype.call;
          ci.exports = Dh ? It.bind(It) : function() {
            return It.apply(It, arguments);
          };
        });
        var mi = v((di) => {
          "use strict";
          var pi = {}.propertyIsEnumerable, fi = Object.getOwnPropertyDescriptor, Fh = fi && !pi.call({ 1: 2 }, 1);
          di.f = Fh ? function(h2) {
            var f = fi(this, h2);
            return !!f && f.enumerable;
          } : pi;
        });
        var As = v((Td, yi) => {
          yi.exports = function(l, h2) {
            return { enumerable: !(l & 1), configurable: !(l & 2), writable: !(l & 4), value: h2 };
          };
        });
        var ue = v((vd, Pi) => {
          var xi = wt(), gi = Function.prototype, Ts = gi.call, Lh = xi && gi.bind.bind(Ts, Ts);
          Pi.exports = xi ? Lh : function(l) {
            return function() {
              return Ts.apply(l, arguments);
            };
          };
        });
        var rt = v((Ed, Ti) => {
          var Ai = ue(), Oh = Ai({}.toString), Bh = Ai("".slice);
          Ti.exports = function(l) {
            return Bh(Oh(l), 8, -1);
          };
        });
        var Ei = v((Cd, vi) => {
          var Mh = ue(), _h = he(), Rh = rt(), vs = Object, jh = Mh("".split);
          vi.exports = _h(function() {
            return !vs("z").propertyIsEnumerable(0);
          }) ? function(l) {
            return Rh(l) == "String" ? jh(l, "") : vs(l);
          } : vs;
        });
        var Es = v((bd, Ci) => {
          Ci.exports = function(l) {
            return l == null;
          };
        });
        var Cs = v((Sd, bi) => {
          var qh = Es(), Uh = TypeError;
          bi.exports = function(l) {
            if (qh(l))
              throw Uh("Can't call method on " + l);
            return l;
          };
        });
        var kt = v((wd, Si) => {
          var $h = Ei(), Hh = Cs();
          Si.exports = function(l) {
            return $h(Hh(l));
          };
        });
        var Ss = v((Id, wi) => {
          var bs = typeof document == "object" && document.all, zh = typeof bs > "u" && bs !== void 0;
          wi.exports = { all: bs, IS_HTMLDDA: zh };
        });
        var ne = v((Nd, Ni) => {
          var Ii = Ss(), Vh = Ii.all;
          Ni.exports = Ii.IS_HTMLDDA ? function(l) {
            return typeof l == "function" || l === Vh;
          } : function(l) {
            return typeof l == "function";
          };
        });
        var Oe = v((kd, Fi) => {
          var ki = ne(), Di = Ss(), Kh = Di.all;
          Fi.exports = Di.IS_HTMLDDA ? function(l) {
            return typeof l == "object" ? l !== null : ki(l) || l === Kh;
          } : function(l) {
            return typeof l == "object" ? l !== null : ki(l);
          };
        });
        var it = v((Dd, Li) => {
          var ws = le(), Wh = ne(), Gh = function(l) {
            return Wh(l) ? l : void 0;
          };
          Li.exports = function(l, h2) {
            return arguments.length < 2 ? Gh(ws[l]) : ws[l] && ws[l][h2];
          };
        });
        var Bi = v((Fd, Oi) => {
          var Jh = ue();
          Oi.exports = Jh({}.isPrototypeOf);
        });
        var _i = v((Ld, Mi) => {
          var Xh = it();
          Mi.exports = Xh("navigator", "userAgent") || "";
        });
        var zi = v((Od, Hi) => {
          var $i = le(), Is = _i(), Ri = $i.process, ji = $i.Deno, qi = Ri && Ri.versions || ji && ji.version, Ui = qi && qi.v8, ce, Dt;
          Ui && (ce = Ui.split("."), Dt = ce[0] > 0 && ce[0] < 4 ? 1 : +(ce[0] + ce[1]));
          !Dt && Is && (ce = Is.match(/Edge\/(\d+)/), (!ce || ce[1] >= 74) && (ce = Is.match(/Chrome\/(\d+)/), ce && (Dt = +ce[1])));
          Hi.exports = Dt;
        });
        var Ns = v((Bd, Ki) => {
          var Vi = zi(), Yh = he();
          Ki.exports = !!Object.getOwnPropertySymbols && !Yh(function() {
            var l = Symbol();
            return !String(l) || !(Object(l) instanceof Symbol) || !Symbol.sham && Vi && Vi < 41;
          });
        });
        var ks = v((Md, Wi) => {
          var Qh = Ns();
          Wi.exports = Qh && !Symbol.sham && typeof Symbol.iterator == "symbol";
        });
        var Ds = v((_d, Gi) => {
          var Zh = it(), eu = ne(), tu = Bi(), su = ks(), ru = Object;
          Gi.exports = su ? function(l) {
            return typeof l == "symbol";
          } : function(l) {
            var h2 = Zh("Symbol");
            return eu(h2) && tu(h2.prototype, ru(l));
          };
        });
        var Xi = v((Rd, Ji) => {
          var iu = String;
          Ji.exports = function(l) {
            try {
              return iu(l);
            } catch {
              return "Object";
            }
          };
        });
        var Ft = v((jd, Yi) => {
          var au = ne(), nu = Xi(), ou = TypeError;
          Yi.exports = function(l) {
            if (au(l))
              return l;
            throw ou(nu(l) + " is not a function");
          };
        });
        var Zi = v((qd, Qi) => {
          var lu = Ft(), hu = Es();
          Qi.exports = function(l, h2) {
            var f = l[h2];
            return hu(f) ? void 0 : lu(f);
          };
        });
        var ta = v((Ud, ea) => {
          var Fs = Nt(), Ls = ne(), Os = Oe(), uu = TypeError;
          ea.exports = function(l, h2) {
            var f, d;
            if (h2 === "string" && Ls(f = l.toString) && !Os(d = Fs(f, l)) || Ls(f = l.valueOf) && !Os(d = Fs(f, l)) || h2 !== "string" && Ls(f = l.toString) && !Os(d = Fs(f, l)))
              return d;
            throw uu("Can't convert object to primitive value");
          };
        });
        var ra = v(($d, sa) => {
          sa.exports = false;
        });
        var Lt = v((Hd, aa) => {
          var ia = le(), cu = Object.defineProperty;
          aa.exports = function(l, h2) {
            try {
              cu(ia, l, { value: h2, configurable: true, writable: true });
            } catch {
              ia[l] = h2;
            }
            return h2;
          };
        });
        var Ot = v((zd, oa) => {
          var pu = le(), fu = Lt(), na = "__core-js_shared__", du = pu[na] || fu(na, {});
          oa.exports = du;
        });
        var Bs = v((Vd, ha) => {
          var mu = ra(), la = Ot();
          (ha.exports = function(l, h2) {
            return la[l] || (la[l] = h2 !== void 0 ? h2 : {});
          })("versions", []).push({ version: "3.26.1", mode: mu ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
        });
        var Ms = v((Kd, ua) => {
          var yu = Cs(), xu = Object;
          ua.exports = function(l) {
            return xu(yu(l));
          };
        });
        var Ie = v((Wd, ca) => {
          var gu = ue(), Pu = Ms(), Au = gu({}.hasOwnProperty);
          ca.exports = Object.hasOwn || function(h2, f) {
            return Au(Pu(h2), f);
          };
        });
        var _s = v((Gd, pa) => {
          var Tu = ue(), vu = 0, Eu = Math.random(), Cu = Tu(1 .toString);
          pa.exports = function(l) {
            return "Symbol(" + (l === void 0 ? "" : l) + ")_" + Cu(++vu + Eu, 36);
          };
        });
        var at = v((Jd, xa) => {
          var bu = le(), Su = Bs(), fa = Ie(), wu = _s(), da = Ns(), ya = ks(), Ke = Su("wks"), Be = bu.Symbol, ma = Be && Be.for, Iu = ya ? Be : Be && Be.withoutSetter || wu;
          xa.exports = function(l) {
            if (!fa(Ke, l) || !(da || typeof Ke[l] == "string")) {
              var h2 = "Symbol." + l;
              da && fa(Be, l) ? Ke[l] = Be[l] : ya && ma ? Ke[l] = ma(h2) : Ke[l] = Iu(h2);
            }
            return Ke[l];
          };
        });
        var Ta = v((Xd, Aa) => {
          var Nu = Nt(), ga = Oe(), Pa = Ds(), ku = Zi(), Du = ta(), Fu = at(), Lu = TypeError, Ou = Fu("toPrimitive");
          Aa.exports = function(l, h2) {
            if (!ga(l) || Pa(l))
              return l;
            var f = ku(l, Ou), d;
            if (f) {
              if (h2 === void 0 && (h2 = "default"), d = Nu(f, l, h2), !ga(d) || Pa(d))
                return d;
              throw Lu("Can't convert object to primitive value");
            }
            return h2 === void 0 && (h2 = "number"), Du(l, h2);
          };
        });
        var Rs = v((Yd, va) => {
          var Bu = Ta(), Mu = Ds();
          va.exports = function(l) {
            var h2 = Bu(l, "string");
            return Mu(h2) ? h2 : h2 + "";
          };
        });
        var ba = v((Qd, Ca) => {
          var _u = le(), Ea = Oe(), js = _u.document, Ru = Ea(js) && Ea(js.createElement);
          Ca.exports = function(l) {
            return Ru ? js.createElement(l) : {};
          };
        });
        var qs = v((Zd, Sa) => {
          var ju = ve(), qu = he(), Uu = ba();
          Sa.exports = !ju && !qu(function() {
            return Object.defineProperty(Uu("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        });
        var Us = v((Ia) => {
          var $u = ve(), Hu = Nt(), zu = mi(), Vu = As(), Ku = kt(), Wu = Rs(), Gu = Ie(), Ju = qs(), wa = Object.getOwnPropertyDescriptor;
          Ia.f = $u ? wa : function(h2, f) {
            if (h2 = Ku(h2), f = Wu(f), Ju)
              try {
                return wa(h2, f);
              } catch {
              }
            if (Gu(h2, f))
              return Vu(!Hu(zu.f, h2, f), h2[f]);
          };
        });
        var ka = v((tm, Na) => {
          var Xu = ve(), Yu = he();
          Na.exports = Xu && Yu(function() {
            return Object.defineProperty(function() {
            }, "prototype", { value: 42, writable: false }).prototype != 42;
          });
        });
        var Bt = v((sm, Da) => {
          var Qu = Oe(), Zu = String, ec = TypeError;
          Da.exports = function(l) {
            if (Qu(l))
              return l;
            throw ec(Zu(l) + " is not an object");
          };
        });
        var nt = v((La) => {
          var tc = ve(), sc = qs(), rc = ka(), Mt = Bt(), Fa = Rs(), ic = TypeError, $s = Object.defineProperty, ac = Object.getOwnPropertyDescriptor, Hs = "enumerable", zs = "configurable", Vs = "writable";
          La.f = tc ? rc ? function(h2, f, d) {
            if (Mt(h2), f = Fa(f), Mt(d), typeof h2 == "function" && f === "prototype" && "value" in d && Vs in d && !d[Vs]) {
              var y = ac(h2, f);
              y && y[Vs] && (h2[f] = d.value, d = { configurable: zs in d ? d[zs] : y[zs], enumerable: Hs in d ? d[Hs] : y[Hs], writable: false });
            }
            return $s(h2, f, d);
          } : $s : function(h2, f, d) {
            if (Mt(h2), f = Fa(f), Mt(d), sc)
              try {
                return $s(h2, f, d);
              } catch {
              }
            if ("get" in d || "set" in d)
              throw ic("Accessors not supported");
            return "value" in d && (h2[f] = d.value), h2;
          };
        });
        var Ks = v((im, Oa) => {
          var nc = ve(), oc = nt(), lc = As();
          Oa.exports = nc ? function(l, h2, f) {
            return oc.f(l, h2, lc(1, f));
          } : function(l, h2, f) {
            return l[h2] = f, l;
          };
        });
        var _a = v((am, Ma) => {
          var Ws = ve(), hc = Ie(), Ba = Function.prototype, uc = Ws && Object.getOwnPropertyDescriptor, Gs = hc(Ba, "name"), cc = Gs && function() {
          }.name === "something", pc = Gs && (!Ws || Ws && uc(Ba, "name").configurable);
          Ma.exports = { EXISTS: Gs, PROPER: cc, CONFIGURABLE: pc };
        });
        var Xs = v((nm, Ra) => {
          var fc = ue(), dc = ne(), Js = Ot(), mc = fc(Function.toString);
          dc(Js.inspectSource) || (Js.inspectSource = function(l) {
            return mc(l);
          });
          Ra.exports = Js.inspectSource;
        });
        var Ua = v((om, qa) => {
          var yc = le(), xc = ne(), ja = yc.WeakMap;
          qa.exports = xc(ja) && /native code/.test(String(ja));
        });
        var za = v((lm, Ha) => {
          var gc = Bs(), Pc = _s(), $a = gc("keys");
          Ha.exports = function(l) {
            return $a[l] || ($a[l] = Pc(l));
          };
        });
        var Ys = v((hm, Va) => {
          Va.exports = {};
        });
        var Ja = v((um, Ga) => {
          var Ac = Ua(), Wa = le(), Tc = Oe(), vc = Ks(), Qs = Ie(), Zs = Ot(), Ec = za(), Cc = Ys(), Ka = "Object already initialized", er = Wa.TypeError, bc = Wa.WeakMap, _t, ot, Rt, Sc = function(l) {
            return Rt(l) ? ot(l) : _t(l, {});
          }, wc = function(l) {
            return function(h2) {
              var f;
              if (!Tc(h2) || (f = ot(h2)).type !== l)
                throw er("Incompatible receiver, " + l + " required");
              return f;
            };
          };
          Ac || Zs.state ? (pe = Zs.state || (Zs.state = new bc()), pe.get = pe.get, pe.has = pe.has, pe.set = pe.set, _t = function(l, h2) {
            if (pe.has(l))
              throw er(Ka);
            return h2.facade = l, pe.set(l, h2), h2;
          }, ot = function(l) {
            return pe.get(l) || {};
          }, Rt = function(l) {
            return pe.has(l);
          }) : (Me = Ec("state"), Cc[Me] = true, _t = function(l, h2) {
            if (Qs(l, Me))
              throw er(Ka);
            return h2.facade = l, vc(l, Me, h2), h2;
          }, ot = function(l) {
            return Qs(l, Me) ? l[Me] : {};
          }, Rt = function(l) {
            return Qs(l, Me);
          });
          var pe, Me;
          Ga.exports = { set: _t, get: ot, has: Rt, enforce: Sc, getterFor: wc };
        });
        var sr = v((cm, Ya) => {
          var Ic = he(), Nc = ne(), jt = Ie(), tr = ve(), kc = _a().CONFIGURABLE, Dc = Xs(), Xa = Ja(), Fc = Xa.enforce, Lc = Xa.get, qt = Object.defineProperty, Oc = tr && !Ic(function() {
            return qt(function() {
            }, "length", { value: 8 }).length !== 8;
          }), Bc = String(String).split("String"), Mc = Ya.exports = function(l, h2, f) {
            String(h2).slice(0, 7) === "Symbol(" && (h2 = "[" + String(h2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), f && f.getter && (h2 = "get " + h2), f && f.setter && (h2 = "set " + h2), (!jt(l, "name") || kc && l.name !== h2) && (tr ? qt(l, "name", { value: h2, configurable: true }) : l.name = h2), Oc && f && jt(f, "arity") && l.length !== f.arity && qt(l, "length", { value: f.arity });
            try {
              f && jt(f, "constructor") && f.constructor ? tr && qt(l, "prototype", { writable: false }) : l.prototype && (l.prototype = void 0);
            } catch {
            }
            var d = Fc(l);
            return jt(d, "source") || (d.source = Bc.join(typeof h2 == "string" ? h2 : "")), l;
          };
          Function.prototype.toString = Mc(function() {
            return Nc(this) && Lc(this).source || Dc(this);
          }, "toString");
        });
        var Za = v((pm, Qa) => {
          var _c = ne(), Rc = nt(), jc = sr(), qc = Lt();
          Qa.exports = function(l, h2, f, d) {
            d || (d = {});
            var y = d.enumerable, P = d.name !== void 0 ? d.name : h2;
            if (_c(f) && jc(f, P, d), d.global)
              y ? l[h2] = f : qc(h2, f);
            else {
              try {
                d.unsafe ? l[h2] && (y = true) : delete l[h2];
              } catch {
              }
              y ? l[h2] = f : Rc.f(l, h2, { value: f, enumerable: false, configurable: !d.nonConfigurable, writable: !d.nonWritable });
            }
            return l;
          };
        });
        var tn = v((fm, en) => {
          var Uc = Math.ceil, $c = Math.floor;
          en.exports = Math.trunc || function(h2) {
            var f = +h2;
            return (f > 0 ? $c : Uc)(f);
          };
        });
        var rr = v((dm, sn) => {
          var Hc = tn();
          sn.exports = function(l) {
            var h2 = +l;
            return h2 !== h2 || h2 === 0 ? 0 : Hc(h2);
          };
        });
        var an = v((mm, rn) => {
          var zc = rr(), Vc = Math.max, Kc = Math.min;
          rn.exports = function(l, h2) {
            var f = zc(l);
            return f < 0 ? Vc(f + h2, 0) : Kc(f, h2);
          };
        });
        var on = v((ym, nn) => {
          var Wc = rr(), Gc = Math.min;
          nn.exports = function(l) {
            return l > 0 ? Gc(Wc(l), 9007199254740991) : 0;
          };
        });
        var Ut = v((xm, ln) => {
          var Jc = on();
          ln.exports = function(l) {
            return Jc(l.length);
          };
        });
        var cn = v((gm, un) => {
          var Xc = kt(), Yc = an(), Qc = Ut(), hn = function(l) {
            return function(h2, f, d) {
              var y = Xc(h2), P = Qc(y), g = Yc(d, P), T;
              if (l && f != f) {
                for (; P > g; )
                  if (T = y[g++], T != T)
                    return true;
              } else
                for (; P > g; g++)
                  if ((l || g in y) && y[g] === f)
                    return l || g || 0;
              return !l && -1;
            };
          };
          un.exports = { includes: hn(true), indexOf: hn(false) };
        });
        var dn = v((Pm, fn) => {
          var Zc = ue(), ir = Ie(), ep = kt(), tp = cn().indexOf, sp = Ys(), pn = Zc([].push);
          fn.exports = function(l, h2) {
            var f = ep(l), d = 0, y = [], P;
            for (P in f)
              !ir(sp, P) && ir(f, P) && pn(y, P);
            for (; h2.length > d; )
              ir(f, P = h2[d++]) && (~tp(y, P) || pn(y, P));
            return y;
          };
        });
        var yn = v((Am, mn) => {
          mn.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
        });
        var gn = v((xn) => {
          var rp = dn(), ip = yn(), ap = ip.concat("length", "prototype");
          xn.f = Object.getOwnPropertyNames || function(h2) {
            return rp(h2, ap);
          };
        });
        var An = v((Pn) => {
          Pn.f = Object.getOwnPropertySymbols;
        });
        var vn = v((Em, Tn) => {
          var np = it(), op = ue(), lp = gn(), hp = An(), up = Bt(), cp = op([].concat);
          Tn.exports = np("Reflect", "ownKeys") || function(h2) {
            var f = lp.f(up(h2)), d = hp.f;
            return d ? cp(f, d(h2)) : f;
          };
        });
        var bn = v((Cm, Cn) => {
          var En = Ie(), pp = vn(), fp = Us(), dp = nt();
          Cn.exports = function(l, h2, f) {
            for (var d = pp(h2), y = dp.f, P = fp.f, g = 0; g < d.length; g++) {
              var T = d[g];
              !En(l, T) && !(f && En(f, T)) && y(l, T, P(h2, T));
            }
          };
        });
        var wn = v((bm, Sn) => {
          var mp = he(), yp = ne(), xp = /#|\.prototype\./, lt = function(l, h2) {
            var f = Pp[gp(l)];
            return f == Tp ? true : f == Ap ? false : yp(h2) ? mp(h2) : !!h2;
          }, gp = lt.normalize = function(l) {
            return String(l).replace(xp, ".").toLowerCase();
          }, Pp = lt.data = {}, Ap = lt.NATIVE = "N", Tp = lt.POLYFILL = "P";
          Sn.exports = lt;
        });
        var nr = v((Sm, In) => {
          var ar = le(), vp = Us().f, Ep = Ks(), Cp = Za(), bp = Lt(), Sp = bn(), wp = wn();
          In.exports = function(l, h2) {
            var f = l.target, d = l.global, y = l.stat, P, g, T, S, F4, I;
            if (d ? g = ar : y ? g = ar[f] || bp(f, {}) : g = (ar[f] || {}).prototype, g)
              for (T in h2) {
                if (F4 = h2[T], l.dontCallGetSet ? (I = vp(g, T), S = I && I.value) : S = g[T], P = wp(d ? T : f + (y ? "." : "#") + T, l.forced), !P && S !== void 0) {
                  if (typeof F4 == typeof S)
                    continue;
                  Sp(F4, S);
                }
                (l.sham || S && S.sham) && Ep(F4, "sham", true), Cp(g, T, F4, l);
              }
          };
        });
        var Nn = v(() => {
          var Ip = nr(), or = le();
          Ip({ global: true, forced: or.globalThis !== or }, { globalThis: or });
        });
        var kn = v(() => {
          Nn();
        });
        var Ln = v((Dm, Fn) => {
          var Dn = sr(), Np = nt();
          Fn.exports = function(l, h2, f) {
            return f.get && Dn(f.get, h2, { getter: true }), f.set && Dn(f.set, h2, { setter: true }), Np.f(l, h2, f);
          };
        });
        var Bn = v((Fm, On) => {
          "use strict";
          var kp = Bt();
          On.exports = function() {
            var l = kp(this), h2 = "";
            return l.hasIndices && (h2 += "d"), l.global && (h2 += "g"), l.ignoreCase && (h2 += "i"), l.multiline && (h2 += "m"), l.dotAll && (h2 += "s"), l.unicode && (h2 += "u"), l.unicodeSets && (h2 += "v"), l.sticky && (h2 += "y"), h2;
          };
        });
        var Rn = v(() => {
          var Dp = le(), Fp = ve(), Lp = Ln(), Op = Bn(), Bp = he(), Mn = Dp.RegExp, _n = Mn.prototype, Mp = Fp && Bp(function() {
            var l = true;
            try {
              Mn(".", "d");
            } catch {
              l = false;
            }
            var h2 = {}, f = "", d = l ? "dgimsy" : "gimsy", y = function(S, F4) {
              Object.defineProperty(h2, S, { get: function() {
                return f += F4, true;
              } });
            }, P = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
            l && (P.hasIndices = "d");
            for (var g in P)
              y(g, P[g]);
            var T = Object.getOwnPropertyDescriptor(_n, "flags").get.call(h2);
            return T !== d || f !== d;
          });
          Mp && Lp(_n, "flags", { configurable: true, get: Op });
        });
        var lr = v((Bm, jn) => {
          var _p = rt();
          jn.exports = Array.isArray || function(h2) {
            return _p(h2) == "Array";
          };
        });
        var Un = v((Mm, qn) => {
          var Rp = TypeError, jp = 9007199254740991;
          qn.exports = function(l) {
            if (l > jp)
              throw Rp("Maximum allowed index exceeded");
            return l;
          };
        });
        var Hn = v((_m, $n) => {
          var qp = rt(), Up = ue();
          $n.exports = function(l) {
            if (qp(l) === "Function")
              return Up(l);
          };
        });
        var Kn = v((Rm, Vn) => {
          var zn = Hn(), $p = Ft(), Hp = wt(), zp = zn(zn.bind);
          Vn.exports = function(l, h2) {
            return $p(l), h2 === void 0 ? l : Hp ? zp(l, h2) : function() {
              return l.apply(h2, arguments);
            };
          };
        });
        var Jn = v((jm, Gn) => {
          "use strict";
          var Vp = lr(), Kp = Ut(), Wp = Un(), Gp = Kn(), Wn = function(l, h2, f, d, y, P, g, T) {
            for (var S = y, F4 = 0, I = g ? Gp(g, T) : false, C, L; F4 < d; )
              F4 in f && (C = I ? I(f[F4], F4, h2) : f[F4], P > 0 && Vp(C) ? (L = Kp(C), S = Wn(l, h2, C, L, S, P - 1) - 1) : (Wp(S + 1), l[S] = C), S++), F4++;
            return S;
          };
          Gn.exports = Wn;
        });
        var Qn = v((qm, Yn) => {
          var Jp = at(), Xp = Jp("toStringTag"), Xn = {};
          Xn[Xp] = "z";
          Yn.exports = String(Xn) === "[object z]";
        });
        var eo = v((Um, Zn) => {
          var Yp = Qn(), Qp = ne(), $t = rt(), Zp = at(), ef = Zp("toStringTag"), tf = Object, sf = $t(function() {
            return arguments;
          }()) == "Arguments", rf = function(l, h2) {
            try {
              return l[h2];
            } catch {
            }
          };
          Zn.exports = Yp ? $t : function(l) {
            var h2, f, d;
            return l === void 0 ? "Undefined" : l === null ? "Null" : typeof (f = rf(h2 = tf(l), ef)) == "string" ? f : sf ? $t(h2) : (d = $t(h2)) == "Object" && Qp(h2.callee) ? "Arguments" : d;
          };
        });
        var no = v(($m, ao) => {
          var af = ue(), nf = he(), to = ne(), of = eo(), lf = it(), hf = Xs(), so = function() {
          }, uf = [], ro = lf("Reflect", "construct"), hr = /^\s*(?:class|function)\b/, cf = af(hr.exec), pf = !hr.exec(so), ht = function(h2) {
            if (!to(h2))
              return false;
            try {
              return ro(so, uf, h2), true;
            } catch {
              return false;
            }
          }, io = function(h2) {
            if (!to(h2))
              return false;
            switch (of(h2)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return false;
            }
            try {
              return pf || !!cf(hr, hf(h2));
            } catch {
              return true;
            }
          };
          io.sham = true;
          ao.exports = !ro || nf(function() {
            var l;
            return ht(ht.call) || !ht(Object) || !ht(function() {
              l = true;
            }) || l;
          }) ? io : ht;
        });
        var uo = v((Hm, ho) => {
          var oo = lr(), ff = no(), df = Oe(), mf = at(), yf = mf("species"), lo = Array;
          ho.exports = function(l) {
            var h2;
            return oo(l) && (h2 = l.constructor, ff(h2) && (h2 === lo || oo(h2.prototype)) ? h2 = void 0 : df(h2) && (h2 = h2[yf], h2 === null && (h2 = void 0))), h2 === void 0 ? lo : h2;
          };
        });
        var po = v((zm, co) => {
          var xf = uo();
          co.exports = function(l, h2) {
            return new (xf(l))(h2 === 0 ? 0 : h2);
          };
        });
        var fo = v(() => {
          "use strict";
          var gf = nr(), Pf = Jn(), Af = Ft(), Tf = Ms(), vf = Ut(), Ef = po();
          gf({ target: "Array", proto: true }, { flatMap: function(h2) {
            var f = Tf(this), d = vf(f), y;
            return Af(h2), y = Ef(f, 0), y.length = Pf(y, f, f, d, 0, 1, h2, arguments.length > 1 ? arguments[1] : void 0), y;
          } });
        });
        var fd = v((Zm, Ho) => {
          kn();
          Rn();
          fo();
          var fr = Object.defineProperty, Cf = Object.getOwnPropertyDescriptor, dr = Object.getOwnPropertyNames, bf = Object.prototype.hasOwnProperty, Ao = (l, h2) => function() {
            return l && (h2 = (0, l[dr(l)[0]])(l = 0)), h2;
          }, K = (l, h2) => function() {
            return h2 || (0, l[dr(l)[0]])((h2 = { exports: {} }).exports, h2), h2.exports;
          }, Sf = (l, h2) => {
            for (var f in h2)
              fr(l, f, { get: h2[f], enumerable: true });
          }, wf = (l, h2, f, d) => {
            if (h2 && typeof h2 == "object" || typeof h2 == "function")
              for (let y of dr(h2))
                !bf.call(l, y) && y !== f && fr(l, y, { get: () => h2[y], enumerable: !(d = Cf(h2, y)) || d.enumerable });
            return l;
          }, If = (l) => wf(fr({}, "__esModule", { value: true }), l), V = Ao({ "<define:process>"() {
          } }), Nf = K({ "src/utils/try-combinations.js"(l, h2) {
            "use strict";
            V();
            function f() {
              let d;
              for (var y = arguments.length, P = new Array(y), g = 0; g < y; g++)
                P[g] = arguments[g];
              for (let [T, S] of P.entries())
                try {
                  return { result: S() };
                } catch (F4) {
                  T === 0 && (d = F4);
                }
              return { error: d };
            }
            h2.exports = f;
          } }), To = K({ "src/language-js/utils/get-shebang.js"(l, h2) {
            "use strict";
            V();
            function f(d) {
              if (!d.startsWith("#!"))
                return "";
              let y = d.indexOf(`
`);
              return y === -1 ? d : d.slice(0, y);
            }
            h2.exports = f;
          } }), kf = K({ "src/utils/text/skip-inline-comment.js"(l, h2) {
            "use strict";
            V();
            function f(d, y) {
              if (y === false)
                return false;
              if (d.charAt(y) === "/" && d.charAt(y + 1) === "*") {
                for (let P = y + 2; P < d.length; ++P)
                  if (d.charAt(P) === "*" && d.charAt(P + 1) === "/")
                    return P + 2;
              }
              return y;
            }
            h2.exports = f;
          } }), Df = K({ "src/utils/text/skip-newline.js"(l, h2) {
            "use strict";
            V();
            function f(d, y, P) {
              let g = P && P.backwards;
              if (y === false)
                return false;
              let T = d.charAt(y);
              if (g) {
                if (d.charAt(y - 1) === "\r" && T === `
`)
                  return y - 2;
                if (T === `
` || T === "\r" || T === "\u2028" || T === "\u2029")
                  return y - 1;
              } else {
                if (T === "\r" && d.charAt(y + 1) === `
`)
                  return y + 2;
                if (T === `
` || T === "\r" || T === "\u2028" || T === "\u2029")
                  return y + 1;
              }
              return y;
            }
            h2.exports = f;
          } }), vo = K({ "src/utils/text/skip.js"(l, h2) {
            "use strict";
            V();
            function f(T) {
              return (S, F4, I) => {
                let C = I && I.backwards;
                if (F4 === false)
                  return false;
                let { length: L } = S, j = F4;
                for (; j >= 0 && j < L; ) {
                  let k = S.charAt(j);
                  if (T instanceof RegExp) {
                    if (!T.test(k))
                      return j;
                  } else if (!T.includes(k))
                    return j;
                  C ? j-- : j++;
                }
                return j === -1 || j === L ? j : false;
              };
            }
            var d = f(/\s/), y = f(" 	"), P = f(",; 	"), g = f(/[^\n\r]/);
            h2.exports = { skipWhitespace: d, skipSpaces: y, skipToLineEnd: P, skipEverythingButNewLine: g };
          } }), Ff = K({ "src/utils/text/skip-trailing-comment.js"(l, h2) {
            "use strict";
            V();
            var { skipEverythingButNewLine: f } = vo();
            function d(y, P) {
              return P === false ? false : y.charAt(P) === "/" && y.charAt(P + 1) === "/" ? f(y, P) : P;
            }
            h2.exports = d;
          } }), Lf = K({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(l, h2) {
            "use strict";
            V();
            var f = kf(), d = Df(), y = Ff(), { skipSpaces: P } = vo();
            function g(T, S) {
              let F4 = null, I = S;
              for (; I !== F4; )
                F4 = I, I = P(T, I), I = f(T, I), I = y(T, I), I = d(T, I);
              return I;
            }
            h2.exports = g;
          } }), Eo = {};
          Sf(Eo, { EOL: () => pr, arch: () => Of, cpus: () => ko, default: () => Bo, endianness: () => Co, freemem: () => Io, getNetworkInterfaces: () => Oo, hostname: () => bo, loadavg: () => So, networkInterfaces: () => Lo, platform: () => Bf, release: () => Fo, tmpDir: () => ur, tmpdir: () => cr, totalmem: () => No, type: () => Do, uptime: () => wo });
          function Co() {
            if (typeof Ht > "u") {
              var l = new ArrayBuffer(2), h2 = new Uint8Array(l), f = new Uint16Array(l);
              if (h2[0] = 1, h2[1] = 2, f[0] === 258)
                Ht = "BE";
              else if (f[0] === 513)
                Ht = "LE";
              else
                throw new Error("unable to figure out endianess");
            }
            return Ht;
          }
          function bo() {
            return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
          }
          function So() {
            return [];
          }
          function wo() {
            return 0;
          }
          function Io() {
            return Number.MAX_VALUE;
          }
          function No() {
            return Number.MAX_VALUE;
          }
          function ko() {
            return [];
          }
          function Do() {
            return "Browser";
          }
          function Fo() {
            return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
          }
          function Lo() {
          }
          function Oo() {
          }
          function Of() {
            return "javascript";
          }
          function Bf() {
            return "browser";
          }
          function ur() {
            return "/tmp";
          }
          var Ht, cr, pr, Bo, Mf = Ao({ "node-modules-polyfills:os"() {
            V(), cr = ur, pr = `
`, Bo = { EOL: pr, tmpdir: cr, tmpDir: ur, networkInterfaces: Lo, getNetworkInterfaces: Oo, release: Fo, type: Do, cpus: ko, totalmem: No, freemem: Io, uptime: wo, loadavg: So, hostname: bo, endianness: Co };
          } }), _f = K({ "node-modules-polyfills-commonjs:os"(l, h2) {
            V();
            var f = (Mf(), If(Eo));
            if (f && f.default) {
              h2.exports = f.default;
              for (let d in f)
                h2.exports[d] = f[d];
            } else
              f && (h2.exports = f);
          } }), Rf = K({ "node_modules/detect-newline/index.js"(l, h2) {
            "use strict";
            V();
            var f = (d) => {
              if (typeof d != "string")
                throw new TypeError("Expected a string");
              let y = d.match(/(?:\r?\n)/g) || [];
              if (y.length === 0)
                return;
              let P = y.filter((T) => T === `\r
`).length, g = y.length - P;
              return P > g ? `\r
` : `
`;
            };
            h2.exports = f, h2.exports.graceful = (d) => typeof d == "string" && f(d) || `
`;
          } }), jf = K({ "node_modules/jest-docblock/build/index.js"(l) {
            "use strict";
            V(), Object.defineProperty(l, "__esModule", { value: true }), l.extract = j, l.parse = H, l.parseWithComments = W, l.print = B, l.strip = k;
            function h2() {
              let u = _f();
              return h2 = function() {
                return u;
              }, u;
            }
            function f() {
              let u = d(Rf());
              return f = function() {
                return u;
              }, u;
            }
            function d(u) {
              return u && u.__esModule ? u : { default: u };
            }
            var y = /\*\/$/, P = /^\/\*\*?/, g = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, T = /(^|\s+)\/\/([^\r\n]*)/g, S = /^(\r?\n)+/, F4 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, I = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, C = /(\r?\n|^) *\* ?/g, L = [];
            function j(u) {
              let G = u.match(g);
              return G ? G[0].trimLeft() : "";
            }
            function k(u) {
              let G = u.match(g);
              return G && G[0] ? u.substring(G[0].length) : u;
            }
            function H(u) {
              return W(u).pragmas;
            }
            function W(u) {
              let G = (0, f().default)(u) || h2().EOL;
              u = u.replace(P, "").replace(y, "").replace(C, "$1");
              let oe = "";
              for (; oe !== u; )
                oe = u, u = u.replace(F4, `${G}$1 $2${G}`);
              u = u.replace(S, "").trimRight();
              let X = /* @__PURE__ */ Object.create(null), _e = u.replace(I, "").replace(S, "").trimRight(), Z;
              for (; Z = I.exec(u); ) {
                let $ = Z[2].replace(T, "");
                typeof X[Z[1]] == "string" || Array.isArray(X[Z[1]]) ? X[Z[1]] = L.concat(X[Z[1]], $) : X[Z[1]] = $;
              }
              return { comments: _e, pragmas: X };
            }
            function B(u) {
              let { comments: G = "", pragmas: oe = {} } = u, X = (0, f().default)(G) || h2().EOL, _e = "/**", Z = " *", $ = " */", M = Object.keys(oe), E = M.map((ee) => _(ee, oe[ee])).reduce((ee, fe) => ee.concat(fe), []).map((ee) => `${Z} ${ee}${X}`).join("");
              if (!G) {
                if (M.length === 0)
                  return "";
                if (M.length === 1 && !Array.isArray(oe[M[0]])) {
                  let ee = oe[M[0]];
                  return `${_e} ${_(M[0], ee)[0]}${$}`;
                }
              }
              let Je = G.split(X).map((ee) => `${Z} ${ee}`).join(X) + X;
              return _e + X + (G ? Je : "") + (G && M.length ? Z + X : "") + E + $;
            }
            function _(u, G) {
              return L.concat(G).map((oe) => `@${u} ${oe}`.trim());
            }
          } }), qf = K({ "src/common/end-of-line.js"(l, h2) {
            "use strict";
            V();
            function f(g) {
              let T = g.indexOf("\r");
              return T >= 0 ? g.charAt(T + 1) === `
` ? "crlf" : "cr" : "lf";
            }
            function d(g) {
              switch (g) {
                case "cr":
                  return "\r";
                case "crlf":
                  return `\r
`;
                default:
                  return `
`;
              }
            }
            function y(g, T) {
              let S;
              switch (T) {
                case `
`:
                  S = /\n/g;
                  break;
                case "\r":
                  S = /\r/g;
                  break;
                case `\r
`:
                  S = /\r\n/g;
                  break;
                default:
                  throw new Error(`Unexpected "eol" ${JSON.stringify(T)}.`);
              }
              let F4 = g.match(S);
              return F4 ? F4.length : 0;
            }
            function P(g) {
              return g.replace(/\r\n?/g, `
`);
            }
            h2.exports = { guessEndOfLine: f, convertEndOfLineToChars: d, countEndOfLineChars: y, normalizeEndOfLine: P };
          } }), Uf = K({ "src/language-js/pragma.js"(l, h2) {
            "use strict";
            V();
            var { parseWithComments: f, strip: d, extract: y, print: P } = jf(), { normalizeEndOfLine: g } = qf(), T = To();
            function S(C) {
              let L = T(C);
              L && (C = C.slice(L.length + 1));
              let j = y(C), { pragmas: k, comments: H } = f(j);
              return { shebang: L, text: C, pragmas: k, comments: H };
            }
            function F4(C) {
              let L = Object.keys(S(C).pragmas);
              return L.includes("prettier") || L.includes("format");
            }
            function I(C) {
              let { shebang: L, text: j, pragmas: k, comments: H } = S(C), W = d(j), B = P({ pragmas: Object.assign({ format: "" }, k), comments: H.trimStart() });
              return (L ? `${L}
` : "") + g(B) + (W.startsWith(`
`) ? `
` : `

`) + W;
            }
            h2.exports = { hasPragma: F4, insertPragma: I };
          } }), mr = K({ "src/utils/is-non-empty-array.js"(l, h2) {
            "use strict";
            V();
            function f(d) {
              return Array.isArray(d) && d.length > 0;
            }
            h2.exports = f;
          } }), Mo = K({ "src/language-js/loc.js"(l, h2) {
            "use strict";
            V();
            var f = mr();
            function d(S) {
              var F4, I;
              let C = S.range ? S.range[0] : S.start, L = (F4 = (I = S.declaration) === null || I === void 0 ? void 0 : I.decorators) !== null && F4 !== void 0 ? F4 : S.decorators;
              return f(L) ? Math.min(d(L[0]), C) : C;
            }
            function y(S) {
              return S.range ? S.range[1] : S.end;
            }
            function P(S, F4) {
              let I = d(S);
              return Number.isInteger(I) && I === d(F4);
            }
            function g(S, F4) {
              let I = y(S);
              return Number.isInteger(I) && I === y(F4);
            }
            function T(S, F4) {
              return P(S, F4) && g(S, F4);
            }
            h2.exports = { locStart: d, locEnd: y, hasSameLocStart: P, hasSameLoc: T };
          } }), _o = K({ "src/language-js/parse/utils/create-parser.js"(l, h2) {
            "use strict";
            V();
            var { hasPragma: f } = Uf(), { locStart: d, locEnd: y } = Mo();
            function P(g) {
              return g = typeof g == "function" ? { parse: g } : g, Object.assign({ astFormat: "estree", hasPragma: f, locStart: d, locEnd: y }, g);
            }
            h2.exports = P;
          } }), yr = K({ "src/common/parser-create-error.js"(l, h2) {
            "use strict";
            V();
            function f(d, y) {
              let P = new SyntaxError(d + " (" + y.start.line + ":" + y.start.column + ")");
              return P.loc = y, P;
            }
            h2.exports = f;
          } }), Ro = K({ "src/language-js/parse/utils/create-babel-parse-error.js"(l, h2) {
            "use strict";
            V();
            var f = yr();
            function d(y) {
              let { message: P, loc: g } = y;
              return f(P.replace(/ \(.*\)/, ""), { start: { line: g ? g.line : 0, column: g ? g.column + 1 : 0 } });
            }
            h2.exports = d;
          } }), $f = K({ "src/language-js/utils/is-ts-keyword-type.js"(l, h2) {
            "use strict";
            V();
            function f(d) {
              let { type: y } = d;
              return y.startsWith("TS") && y.endsWith("Keyword");
            }
            h2.exports = f;
          } }), Hf = K({ "src/language-js/utils/is-block-comment.js"(l, h2) {
            "use strict";
            V();
            var f = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), d = (y) => f.has(y == null ? void 0 : y.type);
            h2.exports = d;
          } }), zf = K({ "src/language-js/utils/is-type-cast-comment.js"(l, h2) {
            "use strict";
            V();
            var f = Hf();
            function d(y) {
              return f(y) && y.value[0] === "*" && /@(?:type|satisfies)\b/.test(y.value);
            }
            h2.exports = d;
          } }), Vf = K({ "src/utils/get-last.js"(l, h2) {
            "use strict";
            V();
            var f = (d) => d[d.length - 1];
            h2.exports = f;
          } }), jo = K({ "src/language-js/parse/postprocess/visit-node.js"(l, h2) {
            "use strict";
            V();
            function f(d, y) {
              if (Array.isArray(d)) {
                for (let P = 0; P < d.length; P++)
                  d[P] = f(d[P], y);
                return d;
              }
              if (d && typeof d == "object" && typeof d.type == "string") {
                let P = Object.keys(d);
                for (let g = 0; g < P.length; g++)
                  d[P[g]] = f(d[P[g]], y);
                return y(d) || d;
              }
              return d;
            }
            h2.exports = f;
          } }), qo = K({ "src/language-js/parse/postprocess/throw-syntax-error.js"(l, h2) {
            "use strict";
            V();
            var f = yr();
            function d(y, P) {
              let { start: g, end: T } = y.loc;
              throw f(P, { start: { line: g.line, column: g.column + 1 }, end: { line: T.line, column: T.column + 1 } });
            }
            h2.exports = d;
          } }), Kf = K({ "src/language-js/parse/postprocess/typescript.js"(l, h2) {
            "use strict";
            V();
            var f = mr(), d = jo(), y = qo(), P = { AbstractKeyword: 126, SourceFile: 308, PropertyDeclaration: 169 };
            function g(I) {
              for (; I && I.kind !== P.SourceFile; )
                I = I.parent;
              return I;
            }
            function T(I) {
              let { illegalDecorators: C } = I;
              if (!f(C))
                return;
              let [{ expression: L }] = C, j = g(L), [k, H] = [L.pos, L.end].map((W) => {
                let { line: B, character: _ } = j.getLineAndCharacterOfPosition(W);
                return { line: B + 1, column: _ };
              });
              y({ loc: { start: k, end: H } }, "Decorators are not valid here.");
            }
            function S(I, C) {
              I.kind !== P.PropertyDeclaration || I.modifiers && !I.modifiers.some((L) => L.kind === P.AbstractKeyword) || I.initializer && C.value === null && y(C, "Abstract property cannot have an initializer");
            }
            function F4(I, C) {
              let { esTreeNodeToTSNodeMap: L, tsNodeToESTreeNodeMap: j } = C.tsParseResult;
              d(I, (k) => {
                let H = L.get(k);
                if (!H)
                  return;
                let W = j.get(H);
                W === k && (T(H), S(H, W));
              });
            }
            h2.exports = { throwErrorForInvalidNodes: F4 };
          } }), Wf = K({ "src/language-js/parse/postprocess/index.js"(l, h2) {
            "use strict";
            V();
            var { locStart: f, locEnd: d } = Mo(), y = $f(), P = zf(), g = Vf(), T = jo(), { throwErrorForInvalidNodes: S } = Kf(), F4 = qo();
            function I(k, H) {
              if (H.parser === "typescript" && /@|abstract/.test(H.originalText) && S(k, H), H.parser !== "typescript" && H.parser !== "flow" && H.parser !== "acorn" && H.parser !== "espree" && H.parser !== "meriyah") {
                let B = /* @__PURE__ */ new Set();
                k = T(k, (_) => {
                  _.leadingComments && _.leadingComments.some(P) && B.add(f(_));
                }), k = T(k, (_) => {
                  if (_.type === "ParenthesizedExpression") {
                    let { expression: u } = _;
                    if (u.type === "TypeCastExpression")
                      return u.range = _.range, u;
                    let G = f(_);
                    if (!B.has(G))
                      return u.extra = Object.assign(Object.assign({}, u.extra), {}, { parenthesized: true }), u;
                  }
                });
              }
              return k = T(k, (B) => {
                switch (B.type) {
                  case "ChainExpression":
                    return C(B.expression);
                  case "LogicalExpression": {
                    if (L(B))
                      return j(B);
                    break;
                  }
                  case "VariableDeclaration": {
                    let _ = g(B.declarations);
                    _ && _.init && W(B, _);
                    break;
                  }
                  case "TSParenthesizedType":
                    return y(B.typeAnnotation) || B.typeAnnotation.type === "TSThisType" || (B.typeAnnotation.range = [f(B), d(B)]), B.typeAnnotation;
                  case "TSTypeParameter":
                    if (typeof B.name == "string") {
                      let _ = f(B);
                      B.name = { type: "Identifier", name: B.name, range: [_, _ + B.name.length] };
                    }
                    break;
                  case "ObjectExpression":
                    if (H.parser === "typescript") {
                      let _ = B.properties.find((u) => u.type === "Property" && u.value.type === "TSEmptyBodyFunctionExpression");
                      _ && F4(_.value, "Unexpected token.");
                    }
                    break;
                  case "SequenceExpression": {
                    let _ = g(B.expressions);
                    B.range = [f(B), Math.min(d(_), d(B))];
                    break;
                  }
                  case "TopicReference":
                    H.__isUsingHackPipeline = true;
                    break;
                  case "ExportAllDeclaration": {
                    let { exported: _ } = B;
                    if (H.parser === "meriyah" && _ && _.type === "Identifier") {
                      let u = H.originalText.slice(f(_), d(_));
                      (u.startsWith('"') || u.startsWith("'")) && (B.exported = Object.assign(Object.assign({}, B.exported), {}, { type: "Literal", value: B.exported.name, raw: u }));
                    }
                    break;
                  }
                  case "PropertyDefinition":
                    if (H.parser === "meriyah" && B.static && !B.computed && !B.key) {
                      let _ = "static", u = f(B);
                      Object.assign(B, { static: false, key: { type: "Identifier", name: _, range: [u, u + _.length] } });
                    }
                    break;
                }
              }), k;
              function W(B, _) {
                H.originalText[d(_)] !== ";" && (B.range = [f(B), d(_)]);
              }
            }
            function C(k) {
              switch (k.type) {
                case "CallExpression":
                  k.type = "OptionalCallExpression", k.callee = C(k.callee);
                  break;
                case "MemberExpression":
                  k.type = "OptionalMemberExpression", k.object = C(k.object);
                  break;
                case "TSNonNullExpression":
                  k.expression = C(k.expression);
                  break;
              }
              return k;
            }
            function L(k) {
              return k.type === "LogicalExpression" && k.right.type === "LogicalExpression" && k.operator === k.right.operator;
            }
            function j(k) {
              return L(k) ? j({ type: "LogicalExpression", operator: k.operator, left: j({ type: "LogicalExpression", operator: k.operator, left: k.left, right: k.right.left, range: [f(k.left), d(k.right.left)] }), right: k.right.right, range: [f(k), d(k)] }) : k;
            }
            h2.exports = I;
          } }), Uo = K({ "node_modules/@babel/parser/lib/index.js"(l) {
            "use strict";
            V(), Object.defineProperty(l, "__esModule", { value: true });
            function h2(t4, r) {
              if (t4 == null)
                return {};
              var e = {}, s = Object.keys(t4), i, a;
              for (a = 0; a < s.length; a++)
                i = s[a], !(r.indexOf(i) >= 0) && (e[i] = t4[i]);
              return e;
            }
            var f = class {
              constructor(t4, r, e) {
                this.line = void 0, this.column = void 0, this.index = void 0, this.line = t4, this.column = r, this.index = e;
              }
            }, d = class {
              constructor(t4, r) {
                this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t4, this.end = r;
              }
            };
            function y(t4, r) {
              let { line: e, column: s, index: i } = t4;
              return new f(e, s + r, i + r);
            }
            var P = { SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }, g = function(t4) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t4.length - 1;
              return { get() {
                return t4.reduce((e, s) => e[s], this);
              }, set(e) {
                t4.reduce((s, i, a) => a === r ? s[i] = e : s[i], this);
              } };
            }, T = (t4, r, e) => Object.keys(e).map((s) => [s, e[s]]).filter((s) => {
              let [, i] = s;
              return !!i;
            }).map((s) => {
              let [i, a] = s;
              return [i, typeof a == "function" ? { value: a, enumerable: false } : typeof a.reflect == "string" ? Object.assign({}, a, g(a.reflect.split("."))) : a];
            }).reduce((s, i) => {
              let [a, n] = i;
              return Object.defineProperty(s, a, Object.assign({ configurable: true }, n));
            }, Object.assign(new t4(), r)), S = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: P.SourceTypeModuleError }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: P.SourceTypeModuleError } }, F4 = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, I = (t4) => {
              let { type: r, prefix: e } = t4;
              return r === "UpdateExpression" ? F4.UpdateExpression[String(e)] : F4[r];
            }, C = { AccessorIsGenerator: (t4) => {
              let { kind: r } = t4;
              return `A ${r}ter cannot be a generator.`;
            }, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: (t4) => {
              let { kind: r } = t4;
              return `Missing initializer in ${r} declaration.`;
            }, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: (t4) => {
              let { exportName: r } = t4;
              return `\`${r}\` has already been exported. Exported identifiers must be unique.`;
            }, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: (t4) => {
              let { localName: r, exportName: e } = t4;
              return `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${r}' as '${e}' } from 'some-module'\`?`;
            }, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: (t4) => {
              let { type: r } = t4;
              return `'${r === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`;
            }, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: (t4) => {
              let { type: r } = t4;
              return `Unsyntactic ${r === "BreakStatement" ? "break" : "continue"}.`;
            }, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: (t4) => {
              let { importName: r } = t4;
              return `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${r}" as foo }\`?`;
            }, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: (t4) => {
              let { maxArgumentCount: r } = t4;
              return `\`import()\` requires exactly ${r === 1 ? "one argument" : "one or two arguments"}.`;
            }, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: (t4) => {
              let { radix: r } = t4;
              return `Expected number in radix ${r}.`;
            }, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: (t4) => {
              let { reservedWord: r } = t4;
              return `Escape sequence in keyword ${r}.`;
            }, InvalidIdentifier: (t4) => {
              let { identifierName: r } = t4;
              return `Invalid identifier ${r}.`;
            }, InvalidLhs: (t4) => {
              let { ancestor: r } = t4;
              return `Invalid left-hand side in ${I(r)}.`;
            }, InvalidLhsBinding: (t4) => {
              let { ancestor: r } = t4;
              return `Binding invalid left-hand side in ${I(r)}.`;
            }, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: (t4) => {
              let { unexpected: r } = t4;
              return `Unexpected character '${r}'.`;
            }, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: (t4) => {
              let { identifierName: r } = t4;
              return `Private name #${r} is not defined.`;
            }, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: (t4) => {
              let { labelName: r } = t4;
              return `Label '${r}' is already declared.`;
            }, LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: (t4) => {
              let { missingPlugin: r } = t4;
              return `This experimental syntax requires enabling the parser plugin: ${r.map((e) => JSON.stringify(e)).join(", ")}.`;
            }, MissingOneOfPlugins: (t4) => {
              let { missingPlugin: r } = t4;
              return `This experimental syntax requires enabling one of the following parser plugin(s): ${r.map((e) => JSON.stringify(e)).join(", ")}.`;
            }, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: (t4) => {
              let { key: r } = t4;
              return `Duplicate key "${r}" is not allowed in module attributes.`;
            }, ModuleExportNameHasLoneSurrogate: (t4) => {
              let { surrogateCharCode: r } = t4;
              return `An export name cannot include a lone surrogate, found '\\u${r.toString(16)}'.`;
            }, ModuleExportUndefined: (t4) => {
              let { localName: r } = t4;
              return `Export '${r}' is not defined.`;
            }, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: (t4) => {
              let { identifierName: r } = t4;
              return `Private names are only allowed in property accesses (\`obj.#${r}\`) or in \`in\` expressions (\`#${r} in obj\`).`;
            }, PrivateNameRedeclaration: (t4) => {
              let { identifierName: r } = t4;
              return `Duplicate private name #${r}.`;
            }, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: (t4) => {
              let { keyword: r } = t4;
              return `Unexpected keyword '${r}'.`;
            }, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: (t4) => {
              let { reservedWord: r } = t4;
              return `Unexpected reserved word '${r}'.`;
            }, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: (t4) => {
              let { expected: r, unexpected: e } = t4;
              return `Unexpected token${e ? ` '${e}'.` : ""}${r ? `, expected "${r}"` : ""}`;
            }, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: (t4) => {
              let { target: r, onlyValidPropertyName: e } = t4;
              return `The only valid meta property for ${r} is ${r}.${e}.`;
            }, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: (t4) => {
              let { identifierName: r } = t4;
              return `Identifier '${r}' has already been declared.`;
            }, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, L = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: (t4) => {
              let { referenceName: r } = t4;
              return `Assigning to '${r}' in strict mode.`;
            }, StrictEvalArgumentsBinding: (t4) => {
              let { bindingName: r } = t4;
              return `Binding '${r}' in strict mode.`;
            }, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, j = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), k = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: (t4) => {
              let { token: r } = t4;
              return `Invalid topic token ${r}. In order to use ${r} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${r}" }.`;
            }, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: (t4) => {
              let { type: r } = t4;
              return `Hack-style pipe body cannot be an unparenthesized ${I({ type: r })}; please wrap it in parentheses.`;
            }, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, H = ["toMessage"], W = ["message"];
            function B(t4) {
              let { toMessage: r } = t4, e = h2(t4, H);
              return function s(i) {
                let { loc: a, details: n } = i;
                return T(SyntaxError, Object.assign({}, e, { loc: a }), { clone() {
                  let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c = o.loc || {};
                  return s({ loc: new f("line" in c ? c.line : this.loc.line, "column" in c ? c.column : this.loc.column, "index" in c ? c.index : this.loc.index), details: Object.assign({}, this.details, o.details) });
                }, details: { value: n, enumerable: false }, message: { get() {
                  return `${r(this.details)} (${this.loc.line}:${this.loc.column})`;
                }, set(o) {
                  Object.defineProperty(this, "message", { value: o });
                } }, pos: { reflect: "loc.index", enumerable: true }, missingPlugin: "missingPlugin" in n && { reflect: "details.missingPlugin", enumerable: true } });
              };
            }
            function _(t4, r) {
              if (Array.isArray(t4))
                return (s) => _(s, t4[0]);
              let e = {};
              for (let s of Object.keys(t4)) {
                let i = t4[s], a = typeof i == "string" ? { message: () => i } : typeof i == "function" ? { message: i } : i, { message: n } = a, o = h2(a, W), c = typeof n == "string" ? () => n : n;
                e[s] = B(Object.assign({ code: P.SyntaxError, reasonCode: s, toMessage: c }, r ? { syntaxPlugin: r } : {}, o));
              }
              return e;
            }
            var u = Object.assign({}, _(S), _(C), _(L), _`pipelineOperator`(k)), { defineProperty: G } = Object, oe = (t4, r) => G(t4, r, { enumerable: false, value: t4[r] });
            function X(t4) {
              return t4.loc.start && oe(t4.loc.start, "index"), t4.loc.end && oe(t4.loc.end, "index"), t4;
            }
            var _e = (t4) => class extends t4 {
              parse() {
                let e = X(super.parse());
                return this.options.tokens && (e.tokens = e.tokens.map(X)), e;
              }
              parseRegExpLiteral(e) {
                let { pattern: s, flags: i } = e, a = null;
                try {
                  a = new RegExp(s, i);
                } catch {
                }
                let n = this.estreeParseLiteral(a);
                return n.regex = { pattern: s, flags: i }, n;
              }
              parseBigIntLiteral(e) {
                let s;
                try {
                  s = BigInt(e);
                } catch {
                  s = null;
                }
                let i = this.estreeParseLiteral(s);
                return i.bigint = String(i.value || e), i;
              }
              parseDecimalLiteral(e) {
                let i = this.estreeParseLiteral(null);
                return i.decimal = String(i.value || e), i;
              }
              estreeParseLiteral(e) {
                return this.parseLiteral(e, "Literal");
              }
              parseStringLiteral(e) {
                return this.estreeParseLiteral(e);
              }
              parseNumericLiteral(e) {
                return this.estreeParseLiteral(e);
              }
              parseNullLiteral() {
                return this.estreeParseLiteral(null);
              }
              parseBooleanLiteral(e) {
                return this.estreeParseLiteral(e);
              }
              directiveToStmt(e) {
                let s = e.value;
                delete e.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
                let i = e;
                return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
              }
              initFunction(e, s) {
                super.initFunction(e, s), e.expression = false;
              }
              checkDeclaration(e) {
                e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
              }
              getObjectOrClassMethodParams(e) {
                return e.value.params;
              }
              isValidDirective(e) {
                var s;
                return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((s = e.expression.extra) != null && s.parenthesized);
              }
              parseBlockBody(e, s, i, a, n) {
                super.parseBlockBody(e, s, i, a, n);
                let o = e.directives.map((c) => this.directiveToStmt(c));
                e.body = o.concat(e.body), delete e.directives;
              }
              pushClassMethod(e, s, i, a, n, o) {
                this.parseMethod(s, i, a, n, o, "ClassMethod", true), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters), e.body.push(s);
              }
              parsePrivateName() {
                let e = super.parsePrivateName();
                return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
              }
              convertPrivateNameToPrivateIdentifier(e) {
                let s = super.getPrivateNameSV(e);
                return e = e, delete e.id, e.name = s, e.type = "PrivateIdentifier", e;
              }
              isPrivateName(e) {
                return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
              }
              getPrivateNameSV(e) {
                return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
              }
              parseLiteral(e, s) {
                let i = super.parseLiteral(e, s);
                return i.raw = i.extra.raw, delete i.extra, i;
              }
              parseFunctionBody(e, s) {
                let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                super.parseFunctionBody(e, s, i), e.expression = e.body.type !== "BlockStatement";
              }
              parseMethod(e, s, i, a, n, o) {
                let c = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, p = this.startNode();
                return p.kind = e.kind, p = super.parseMethod(p, s, i, a, n, o, c), p.type = "FunctionExpression", delete p.kind, e.value = p, o === "ClassPrivateMethod" && (e.computed = false), this.finishNode(e, "MethodDefinition");
              }
              parseClassProperty() {
                let e = super.parseClassProperty(...arguments);
                return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition"), e;
              }
              parseClassPrivateProperty() {
                let e = super.parseClassPrivateProperty(...arguments);
                return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition", e.computed = false), e;
              }
              parseObjectMethod(e, s, i, a, n) {
                let o = super.parseObjectMethod(e, s, i, a, n);
                return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = false), o;
              }
              parseObjectProperty(e, s, i, a) {
                let n = super.parseObjectProperty(e, s, i, a);
                return n && (n.kind = "init", n.type = "Property"), n;
              }
              isValidLVal(e, s, i) {
                return e === "Property" ? "value" : super.isValidLVal(e, s, i);
              }
              isAssignable(e, s) {
                return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, s) : super.isAssignable(e, s);
              }
              toAssignable(e) {
                let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (e != null && this.isObjectProperty(e)) {
                  let { key: i, value: a } = e;
                  this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a, s);
                } else
                  super.toAssignable(e, s);
              }
              toAssignableObjectExpressionProp(e, s, i) {
                e.kind === "get" || e.kind === "set" ? this.raise(u.PatternHasAccessor, { at: e.key }) : e.method ? this.raise(u.PatternHasMethod, { at: e.key }) : super.toAssignableObjectExpressionProp(e, s, i);
              }
              finishCallExpression(e, s) {
                let i = super.finishCallExpression(e, s);
                if (i.callee.type === "Import") {
                  if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAssertions")) {
                    var a;
                    i.attributes = (a = i.arguments[1]) != null ? a : null;
                  }
                  delete i.arguments, delete i.callee;
                }
                return i;
              }
              toReferencedArguments(e) {
                e.type !== "ImportExpression" && super.toReferencedArguments(e);
              }
              parseExport(e, s) {
                let i = this.state.lastTokStartLoc, a = super.parseExport(e, s);
                switch (a.type) {
                  case "ExportAllDeclaration":
                    a.exported = null;
                    break;
                  case "ExportNamedDeclaration":
                    a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported = a.specifiers[0].exported, delete a.specifiers);
                  case "ExportDefaultDeclaration":
                    {
                      var n;
                      let { declaration: o } = a;
                      (o == null ? void 0 : o.type) === "ClassDeclaration" && ((n = o.decorators) == null ? void 0 : n.length) > 0 && o.start === a.start && this.resetStartLocation(a, i);
                    }
                    break;
                }
                return a;
              }
              parseSubscript(e, s, i, a) {
                let n = super.parseSubscript(e, s, i, a);
                if (a.optionalChainMember) {
                  if ((n.type === "OptionalMemberExpression" || n.type === "OptionalCallExpression") && (n.type = n.type.substring(8)), a.stop) {
                    let o = this.startNodeAtNode(n);
                    return o.expression = n, this.finishNode(o, "ChainExpression");
                  }
                } else
                  (n.type === "MemberExpression" || n.type === "CallExpression") && (n.optional = false);
                return n;
              }
              hasPropertyAsPrivateName(e) {
                return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
              }
              isOptionalChain(e) {
                return e.type === "ChainExpression";
              }
              isObjectProperty(e) {
                return e.type === "Property" && e.kind === "init" && !e.method;
              }
              isObjectMethod(e) {
                return e.method || e.kind === "get" || e.kind === "set";
              }
              finishNodeAt(e, s, i) {
                return X(super.finishNodeAt(e, s, i));
              }
              resetStartLocation(e, s) {
                super.resetStartLocation(e, s), X(e);
              }
              resetEndLocation(e) {
                let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
                super.resetEndLocation(e, s), X(e);
              }
            }, Z = class {
              constructor(t4, r) {
                this.token = void 0, this.preserveSpace = void 0, this.token = t4, this.preserveSpace = !!r;
              }
            }, $ = { brace: new Z("{"), j_oTag: new Z("<tag"), j_cTag: new Z("</tag"), j_expr: new Z("<tag>...</tag>", true) };
            $.template = new Z("`", true);
            var M = true, E = true, Je = true, ee = true, fe = true, zo = true, xr = class {
              constructor(t4) {
                let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t4, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.updateContext = null;
              }
            }, zt = /* @__PURE__ */ new Map();
            function U3(t4) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              r.keyword = t4;
              let e = N6(t4, r);
              return zt.set(t4, e), e;
            }
            function re(t4, r) {
              return N6(t4, { beforeExpr: M, binop: r });
            }
            var Xe = -1, me = [], Vt = [], Kt = [], Wt = [], Gt = [], Jt = [];
            function N6(t4) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var e, s, i, a;
              return ++Xe, Vt.push(t4), Kt.push((e = r.binop) != null ? e : -1), Wt.push((s = r.beforeExpr) != null ? s : false), Gt.push((i = r.startsExpr) != null ? i : false), Jt.push((a = r.prefix) != null ? a : false), me.push(new xr(t4, r)), Xe;
            }
            function q(t4) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var e, s, i, a;
              return ++Xe, zt.set(t4, Xe), Vt.push(t4), Kt.push((e = r.binop) != null ? e : -1), Wt.push((s = r.beforeExpr) != null ? s : false), Gt.push((i = r.startsExpr) != null ? i : false), Jt.push((a = r.prefix) != null ? a : false), me.push(new xr("name", r)), Xe;
            }
            var Vo = { bracketL: N6("[", { beforeExpr: M, startsExpr: E }), bracketHashL: N6("#[", { beforeExpr: M, startsExpr: E }), bracketBarL: N6("[|", { beforeExpr: M, startsExpr: E }), bracketR: N6("]"), bracketBarR: N6("|]"), braceL: N6("{", { beforeExpr: M, startsExpr: E }), braceBarL: N6("{|", { beforeExpr: M, startsExpr: E }), braceHashL: N6("#{", { beforeExpr: M, startsExpr: E }), braceR: N6("}"), braceBarR: N6("|}"), parenL: N6("(", { beforeExpr: M, startsExpr: E }), parenR: N6(")"), comma: N6(",", { beforeExpr: M }), semi: N6(";", { beforeExpr: M }), colon: N6(":", { beforeExpr: M }), doubleColon: N6("::", { beforeExpr: M }), dot: N6("."), question: N6("?", { beforeExpr: M }), questionDot: N6("?."), arrow: N6("=>", { beforeExpr: M }), template: N6("template"), ellipsis: N6("...", { beforeExpr: M }), backQuote: N6("`", { startsExpr: E }), dollarBraceL: N6("${", { beforeExpr: M, startsExpr: E }), templateTail: N6("...`", { startsExpr: E }), templateNonTail: N6("...${", { beforeExpr: M, startsExpr: E }), at: N6("@"), hash: N6("#", { startsExpr: E }), interpreterDirective: N6("#!..."), eq: N6("=", { beforeExpr: M, isAssign: ee }), assign: N6("_=", { beforeExpr: M, isAssign: ee }), slashAssign: N6("_=", { beforeExpr: M, isAssign: ee }), xorAssign: N6("_=", { beforeExpr: M, isAssign: ee }), moduloAssign: N6("_=", { beforeExpr: M, isAssign: ee }), incDec: N6("++/--", { prefix: fe, postfix: zo, startsExpr: E }), bang: N6("!", { beforeExpr: M, prefix: fe, startsExpr: E }), tilde: N6("~", { beforeExpr: M, prefix: fe, startsExpr: E }), doubleCaret: N6("^^", { startsExpr: E }), doubleAt: N6("@@", { startsExpr: E }), pipeline: re("|>", 0), nullishCoalescing: re("??", 1), logicalOR: re("||", 1), logicalAND: re("&&", 2), bitwiseOR: re("|", 3), bitwiseXOR: re("^", 4), bitwiseAND: re("&", 5), equality: re("==/!=/===/!==", 6), lt: re("</>/<=/>=", 7), gt: re("</>/<=/>=", 7), relational: re("</>/<=/>=", 7), bitShift: re("<</>>/>>>", 8), bitShiftL: re("<</>>/>>>", 8), bitShiftR: re("<</>>/>>>", 8), plusMin: N6("+/-", { beforeExpr: M, binop: 9, prefix: fe, startsExpr: E }), modulo: N6("%", { binop: 10, startsExpr: E }), star: N6("*", { binop: 10 }), slash: re("/", 10), exponent: N6("**", { beforeExpr: M, binop: 11, rightAssociative: true }), _in: U3("in", { beforeExpr: M, binop: 7 }), _instanceof: U3("instanceof", { beforeExpr: M, binop: 7 }), _break: U3("break"), _case: U3("case", { beforeExpr: M }), _catch: U3("catch"), _continue: U3("continue"), _debugger: U3("debugger"), _default: U3("default", { beforeExpr: M }), _else: U3("else", { beforeExpr: M }), _finally: U3("finally"), _function: U3("function", { startsExpr: E }), _if: U3("if"), _return: U3("return", { beforeExpr: M }), _switch: U3("switch"), _throw: U3("throw", { beforeExpr: M, prefix: fe, startsExpr: E }), _try: U3("try"), _var: U3("var"), _const: U3("const"), _with: U3("with"), _new: U3("new", { beforeExpr: M, startsExpr: E }), _this: U3("this", { startsExpr: E }), _super: U3("super", { startsExpr: E }), _class: U3("class", { startsExpr: E }), _extends: U3("extends", { beforeExpr: M }), _export: U3("export"), _import: U3("import", { startsExpr: E }), _null: U3("null", { startsExpr: E }), _true: U3("true", { startsExpr: E }), _false: U3("false", { startsExpr: E }), _typeof: U3("typeof", { beforeExpr: M, prefix: fe, startsExpr: E }), _void: U3("void", { beforeExpr: M, prefix: fe, startsExpr: E }), _delete: U3("delete", { beforeExpr: M, prefix: fe, startsExpr: E }), _do: U3("do", { isLoop: Je, beforeExpr: M }), _for: U3("for", { isLoop: Je }), _while: U3("while", { isLoop: Je }), _as: q("as", { startsExpr: E }), _assert: q("assert", { startsExpr: E }), _async: q("async", { startsExpr: E }), _await: q("await", { startsExpr: E }), _from: q("from", { startsExpr: E }), _get: q("get", { startsExpr: E }), _let: q("let", { startsExpr: E }), _meta: q("meta", { startsExpr: E }), _of: q("of", { startsExpr: E }), _sent: q("sent", { startsExpr: E }), _set: q("set", { startsExpr: E }), _static: q("static", { startsExpr: E }), _using: q("using", { startsExpr: E }), _yield: q("yield", { startsExpr: E }), _asserts: q("asserts", { startsExpr: E }), _checks: q("checks", { startsExpr: E }), _exports: q("exports", { startsExpr: E }), _global: q("global", { startsExpr: E }), _implements: q("implements", { startsExpr: E }), _intrinsic: q("intrinsic", { startsExpr: E }), _infer: q("infer", { startsExpr: E }), _is: q("is", { startsExpr: E }), _mixins: q("mixins", { startsExpr: E }), _proto: q("proto", { startsExpr: E }), _require: q("require", { startsExpr: E }), _satisfies: q("satisfies", { startsExpr: E }), _keyof: q("keyof", { startsExpr: E }), _readonly: q("readonly", { startsExpr: E }), _unique: q("unique", { startsExpr: E }), _abstract: q("abstract", { startsExpr: E }), _declare: q("declare", { startsExpr: E }), _enum: q("enum", { startsExpr: E }), _module: q("module", { startsExpr: E }), _namespace: q("namespace", { startsExpr: E }), _interface: q("interface", { startsExpr: E }), _type: q("type", { startsExpr: E }), _opaque: q("opaque", { startsExpr: E }), name: N6("name", { startsExpr: E }), string: N6("string", { startsExpr: E }), num: N6("num", { startsExpr: E }), bigint: N6("bigint", { startsExpr: E }), decimal: N6("decimal", { startsExpr: E }), regexp: N6("regexp", { startsExpr: E }), privateName: N6("#name", { startsExpr: E }), eof: N6("eof"), jsxName: N6("jsxName"), jsxText: N6("jsxText", { beforeExpr: true }), jsxTagStart: N6("jsxTagStart", { startsExpr: true }), jsxTagEnd: N6("jsxTagEnd"), placeholder: N6("%%", { startsExpr: true }) };
            function z(t4) {
              return t4 >= 93 && t4 <= 130;
            }
            function Ko(t4) {
              return t4 <= 92;
            }
            function ye(t4) {
              return t4 >= 58 && t4 <= 130;
            }
            function gr(t4) {
              return t4 >= 58 && t4 <= 134;
            }
            function Wo(t4) {
              return Wt[t4];
            }
            function Xt(t4) {
              return Gt[t4];
            }
            function Go(t4) {
              return t4 >= 29 && t4 <= 33;
            }
            function Pr(t4) {
              return t4 >= 127 && t4 <= 129;
            }
            function Jo(t4) {
              return t4 >= 90 && t4 <= 92;
            }
            function Yt(t4) {
              return t4 >= 58 && t4 <= 92;
            }
            function Xo(t4) {
              return t4 >= 39 && t4 <= 59;
            }
            function Yo(t4) {
              return t4 === 34;
            }
            function Qo(t4) {
              return Jt[t4];
            }
            function Zo(t4) {
              return t4 >= 119 && t4 <= 121;
            }
            function el(t4) {
              return t4 >= 122 && t4 <= 128;
            }
            function Ee(t4) {
              return Vt[t4];
            }
            function ut(t4) {
              return Kt[t4];
            }
            function tl(t4) {
              return t4 === 57;
            }
            function ct(t4) {
              return t4 >= 24 && t4 <= 25;
            }
            function xe(t4) {
              return me[t4];
            }
            me[8].updateContext = (t4) => {
              t4.pop();
            }, me[5].updateContext = me[7].updateContext = me[23].updateContext = (t4) => {
              t4.push($.brace);
            }, me[22].updateContext = (t4) => {
              t4[t4.length - 1] === $.template ? t4.pop() : t4.push($.template);
            }, me[140].updateContext = (t4) => {
              t4.push($.j_expr, $.j_oTag);
            };
            var Qt = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Ar = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", sl = new RegExp("[" + Qt + "]"), rl = new RegExp("[" + Qt + Ar + "]");
            Qt = Ar = null;
            var Tr = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], il = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
            function Zt(t4, r) {
              let e = 65536;
              for (let s = 0, i = r.length; s < i; s += 2) {
                if (e += r[s], e > t4)
                  return false;
                if (e += r[s + 1], e >= t4)
                  return true;
              }
              return false;
            }
            function ge(t4) {
              return t4 < 65 ? t4 === 36 : t4 <= 90 ? true : t4 < 97 ? t4 === 95 : t4 <= 122 ? true : t4 <= 65535 ? t4 >= 170 && sl.test(String.fromCharCode(t4)) : Zt(t4, Tr);
            }
            function Re(t4) {
              return t4 < 48 ? t4 === 36 : t4 < 58 ? true : t4 < 65 ? false : t4 <= 90 ? true : t4 < 97 ? t4 === 95 : t4 <= 122 ? true : t4 <= 65535 ? t4 >= 170 && rl.test(String.fromCharCode(t4)) : Zt(t4, Tr) || Zt(t4, il);
            }
            var es = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, al = new Set(es.keyword), nl = new Set(es.strict), ol = new Set(es.strictBind);
            function vr(t4, r) {
              return r && t4 === "await" || t4 === "enum";
            }
            function Er(t4, r) {
              return vr(t4, r) || nl.has(t4);
            }
            function Cr(t4) {
              return ol.has(t4);
            }
            function br(t4, r) {
              return Er(t4, r) || Cr(t4);
            }
            function ll(t4) {
              return al.has(t4);
            }
            function hl(t4, r, e) {
              return t4 === 64 && r === 64 && ge(e);
            }
            var ul = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
            function cl(t4) {
              return ul.has(t4);
            }
            var je = 0, qe = 1, Pe = 2, ts = 4, Sr = 8, pt = 16, wr = 32, Ne = 64, ft = 128, Ue = 256, dt = qe | Pe | ft | Ue, Ae = 1, ke = 2, Ir = 4, Ce = 8, mt = 16, Nr = 64, yt = 128, ss = 256, rs = 512, is2 = 1024, as = 2048, Ye = 4096, kr = Ae | ke | Ce | yt, De = Ae | 0 | Ce | 0, xt = Ae | 0 | Ir | 0, Dr = Ae | 0 | mt | 0, pl = 0 | ke | 0 | yt, fl = 0 | ke | 0 | 0, Fr = Ae | ke | Ce | ss, Lr = 0 | is2, be = 0 | Nr, dl = Ae | 0 | 0 | Nr, ml = Fr | rs, yl = 0 | is2, Or = 0 | ke | 0 | Ye, xl = as, gt = 4, ns = 2, os = 1, ls = ns | os, gl = ns | gt, Pl = os | gt, Al = ns, Tl = os, hs = 0, us = class {
              constructor(t4) {
                this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t4;
              }
            }, cs = class {
              constructor(t4, r) {
                this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t4, this.inModule = r;
              }
              get inTopLevel() {
                return (this.currentScope().flags & qe) > 0;
              }
              get inFunction() {
                return (this.currentVarScopeFlags() & Pe) > 0;
              }
              get allowSuper() {
                return (this.currentThisScopeFlags() & pt) > 0;
              }
              get allowDirectSuper() {
                return (this.currentThisScopeFlags() & wr) > 0;
              }
              get inClass() {
                return (this.currentThisScopeFlags() & Ne) > 0;
              }
              get inClassAndNotInNonArrowFunction() {
                let t4 = this.currentThisScopeFlags();
                return (t4 & Ne) > 0 && (t4 & Pe) === 0;
              }
              get inStaticBlock() {
                for (let t4 = this.scopeStack.length - 1; ; t4--) {
                  let { flags: r } = this.scopeStack[t4];
                  if (r & ft)
                    return true;
                  if (r & (dt | Ne))
                    return false;
                }
              }
              get inNonArrowFunction() {
                return (this.currentThisScopeFlags() & Pe) > 0;
              }
              get treatFunctionsAsVar() {
                return this.treatFunctionsAsVarInScope(this.currentScope());
              }
              createScope(t4) {
                return new us(t4);
              }
              enter(t4) {
                this.scopeStack.push(this.createScope(t4));
              }
              exit() {
                return this.scopeStack.pop().flags;
              }
              treatFunctionsAsVarInScope(t4) {
                return !!(t4.flags & (Pe | ft) || !this.parser.inModule && t4.flags & qe);
              }
              declareName(t4, r, e) {
                let s = this.currentScope();
                if (r & Ce || r & mt)
                  this.checkRedeclarationInScope(s, t4, r, e), r & mt ? s.functions.add(t4) : s.lexical.add(t4), r & Ce && this.maybeExportDefined(s, t4);
                else if (r & Ir)
                  for (let i = this.scopeStack.length - 1; i >= 0 && (s = this.scopeStack[i], this.checkRedeclarationInScope(s, t4, r, e), s.var.add(t4), this.maybeExportDefined(s, t4), !(s.flags & dt)); --i)
                    ;
                this.parser.inModule && s.flags & qe && this.undefinedExports.delete(t4);
              }
              maybeExportDefined(t4, r) {
                this.parser.inModule && t4.flags & qe && this.undefinedExports.delete(r);
              }
              checkRedeclarationInScope(t4, r, e, s) {
                this.isRedeclaredInScope(t4, r, e) && this.parser.raise(u.VarRedeclaration, { at: s, identifierName: r });
              }
              isRedeclaredInScope(t4, r, e) {
                return e & Ae ? e & Ce ? t4.lexical.has(r) || t4.functions.has(r) || t4.var.has(r) : e & mt ? t4.lexical.has(r) || !this.treatFunctionsAsVarInScope(t4) && t4.var.has(r) : t4.lexical.has(r) && !(t4.flags & Sr && t4.lexical.values().next().value === r) || !this.treatFunctionsAsVarInScope(t4) && t4.functions.has(r) : false;
              }
              checkLocalExport(t4) {
                let { name: r } = t4, e = this.scopeStack[0];
                !e.lexical.has(r) && !e.var.has(r) && !e.functions.has(r) && this.undefinedExports.set(r, t4.loc.start);
              }
              currentScope() {
                return this.scopeStack[this.scopeStack.length - 1];
              }
              currentVarScopeFlags() {
                for (let t4 = this.scopeStack.length - 1; ; t4--) {
                  let { flags: r } = this.scopeStack[t4];
                  if (r & dt)
                    return r;
                }
              }
              currentThisScopeFlags() {
                for (let t4 = this.scopeStack.length - 1; ; t4--) {
                  let { flags: r } = this.scopeStack[t4];
                  if (r & (dt | Ne) && !(r & ts))
                    return r;
                }
              }
            }, vl = class extends us {
              constructor() {
                super(...arguments), this.declareFunctions = /* @__PURE__ */ new Set();
              }
            }, El = class extends cs {
              createScope(t4) {
                return new vl(t4);
              }
              declareName(t4, r, e) {
                let s = this.currentScope();
                if (r & as) {
                  this.checkRedeclarationInScope(s, t4, r, e), this.maybeExportDefined(s, t4), s.declareFunctions.add(t4);
                  return;
                }
                super.declareName(t4, r, e);
              }
              isRedeclaredInScope(t4, r, e) {
                return super.isRedeclaredInScope(t4, r, e) ? true : e & as ? !t4.declareFunctions.has(r) && (t4.lexical.has(r) || t4.functions.has(r)) : false;
              }
              checkLocalExport(t4) {
                this.scopeStack[0].declareFunctions.has(t4.name) || super.checkLocalExport(t4);
              }
            }, Cl = class {
              constructor() {
                this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
              }
              hasPlugin(t4) {
                if (typeof t4 == "string")
                  return this.plugins.has(t4);
                {
                  let [r, e] = t4;
                  if (!this.hasPlugin(r))
                    return false;
                  let s = this.plugins.get(r);
                  for (let i of Object.keys(e))
                    if ((s == null ? void 0 : s[i]) !== e[i])
                      return false;
                  return true;
                }
              }
              getPluginOption(t4, r) {
                var e;
                return (e = this.plugins.get(t4)) == null ? void 0 : e[r];
              }
            };
            function Br(t4, r) {
              t4.trailingComments === void 0 ? t4.trailingComments = r : t4.trailingComments.unshift(...r);
            }
            function bl(t4, r) {
              t4.leadingComments === void 0 ? t4.leadingComments = r : t4.leadingComments.unshift(...r);
            }
            function Qe(t4, r) {
              t4.innerComments === void 0 ? t4.innerComments = r : t4.innerComments.unshift(...r);
            }
            function Ze(t4, r, e) {
              let s = null, i = r.length;
              for (; s === null && i > 0; )
                s = r[--i];
              s === null || s.start > e.start ? Qe(t4, e.comments) : Br(s, e.comments);
            }
            var Sl = class extends Cl {
              addComment(t4) {
                this.filename && (t4.loc.filename = this.filename), this.state.comments.push(t4);
              }
              processComment(t4) {
                let { commentStack: r } = this.state, e = r.length;
                if (e === 0)
                  return;
                let s = e - 1, i = r[s];
                i.start === t4.end && (i.leadingNode = t4, s--);
                let { start: a } = t4;
                for (; s >= 0; s--) {
                  let n = r[s], o = n.end;
                  if (o > a)
                    n.containingNode = t4, this.finalizeComment(n), r.splice(s, 1);
                  else {
                    o === a && (n.trailingNode = t4);
                    break;
                  }
                }
              }
              finalizeComment(t4) {
                let { comments: r } = t4;
                if (t4.leadingNode !== null || t4.trailingNode !== null)
                  t4.leadingNode !== null && Br(t4.leadingNode, r), t4.trailingNode !== null && bl(t4.trailingNode, r);
                else {
                  let { containingNode: e, start: s } = t4;
                  if (this.input.charCodeAt(s - 1) === 44)
                    switch (e.type) {
                      case "ObjectExpression":
                      case "ObjectPattern":
                      case "RecordExpression":
                        Ze(e, e.properties, t4);
                        break;
                      case "CallExpression":
                      case "OptionalCallExpression":
                        Ze(e, e.arguments, t4);
                        break;
                      case "FunctionDeclaration":
                      case "FunctionExpression":
                      case "ArrowFunctionExpression":
                      case "ObjectMethod":
                      case "ClassMethod":
                      case "ClassPrivateMethod":
                        Ze(e, e.params, t4);
                        break;
                      case "ArrayExpression":
                      case "ArrayPattern":
                      case "TupleExpression":
                        Ze(e, e.elements, t4);
                        break;
                      case "ExportNamedDeclaration":
                      case "ImportDeclaration":
                        Ze(e, e.specifiers, t4);
                        break;
                      default:
                        Qe(e, r);
                    }
                  else
                    Qe(e, r);
                }
              }
              finalizeRemainingComments() {
                let { commentStack: t4 } = this.state;
                for (let r = t4.length - 1; r >= 0; r--)
                  this.finalizeComment(t4[r]);
                this.state.commentStack = [];
              }
              resetPreviousNodeTrailingComments(t4) {
                let { commentStack: r } = this.state, { length: e } = r;
                if (e === 0)
                  return;
                let s = r[e - 1];
                s.leadingNode === t4 && (s.leadingNode = null);
              }
              takeSurroundingComments(t4, r, e) {
                let { commentStack: s } = this.state, i = s.length;
                if (i === 0)
                  return;
                let a = i - 1;
                for (; a >= 0; a--) {
                  let n = s[a], o = n.end;
                  if (n.start === e)
                    n.leadingNode = t4;
                  else if (o === r)
                    n.trailingNode = t4;
                  else if (o < r)
                    break;
                }
              }
            }, ps = /\r\n?|[\n\u2028\u2029]/, Pt = new RegExp(ps.source, "g");
            function et(t4) {
              switch (t4) {
                case 10:
                case 13:
                case 8232:
                case 8233:
                  return true;
                default:
                  return false;
              }
            }
            var fs = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, wl = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y, Mr = new RegExp("(?=(" + wl.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
            function Il(t4) {
              switch (t4) {
                case 9:
                case 11:
                case 12:
                case 32:
                case 160:
                case 5760:
                case 8192:
                case 8193:
                case 8194:
                case 8195:
                case 8196:
                case 8197:
                case 8198:
                case 8199:
                case 8200:
                case 8201:
                case 8202:
                case 8239:
                case 8287:
                case 12288:
                case 65279:
                  return true;
                default:
                  return false;
              }
            }
            var _r = class {
              constructor() {
                this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 137, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [$.brace], this.canStartJSXElement = true, this.containsEsc = false, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
              }
              init(t4) {
                let { strictMode: r, sourceType: e, startLine: s, startColumn: i } = t4;
                this.strict = r === false ? false : r === true ? true : e === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new f(s, i, 0);
              }
              curPosition() {
                return new f(this.curLine, this.pos - this.lineStart, this.pos);
              }
              clone(t4) {
                let r = new _r(), e = Object.keys(this);
                for (let s = 0, i = e.length; s < i; s++) {
                  let a = e[s], n = this[a];
                  !t4 && Array.isArray(n) && (n = n.slice()), r[a] = n;
                }
                return r;
              }
            }, Nl = function(r) {
              return r >= 48 && r <= 57;
            }, Rr = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, At = { bin: (t4) => t4 === 48 || t4 === 49, oct: (t4) => t4 >= 48 && t4 <= 55, dec: (t4) => t4 >= 48 && t4 <= 57, hex: (t4) => t4 >= 48 && t4 <= 57 || t4 >= 65 && t4 <= 70 || t4 >= 97 && t4 <= 102 };
            function jr(t4, r, e, s, i, a) {
              let n = e, o = s, c = i, p = "", m = null, x = e, { length: A } = r;
              for (; ; ) {
                if (e >= A) {
                  a.unterminated(n, o, c), p += r.slice(x, e);
                  break;
                }
                let b = r.charCodeAt(e);
                if (kl(t4, b, r, e)) {
                  p += r.slice(x, e);
                  break;
                }
                if (b === 92) {
                  p += r.slice(x, e);
                  let O = Dl(r, e, s, i, t4 === "template", a);
                  O.ch === null && !m ? m = { pos: e, lineStart: s, curLine: i } : p += O.ch, { pos: e, lineStart: s, curLine: i } = O, x = e;
                } else
                  b === 8232 || b === 8233 ? (++e, ++i, s = e) : b === 10 || b === 13 ? t4 === "template" ? (p += r.slice(x, e) + `
`, ++e, b === 13 && r.charCodeAt(e) === 10 && ++e, ++i, x = s = e) : a.unterminated(n, o, c) : ++e;
              }
              return { pos: e, str: p, firstInvalidLoc: m, lineStart: s, curLine: i, containsInvalid: !!m };
            }
            function kl(t4, r, e, s) {
              return t4 === "template" ? r === 96 || r === 36 && e.charCodeAt(s + 1) === 123 : r === (t4 === "double" ? 34 : 39);
            }
            function Dl(t4, r, e, s, i, a) {
              let n = !i;
              r++;
              let o = (p) => ({ pos: r, ch: p, lineStart: e, curLine: s }), c = t4.charCodeAt(r++);
              switch (c) {
                case 110:
                  return o(`
`);
                case 114:
                  return o("\r");
                case 120: {
                  let p;
                  return { code: p, pos: r } = ds(t4, r, e, s, 2, false, n, a), o(p === null ? null : String.fromCharCode(p));
                }
                case 117: {
                  let p;
                  return { code: p, pos: r } = Ur(t4, r, e, s, n, a), o(p === null ? null : String.fromCodePoint(p));
                }
                case 116:
                  return o("	");
                case 98:
                  return o("\b");
                case 118:
                  return o("\v");
                case 102:
                  return o("\f");
                case 13:
                  t4.charCodeAt(r) === 10 && ++r;
                case 10:
                  e = r, ++s;
                case 8232:
                case 8233:
                  return o("");
                case 56:
                case 57:
                  if (i)
                    return o(null);
                  a.strictNumericEscape(r - 1, e, s);
                default:
                  if (c >= 48 && c <= 55) {
                    let p = r - 1, x = t4.slice(p, r + 2).match(/^[0-7]+/)[0], A = parseInt(x, 8);
                    A > 255 && (x = x.slice(0, -1), A = parseInt(x, 8)), r += x.length - 1;
                    let b = t4.charCodeAt(r);
                    if (x !== "0" || b === 56 || b === 57) {
                      if (i)
                        return o(null);
                      a.strictNumericEscape(p, e, s);
                    }
                    return o(String.fromCharCode(A));
                  }
                  return o(String.fromCharCode(c));
              }
            }
            function ds(t4, r, e, s, i, a, n, o) {
              let c = r, p;
              return { n: p, pos: r } = qr(t4, r, e, s, 16, i, a, false, o, !n), p === null && (n ? o.invalidEscapeSequence(c, e, s) : r = c - 1), { code: p, pos: r };
            }
            function qr(t4, r, e, s, i, a, n, o, c, p) {
              let m = r, x = i === 16 ? Rr.hex : Rr.decBinOct, A = i === 16 ? At.hex : i === 10 ? At.dec : i === 8 ? At.oct : At.bin, b = false, O = 0;
              for (let R4 = 0, Y = a == null ? 1 / 0 : a; R4 < Y; ++R4) {
                let Q = t4.charCodeAt(r), J;
                if (Q === 95 && o !== "bail") {
                  let se = t4.charCodeAt(r - 1), Ve = t4.charCodeAt(r + 1);
                  if (o) {
                    if (Number.isNaN(Ve) || !A(Ve) || x.has(se) || x.has(Ve)) {
                      if (p)
                        return { n: null, pos: r };
                      c.unexpectedNumericSeparator(r, e, s);
                    }
                  } else {
                    if (p)
                      return { n: null, pos: r };
                    c.numericSeparatorInEscapeSequence(r, e, s);
                  }
                  ++r;
                  continue;
                }
                if (Q >= 97 ? J = Q - 97 + 10 : Q >= 65 ? J = Q - 65 + 10 : Nl(Q) ? J = Q - 48 : J = 1 / 0, J >= i) {
                  if (J <= 9 && p)
                    return { n: null, pos: r };
                  if (J <= 9 && c.invalidDigit(r, e, s, i))
                    J = 0;
                  else if (n)
                    J = 0, b = true;
                  else
                    break;
                }
                ++r, O = O * i + J;
              }
              return r === m || a != null && r - m !== a || b ? { n: null, pos: r } : { n: O, pos: r };
            }
            function Ur(t4, r, e, s, i, a) {
              let n = t4.charCodeAt(r), o;
              if (n === 123) {
                if (++r, { code: o, pos: r } = ds(t4, r, e, s, t4.indexOf("}", r) - r, true, i, a), ++r, o !== null && o > 1114111)
                  if (i)
                    a.invalidCodePoint(r, e, s);
                  else
                    return { code: null, pos: r };
              } else
                ({ code: o, pos: r } = ds(t4, r, e, s, 4, false, i, a));
              return { code: o, pos: r };
            }
            var Fl = ["at"], Ll = ["at"];
            function tt(t4, r, e) {
              return new f(e, t4 - r, t4);
            }
            var Ol = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Se = class {
              constructor(t4) {
                this.type = t4.type, this.value = t4.value, this.start = t4.start, this.end = t4.end, this.loc = new d(t4.startLoc, t4.endLoc);
              }
            }, Bl = class extends Sl {
              constructor(t4, r) {
                super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (e, s, i, a) => this.options.errorRecovery ? (this.raise(u.InvalidDigit, { at: tt(e, s, i), radix: a }), true) : false, numericSeparatorInEscapeSequence: this.errorBuilder(u.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(u.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(u.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(u.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (e, s, i) => {
                  this.recordStrictModeErrors(u.StrictNumericEscape, { at: tt(e, s, i) });
                }, unterminated: (e, s, i) => {
                  throw this.raise(u.UnterminatedString, { at: tt(e - 1, s, i) });
                } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(u.StrictNumericEscape), unterminated: (e, s, i) => {
                  throw this.raise(u.UnterminatedTemplate, { at: tt(e, s, i) });
                } }), this.state = new _r(), this.state.init(t4), this.input = r, this.length = r.length, this.isLookahead = false;
              }
              pushToken(t4) {
                this.tokens.length = this.state.tokensLength, this.tokens.push(t4), ++this.state.tokensLength;
              }
              next() {
                this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Se(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
              }
              eat(t4) {
                return this.match(t4) ? (this.next(), true) : false;
              }
              match(t4) {
                return this.state.type === t4;
              }
              createLookaheadState(t4) {
                return { pos: t4.pos, value: null, type: t4.type, start: t4.start, end: t4.end, context: [this.curContext()], inType: t4.inType, startLoc: t4.startLoc, lastTokEndLoc: t4.lastTokEndLoc, curLine: t4.curLine, lineStart: t4.lineStart, curPosition: t4.curPosition };
              }
              lookahead() {
                let t4 = this.state;
                this.state = this.createLookaheadState(t4), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
                let r = this.state;
                return this.state = t4, r;
              }
              nextTokenStart() {
                return this.nextTokenStartSince(this.state.pos);
              }
              nextTokenStartSince(t4) {
                return fs.lastIndex = t4, fs.test(this.input) ? fs.lastIndex : t4;
              }
              lookaheadCharCode() {
                return this.input.charCodeAt(this.nextTokenStart());
              }
              codePointAtPos(t4) {
                let r = this.input.charCodeAt(t4);
                if ((r & 64512) === 55296 && ++t4 < this.input.length) {
                  let e = this.input.charCodeAt(t4);
                  (e & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (e & 1023));
                }
                return r;
              }
              setStrict(t4) {
                this.state.strict = t4, t4 && (this.state.strictErrors.forEach((r) => {
                  let [e, s] = r;
                  return this.raise(e, { at: s });
                }), this.state.strictErrors.clear());
              }
              curContext() {
                return this.state.context[this.state.context.length - 1];
              }
              nextToken() {
                if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
                  this.finishToken(137);
                  return;
                }
                this.getTokenFromCode(this.codePointAtPos(this.state.pos));
              }
              skipBlockComment(t4) {
                let r;
                this.isLookahead || (r = this.state.curPosition());
                let e = this.state.pos, s = this.input.indexOf(t4, e + 2);
                if (s === -1)
                  throw this.raise(u.UnterminatedComment, { at: this.state.curPosition() });
                for (this.state.pos = s + t4.length, Pt.lastIndex = e + 2; Pt.test(this.input) && Pt.lastIndex <= s; )
                  ++this.state.curLine, this.state.lineStart = Pt.lastIndex;
                if (this.isLookahead)
                  return;
                let i = { type: "CommentBlock", value: this.input.slice(e + 2, s), start: e, end: s + t4.length, loc: new d(r, this.state.curPosition()) };
                return this.options.tokens && this.pushToken(i), i;
              }
              skipLineComment(t4) {
                let r = this.state.pos, e;
                this.isLookahead || (e = this.state.curPosition());
                let s = this.input.charCodeAt(this.state.pos += t4);
                if (this.state.pos < this.length)
                  for (; !et(s) && ++this.state.pos < this.length; )
                    s = this.input.charCodeAt(this.state.pos);
                if (this.isLookahead)
                  return;
                let i = this.state.pos, n = { type: "CommentLine", value: this.input.slice(r + t4, i), start: r, end: i, loc: new d(e, this.state.curPosition()) };
                return this.options.tokens && this.pushToken(n), n;
              }
              skipSpace() {
                let t4 = this.state.pos, r = [];
                e:
                  for (; this.state.pos < this.length; ) {
                    let e = this.input.charCodeAt(this.state.pos);
                    switch (e) {
                      case 32:
                      case 160:
                      case 9:
                        ++this.state.pos;
                        break;
                      case 13:
                        this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                      case 10:
                      case 8232:
                      case 8233:
                        ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                        break;
                      case 47:
                        switch (this.input.charCodeAt(this.state.pos + 1)) {
                          case 42: {
                            let s = this.skipBlockComment("*/");
                            s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
                            break;
                          }
                          case 47: {
                            let s = this.skipLineComment(2);
                            s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
                            break;
                          }
                          default:
                            break e;
                        }
                        break;
                      default:
                        if (Il(e))
                          ++this.state.pos;
                        else if (e === 45 && !this.inModule) {
                          let s = this.state.pos;
                          if (this.input.charCodeAt(s + 1) === 45 && this.input.charCodeAt(s + 2) === 62 && (t4 === 0 || this.state.lineStart > t4)) {
                            let i = this.skipLineComment(3);
                            i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                          } else
                            break e;
                        } else if (e === 60 && !this.inModule) {
                          let s = this.state.pos;
                          if (this.input.charCodeAt(s + 1) === 33 && this.input.charCodeAt(s + 2) === 45 && this.input.charCodeAt(s + 3) === 45) {
                            let i = this.skipLineComment(4);
                            i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                          } else
                            break e;
                        } else
                          break e;
                    }
                  }
                if (r.length > 0) {
                  let e = this.state.pos, s = { start: t4, end: e, comments: r, leadingNode: null, trailingNode: null, containingNode: null };
                  this.state.commentStack.push(s);
                }
              }
              finishToken(t4, r) {
                this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
                let e = this.state.type;
                this.state.type = t4, this.state.value = r, this.isLookahead || this.updateContext(e);
              }
              replaceToken(t4) {
                this.state.type = t4, this.updateContext();
              }
              readToken_numberSign() {
                if (this.state.pos === 0 && this.readToken_interpreter())
                  return;
                let t4 = this.state.pos + 1, r = this.codePointAtPos(t4);
                if (r >= 48 && r <= 57)
                  throw this.raise(u.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
                if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
                  if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
                    throw this.raise(r === 123 ? u.RecordExpressionHashIncorrectStartSyntaxType : u.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
                } else
                  ge(r) ? (++this.state.pos, this.finishToken(136, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(136, this.readWord1())) : this.finishOp(27, 1);
              }
              readToken_dot() {
                let t4 = this.input.charCodeAt(this.state.pos + 1);
                if (t4 >= 48 && t4 <= 57) {
                  this.readNumber(true);
                  return;
                }
                t4 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
              }
              readToken_slash() {
                this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
              }
              readToken_interpreter() {
                if (this.state.pos !== 0 || this.length < 2)
                  return false;
                let t4 = this.input.charCodeAt(this.state.pos + 1);
                if (t4 !== 33)
                  return false;
                let r = this.state.pos;
                for (this.state.pos += 1; !et(t4) && ++this.state.pos < this.length; )
                  t4 = this.input.charCodeAt(this.state.pos);
                let e = this.input.slice(r + 2, this.state.pos);
                return this.finishToken(28, e), true;
              }
              readToken_mult_modulo(t4) {
                let r = t4 === 42 ? 55 : 54, e = 1, s = this.input.charCodeAt(this.state.pos + 1);
                t4 === 42 && s === 42 && (e++, s = this.input.charCodeAt(this.state.pos + 2), r = 57), s === 61 && !this.state.inType && (e++, r = t4 === 37 ? 33 : 30), this.finishOp(r, e);
              }
              readToken_pipe_amp(t4) {
                let r = this.input.charCodeAt(this.state.pos + 1);
                if (r === t4) {
                  this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t4 === 124 ? 41 : 42, 2);
                  return;
                }
                if (t4 === 124) {
                  if (r === 62) {
                    this.finishOp(39, 2);
                    return;
                  }
                  if (this.hasPlugin("recordAndTuple") && r === 125) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                      throw this.raise(u.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                    this.state.pos += 2, this.finishToken(9);
                    return;
                  }
                  if (this.hasPlugin("recordAndTuple") && r === 93) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                      throw this.raise(u.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                    this.state.pos += 2, this.finishToken(4);
                    return;
                  }
                }
                if (r === 61) {
                  this.finishOp(30, 2);
                  return;
                }
                this.finishOp(t4 === 124 ? 43 : 45, 1);
              }
              readToken_caret() {
                let t4 = this.input.charCodeAt(this.state.pos + 1);
                if (t4 === 61 && !this.state.inType)
                  this.finishOp(32, 2);
                else if (t4 === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }])) {
                  if (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94)
                    throw this.unexpected();
                } else
                  this.finishOp(44, 1);
              }
              readToken_atSign() {
                this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
              }
              readToken_plus_min(t4) {
                let r = this.input.charCodeAt(this.state.pos + 1);
                if (r === t4) {
                  this.finishOp(34, 2);
                  return;
                }
                r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
              }
              readToken_lt() {
                let { pos: t4 } = this.state, r = this.input.charCodeAt(t4 + 1);
                if (r === 60) {
                  if (this.input.charCodeAt(t4 + 2) === 61) {
                    this.finishOp(30, 3);
                    return;
                  }
                  this.finishOp(51, 2);
                  return;
                }
                if (r === 61) {
                  this.finishOp(49, 2);
                  return;
                }
                this.finishOp(47, 1);
              }
              readToken_gt() {
                let { pos: t4 } = this.state, r = this.input.charCodeAt(t4 + 1);
                if (r === 62) {
                  let e = this.input.charCodeAt(t4 + 2) === 62 ? 3 : 2;
                  if (this.input.charCodeAt(t4 + e) === 61) {
                    this.finishOp(30, e + 1);
                    return;
                  }
                  this.finishOp(52, e);
                  return;
                }
                if (r === 61) {
                  this.finishOp(49, 2);
                  return;
                }
                this.finishOp(48, 1);
              }
              readToken_eq_excl(t4) {
                let r = this.input.charCodeAt(this.state.pos + 1);
                if (r === 61) {
                  this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                  return;
                }
                if (t4 === 61 && r === 62) {
                  this.state.pos += 2, this.finishToken(19);
                  return;
                }
                this.finishOp(t4 === 61 ? 29 : 35, 1);
              }
              readToken_question() {
                let t4 = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
                t4 === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t4 === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
              }
              getTokenFromCode(t4) {
                switch (t4) {
                  case 46:
                    this.readToken_dot();
                    return;
                  case 40:
                    ++this.state.pos, this.finishToken(10);
                    return;
                  case 41:
                    ++this.state.pos, this.finishToken(11);
                    return;
                  case 59:
                    ++this.state.pos, this.finishToken(13);
                    return;
                  case 44:
                    ++this.state.pos, this.finishToken(12);
                    return;
                  case 91:
                    if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                        throw this.raise(u.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                      this.state.pos += 2, this.finishToken(2);
                    } else
                      ++this.state.pos, this.finishToken(0);
                    return;
                  case 93:
                    ++this.state.pos, this.finishToken(3);
                    return;
                  case 123:
                    if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                        throw this.raise(u.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                      this.state.pos += 2, this.finishToken(6);
                    } else
                      ++this.state.pos, this.finishToken(5);
                    return;
                  case 125:
                    ++this.state.pos, this.finishToken(8);
                    return;
                  case 58:
                    this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
                    return;
                  case 63:
                    this.readToken_question();
                    return;
                  case 96:
                    this.readTemplateToken();
                    return;
                  case 48: {
                    let r = this.input.charCodeAt(this.state.pos + 1);
                    if (r === 120 || r === 88) {
                      this.readRadixNumber(16);
                      return;
                    }
                    if (r === 111 || r === 79) {
                      this.readRadixNumber(8);
                      return;
                    }
                    if (r === 98 || r === 66) {
                      this.readRadixNumber(2);
                      return;
                    }
                  }
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                    this.readNumber(false);
                    return;
                  case 34:
                  case 39:
                    this.readString(t4);
                    return;
                  case 47:
                    this.readToken_slash();
                    return;
                  case 37:
                  case 42:
                    this.readToken_mult_modulo(t4);
                    return;
                  case 124:
                  case 38:
                    this.readToken_pipe_amp(t4);
                    return;
                  case 94:
                    this.readToken_caret();
                    return;
                  case 43:
                  case 45:
                    this.readToken_plus_min(t4);
                    return;
                  case 60:
                    this.readToken_lt();
                    return;
                  case 62:
                    this.readToken_gt();
                    return;
                  case 61:
                  case 33:
                    this.readToken_eq_excl(t4);
                    return;
                  case 126:
                    this.finishOp(36, 1);
                    return;
                  case 64:
                    this.readToken_atSign();
                    return;
                  case 35:
                    this.readToken_numberSign();
                    return;
                  case 92:
                    this.readWord();
                    return;
                  default:
                    if (ge(t4)) {
                      this.readWord(t4);
                      return;
                    }
                }
                throw this.raise(u.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(t4) });
              }
              finishOp(t4, r) {
                let e = this.input.slice(this.state.pos, this.state.pos + r);
                this.state.pos += r, this.finishToken(t4, e);
              }
              readRegexp() {
                let t4 = this.state.startLoc, r = this.state.start + 1, e, s, { pos: i } = this.state;
                for (; ; ++i) {
                  if (i >= this.length)
                    throw this.raise(u.UnterminatedRegExp, { at: y(t4, 1) });
                  let c = this.input.charCodeAt(i);
                  if (et(c))
                    throw this.raise(u.UnterminatedRegExp, { at: y(t4, 1) });
                  if (e)
                    e = false;
                  else {
                    if (c === 91)
                      s = true;
                    else if (c === 93 && s)
                      s = false;
                    else if (c === 47 && !s)
                      break;
                    e = c === 92;
                  }
                }
                let a = this.input.slice(r, i);
                ++i;
                let n = "", o = () => y(t4, i + 2 - r);
                for (; i < this.length; ) {
                  let c = this.codePointAtPos(i), p = String.fromCharCode(c);
                  if (Ol.has(c))
                    c === 118 ? (this.expectPlugin("regexpUnicodeSets", o()), n.includes("u") && this.raise(u.IncompatibleRegExpUVFlags, { at: o() })) : c === 117 && n.includes("v") && this.raise(u.IncompatibleRegExpUVFlags, { at: o() }), n.includes(p) && this.raise(u.DuplicateRegExpFlags, { at: o() });
                  else if (Re(c) || c === 92)
                    this.raise(u.MalformedRegExpFlags, { at: o() });
                  else
                    break;
                  ++i, n += p;
                }
                this.state.pos = i, this.finishToken(135, { pattern: a, flags: n });
              }
              readInt(t4, r) {
                let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, { n: i, pos: a } = qr(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t4, r, e, s, this.errorHandlers_readInt, false);
                return this.state.pos = a, i;
              }
              readRadixNumber(t4) {
                let r = this.state.curPosition(), e = false;
                this.state.pos += 2;
                let s = this.readInt(t4);
                s == null && this.raise(u.InvalidDigit, { at: y(r, 2), radix: t4 });
                let i = this.input.charCodeAt(this.state.pos);
                if (i === 110)
                  ++this.state.pos, e = true;
                else if (i === 109)
                  throw this.raise(u.InvalidDecimal, { at: r });
                if (ge(this.codePointAtPos(this.state.pos)))
                  throw this.raise(u.NumberIdentifier, { at: this.state.curPosition() });
                if (e) {
                  let a = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
                  this.finishToken(133, a);
                  return;
                }
                this.finishToken(132, s);
              }
              readNumber(t4) {
                let r = this.state.pos, e = this.state.curPosition(), s = false, i = false, a = false, n = false, o = false;
                !t4 && this.readInt(10) === null && this.raise(u.InvalidNumber, { at: this.state.curPosition() });
                let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
                if (c) {
                  let A = this.input.slice(r, this.state.pos);
                  if (this.recordStrictModeErrors(u.StrictOctalLiteral, { at: e }), !this.state.strict) {
                    let b = A.indexOf("_");
                    b > 0 && this.raise(u.ZeroDigitNumericSeparator, { at: y(e, b) });
                  }
                  o = c && !/[89]/.test(A);
                }
                let p = this.input.charCodeAt(this.state.pos);
                if (p === 46 && !o && (++this.state.pos, this.readInt(10), s = true, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) && !o && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(u.InvalidOrMissingExponent, { at: e }), s = true, n = true, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((s || c) && this.raise(u.InvalidBigIntLiteral, { at: e }), ++this.state.pos, i = true), p === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (n || c) && this.raise(u.InvalidDecimal, { at: e }), ++this.state.pos, a = true), ge(this.codePointAtPos(this.state.pos)))
                  throw this.raise(u.NumberIdentifier, { at: this.state.curPosition() });
                let m = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
                if (i) {
                  this.finishToken(133, m);
                  return;
                }
                if (a) {
                  this.finishToken(134, m);
                  return;
                }
                let x = o ? parseInt(m, 8) : parseFloat(m);
                this.finishToken(132, x);
              }
              readCodePoint(t4) {
                let { code: r, pos: e } = Ur(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t4, this.errorHandlers_readCodePoint);
                return this.state.pos = e, r;
              }
              readString(t4) {
                let { str: r, pos: e, curLine: s, lineStart: i } = jr(t4 === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
                this.state.pos = e + 1, this.state.lineStart = i, this.state.curLine = s, this.finishToken(131, r);
              }
              readTemplateContinuation() {
                this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
              }
              readTemplateToken() {
                let t4 = this.input[this.state.pos], { str: r, firstInvalidLoc: e, pos: s, curLine: i, lineStart: a } = jr("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
                this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = i, e && (this.state.firstInvalidTemplateEscapePos = new f(e.curLine, e.pos - e.lineStart, e.pos)), this.input.codePointAt(s) === 96 ? this.finishToken(24, e ? null : t4 + r + "`") : (this.state.pos++, this.finishToken(25, e ? null : t4 + r + "${"));
              }
              recordStrictModeErrors(t4, r) {
                let { at: e } = r, s = e.index;
                this.state.strict && !this.state.strictErrors.has(s) ? this.raise(t4, { at: e }) : this.state.strictErrors.set(s, [t4, e]);
              }
              readWord1(t4) {
                this.state.containsEsc = false;
                let r = "", e = this.state.pos, s = this.state.pos;
                for (t4 !== void 0 && (this.state.pos += t4 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
                  let i = this.codePointAtPos(this.state.pos);
                  if (Re(i))
                    this.state.pos += i <= 65535 ? 1 : 2;
                  else if (i === 92) {
                    this.state.containsEsc = true, r += this.input.slice(s, this.state.pos);
                    let a = this.state.curPosition(), n = this.state.pos === e ? ge : Re;
                    if (this.input.charCodeAt(++this.state.pos) !== 117) {
                      this.raise(u.MissingUnicodeEscape, { at: this.state.curPosition() }), s = this.state.pos - 1;
                      continue;
                    }
                    ++this.state.pos;
                    let o = this.readCodePoint(true);
                    o !== null && (n(o) || this.raise(u.EscapedCharNotAnIdentifier, { at: a }), r += String.fromCodePoint(o)), s = this.state.pos;
                  } else
                    break;
                }
                return r + this.input.slice(s, this.state.pos);
              }
              readWord(t4) {
                let r = this.readWord1(t4), e = zt.get(r);
                e !== void 0 ? this.finishToken(e, Ee(e)) : this.finishToken(130, r);
              }
              checkKeywordEscapes() {
                let { type: t4 } = this.state;
                Yt(t4) && this.state.containsEsc && this.raise(u.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: Ee(t4) });
              }
              raise(t4, r) {
                let { at: e } = r, s = h2(r, Fl), i = e instanceof f ? e : e.loc.start, a = t4({ loc: i, details: s });
                if (!this.options.errorRecovery)
                  throw a;
                return this.isLookahead || this.state.errors.push(a), a;
              }
              raiseOverwrite(t4, r) {
                let { at: e } = r, s = h2(r, Ll), i = e instanceof f ? e : e.loc.start, a = i.index, n = this.state.errors;
                for (let o = n.length - 1; o >= 0; o--) {
                  let c = n[o];
                  if (c.loc.index === a)
                    return n[o] = t4({ loc: i, details: s });
                  if (c.loc.index < a)
                    break;
                }
                return this.raise(t4, r);
              }
              updateContext(t4) {
              }
              unexpected(t4, r) {
                throw this.raise(u.UnexpectedToken, { expected: r ? Ee(r) : null, at: t4 != null ? t4 : this.state.startLoc });
              }
              expectPlugin(t4, r) {
                if (this.hasPlugin(t4))
                  return true;
                throw this.raise(u.MissingPlugin, { at: r != null ? r : this.state.startLoc, missingPlugin: [t4] });
              }
              expectOnePlugin(t4) {
                if (!t4.some((r) => this.hasPlugin(r)))
                  throw this.raise(u.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: t4 });
              }
              errorBuilder(t4) {
                return (r, e, s) => {
                  this.raise(t4, { at: tt(r, e, s) });
                };
              }
            }, Ml = class {
              constructor() {
                this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
              }
            }, _l = class {
              constructor(t4) {
                this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t4;
              }
              current() {
                return this.stack[this.stack.length - 1];
              }
              enter() {
                this.stack.push(new Ml());
              }
              exit() {
                let t4 = this.stack.pop(), r = this.current();
                for (let [e, s] of Array.from(t4.undefinedPrivateNames))
                  r ? r.undefinedPrivateNames.has(e) || r.undefinedPrivateNames.set(e, s) : this.parser.raise(u.InvalidPrivateFieldResolution, { at: s, identifierName: e });
              }
              declarePrivateName(t4, r, e) {
                let { privateNames: s, loneAccessors: i, undefinedPrivateNames: a } = this.current(), n = s.has(t4);
                if (r & ls) {
                  let o = n && i.get(t4);
                  if (o) {
                    let c = o & gt, p = r & gt, m = o & ls, x = r & ls;
                    n = m === x || c !== p, n || i.delete(t4);
                  } else
                    n || i.set(t4, r);
                }
                n && this.parser.raise(u.PrivateNameRedeclaration, { at: e, identifierName: t4 }), s.add(t4), a.delete(t4);
              }
              usePrivateName(t4, r) {
                let e;
                for (e of this.stack)
                  if (e.privateNames.has(t4))
                    return;
                e ? e.undefinedPrivateNames.set(t4, r) : this.parser.raise(u.InvalidPrivateFieldResolution, { at: r, identifierName: t4 });
              }
            }, Rl = 0, $r = 1, ms = 2, Hr = 3, Tt = class {
              constructor() {
                let t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Rl;
                this.type = void 0, this.type = t4;
              }
              canBeArrowParameterDeclaration() {
                return this.type === ms || this.type === $r;
              }
              isCertainlyParameterDeclaration() {
                return this.type === Hr;
              }
            }, zr = class extends Tt {
              constructor(t4) {
                super(t4), this.declarationErrors = /* @__PURE__ */ new Map();
              }
              recordDeclarationError(t4, r) {
                let { at: e } = r, s = e.index;
                this.declarationErrors.set(s, [t4, e]);
              }
              clearDeclarationError(t4) {
                this.declarationErrors.delete(t4);
              }
              iterateErrors(t4) {
                this.declarationErrors.forEach(t4);
              }
            }, jl = class {
              constructor(t4) {
                this.parser = void 0, this.stack = [new Tt()], this.parser = t4;
              }
              enter(t4) {
                this.stack.push(t4);
              }
              exit() {
                this.stack.pop();
              }
              recordParameterInitializerError(t4, r) {
                let { at: e } = r, s = { at: e.loc.start }, { stack: i } = this, a = i.length - 1, n = i[a];
                for (; !n.isCertainlyParameterDeclaration(); ) {
                  if (n.canBeArrowParameterDeclaration())
                    n.recordDeclarationError(t4, s);
                  else
                    return;
                  n = i[--a];
                }
                this.parser.raise(t4, s);
              }
              recordArrowParameterBindingError(t4, r) {
                let { at: e } = r, { stack: s } = this, i = s[s.length - 1], a = { at: e.loc.start };
                if (i.isCertainlyParameterDeclaration())
                  this.parser.raise(t4, a);
                else if (i.canBeArrowParameterDeclaration())
                  i.recordDeclarationError(t4, a);
                else
                  return;
              }
              recordAsyncArrowParametersError(t4) {
                let { at: r } = t4, { stack: e } = this, s = e.length - 1, i = e[s];
                for (; i.canBeArrowParameterDeclaration(); )
                  i.type === ms && i.recordDeclarationError(u.AwaitBindingIdentifier, { at: r }), i = e[--s];
              }
              validateAsPattern() {
                let { stack: t4 } = this, r = t4[t4.length - 1];
                r.canBeArrowParameterDeclaration() && r.iterateErrors((e) => {
                  let [s, i] = e;
                  this.parser.raise(s, { at: i });
                  let a = t4.length - 2, n = t4[a];
                  for (; n.canBeArrowParameterDeclaration(); )
                    n.clearDeclarationError(i.index), n = t4[--a];
                });
              }
            };
            function ql() {
              return new Tt(Hr);
            }
            function Ul() {
              return new zr($r);
            }
            function $l() {
              return new zr(ms);
            }
            function Vr() {
              return new Tt();
            }
            var $e = 0, Kr = 1, vt = 2, Wr = 4, He = 8, Hl = class {
              constructor() {
                this.stacks = [];
              }
              enter(t4) {
                this.stacks.push(t4);
              }
              exit() {
                this.stacks.pop();
              }
              currentFlags() {
                return this.stacks[this.stacks.length - 1];
              }
              get hasAwait() {
                return (this.currentFlags() & vt) > 0;
              }
              get hasYield() {
                return (this.currentFlags() & Kr) > 0;
              }
              get hasReturn() {
                return (this.currentFlags() & Wr) > 0;
              }
              get hasIn() {
                return (this.currentFlags() & He) > 0;
              }
            };
            function Et(t4, r) {
              return (t4 ? vt : 0) | (r ? Kr : 0);
            }
            var zl = class extends Bl {
              addExtra(t4, r, e) {
                let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                if (!t4)
                  return;
                let i = t4.extra = t4.extra || {};
                s ? i[r] = e : Object.defineProperty(i, r, { enumerable: s, value: e });
              }
              isContextual(t4) {
                return this.state.type === t4 && !this.state.containsEsc;
              }
              isUnparsedContextual(t4, r) {
                let e = t4 + r.length;
                if (this.input.slice(t4, e) === r) {
                  let s = this.input.charCodeAt(e);
                  return !(Re(s) || (s & 64512) === 55296);
                }
                return false;
              }
              isLookaheadContextual(t4) {
                let r = this.nextTokenStart();
                return this.isUnparsedContextual(r, t4);
              }
              eatContextual(t4) {
                return this.isContextual(t4) ? (this.next(), true) : false;
              }
              expectContextual(t4, r) {
                if (!this.eatContextual(t4))
                  throw r != null ? this.raise(r, { at: this.state.startLoc }) : this.unexpected(null, t4);
              }
              canInsertSemicolon() {
                return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
              }
              hasPrecedingLineBreak() {
                return ps.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
              }
              hasFollowingLineBreak() {
                return Mr.lastIndex = this.state.end, Mr.test(this.input);
              }
              isLineTerminator() {
                return this.eat(13) || this.canInsertSemicolon();
              }
              semicolon() {
                ((arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true) ? this.isLineTerminator() : this.eat(13)) || this.raise(u.MissingSemicolon, { at: this.state.lastTokEndLoc });
              }
              expect(t4, r) {
                this.eat(t4) || this.unexpected(r, t4);
              }
              tryParse(t4) {
                let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone(), e = { node: null };
                try {
                  let s = t4(function() {
                    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                    throw e.node = i, e;
                  });
                  if (this.state.errors.length > r.errors.length) {
                    let i = this.state;
                    return this.state = r, this.state.tokensLength = i.tokensLength, { node: s, error: i.errors[r.errors.length], thrown: false, aborted: false, failState: i };
                  }
                  return { node: s, error: null, thrown: false, aborted: false, failState: null };
                } catch (s) {
                  let i = this.state;
                  if (this.state = r, s instanceof SyntaxError)
                    return { node: null, error: s, thrown: true, aborted: false, failState: i };
                  if (s === e)
                    return { node: e.node, error: null, thrown: false, aborted: true, failState: i };
                  throw s;
                }
              }
              checkExpressionErrors(t4, r) {
                if (!t4)
                  return false;
                let { shorthandAssignLoc: e, doubleProtoLoc: s, privateKeyLoc: i, optionalParametersLoc: a } = t4, n = !!e || !!s || !!a || !!i;
                if (!r)
                  return n;
                e != null && this.raise(u.InvalidCoverInitializedName, { at: e }), s != null && this.raise(u.DuplicateProto, { at: s }), i != null && this.raise(u.UnexpectedPrivateField, { at: i }), a != null && this.unexpected(a);
              }
              isLiteralPropertyName() {
                return gr(this.state.type);
              }
              isPrivateName(t4) {
                return t4.type === "PrivateName";
              }
              getPrivateNameSV(t4) {
                return t4.id.name;
              }
              hasPropertyAsPrivateName(t4) {
                return (t4.type === "MemberExpression" || t4.type === "OptionalMemberExpression") && this.isPrivateName(t4.property);
              }
              isOptionalChain(t4) {
                return t4.type === "OptionalMemberExpression" || t4.type === "OptionalCallExpression";
              }
              isObjectProperty(t4) {
                return t4.type === "ObjectProperty";
              }
              isObjectMethod(t4) {
                return t4.type === "ObjectMethod";
              }
              initializeScopes() {
                let t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module", r = this.state.labels;
                this.state.labels = [];
                let e = this.exportedIdentifiers;
                this.exportedIdentifiers = /* @__PURE__ */ new Set();
                let s = this.inModule;
                this.inModule = t4;
                let i = this.scope, a = this.getScopeHandler();
                this.scope = new a(this, t4);
                let n = this.prodParam;
                this.prodParam = new Hl();
                let o = this.classScope;
                this.classScope = new _l(this);
                let c = this.expressionScope;
                return this.expressionScope = new jl(this), () => {
                  this.state.labels = r, this.exportedIdentifiers = e, this.inModule = s, this.scope = i, this.prodParam = n, this.classScope = o, this.expressionScope = c;
                };
              }
              enterInitialScopes() {
                let t4 = $e;
                this.inModule && (t4 |= vt), this.scope.enter(qe), this.prodParam.enter(t4);
              }
              checkDestructuringPrivate(t4) {
                let { privateKeyLoc: r } = t4;
                r !== null && this.expectPlugin("destructuringPrivate", r);
              }
            }, Ct = class {
              constructor() {
                this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
              }
            }, bt = class {
              constructor(t4, r, e) {
                this.type = "", this.start = r, this.end = 0, this.loc = new d(e), t4 != null && t4.options.ranges && (this.range = [r, 0]), t4 != null && t4.filename && (this.loc.filename = t4.filename);
              }
            }, ys = bt.prototype;
            ys.__clone = function() {
              let t4 = new bt(void 0, this.start, this.loc.start), r = Object.keys(this);
              for (let e = 0, s = r.length; e < s; e++) {
                let i = r[e];
                i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t4[i] = this[i]);
              }
              return t4;
            };
            function Vl(t4) {
              return Te(t4);
            }
            function Te(t4) {
              let { type: r, start: e, end: s, loc: i, range: a, extra: n, name: o } = t4, c = Object.create(ys);
              return c.type = r, c.start = e, c.end = s, c.loc = i, c.range = a, c.extra = n, c.name = o, r === "Placeholder" && (c.expectedNode = t4.expectedNode), c;
            }
            function Kl(t4) {
              let { type: r, start: e, end: s, loc: i, range: a, extra: n } = t4;
              if (r === "Placeholder")
                return Vl(t4);
              let o = Object.create(ys);
              return o.type = r, o.start = e, o.end = s, o.loc = i, o.range = a, t4.raw !== void 0 ? o.raw = t4.raw : o.extra = n, o.value = t4.value, o;
            }
            var Wl = class extends zl {
              startNode() {
                return new bt(this, this.state.start, this.state.startLoc);
              }
              startNodeAt(t4) {
                return new bt(this, t4.index, t4);
              }
              startNodeAtNode(t4) {
                return this.startNodeAt(t4.loc.start);
              }
              finishNode(t4, r) {
                return this.finishNodeAt(t4, r, this.state.lastTokEndLoc);
              }
              finishNodeAt(t4, r, e) {
                return t4.type = r, t4.end = e.index, t4.loc.end = e, this.options.ranges && (t4.range[1] = e.index), this.options.attachComment && this.processComment(t4), t4;
              }
              resetStartLocation(t4, r) {
                t4.start = r.index, t4.loc.start = r, this.options.ranges && (t4.range[0] = r.index);
              }
              resetEndLocation(t4) {
                let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
                t4.end = r.index, t4.loc.end = r, this.options.ranges && (t4.range[1] = r.index);
              }
              resetStartLocationFromNode(t4, r) {
                this.resetStartLocation(t4, r.loc.start);
              }
            }, Gl = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), D = _`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: (t4) => {
              let { reservedType: r } = t4;
              return `Cannot overwrite reserved type ${r}.`;
            }, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: (t4) => {
              let { memberName: r, enumName: e } = t4;
              return `Boolean enum members need to be initialized. Use either \`${r} = true,\` or \`${r} = false,\` in enum \`${e}\`.`;
            }, EnumDuplicateMemberName: (t4) => {
              let { memberName: r, enumName: e } = t4;
              return `Enum member names need to be unique, but the name \`${r}\` has already been used before in enum \`${e}\`.`;
            }, EnumInconsistentMemberValues: (t4) => {
              let { enumName: r } = t4;
              return `Enum \`${r}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`;
            }, EnumInvalidExplicitType: (t4) => {
              let { invalidEnumType: r, enumName: e } = t4;
              return `Enum type \`${r}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`;
            }, EnumInvalidExplicitTypeUnknownSupplied: (t4) => {
              let { enumName: r } = t4;
              return `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r}\`.`;
            }, EnumInvalidMemberInitializerPrimaryType: (t4) => {
              let { enumName: r, memberName: e, explicitType: s } = t4;
              return `Enum \`${r}\` has type \`${s}\`, so the initializer of \`${e}\` needs to be a ${s} literal.`;
            }, EnumInvalidMemberInitializerSymbolType: (t4) => {
              let { enumName: r, memberName: e } = t4;
              return `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${r}\`.`;
            }, EnumInvalidMemberInitializerUnknownType: (t4) => {
              let { enumName: r, memberName: e } = t4;
              return `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${r}\`.`;
            }, EnumInvalidMemberName: (t4) => {
              let { enumName: r, memberName: e, suggestion: s } = t4;
              return `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${s}\`, in enum \`${r}\`.`;
            }, EnumNumberMemberNotInitialized: (t4) => {
              let { enumName: r, memberName: e } = t4;
              return `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${r}\`.`;
            }, EnumStringMemberInconsistentlyInitailized: (t4) => {
              let { enumName: r } = t4;
              return `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${r}\`.`;
            }, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: (t4) => {
              let { reservedType: r } = t4;
              return `Unexpected reserved type ${r}.`;
            }, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: (t4) => {
              let { unsupportedExportKind: r, suggestion: e } = t4;
              return `\`declare export ${r}\` is not supported. Use \`${e}\` instead.`;
            }, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
            function Jl(t4) {
              return t4.type === "DeclareExportAllDeclaration" || t4.type === "DeclareExportDeclaration" && (!t4.declaration || t4.declaration.type !== "TypeAlias" && t4.declaration.type !== "InterfaceDeclaration");
            }
            function xs(t4) {
              return t4.importKind === "type" || t4.importKind === "typeof";
            }
            function Gr(t4) {
              return ye(t4) && t4 !== 97;
            }
            var Xl = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
            function Yl(t4, r) {
              let e = [], s = [];
              for (let i = 0; i < t4.length; i++)
                (r(t4[i], i, t4) ? e : s).push(t4[i]);
              return [e, s];
            }
            var Ql = /\*?\s*@((?:no)?flow)\b/, Zl = (t4) => class extends t4 {
              constructor() {
                super(...arguments), this.flowPragma = void 0;
              }
              getScopeHandler() {
                return El;
              }
              shouldParseTypes() {
                return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
              }
              shouldParseEnums() {
                return !!this.getPluginOption("flow", "enums");
              }
              finishToken(e, s) {
                return e !== 131 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, s);
              }
              addComment(e) {
                if (this.flowPragma === void 0) {
                  let s = Ql.exec(e.value);
                  if (s)
                    if (s[1] === "flow")
                      this.flowPragma = "flow";
                    else if (s[1] === "noflow")
                      this.flowPragma = "noflow";
                    else
                      throw new Error("Unexpected flow pragma");
                }
                return super.addComment(e);
              }
              flowParseTypeInitialiser(e) {
                let s = this.state.inType;
                this.state.inType = true, this.expect(e || 14);
                let i = this.flowParseType();
                return this.state.inType = s, i;
              }
              flowParsePredicate() {
                let e = this.startNode(), s = this.state.startLoc;
                return this.next(), this.expectContextual(108), this.state.lastTokStart > s.index + 1 && this.raise(D.UnexpectedSpaceBetweenModuloChecks, { at: s }), this.eat(10) ? (e.value = super.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
              }
              flowParseTypeAndPredicateInitialiser() {
                let e = this.state.inType;
                this.state.inType = true, this.expect(14);
                let s = null, i = null;
                return this.match(54) ? (this.state.inType = e, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = e, this.match(54) && (i = this.flowParsePredicate())), [s, i];
              }
              flowParseDeclareClass(e) {
                return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
              }
              flowParseDeclareFunction(e) {
                this.next();
                let s = e.id = this.parseIdentifier(), i = this.startNode(), a = this.startNode();
                this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
                let n = this.flowParseFunctionTypeParams();
                return i.params = n.params, i.rest = n.rest, i.this = n._this, this.expect(11), [i.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(s), this.semicolon(), this.scope.declareName(e.id.name, xl, e.id.loc.start), this.finishNode(e, "DeclareFunction");
              }
              flowParseDeclare(e, s) {
                if (this.match(80))
                  return this.flowParseDeclareClass(e);
                if (this.match(68))
                  return this.flowParseDeclareFunction(e);
                if (this.match(74))
                  return this.flowParseDeclareVariable(e);
                if (this.eatContextual(125))
                  return this.match(16) ? this.flowParseDeclareModuleExports(e) : (s && this.raise(D.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(e));
                if (this.isContextual(128))
                  return this.flowParseDeclareTypeAlias(e);
                if (this.isContextual(129))
                  return this.flowParseDeclareOpaqueType(e);
                if (this.isContextual(127))
                  return this.flowParseDeclareInterface(e);
                if (this.match(82))
                  return this.flowParseDeclareExportDeclaration(e, s);
                throw this.unexpected();
              }
              flowParseDeclareVariable(e) {
                return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, xt, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
              }
              flowParseDeclareModule(e) {
                this.scope.enter(je), this.match(131) ? e.id = super.parseExprAtom() : e.id = this.parseIdentifier();
                let s = e.body = this.startNode(), i = s.body = [];
                for (this.expect(5); !this.match(8); ) {
                  let o = this.startNode();
                  this.match(83) ? (this.next(), !this.isContextual(128) && !this.match(87) && this.raise(D.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), super.parseImport(o)) : (this.expectContextual(123, D.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, true)), i.push(o);
                }
                this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
                let a = null, n = false;
                return i.forEach((o) => {
                  Jl(o) ? (a === "CommonJS" && this.raise(D.AmbiguousDeclareModuleKind, { at: o }), a = "ES") : o.type === "DeclareModuleExports" && (n && this.raise(D.DuplicateDeclareModuleExports, { at: o }), a === "ES" && this.raise(D.AmbiguousDeclareModuleKind, { at: o }), a = "CommonJS", n = true);
                }), e.kind = a || "CommonJS", this.finishNode(e, "DeclareModule");
              }
              flowParseDeclareExportDeclaration(e, s) {
                if (this.expect(82), this.eat(65))
                  return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
                if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !s) {
                  let i = this.state.value;
                  throw this.raise(D.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: i, suggestion: Xl[i] });
                }
                if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129))
                  return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
                if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129))
                  return e = this.parseExport(e, null), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
                throw this.unexpected();
              }
              flowParseDeclareModuleExports(e) {
                return this.next(), this.expectContextual(109), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
              }
              flowParseDeclareTypeAlias(e) {
                this.next();
                let s = this.flowParseTypeAlias(e);
                return s.type = "DeclareTypeAlias", s;
              }
              flowParseDeclareOpaqueType(e) {
                this.next();
                let s = this.flowParseOpaqueType(e, true);
                return s.type = "DeclareOpaqueType", s;
              }
              flowParseDeclareInterface(e) {
                return this.next(), this.flowParseInterfaceish(e), this.finishNode(e, "DeclareInterface");
              }
              flowParseInterfaceish(e) {
                let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (e.id = this.flowParseRestrictedIdentifier(!s, true), this.scope.declareName(e.id.name, s ? Dr : De, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], e.implements = [], e.mixins = [], this.eat(81))
                  do
                    e.extends.push(this.flowParseInterfaceExtends());
                  while (!s && this.eat(12));
                if (this.isContextual(115)) {
                  this.next();
                  do
                    e.mixins.push(this.flowParseInterfaceExtends());
                  while (this.eat(12));
                }
                if (this.isContextual(111)) {
                  this.next();
                  do
                    e.implements.push(this.flowParseInterfaceExtends());
                  while (this.eat(12));
                }
                e.body = this.flowParseObjectType({ allowStatic: s, allowExact: false, allowSpread: false, allowProto: s, allowInexact: false });
              }
              flowParseInterfaceExtends() {
                let e = this.startNode();
                return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
              }
              flowParseInterface(e) {
                return this.flowParseInterfaceish(e), this.finishNode(e, "InterfaceDeclaration");
              }
              checkNotUnderscore(e) {
                e === "_" && this.raise(D.UnexpectedReservedUnderscore, { at: this.state.startLoc });
              }
              checkReservedType(e, s, i) {
                Gl.has(e) && this.raise(i ? D.AssignReservedType : D.UnexpectedReservedType, { at: s, reservedType: e });
              }
              flowParseRestrictedIdentifier(e, s) {
                return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(e);
              }
              flowParseTypeAlias(e) {
                return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, De, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
              }
              flowParseOpaqueType(e, s) {
                return this.expectContextual(128), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, De, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, s || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
              }
              flowParseTypeParameter() {
                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, s = this.state.startLoc, i = this.startNode(), a = this.flowParseVariance(), n = this.flowParseTypeAnnotatableIdentifier();
                return i.name = n.name, i.variance = a, i.bound = n.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) : e && this.raise(D.MissingTypeParamDefault, { at: s }), this.finishNode(i, "TypeParameter");
              }
              flowParseTypeParameterDeclaration() {
                let e = this.state.inType, s = this.startNode();
                s.params = [], this.state.inType = true, this.match(47) || this.match(140) ? this.next() : this.unexpected();
                let i = false;
                do {
                  let a = this.flowParseTypeParameter(i);
                  s.params.push(a), a.default && (i = true), this.match(48) || this.expect(12);
                } while (!this.match(48));
                return this.expect(48), this.state.inType = e, this.finishNode(s, "TypeParameterDeclaration");
              }
              flowParseTypeParameterInstantiation() {
                let e = this.startNode(), s = this.state.inType;
                e.params = [], this.state.inType = true, this.expect(47);
                let i = this.state.noAnonFunctionType;
                for (this.state.noAnonFunctionType = false; !this.match(48); )
                  e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
                return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
              }
              flowParseTypeParameterInstantiationCallOrNew() {
                let e = this.startNode(), s = this.state.inType;
                for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
                  e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
                return this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
              }
              flowParseInterfaceType() {
                let e = this.startNode();
                if (this.expectContextual(127), e.extends = [], this.eat(81))
                  do
                    e.extends.push(this.flowParseInterfaceExtends());
                  while (this.eat(12));
                return e.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e, "InterfaceTypeAnnotation");
              }
              flowParseObjectPropertyKey() {
                return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
              }
              flowParseObjectTypeIndexer(e, s, i) {
                return e.static = s, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = i, this.finishNode(e, "ObjectTypeIndexer");
              }
              flowParseObjectTypeInternalSlot(e, s) {
                return e.static = s, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
              }
              flowParseObjectTypeMethodish(e) {
                for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
                  e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
                return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
              }
              flowParseObjectTypeCallProperty(e, s) {
                let i = this.startNode();
                return e.static = s, e.value = this.flowParseObjectTypeMethodish(i), this.finishNode(e, "ObjectTypeCallProperty");
              }
              flowParseObjectType(e) {
                let { allowStatic: s, allowExact: i, allowSpread: a, allowProto: n, allowInexact: o } = e, c = this.state.inType;
                this.state.inType = true;
                let p = this.startNode();
                p.callProperties = [], p.properties = [], p.indexers = [], p.internalSlots = [];
                let m, x, A = false;
                for (i && this.match(6) ? (this.expect(6), m = 9, x = true) : (this.expect(5), m = 8, x = false), p.exact = x; !this.match(m); ) {
                  let O = false, R4 = null, Y = null, Q = this.startNode();
                  if (n && this.isContextual(116)) {
                    let se = this.lookahead();
                    se.type !== 14 && se.type !== 17 && (this.next(), R4 = this.state.startLoc, s = false);
                  }
                  if (s && this.isContextual(104)) {
                    let se = this.lookahead();
                    se.type !== 14 && se.type !== 17 && (this.next(), O = true);
                  }
                  let J = this.flowParseVariance();
                  if (this.eat(0))
                    R4 != null && this.unexpected(R4), this.eat(0) ? (J && this.unexpected(J.loc.start), p.internalSlots.push(this.flowParseObjectTypeInternalSlot(Q, O))) : p.indexers.push(this.flowParseObjectTypeIndexer(Q, O, J));
                  else if (this.match(10) || this.match(47))
                    R4 != null && this.unexpected(R4), J && this.unexpected(J.loc.start), p.callProperties.push(this.flowParseObjectTypeCallProperty(Q, O));
                  else {
                    let se = "init";
                    if (this.isContextual(98) || this.isContextual(103)) {
                      let Ih = this.lookahead();
                      gr(Ih.type) && (se = this.state.value, this.next());
                    }
                    let Ve = this.flowParseObjectTypeProperty(Q, O, R4, J, se, a, o != null ? o : !x);
                    Ve === null ? (A = true, Y = this.state.lastTokStartLoc) : p.properties.push(Ve);
                  }
                  this.flowObjectTypeSemicolon(), Y && !this.match(8) && !this.match(9) && this.raise(D.UnexpectedExplicitInexactInObject, { at: Y });
                }
                this.expect(m), a && (p.inexact = A);
                let b = this.finishNode(p, "ObjectTypeAnnotation");
                return this.state.inType = c, b;
              }
              flowParseObjectTypeProperty(e, s, i, a, n, o, c) {
                if (this.eat(21))
                  return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? c || this.raise(D.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(D.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), a && this.raise(D.InexactVariance, { at: a }), null) : (o || this.raise(D.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), i != null && this.unexpected(i), a && this.raise(D.SpreadVariance, { at: a }), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
                {
                  e.key = this.flowParseObjectPropertyKey(), e.static = s, e.proto = i != null, e.kind = n;
                  let p = false;
                  return this.match(47) || this.match(10) ? (e.method = true, i != null && this.unexpected(i), a && this.unexpected(a.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)), (n === "get" || n === "set") && this.flowCheckGetterSetterParams(e), !o && e.key.name === "constructor" && e.value.this && this.raise(D.ThisParamBannedInConstructor, { at: e.value.this })) : (n !== "init" && this.unexpected(), e.method = false, this.eat(17) && (p = true), e.value = this.flowParseTypeInitialiser(), e.variance = a), e.optional = p, this.finishNode(e, "ObjectTypeProperty");
                }
              }
              flowCheckGetterSetterParams(e) {
                let s = e.kind === "get" ? 0 : 1, i = e.value.params.length + (e.value.rest ? 1 : 0);
                e.value.this && this.raise(e.kind === "get" ? D.GetterMayNotHaveThisParam : D.SetterMayNotHaveThisParam, { at: e.value.this }), i !== s && this.raise(e.kind === "get" ? u.BadGetterArity : u.BadSetterArity, { at: e }), e.kind === "set" && e.value.rest && this.raise(u.BadSetterRestParameter, { at: e });
              }
              flowObjectTypeSemicolon() {
                !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
              }
              flowParseQualifiedTypeIdentifier(e, s) {
                var i;
                (i = e) != null || (e = this.state.startLoc);
                let a = s || this.flowParseRestrictedIdentifier(true);
                for (; this.eat(16); ) {
                  let n = this.startNodeAt(e);
                  n.qualification = a, n.id = this.flowParseRestrictedIdentifier(true), a = this.finishNode(n, "QualifiedTypeIdentifier");
                }
                return a;
              }
              flowParseGenericType(e, s) {
                let i = this.startNodeAt(e);
                return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
              }
              flowParseTypeofType() {
                let e = this.startNode();
                return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
              }
              flowParseTupleType() {
                let e = this.startNode();
                for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); )
                  this.expect(12);
                return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
              }
              flowParseFunctionTypeParam(e) {
                let s = null, i = false, a = null, n = this.startNode(), o = this.lookahead(), c = this.state.type === 78;
                return o.type === 14 || o.type === 17 ? (c && !e && this.raise(D.ThisParamMustBeFirst, { at: n }), s = this.parseIdentifier(c), this.eat(17) && (i = true, c && this.raise(D.ThisParamMayNotBeOptional, { at: n })), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), n.name = s, n.optional = i, n.typeAnnotation = a, this.finishNode(n, "FunctionTypeParam");
              }
              reinterpretTypeAsFunctionTypeParam(e) {
                let s = this.startNodeAt(e.loc.start);
                return s.name = null, s.optional = false, s.typeAnnotation = e, this.finishNode(s, "FunctionTypeParam");
              }
              flowParseFunctionTypeParams() {
                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], s = null, i = null;
                for (this.match(78) && (i = this.flowParseFunctionTypeParam(true), i.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
                  e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
                return this.eat(21) && (s = this.flowParseFunctionTypeParam(false)), { params: e, rest: s, _this: i };
              }
              flowIdentToTypeAnnotation(e, s, i) {
                switch (i.name) {
                  case "any":
                    return this.finishNode(s, "AnyTypeAnnotation");
                  case "bool":
                  case "boolean":
                    return this.finishNode(s, "BooleanTypeAnnotation");
                  case "mixed":
                    return this.finishNode(s, "MixedTypeAnnotation");
                  case "empty":
                    return this.finishNode(s, "EmptyTypeAnnotation");
                  case "number":
                    return this.finishNode(s, "NumberTypeAnnotation");
                  case "string":
                    return this.finishNode(s, "StringTypeAnnotation");
                  case "symbol":
                    return this.finishNode(s, "SymbolTypeAnnotation");
                  default:
                    return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, i);
                }
              }
              flowParsePrimaryType() {
                let e = this.state.startLoc, s = this.startNode(), i, a, n = false, o = this.state.noAnonFunctionType;
                switch (this.state.type) {
                  case 5:
                    return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
                  case 6:
                    return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
                  case 0:
                    return this.state.noAnonFunctionType = false, a = this.flowParseTupleType(), this.state.noAnonFunctionType = o, a;
                  case 47:
                    return s.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), s.params = i.params, s.rest = i.rest, s.this = i._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), this.finishNode(s, "FunctionTypeAnnotation");
                  case 10:
                    if (this.next(), !this.match(11) && !this.match(21))
                      if (z(this.state.type) || this.match(78)) {
                        let c = this.lookahead().type;
                        n = c !== 17 && c !== 14;
                      } else
                        n = true;
                    if (n) {
                      if (this.state.noAnonFunctionType = false, a = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
                        return this.expect(11), a;
                      this.eat(12);
                    }
                    return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(), s.params = i.params, s.rest = i.rest, s.this = i._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
                  case 131:
                    return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                  case 85:
                  case 86:
                    return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
                  case 53:
                    if (this.state.value === "-") {
                      if (this.next(), this.match(132))
                        return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
                      if (this.match(133))
                        return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
                      throw this.raise(D.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                    }
                    throw this.unexpected();
                  case 132:
                    return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                  case 133:
                    return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                  case 88:
                    return this.next(), this.finishNode(s, "VoidTypeAnnotation");
                  case 84:
                    return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
                  case 78:
                    return this.next(), this.finishNode(s, "ThisTypeAnnotation");
                  case 55:
                    return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
                  case 87:
                    return this.flowParseTypeofType();
                  default:
                    if (Yt(this.state.type)) {
                      let c = Ee(this.state.type);
                      return this.next(), super.createIdentifier(s, c);
                    } else if (z(this.state.type))
                      return this.isContextual(127) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, s, this.parseIdentifier());
                }
                throw this.unexpected();
              }
              flowParsePostfixType() {
                let e = this.state.startLoc, s = this.flowParsePrimaryType(), i = false;
                for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
                  let a = this.startNodeAt(e), n = this.eat(18);
                  i = i || n, this.expect(0), !n && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.objectType = s, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = n, s = this.finishNode(a, "OptionalIndexedAccessType")) : s = this.finishNode(a, "IndexedAccessType"));
                }
                return s;
              }
              flowParsePrefixType() {
                let e = this.startNode();
                return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
              }
              flowParseAnonFunctionWithoutParens() {
                let e = this.flowParsePrefixType();
                if (!this.state.noAnonFunctionType && this.eat(19)) {
                  let s = this.startNodeAt(e.loc.start);
                  return s.params = [this.reinterpretTypeAsFunctionTypeParam(e)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
                }
                return e;
              }
              flowParseIntersectionType() {
                let e = this.startNode();
                this.eat(45);
                let s = this.flowParseAnonFunctionWithoutParens();
                for (e.types = [s]; this.eat(45); )
                  e.types.push(this.flowParseAnonFunctionWithoutParens());
                return e.types.length === 1 ? s : this.finishNode(e, "IntersectionTypeAnnotation");
              }
              flowParseUnionType() {
                let e = this.startNode();
                this.eat(43);
                let s = this.flowParseIntersectionType();
                for (e.types = [s]; this.eat(43); )
                  e.types.push(this.flowParseIntersectionType());
                return e.types.length === 1 ? s : this.finishNode(e, "UnionTypeAnnotation");
              }
              flowParseType() {
                let e = this.state.inType;
                this.state.inType = true;
                let s = this.flowParseUnionType();
                return this.state.inType = e, s;
              }
              flowParseTypeOrImplicitInstantiation() {
                if (this.state.type === 130 && this.state.value === "_") {
                  let e = this.state.startLoc, s = this.parseIdentifier();
                  return this.flowParseGenericType(e, s);
                } else
                  return this.flowParseType();
              }
              flowParseTypeAnnotation() {
                let e = this.startNode();
                return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
              }
              flowParseTypeAnnotatableIdentifier(e) {
                let s = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
              }
              typeCastToParameter(e) {
                return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
              }
              flowParseVariance() {
                let e = null;
                return this.match(53) ? (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")) : e;
              }
              parseFunctionBody(e, s) {
                let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                return s ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, i)) : super.parseFunctionBody(e, false, i);
              }
              parseFunctionBodyAndFinish(e, s) {
                let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                if (this.match(14)) {
                  let a = this.startNode();
                  [a.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = a.typeAnnotation ? this.finishNode(a, "TypeAnnotation") : null;
                }
                return super.parseFunctionBodyAndFinish(e, s, i);
              }
              parseStatementLike(e) {
                if (this.state.strict && this.isContextual(127)) {
                  let i = this.lookahead();
                  if (ye(i.type)) {
                    let a = this.startNode();
                    return this.next(), this.flowParseInterface(a);
                  }
                } else if (this.shouldParseEnums() && this.isContextual(124)) {
                  let i = this.startNode();
                  return this.next(), this.flowParseEnumDeclaration(i);
                }
                let s = super.parseStatementLike(e);
                return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
              }
              parseExpressionStatement(e, s, i) {
                if (s.type === "Identifier") {
                  if (s.name === "declare") {
                    if (this.match(80) || z(this.state.type) || this.match(68) || this.match(74) || this.match(82))
                      return this.flowParseDeclare(e);
                  } else if (z(this.state.type)) {
                    if (s.name === "interface")
                      return this.flowParseInterface(e);
                    if (s.name === "type")
                      return this.flowParseTypeAlias(e);
                    if (s.name === "opaque")
                      return this.flowParseOpaqueType(e, false);
                  }
                }
                return super.parseExpressionStatement(e, s, i);
              }
              shouldParseExportDeclaration() {
                let { type: e } = this.state;
                return Pr(e) || this.shouldParseEnums() && e === 124 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
              }
              isExportDefaultSpecifier() {
                let { type: e } = this.state;
                return Pr(e) || this.shouldParseEnums() && e === 124 ? this.state.containsEsc : super.isExportDefaultSpecifier();
              }
              parseExportDefaultExpression() {
                if (this.shouldParseEnums() && this.isContextual(124)) {
                  let e = this.startNode();
                  return this.next(), this.flowParseEnumDeclaration(e);
                }
                return super.parseExportDefaultExpression();
              }
              parseConditional(e, s, i) {
                if (!this.match(17))
                  return e;
                if (this.state.maybeInArrowParameters) {
                  let A = this.lookaheadCharCode();
                  if (A === 44 || A === 61 || A === 58 || A === 41)
                    return this.setOptionalParametersError(i), e;
                }
                this.expect(17);
                let a = this.state.clone(), n = this.state.noArrowAt, o = this.startNodeAt(s), { consequent: c, failed: p } = this.tryParseConditionalConsequent(), [m, x] = this.getArrowLikeExpressions(c);
                if (p || x.length > 0) {
                  let A = [...n];
                  if (x.length > 0) {
                    this.state = a, this.state.noArrowAt = A;
                    for (let b = 0; b < x.length; b++)
                      A.push(x[b].start);
                    ({ consequent: c, failed: p } = this.tryParseConditionalConsequent()), [m, x] = this.getArrowLikeExpressions(c);
                  }
                  p && m.length > 1 && this.raise(D.AmbiguousConditionalArrow, { at: a.startLoc }), p && m.length === 1 && (this.state = a, A.push(m[0].start), this.state.noArrowAt = A, { consequent: c, failed: p } = this.tryParseConditionalConsequent());
                }
                return this.getArrowLikeExpressions(c, true), this.state.noArrowAt = n, this.expect(14), o.test = e, o.consequent = c, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
              }
              tryParseConditionalConsequent() {
                this.state.noArrowParamsConversionAt.push(this.state.start);
                let e = this.parseMaybeAssignAllowIn(), s = !this.match(14);
                return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: s };
              }
              getArrowLikeExpressions(e, s) {
                let i = [e], a = [];
                for (; i.length !== 0; ) {
                  let n = i.pop();
                  n.type === "ArrowFunctionExpression" ? (n.typeParameters || !n.returnType ? this.finishArrowValidation(n) : a.push(n), i.push(n.body)) : n.type === "ConditionalExpression" && (i.push(n.consequent), i.push(n.alternate));
                }
                return s ? (a.forEach((n) => this.finishArrowValidation(n)), [a, []]) : Yl(a, (n) => n.params.every((o) => this.isAssignable(o, true)));
              }
              finishArrowValidation(e) {
                var s;
                this.toAssignableList(e.params, (s = e.extra) == null ? void 0 : s.trailingCommaLoc, false), this.scope.enter(Pe | ts), super.checkParams(e, false, true), this.scope.exit();
              }
              forwardNoArrowParamsConversionAt(e, s) {
                let i;
                return this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
              }
              parseParenItem(e, s) {
                if (e = super.parseParenItem(e, s), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
                  let i = this.startNodeAt(s);
                  return i.expression = e, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
                }
                return e;
              }
              assertModuleNodeAllowed(e) {
                e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
              }
              parseExport(e, s) {
                let i = super.parseExport(e, s);
                return (i.type === "ExportNamedDeclaration" || i.type === "ExportAllDeclaration") && (i.exportKind = i.exportKind || "value"), i;
              }
              parseExportDeclaration(e) {
                if (this.isContextual(128)) {
                  e.exportKind = "type";
                  let s = this.startNode();
                  return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e), null) : this.flowParseTypeAlias(s);
                } else if (this.isContextual(129)) {
                  e.exportKind = "type";
                  let s = this.startNode();
                  return this.next(), this.flowParseOpaqueType(s, false);
                } else if (this.isContextual(127)) {
                  e.exportKind = "type";
                  let s = this.startNode();
                  return this.next(), this.flowParseInterface(s);
                } else if (this.shouldParseEnums() && this.isContextual(124)) {
                  e.exportKind = "value";
                  let s = this.startNode();
                  return this.next(), this.flowParseEnumDeclaration(s);
                } else
                  return super.parseExportDeclaration(e);
              }
              eatExportStar(e) {
                return super.eatExportStar(e) ? true : this.isContextual(128) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
              }
              maybeParseExportNamespaceSpecifier(e) {
                let { startLoc: s } = this.state, i = super.maybeParseExportNamespaceSpecifier(e);
                return i && e.exportKind === "type" && this.unexpected(s), i;
              }
              parseClassId(e, s, i) {
                super.parseClassId(e, s, i), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
              }
              parseClassMember(e, s, i) {
                let { startLoc: a } = this.state;
                if (this.isContextual(123)) {
                  if (super.parseClassMemberFromModifier(e, s))
                    return;
                  s.declare = true;
                }
                super.parseClassMember(e, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "PropertyDefinition" ? this.raise(D.DeclareClassElement, { at: a }) : s.value && this.raise(D.DeclareClassFieldInitializer, { at: s.value }));
              }
              isIterator(e) {
                return e === "iterator" || e === "asyncIterator";
              }
              readIterator() {
                let e = super.readWord1(), s = "@@" + e;
                (!this.isIterator(e) || !this.state.inType) && this.raise(u.InvalidIdentifier, { at: this.state.curPosition(), identifierName: s }), this.finishToken(130, s);
              }
              getTokenFromCode(e) {
                let s = this.input.charCodeAt(this.state.pos + 1);
                return e === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : hl(e, s, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
              }
              isAssignable(e, s) {
                return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, s) : super.isAssignable(e, s);
              }
              toAssignable(e) {
                let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                !s && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, s);
              }
              toAssignableList(e, s, i) {
                for (let a = 0; a < e.length; a++) {
                  let n = e[a];
                  (n == null ? void 0 : n.type) === "TypeCastExpression" && (e[a] = this.typeCastToParameter(n));
                }
                super.toAssignableList(e, s, i);
              }
              toReferencedList(e, s) {
                for (let a = 0; a < e.length; a++) {
                  var i;
                  let n = e[a];
                  n && n.type === "TypeCastExpression" && !((i = n.extra) != null && i.parenthesized) && (e.length > 1 || !s) && this.raise(D.TypeCastInPattern, { at: n.typeAnnotation });
                }
                return e;
              }
              parseArrayLike(e, s, i, a) {
                let n = super.parseArrayLike(e, s, i, a);
                return s && !this.state.maybeInArrowParameters && this.toReferencedList(n.elements), n;
              }
              isValidLVal(e, s, i) {
                return e === "TypeCastExpression" || super.isValidLVal(e, s, i);
              }
              parseClassProperty(e) {
                return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
              }
              parseClassPrivateProperty(e) {
                return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
              }
              isClassMethod() {
                return this.match(47) || super.isClassMethod();
              }
              isClassProperty() {
                return this.match(14) || super.isClassProperty();
              }
              isNonstaticConstructor(e) {
                return !this.match(14) && super.isNonstaticConstructor(e);
              }
              pushClassMethod(e, s, i, a, n, o) {
                if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, s, i, a, n, o), s.params && n) {
                  let c = s.params;
                  c.length > 0 && this.isThisParam(c[0]) && this.raise(D.ThisParamBannedInConstructor, { at: s });
                } else if (s.type === "MethodDefinition" && n && s.value.params) {
                  let c = s.value.params;
                  c.length > 0 && this.isThisParam(c[0]) && this.raise(D.ThisParamBannedInConstructor, { at: s });
                }
              }
              pushClassPrivateMethod(e, s, i, a) {
                s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, s, i, a);
              }
              parseClassSuper(e) {
                if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(111)) {
                  this.next();
                  let s = e.implements = [];
                  do {
                    let i = this.startNode();
                    i.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
                  } while (this.eat(12));
                }
              }
              checkGetterSetterParams(e) {
                super.checkGetterSetterParams(e);
                let s = this.getObjectOrClassMethodParams(e);
                if (s.length > 0) {
                  let i = s[0];
                  this.isThisParam(i) && e.kind === "get" ? this.raise(D.GetterMayNotHaveThisParam, { at: i }) : this.isThisParam(i) && this.raise(D.SetterMayNotHaveThisParam, { at: i });
                }
              }
              parsePropertyNamePrefixOperator(e) {
                e.variance = this.flowParseVariance();
              }
              parseObjPropValue(e, s, i, a, n, o, c) {
                e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
                let p;
                this.match(47) && !o && (p = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
                let m = super.parseObjPropValue(e, s, i, a, n, o, c);
                return p && ((m.value || m).typeParameters = p), m;
              }
              parseAssignableListItemTypes(e) {
                return this.eat(17) && (e.type !== "Identifier" && this.raise(D.PatternIsOptional, { at: e }), this.isThisParam(e) && this.raise(D.ThisParamMayNotBeOptional, { at: e }), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(D.ThisParamAnnotationRequired, { at: e }), this.match(29) && this.isThisParam(e) && this.raise(D.ThisParamNoDefault, { at: e }), this.resetEndLocation(e), e;
              }
              parseMaybeDefault(e, s) {
                let i = super.parseMaybeDefault(e, s);
                return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(D.TypeBeforeInitializer, { at: i.typeAnnotation }), i;
              }
              shouldParseDefaultImport(e) {
                return xs(e) ? Gr(this.state.type) : super.shouldParseDefaultImport(e);
              }
              checkImportReflection(e) {
                super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(D.ImportReflectionHasImportType, { at: e.specifiers[0].loc.start });
              }
              parseImportSpecifierLocal(e, s, i) {
                s.local = xs(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, i));
              }
              maybeParseDefaultImportSpecifier(e) {
                e.importKind = "value";
                let s = null;
                if (this.match(87) ? s = "typeof" : this.isContextual(128) && (s = "type"), s) {
                  let i = this.lookahead(), { type: a } = i;
                  s === "type" && a === 55 && this.unexpected(null, i.type), (Gr(a) || a === 5 || a === 55) && (this.next(), e.importKind = s);
                }
                return super.maybeParseDefaultImportSpecifier(e);
              }
              parseImportSpecifier(e, s, i, a, n) {
                let o = e.imported, c = null;
                o.type === "Identifier" && (o.name === "type" ? c = "type" : o.name === "typeof" && (c = "typeof"));
                let p = false;
                if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                  let x = this.parseIdentifier(true);
                  c !== null && !ye(this.state.type) ? (e.imported = x, e.importKind = c, e.local = Te(x)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
                } else {
                  if (c !== null && ye(this.state.type))
                    e.imported = this.parseIdentifier(true), e.importKind = c;
                  else {
                    if (s)
                      throw this.raise(u.ImportBindingIsString, { at: e, importName: o.value });
                    e.imported = o, e.importKind = null;
                  }
                  this.eatContextual(93) ? e.local = this.parseIdentifier() : (p = true, e.local = Te(e.imported));
                }
                let m = xs(e);
                return i && m && this.raise(D.ImportTypeShorthandOnlyInPureImport, { at: e }), (i || m) && this.checkReservedType(e.local.name, e.local.loc.start, true), p && !i && !m && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
              }
              parseBindingAtom() {
                switch (this.state.type) {
                  case 78:
                    return this.parseIdentifier(true);
                  default:
                    return super.parseBindingAtom();
                }
              }
              parseFunctionParams(e, s) {
                let i = e.kind;
                i !== "get" && i !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, s);
              }
              parseVarId(e, s) {
                super.parseVarId(e, s), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
              }
              parseAsyncArrowFromCallExpression(e, s) {
                if (this.match(14)) {
                  let i = this.state.noAnonFunctionType;
                  this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
                }
                return super.parseAsyncArrowFromCallExpression(e, s);
              }
              shouldParseAsyncArrow() {
                return this.match(14) || super.shouldParseAsyncArrow();
              }
              parseMaybeAssign(e, s) {
                var i;
                let a = null, n;
                if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                  if (a = this.state.clone(), n = this.tryParse(() => super.parseMaybeAssign(e, s), a), !n.error)
                    return n.node;
                  let { context: p } = this.state, m = p[p.length - 1];
                  (m === $.j_oTag || m === $.j_expr) && p.pop();
                }
                if ((i = n) != null && i.error || this.match(47)) {
                  var o, c;
                  a = a || this.state.clone();
                  let p, m = this.tryParse((A) => {
                    var b;
                    p = this.flowParseTypeParameterDeclaration();
                    let O = this.forwardNoArrowParamsConversionAt(p, () => {
                      let Y = super.parseMaybeAssign(e, s);
                      return this.resetStartLocationFromNode(Y, p), Y;
                    });
                    (b = O.extra) != null && b.parenthesized && A();
                    let R4 = this.maybeUnwrapTypeCastExpression(O);
                    return R4.type !== "ArrowFunctionExpression" && A(), R4.typeParameters = p, this.resetStartLocationFromNode(R4, p), O;
                  }, a), x = null;
                  if (m.node && this.maybeUnwrapTypeCastExpression(m.node).type === "ArrowFunctionExpression") {
                    if (!m.error && !m.aborted)
                      return m.node.async && this.raise(D.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: p }), m.node;
                    x = m.node;
                  }
                  if ((o = n) != null && o.node)
                    return this.state = n.failState, n.node;
                  if (x)
                    return this.state = m.failState, x;
                  throw (c = n) != null && c.thrown ? n.error : m.thrown ? m.error : this.raise(D.UnexpectedTokenAfterTypeParameter, { at: p });
                }
                return super.parseMaybeAssign(e, s);
              }
              parseArrow(e) {
                if (this.match(14)) {
                  let s = this.tryParse(() => {
                    let i = this.state.noAnonFunctionType;
                    this.state.noAnonFunctionType = true;
                    let a = this.startNode();
                    return [a.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), a;
                  });
                  if (s.thrown)
                    return null;
                  s.error && (this.state = s.failState), e.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
                }
                return super.parseArrow(e);
              }
              shouldParseArrow(e) {
                return this.match(14) || super.shouldParseArrow(e);
              }
              setArrowFunctionParameters(e, s) {
                this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? e.params = s : super.setArrowFunctionParameters(e, s);
              }
              checkParams(e, s, i) {
                let a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                if (!(i && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
                  for (let n = 0; n < e.params.length; n++)
                    this.isThisParam(e.params[n]) && n > 0 && this.raise(D.ThisParamMustBeFirst, { at: e.params[n] });
                  return super.checkParams(e, s, i, a);
                }
              }
              parseParenAndDistinguishExpression(e) {
                return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1);
              }
              parseSubscripts(e, s, i) {
                if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
                  this.next();
                  let a = this.startNodeAt(s);
                  a.callee = e, a.arguments = super.parseCallExpressionArguments(11, false), e = this.finishNode(a, "CallExpression");
                } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
                  let a = this.state.clone(), n = this.tryParse((c) => this.parseAsyncArrowWithTypeParameters(s) || c(), a);
                  if (!n.error && !n.aborted)
                    return n.node;
                  let o = this.tryParse(() => super.parseSubscripts(e, s, i), a);
                  if (o.node && !o.error)
                    return o.node;
                  if (n.node)
                    return this.state = n.failState, n.node;
                  if (o.node)
                    return this.state = o.failState, o.node;
                  throw n.error || o.error;
                }
                return super.parseSubscripts(e, s, i);
              }
              parseSubscript(e, s, i, a) {
                if (this.match(18) && this.isLookaheadToken_lt()) {
                  if (a.optionalChainMember = true, i)
                    return a.stop = true, e;
                  this.next();
                  let n = this.startNodeAt(s);
                  return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n.arguments = this.parseCallExpressionArguments(11, false), n.optional = true, this.finishCallExpression(n, true);
                } else if (!i && this.shouldParseTypes() && this.match(47)) {
                  let n = this.startNodeAt(s);
                  n.callee = e;
                  let o = this.tryParse(() => (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = super.parseCallExpressionArguments(11, false), a.optionalChainMember && (n.optional = false), this.finishCallExpression(n, a.optionalChainMember)));
                  if (o.node)
                    return o.error && (this.state = o.failState), o.node;
                }
                return super.parseSubscript(e, s, i, a);
              }
              parseNewCallee(e) {
                super.parseNewCallee(e);
                let s = null;
                this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = s;
              }
              parseAsyncArrowWithTypeParameters(e) {
                let s = this.startNodeAt(e);
                if (this.parseFunctionParams(s), !!this.parseArrow(s))
                  return super.parseArrowExpression(s, void 0, true);
              }
              readToken_mult_modulo(e) {
                let s = this.input.charCodeAt(this.state.pos + 1);
                if (e === 42 && s === 47 && this.state.hasFlowComment) {
                  this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
                  return;
                }
                super.readToken_mult_modulo(e);
              }
              readToken_pipe_amp(e) {
                let s = this.input.charCodeAt(this.state.pos + 1);
                if (e === 124 && s === 125) {
                  this.finishOp(9, 2);
                  return;
                }
                super.readToken_pipe_amp(e);
              }
              parseTopLevel(e, s) {
                let i = super.parseTopLevel(e, s);
                return this.state.hasFlowComment && this.raise(D.UnterminatedFlowComment, { at: this.state.curPosition() }), i;
              }
              skipBlockComment() {
                if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                  if (this.state.hasFlowComment)
                    throw this.raise(D.NestedFlowComment, { at: this.state.startLoc });
                  this.hasFlowCommentCompletion();
                  let e = this.skipFlowComment();
                  e && (this.state.pos += e, this.state.hasFlowComment = true);
                  return;
                }
                return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
              }
              skipFlowComment() {
                let { pos: e } = this.state, s = 2;
                for (; [32, 9].includes(this.input.charCodeAt(e + s)); )
                  s++;
                let i = this.input.charCodeAt(s + e), a = this.input.charCodeAt(s + e + 1);
                return i === 58 && a === 58 ? s + 2 : this.input.slice(s + e, s + e + 12) === "flow-include" ? s + 12 : i === 58 && a !== 58 ? s : false;
              }
              hasFlowCommentCompletion() {
                if (this.input.indexOf("*/", this.state.pos) === -1)
                  throw this.raise(u.UnterminatedComment, { at: this.state.curPosition() });
              }
              flowEnumErrorBooleanMemberNotInitialized(e, s) {
                let { enumName: i, memberName: a } = s;
                this.raise(D.EnumBooleanMemberNotInitialized, { at: e, memberName: a, enumName: i });
              }
              flowEnumErrorInvalidMemberInitializer(e, s) {
                return this.raise(s.explicitType ? s.explicitType === "symbol" ? D.EnumInvalidMemberInitializerSymbolType : D.EnumInvalidMemberInitializerPrimaryType : D.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: e }, s));
              }
              flowEnumErrorNumberMemberNotInitialized(e, s) {
                let { enumName: i, memberName: a } = s;
                this.raise(D.EnumNumberMemberNotInitialized, { at: e, enumName: i, memberName: a });
              }
              flowEnumErrorStringMemberInconsistentlyInitailized(e, s) {
                let { enumName: i } = s;
                this.raise(D.EnumStringMemberInconsistentlyInitailized, { at: e, enumName: i });
              }
              flowEnumMemberInit() {
                let e = this.state.startLoc, s = () => this.match(12) || this.match(8);
                switch (this.state.type) {
                  case 132: {
                    let i = this.parseNumericLiteral(this.state.value);
                    return s() ? { type: "number", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
                  }
                  case 131: {
                    let i = this.parseStringLiteral(this.state.value);
                    return s() ? { type: "string", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
                  }
                  case 85:
                  case 86: {
                    let i = this.parseBooleanLiteral(this.match(85));
                    return s() ? { type: "boolean", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
                  }
                  default:
                    return { type: "invalid", loc: e };
                }
              }
              flowEnumMemberRaw() {
                let e = this.state.startLoc, s = this.parseIdentifier(true), i = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e };
                return { id: s, init: i };
              }
              flowEnumCheckExplicitTypeMismatch(e, s, i) {
                let { explicitType: a } = s;
                a !== null && a !== i && this.flowEnumErrorInvalidMemberInitializer(e, s);
              }
              flowEnumMembers(e) {
                let { enumName: s, explicitType: i } = e, a = /* @__PURE__ */ new Set(), n = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, o = false;
                for (; !this.match(8); ) {
                  if (this.eat(21)) {
                    o = true;
                    break;
                  }
                  let c = this.startNode(), { id: p, init: m } = this.flowEnumMemberRaw(), x = p.name;
                  if (x === "")
                    continue;
                  /^[a-z]/.test(x) && this.raise(D.EnumInvalidMemberName, { at: p, memberName: x, suggestion: x[0].toUpperCase() + x.slice(1), enumName: s }), a.has(x) && this.raise(D.EnumDuplicateMemberName, { at: p, memberName: x, enumName: s }), a.add(x);
                  let A = { enumName: s, explicitType: i, memberName: x };
                  switch (c.id = p, m.type) {
                    case "boolean": {
                      this.flowEnumCheckExplicitTypeMismatch(m.loc, A, "boolean"), c.init = m.value, n.booleanMembers.push(this.finishNode(c, "EnumBooleanMember"));
                      break;
                    }
                    case "number": {
                      this.flowEnumCheckExplicitTypeMismatch(m.loc, A, "number"), c.init = m.value, n.numberMembers.push(this.finishNode(c, "EnumNumberMember"));
                      break;
                    }
                    case "string": {
                      this.flowEnumCheckExplicitTypeMismatch(m.loc, A, "string"), c.init = m.value, n.stringMembers.push(this.finishNode(c, "EnumStringMember"));
                      break;
                    }
                    case "invalid":
                      throw this.flowEnumErrorInvalidMemberInitializer(m.loc, A);
                    case "none":
                      switch (i) {
                        case "boolean":
                          this.flowEnumErrorBooleanMemberNotInitialized(m.loc, A);
                          break;
                        case "number":
                          this.flowEnumErrorNumberMemberNotInitialized(m.loc, A);
                          break;
                        default:
                          n.defaultedMembers.push(this.finishNode(c, "EnumDefaultedMember"));
                      }
                  }
                  this.match(8) || this.expect(12);
                }
                return { members: n, hasUnknownMembers: o };
              }
              flowEnumStringMembers(e, s, i) {
                let { enumName: a } = i;
                if (e.length === 0)
                  return s;
                if (s.length === 0)
                  return e;
                if (s.length > e.length) {
                  for (let n of e)
                    this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: a });
                  return s;
                } else {
                  for (let n of s)
                    this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: a });
                  return e;
                }
              }
              flowEnumParseExplicitType(e) {
                let { enumName: s } = e;
                if (!this.eatContextual(101))
                  return null;
                if (!z(this.state.type))
                  throw this.raise(D.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: s });
                let { value: i } = this.state;
                return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(D.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: s, invalidEnumType: i }), i;
              }
              flowEnumBody(e, s) {
                let i = s.name, a = s.loc.start, n = this.flowEnumParseExplicitType({ enumName: i });
                this.expect(5);
                let { members: o, hasUnknownMembers: c } = this.flowEnumMembers({ enumName: i, explicitType: n });
                switch (e.hasUnknownMembers = c, n) {
                  case "boolean":
                    return e.explicitType = true, e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
                  case "number":
                    return e.explicitType = true, e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
                  case "string":
                    return e.explicitType = true, e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
                  case "symbol":
                    return e.members = o.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
                  default: {
                    let p = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
                    e.explicitType = false;
                    let m = o.booleanMembers.length, x = o.numberMembers.length, A = o.stringMembers.length, b = o.defaultedMembers.length;
                    if (!m && !x && !A && !b)
                      return p();
                    if (!m && !x)
                      return e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
                    if (!x && !A && m >= b) {
                      for (let O of o.defaultedMembers)
                        this.flowEnumErrorBooleanMemberNotInitialized(O.loc.start, { enumName: i, memberName: O.id.name });
                      return e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
                    } else if (!m && !A && x >= b) {
                      for (let O of o.defaultedMembers)
                        this.flowEnumErrorNumberMemberNotInitialized(O.loc.start, { enumName: i, memberName: O.id.name });
                      return e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
                    } else
                      return this.raise(D.EnumInconsistentMemberValues, { at: a, enumName: i }), p();
                  }
                }
              }
              flowParseEnumDeclaration(e) {
                let s = this.parseIdentifier();
                return e.id = s, e.body = this.flowEnumBody(this.startNode(), s), this.finishNode(e, "EnumDeclaration");
              }
              isLookaheadToken_lt() {
                let e = this.nextTokenStart();
                if (this.input.charCodeAt(e) === 60) {
                  let s = this.input.charCodeAt(e + 1);
                  return s !== 60 && s !== 61;
                }
                return false;
              }
              maybeUnwrapTypeCastExpression(e) {
                return e.type === "TypeCastExpression" ? e.expression : e;
              }
            }, eh = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, Fe = _`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: (t4) => {
              let { openingTagName: r } = t4;
              return `Expected corresponding JSX closing tag for <${r}>.`;
            }, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: (t4) => {
              let { unexpected: r, HTMLEntity: e } = t4;
              return `Unexpected token \`${r}\`. Did you mean \`${e}\` or \`{'${r}'}\`?`;
            }, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
            function we(t4) {
              return t4 ? t4.type === "JSXOpeningFragment" || t4.type === "JSXClosingFragment" : false;
            }
            function ze(t4) {
              if (t4.type === "JSXIdentifier")
                return t4.name;
              if (t4.type === "JSXNamespacedName")
                return t4.namespace.name + ":" + t4.name.name;
              if (t4.type === "JSXMemberExpression")
                return ze(t4.object) + "." + ze(t4.property);
              throw new Error("Node had unexpected type: " + t4.type);
            }
            var th = (t4) => class extends t4 {
              jsxReadToken() {
                let e = "", s = this.state.pos;
                for (; ; ) {
                  if (this.state.pos >= this.length)
                    throw this.raise(Fe.UnterminatedJsxContent, { at: this.state.startLoc });
                  let i = this.input.charCodeAt(this.state.pos);
                  switch (i) {
                    case 60:
                    case 123:
                      return this.state.pos === this.state.start ? i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(i) : (e += this.input.slice(s, this.state.pos), this.finishToken(139, e));
                    case 38:
                      e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos;
                      break;
                    case 62:
                    case 125:
                    default:
                      et(i) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(true), s = this.state.pos) : ++this.state.pos;
                  }
                }
              }
              jsxReadNewLine(e) {
                let s = this.input.charCodeAt(this.state.pos), i;
                return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = e ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
              }
              jsxReadString(e) {
                let s = "", i = ++this.state.pos;
                for (; ; ) {
                  if (this.state.pos >= this.length)
                    throw this.raise(u.UnterminatedString, { at: this.state.startLoc });
                  let a = this.input.charCodeAt(this.state.pos);
                  if (a === e)
                    break;
                  a === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : et(a) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(false), i = this.state.pos) : ++this.state.pos;
                }
                return s += this.input.slice(i, this.state.pos++), this.finishToken(131, s);
              }
              jsxReadEntity() {
                let e = ++this.state.pos;
                if (this.codePointAtPos(this.state.pos) === 35) {
                  ++this.state.pos;
                  let s = 10;
                  this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
                  let i = this.readInt(s, void 0, false, "bail");
                  if (i !== null && this.codePointAtPos(this.state.pos) === 59)
                    return ++this.state.pos, String.fromCodePoint(i);
                } else {
                  let s = 0, i = false;
                  for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) == 59); )
                    ++this.state.pos;
                  if (i) {
                    let a = this.input.slice(e, this.state.pos), n = eh[a];
                    if (++this.state.pos, n)
                      return n;
                  }
                }
                return this.state.pos = e, "&";
              }
              jsxReadWord() {
                let e, s = this.state.pos;
                do
                  e = this.input.charCodeAt(++this.state.pos);
                while (Re(e) || e === 45);
                return this.finishToken(138, this.input.slice(s, this.state.pos));
              }
              jsxParseIdentifier() {
                let e = this.startNode();
                return this.match(138) ? e.name = this.state.value : Yt(this.state.type) ? e.name = Ee(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
              }
              jsxParseNamespacedName() {
                let e = this.state.startLoc, s = this.jsxParseIdentifier();
                if (!this.eat(14))
                  return s;
                let i = this.startNodeAt(e);
                return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
              }
              jsxParseElementName() {
                let e = this.state.startLoc, s = this.jsxParseNamespacedName();
                if (s.type === "JSXNamespacedName")
                  return s;
                for (; this.eat(16); ) {
                  let i = this.startNodeAt(e);
                  i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
                }
                return s;
              }
              jsxParseAttributeValue() {
                let e;
                switch (this.state.type) {
                  case 5:
                    return e = this.startNode(), this.setContext($.brace), this.next(), e = this.jsxParseExpressionContainer(e, $.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(Fe.AttributeIsEmpty, { at: e }), e;
                  case 140:
                  case 131:
                    return this.parseExprAtom();
                  default:
                    throw this.raise(Fe.UnsupportedJsxValue, { at: this.state.startLoc });
                }
              }
              jsxParseEmptyExpression() {
                let e = this.startNodeAt(this.state.lastTokEndLoc);
                return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
              }
              jsxParseSpreadChild(e) {
                return this.next(), e.expression = this.parseExpression(), this.setContext($.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
              }
              jsxParseExpressionContainer(e, s) {
                if (this.match(8))
                  e.expression = this.jsxParseEmptyExpression();
                else {
                  let i = this.parseExpression();
                  e.expression = i;
                }
                return this.setContext(s), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
              }
              jsxParseAttribute() {
                let e = this.startNode();
                return this.match(5) ? (this.setContext($.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext($.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
              }
              jsxParseOpeningElementAt(e) {
                let s = this.startNodeAt(e);
                return this.eat(141) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));
              }
              jsxParseOpeningElementAfterName(e) {
                let s = [];
                for (; !this.match(56) && !this.match(141); )
                  s.push(this.jsxParseAttribute());
                return e.attributes = s, e.selfClosing = this.eat(56), this.expect(141), this.finishNode(e, "JSXOpeningElement");
              }
              jsxParseClosingElementAt(e) {
                let s = this.startNodeAt(e);
                return this.eat(141) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(141), this.finishNode(s, "JSXClosingElement"));
              }
              jsxParseElementAt(e) {
                let s = this.startNodeAt(e), i = [], a = this.jsxParseOpeningElementAt(e), n = null;
                if (!a.selfClosing) {
                  e:
                    for (; ; )
                      switch (this.state.type) {
                        case 140:
                          if (e = this.state.startLoc, this.next(), this.eat(56)) {
                            n = this.jsxParseClosingElementAt(e);
                            break e;
                          }
                          i.push(this.jsxParseElementAt(e));
                          break;
                        case 139:
                          i.push(this.parseExprAtom());
                          break;
                        case 5: {
                          let o = this.startNode();
                          this.setContext($.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, $.j_expr));
                          break;
                        }
                        default:
                          throw this.unexpected();
                      }
                  we(a) && !we(n) && n !== null ? this.raise(Fe.MissingClosingTagFragment, { at: n }) : !we(a) && we(n) ? this.raise(Fe.MissingClosingTagElement, { at: n, openingTagName: ze(a.name) }) : !we(a) && !we(n) && ze(n.name) !== ze(a.name) && this.raise(Fe.MissingClosingTagElement, { at: n, openingTagName: ze(a.name) });
                }
                if (we(a) ? (s.openingFragment = a, s.closingFragment = n) : (s.openingElement = a, s.closingElement = n), s.children = i, this.match(47))
                  throw this.raise(Fe.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
                return we(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
              }
              jsxParseElement() {
                let e = this.state.startLoc;
                return this.next(), this.jsxParseElementAt(e);
              }
              setContext(e) {
                let { context: s } = this.state;
                s[s.length - 1] = e;
              }
              parseExprAtom(e) {
                return this.match(139) ? this.parseLiteral(this.state.value, "JSXText") : this.match(140) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(140), this.jsxParseElement()) : super.parseExprAtom(e);
              }
              skipSpace() {
                this.curContext().preserveSpace || super.skipSpace();
              }
              getTokenFromCode(e) {
                let s = this.curContext();
                if (s === $.j_expr)
                  return this.jsxReadToken();
                if (s === $.j_oTag || s === $.j_cTag) {
                  if (ge(e))
                    return this.jsxReadWord();
                  if (e === 62)
                    return ++this.state.pos, this.finishToken(141);
                  if ((e === 34 || e === 39) && s === $.j_oTag)
                    return this.jsxReadString(e);
                }
                return e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(e);
              }
              updateContext(e) {
                let { context: s, type: i } = this.state;
                if (i === 56 && e === 140)
                  s.splice(-2, 2, $.j_cTag), this.state.canStartJSXElement = false;
                else if (i === 140)
                  s.push($.j_oTag);
                else if (i === 141) {
                  let a = s[s.length - 1];
                  a === $.j_oTag && e === 56 || a === $.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === $.j_expr) : (this.setContext($.j_expr), this.state.canStartJSXElement = true);
                } else
                  this.state.canStartJSXElement = Wo(i);
              }
            }, sh = class extends us {
              constructor() {
                super(...arguments), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
              }
            }, rh = class extends cs {
              constructor() {
                super(...arguments), this.importsStack = [];
              }
              createScope(t4) {
                return this.importsStack.push(/* @__PURE__ */ new Set()), new sh(t4);
              }
              enter(t4) {
                t4 == Ue && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t4);
              }
              exit() {
                let t4 = super.exit();
                return t4 == Ue && this.importsStack.pop(), t4;
              }
              hasImport(t4, r) {
                let e = this.importsStack.length;
                if (this.importsStack[e - 1].has(t4))
                  return true;
                if (!r && e > 1) {
                  for (let s = 0; s < e - 1; s++)
                    if (this.importsStack[s].has(t4))
                      return true;
                }
                return false;
              }
              declareName(t4, r, e) {
                if (r & Ye) {
                  this.hasImport(t4, true) && this.parser.raise(u.VarRedeclaration, { at: e, identifierName: t4 }), this.importsStack[this.importsStack.length - 1].add(t4);
                  return;
                }
                let s = this.currentScope();
                if (r & is2) {
                  this.maybeExportDefined(s, t4), s.exportOnlyBindings.add(t4);
                  return;
                }
                super.declareName(t4, r, e), r & ke && (r & Ae || (this.checkRedeclarationInScope(s, t4, r, e), this.maybeExportDefined(s, t4)), s.types.add(t4)), r & ss && s.enums.add(t4), r & rs && s.constEnums.add(t4), r & yt && s.classes.add(t4);
              }
              isRedeclaredInScope(t4, r, e) {
                if (t4.enums.has(r)) {
                  if (e & ss) {
                    let s = !!(e & rs), i = t4.constEnums.has(r);
                    return s !== i;
                  }
                  return true;
                }
                return e & yt && t4.classes.has(r) ? t4.lexical.has(r) ? !!(e & Ae) : false : e & ke && t4.types.has(r) ? true : super.isRedeclaredInScope(t4, r, e);
              }
              checkLocalExport(t4) {
                let { name: r } = t4;
                if (this.hasImport(r))
                  return;
                let e = this.scopeStack.length;
                for (let s = e - 1; s >= 0; s--) {
                  let i = this.scopeStack[s];
                  if (i.types.has(r) || i.exportOnlyBindings.has(r))
                    return;
                }
                super.checkLocalExport(t4);
              }
            }, ih = (t4, r) => Object.hasOwnProperty.call(t4, r) && t4[r];
            function ah(t4) {
              if (t4 == null)
                throw new Error(`Unexpected ${t4} value.`);
              return t4;
            }
            function Jr(t4) {
              if (!t4)
                throw new Error("Assert fail");
            }
            var w = _`typescript`({ AbstractMethodHasImplementation: (t4) => {
              let { methodName: r } = t4;
              return `Method '${r}' cannot have an implementation because it is marked abstract.`;
            }, AbstractPropertyHasInitializer: (t4) => {
              let { propertyName: r } = t4;
              return `Property '${r}' cannot have an initializer because it is marked abstract.`;
            }, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: (t4) => {
              let { kind: r } = t4;
              return `'declare' is not allowed in ${r}ters.`;
            }, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: (t4) => {
              let { modifier: r } = t4;
              return "Accessibility modifier already seen.";
            }, DuplicateModifier: (t4) => {
              let { modifier: r } = t4;
              return `Duplicate modifier: '${r}'.`;
            }, EmptyHeritageClauseType: (t4) => {
              let { token: r } = t4;
              return `'${r}' list cannot be empty.`;
            }, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: (t4) => {
              let { modifiers: r } = t4;
              return `'${r[0]}' modifier cannot be used with '${r[1]}' modifier.`;
            }, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: (t4) => {
              let { modifier: r } = t4;
              return `Index signatures cannot have an accessibility modifier ('${r}').`;
            }, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: (t4) => {
              let { modifier: r } = t4;
              return `'${r}' modifier cannot appear on a type member.`;
            }, InvalidModifierOnTypeParameter: (t4) => {
              let { modifier: r } = t4;
              return `'${r}' modifier cannot appear on a type parameter.`;
            }, InvalidModifierOnTypeParameterPositions: (t4) => {
              let { modifier: r } = t4;
              return `'${r}' modifier can only appear on a type parameter of a class, interface or type alias.`;
            }, InvalidModifiersOrder: (t4) => {
              let { orderedModifiers: r } = t4;
              return `'${r[0]}' modifier must precede '${r[1]}' modifier.`;
            }, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: (t4) => {
              let { modifier: r } = t4;
              return `Private elements cannot have an accessibility modifier ('${r}').`;
            }, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: (t4) => {
              let { typeParameterName: r } = t4;
              return `Single type parameter ${r} should have a trailing comma. Example usage: <${r},>.`;
            }, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: (t4) => {
              let { type: r } = t4;
              return `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${r}.`;
            } });
            function nh(t4) {
              switch (t4) {
                case "any":
                  return "TSAnyKeyword";
                case "boolean":
                  return "TSBooleanKeyword";
                case "bigint":
                  return "TSBigIntKeyword";
                case "never":
                  return "TSNeverKeyword";
                case "number":
                  return "TSNumberKeyword";
                case "object":
                  return "TSObjectKeyword";
                case "string":
                  return "TSStringKeyword";
                case "symbol":
                  return "TSSymbolKeyword";
                case "undefined":
                  return "TSUndefinedKeyword";
                case "unknown":
                  return "TSUnknownKeyword";
                default:
                  return;
              }
            }
            function Xr(t4) {
              return t4 === "private" || t4 === "public" || t4 === "protected";
            }
            function oh(t4) {
              return t4 === "in" || t4 === "out";
            }
            var lh = (t4) => class extends t4 {
              getScopeHandler() {
                return rh;
              }
              tsIsIdentifier() {
                return z(this.state.type);
              }
              tsTokenCanFollowModifier() {
                return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
              }
              tsNextTokenCanFollowModifier() {
                return this.next(), this.tsTokenCanFollowModifier();
              }
              tsParseModifier(e, s) {
                if (!z(this.state.type) && this.state.type !== 58)
                  return;
                let i = this.state.value;
                if (e.indexOf(i) !== -1) {
                  if (s && this.tsIsStartOfStaticBlocks())
                    return;
                  if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                    return i;
                }
              }
              tsParseModifiers(e) {
                let { modified: s, allowedModifiers: i, disallowedModifiers: a, stopOnStartOfClassStaticBlock: n, errorTemplate: o = w.InvalidModifierOnTypeMember } = e, c = (m, x, A, b) => {
                  x === A && s[b] && this.raise(w.InvalidModifiersOrder, { at: m, orderedModifiers: [A, b] });
                }, p = (m, x, A, b) => {
                  (s[A] && x === b || s[b] && x === A) && this.raise(w.IncompatibleModifiers, { at: m, modifiers: [A, b] });
                };
                for (; ; ) {
                  let { startLoc: m } = this.state, x = this.tsParseModifier(i.concat(a != null ? a : []), n);
                  if (!x)
                    break;
                  Xr(x) ? s.accessibility ? this.raise(w.DuplicateAccessibilityModifier, { at: m, modifier: x }) : (c(m, x, x, "override"), c(m, x, x, "static"), c(m, x, x, "readonly"), s.accessibility = x) : oh(x) ? (s[x] && this.raise(w.DuplicateModifier, { at: m, modifier: x }), s[x] = true, c(m, x, "in", "out")) : (Object.hasOwnProperty.call(s, x) ? this.raise(w.DuplicateModifier, { at: m, modifier: x }) : (c(m, x, "static", "readonly"), c(m, x, "static", "override"), c(m, x, "override", "readonly"), c(m, x, "abstract", "override"), p(m, x, "declare", "override"), p(m, x, "static", "abstract")), s[x] = true), a != null && a.includes(x) && this.raise(o, { at: m, modifier: x });
                }
              }
              tsIsListTerminator(e) {
                switch (e) {
                  case "EnumMembers":
                  case "TypeMembers":
                    return this.match(8);
                  case "HeritageClauseElement":
                    return this.match(5);
                  case "TupleElementTypes":
                    return this.match(3);
                  case "TypeParametersOrArguments":
                    return this.match(48);
                }
                throw new Error("Unreachable");
              }
              tsParseList(e, s) {
                let i = [];
                for (; !this.tsIsListTerminator(e); )
                  i.push(s());
                return i;
              }
              tsParseDelimitedList(e, s, i) {
                return ah(this.tsParseDelimitedListWorker(e, s, true, i));
              }
              tsParseDelimitedListWorker(e, s, i, a) {
                let n = [], o = -1;
                for (; !this.tsIsListTerminator(e); ) {
                  o = -1;
                  let c = s();
                  if (c == null)
                    return;
                  if (n.push(c), this.eat(12)) {
                    o = this.state.lastTokStart;
                    continue;
                  }
                  if (this.tsIsListTerminator(e))
                    break;
                  i && this.expect(12);
                  return;
                }
                return a && (a.value = o), n;
              }
              tsParseBracketedList(e, s, i, a, n) {
                a || (i ? this.expect(0) : this.expect(47));
                let o = this.tsParseDelimitedList(e, s, n);
                return i ? this.expect(3) : this.expect(48), o;
              }
              tsParseImportType() {
                let e = this.startNode();
                return this.expect(83), this.expect(10), this.match(131) || this.raise(w.UnsupportedImportTypeArgument, { at: this.state.startLoc }), e.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
              }
              tsParseEntityName() {
                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s = this.parseIdentifier(e);
                for (; this.eat(16); ) {
                  let i = this.startNodeAtNode(s);
                  i.left = s, i.right = this.parseIdentifier(e), s = this.finishNode(i, "TSQualifiedName");
                }
                return s;
              }
              tsParseTypeReference() {
                let e = this.startNode();
                return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
              }
              tsParseThisTypePredicate(e) {
                this.next();
                let s = this.startNodeAtNode(e);
                return s.parameterName = e, s.typeAnnotation = this.tsParseTypeAnnotation(false), s.asserts = false, this.finishNode(s, "TSTypePredicate");
              }
              tsParseThisTypeNode() {
                let e = this.startNode();
                return this.next(), this.finishNode(e, "TSThisType");
              }
              tsParseTypeQuery() {
                let e = this.startNode();
                return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
              }
              tsParseInOutModifiers(e) {
                this.tsParseModifiers({ modified: e, allowedModifiers: ["in", "out"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: w.InvalidModifierOnTypeParameter });
              }
              tsParseNoneModifiers(e) {
                this.tsParseModifiers({ modified: e, allowedModifiers: [], disallowedModifiers: ["in", "out"], errorTemplate: w.InvalidModifierOnTypeParameterPositions });
              }
              tsParseTypeParameter() {
                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.tsParseNoneModifiers.bind(this), s = this.startNode();
                return e(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(29), this.finishNode(s, "TSTypeParameter");
              }
              tsTryParseTypeParameters(e) {
                if (this.match(47))
                  return this.tsParseTypeParameters(e);
              }
              tsParseTypeParameters(e) {
                let s = this.startNode();
                this.match(47) || this.match(140) ? this.next() : this.unexpected();
                let i = { value: -1 };
                return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, i), s.params.length === 0 && this.raise(w.EmptyTypeParameters, { at: s }), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s, "TSTypeParameterDeclaration");
              }
              tsFillSignature(e, s) {
                let i = e === 19, a = "parameters", n = "typeAnnotation";
                s.typeParameters = this.tsTryParseTypeParameters(), this.expect(10), s[a] = this.tsParseBindingListForSignature(), i ? s[n] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (s[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
              }
              tsParseBindingListForSignature() {
                return super.parseBindingList(11, 41).map((e) => (e.type !== "Identifier" && e.type !== "RestElement" && e.type !== "ObjectPattern" && e.type !== "ArrayPattern" && this.raise(w.UnsupportedSignatureParameterKind, { at: e, type: e.type }), e));
              }
              tsParseTypeMemberSemicolon() {
                !this.eat(12) && !this.isLineTerminator() && this.expect(13);
              }
              tsParseSignatureMember(e, s) {
                return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, e);
              }
              tsIsUnambiguouslyIndexSignature() {
                return this.next(), z(this.state.type) ? (this.next(), this.match(14)) : false;
              }
              tsTryParseIndexSignature(e) {
                if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
                  return;
                this.expect(0);
                let s = this.parseIdentifier();
                s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), e.parameters = [s];
                let i = this.tsTryParseTypeAnnotation();
                return i && (e.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
              }
              tsParsePropertyOrMethodSignature(e, s) {
                this.eat(17) && (e.optional = true);
                let i = e;
                if (this.match(10) || this.match(47)) {
                  s && this.raise(w.ReadonlyForMethodSignature, { at: e });
                  let a = i;
                  a.kind && this.match(47) && this.raise(w.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, a), this.tsParseTypeMemberSemicolon();
                  let n = "parameters", o = "typeAnnotation";
                  if (a.kind === "get")
                    a[n].length > 0 && (this.raise(u.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(a[n][0]) && this.raise(w.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
                  else if (a.kind === "set") {
                    if (a[n].length !== 1)
                      this.raise(u.BadSetterArity, { at: this.state.curPosition() });
                    else {
                      let c = a[n][0];
                      this.isThisParam(c) && this.raise(w.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), c.type === "Identifier" && c.optional && this.raise(w.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), c.type === "RestElement" && this.raise(w.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
                    }
                    a[o] && this.raise(w.SetAccesorCannotHaveReturnType, { at: a[o] });
                  } else
                    a.kind = "method";
                  return this.finishNode(a, "TSMethodSignature");
                } else {
                  let a = i;
                  s && (a.readonly = true);
                  let n = this.tsTryParseTypeAnnotation();
                  return n && (a.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
                }
              }
              tsParseTypeMember() {
                let e = this.startNode();
                if (this.match(10) || this.match(47))
                  return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
                if (this.match(77)) {
                  let i = this.startNode();
                  return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(e, false));
                }
                this.tsParseModifiers({ modified: e, allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] });
                let s = this.tsTryParseIndexSignature(e);
                return s || (super.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
              }
              tsParseTypeLiteral() {
                let e = this.startNode();
                return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
              }
              tsParseObjectTypeMembers() {
                this.expect(5);
                let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                return this.expect(8), e;
              }
              tsIsStartOfMappedType() {
                return this.next(), this.eat(53) ? this.isContextual(120) : (this.isContextual(120) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
              }
              tsParseMappedTypeParameter() {
                let e = this.startNode();
                return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
              }
              tsParseMappedType() {
                let e = this.startNode();
                return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(120)) : this.eatContextual(120) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
              }
              tsParseTupleType() {
                let e = this.startNode();
                e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
                let s = false, i = null;
                return e.elementTypes.forEach((a) => {
                  var n;
                  let { type: o } = a;
                  s && o !== "TSRestType" && o !== "TSOptionalType" && !(o === "TSNamedTupleMember" && a.optional) && this.raise(w.OptionalTypeBeforeRequired, { at: a }), s || (s = o === "TSNamedTupleMember" && a.optional || o === "TSOptionalType");
                  let c = o;
                  o === "TSRestType" && (a = a.typeAnnotation, c = a.type);
                  let p = c === "TSNamedTupleMember";
                  (n = i) != null || (i = p), i !== p && this.raise(w.MixedLabeledAndUnlabeledElements, { at: a });
                }), this.finishNode(e, "TSTupleType");
              }
              tsParseTupleElementType() {
                let { startLoc: e } = this.state, s = this.eat(21), i = this.tsParseType(), a = this.eat(17);
                if (this.eat(14)) {
                  let o = this.startNodeAtNode(i);
                  o.optional = a, i.type === "TSTypeReference" && !i.typeParameters && i.typeName.type === "Identifier" ? o.label = i.typeName : (this.raise(w.InvalidTupleMemberLabel, { at: i }), o.label = i), o.elementType = this.tsParseType(), i = this.finishNode(o, "TSNamedTupleMember");
                } else if (a) {
                  let o = this.startNodeAtNode(i);
                  o.typeAnnotation = i, i = this.finishNode(o, "TSOptionalType");
                }
                if (s) {
                  let o = this.startNodeAt(e);
                  o.typeAnnotation = i, i = this.finishNode(o, "TSRestType");
                }
                return i;
              }
              tsParseParenthesizedType() {
                let e = this.startNode();
                return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
              }
              tsParseFunctionOrConstructorType(e, s) {
                let i = this.startNode();
                return e === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)), this.finishNode(i, e);
              }
              tsParseLiteralTypeNode() {
                let e = this.startNode();
                return e.literal = (() => {
                  switch (this.state.type) {
                    case 132:
                    case 133:
                    case 131:
                    case 85:
                    case 86:
                      return super.parseExprAtom();
                    default:
                      throw this.unexpected();
                  }
                })(), this.finishNode(e, "TSLiteralType");
              }
              tsParseTemplateLiteralType() {
                let e = this.startNode();
                return e.literal = super.parseTemplate(false), this.finishNode(e, "TSLiteralType");
              }
              parseTemplateSubstitution() {
                return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
              }
              tsParseThisTypeOrThisTypePredicate() {
                let e = this.tsParseThisTypeNode();
                return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
              }
              tsParseNonArrayType() {
                switch (this.state.type) {
                  case 131:
                  case 132:
                  case 133:
                  case 85:
                  case 86:
                    return this.tsParseLiteralTypeNode();
                  case 53:
                    if (this.state.value === "-") {
                      let e = this.startNode(), s = this.lookahead();
                      if (s.type !== 132 && s.type !== 133)
                        throw this.unexpected();
                      return e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
                    }
                    break;
                  case 78:
                    return this.tsParseThisTypeOrThisTypePredicate();
                  case 87:
                    return this.tsParseTypeQuery();
                  case 83:
                    return this.tsParseImportType();
                  case 5:
                    return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                  case 0:
                    return this.tsParseTupleType();
                  case 10:
                    return this.tsParseParenthesizedType();
                  case 25:
                  case 24:
                    return this.tsParseTemplateLiteralType();
                  default: {
                    let { type: e } = this.state;
                    if (z(e) || e === 88 || e === 84) {
                      let s = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : nh(this.state.value);
                      if (s !== void 0 && this.lookaheadCharCode() !== 46) {
                        let i = this.startNode();
                        return this.next(), this.finishNode(i, s);
                      }
                      return this.tsParseTypeReference();
                    }
                  }
                }
                throw this.unexpected();
              }
              tsParseArrayTypeOrHigher() {
                let e = this.tsParseNonArrayType();
                for (; !this.hasPrecedingLineBreak() && this.eat(0); )
                  if (this.match(3)) {
                    let s = this.startNodeAtNode(e);
                    s.elementType = e, this.expect(3), e = this.finishNode(s, "TSArrayType");
                  } else {
                    let s = this.startNodeAtNode(e);
                    s.objectType = e, s.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(s, "TSIndexedAccessType");
                  }
                return e;
              }
              tsParseTypeOperator() {
                let e = this.startNode(), s = this.state.value;
                return this.next(), e.operator = s, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
              }
              tsCheckTypeAnnotationForReadOnly(e) {
                switch (e.typeAnnotation.type) {
                  case "TSTupleType":
                  case "TSArrayType":
                    return;
                  default:
                    this.raise(w.UnexpectedReadonly, { at: e });
                }
              }
              tsParseInferType() {
                let e = this.startNode();
                this.expectContextual(113);
                let s = this.startNode();
                return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(s, "TSTypeParameter"), this.finishNode(e, "TSInferType");
              }
              tsParseConstraintForInferType() {
                if (this.eat(81)) {
                  let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
                  if (this.state.inDisallowConditionalTypesContext || !this.match(17))
                    return e;
                }
              }
              tsParseTypeOperatorOrHigher() {
                return Zo(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
              }
              tsParseUnionOrIntersectionType(e, s, i) {
                let a = this.startNode(), n = this.eat(i), o = [];
                do
                  o.push(s());
                while (this.eat(i));
                return o.length === 1 && !n ? o[0] : (a.types = o, this.finishNode(a, e));
              }
              tsParseIntersectionTypeOrHigher() {
                return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
              }
              tsParseUnionTypeOrHigher() {
                return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
              }
              tsIsStartOfFunctionType() {
                return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
              }
              tsSkipParameterStart() {
                if (z(this.state.type) || this.match(78))
                  return this.next(), true;
                if (this.match(5)) {
                  let { errors: e } = this.state, s = e.length;
                  try {
                    return this.parseObjectLike(8, true), e.length === s;
                  } catch {
                    return false;
                  }
                }
                if (this.match(0)) {
                  this.next();
                  let { errors: e } = this.state, s = e.length;
                  try {
                    return super.parseBindingList(3, 93, true), e.length === s;
                  } catch {
                    return false;
                  }
                }
                return false;
              }
              tsIsUnambiguouslyStartOfFunctionType() {
                return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
              }
              tsParseTypeOrTypePredicateAnnotation(e) {
                return this.tsInType(() => {
                  let s = this.startNode();
                  this.expect(e);
                  let i = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                  if (a && this.match(78)) {
                    let c = this.tsParseThisTypeOrThisTypePredicate();
                    return c.type === "TSThisType" ? (i.parameterName = c, i.asserts = true, i.typeAnnotation = null, c = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(c, i), c.asserts = true), s.typeAnnotation = c, this.finishNode(s, "TSTypeAnnotation");
                  }
                  let n = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                  if (!n)
                    return a ? (i.parameterName = this.parseIdentifier(), i.asserts = a, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s);
                  let o = this.tsParseTypeAnnotation(false);
                  return i.parameterName = n, i.typeAnnotation = o, i.asserts = a, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation");
                });
              }
              tsTryParseTypeOrTypePredicateAnnotation() {
                return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
              }
              tsTryParseTypeAnnotation() {
                return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
              }
              tsTryParseType() {
                return this.tsEatThenParseType(14);
              }
              tsParseTypePredicatePrefix() {
                let e = this.parseIdentifier();
                if (this.isContextual(114) && !this.hasPrecedingLineBreak())
                  return this.next(), e;
              }
              tsParseTypePredicateAsserts() {
                if (this.state.type !== 107)
                  return false;
                let e = this.state.containsEsc;
                return this.next(), !z(this.state.type) && !this.match(78) ? false : (e && this.raise(u.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), true);
              }
              tsParseTypeAnnotation() {
                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
                return this.tsInType(() => {
                  e && this.expect(14), s.typeAnnotation = this.tsParseType();
                }), this.finishNode(s, "TSTypeAnnotation");
              }
              tsParseType() {
                Jr(this.state.inType);
                let e = this.tsParseNonConditionalType();
                if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
                  return e;
                let s = this.startNodeAtNode(e);
                return s.checkType = e, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s, "TSConditionalType");
              }
              isAbstractConstructorSignature() {
                return this.isContextual(122) && this.lookahead().type === 77;
              }
              tsParseNonConditionalType() {
                return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
              }
              tsParseTypeAssertion() {
                this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(w.ReservedTypeAssertion, { at: this.state.startLoc });
                let e = this.startNode();
                return e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
              }
              tsParseHeritageClause(e) {
                let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
                  let a = this.startNode();
                  return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(a, "TSExpressionWithTypeArguments");
                });
                return i.length || this.raise(w.EmptyHeritageClauseType, { at: s, token: e }), i;
              }
              tsParseInterfaceDeclaration(e) {
                let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (this.hasFollowingLineBreak())
                  return null;
                this.expectContextual(127), s.declare && (e.declare = true), z(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, pl)) : (e.id = null, this.raise(w.MissingInterfaceName, { at: this.state.startLoc })), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
                let i = this.startNode();
                return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
              }
              tsParseTypeAliasDeclaration(e) {
                return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, fl), e.typeAnnotation = this.tsInType(() => {
                  if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.expect(29), this.isContextual(112) && this.lookahead().type !== 16) {
                    let s = this.startNode();
                    return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
                  }
                  return this.tsParseType();
                }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
              }
              tsInNoContext(e) {
                let s = this.state.context;
                this.state.context = [s[0]];
                try {
                  return e();
                } finally {
                  this.state.context = s;
                }
              }
              tsInType(e) {
                let s = this.state.inType;
                this.state.inType = true;
                try {
                  return e();
                } finally {
                  this.state.inType = s;
                }
              }
              tsInDisallowConditionalTypesContext(e) {
                let s = this.state.inDisallowConditionalTypesContext;
                this.state.inDisallowConditionalTypesContext = true;
                try {
                  return e();
                } finally {
                  this.state.inDisallowConditionalTypesContext = s;
                }
              }
              tsInAllowConditionalTypesContext(e) {
                let s = this.state.inDisallowConditionalTypesContext;
                this.state.inDisallowConditionalTypesContext = false;
                try {
                  return e();
                } finally {
                  this.state.inDisallowConditionalTypesContext = s;
                }
              }
              tsEatThenParseType(e) {
                return this.match(e) ? this.tsNextThenParseType() : void 0;
              }
              tsExpectThenParseType(e) {
                return this.tsDoThenParseType(() => this.expect(e));
              }
              tsNextThenParseType() {
                return this.tsDoThenParseType(() => this.next());
              }
              tsDoThenParseType(e) {
                return this.tsInType(() => (e(), this.tsParseType()));
              }
              tsParseEnumMember() {
                let e = this.startNode();
                return e.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
              }
              tsParseEnumDeclaration(e) {
                let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                return s.const && (e.const = true), s.declare && (e.declare = true), this.expectContextual(124), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? ml : Fr), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
              }
              tsParseModuleBlock() {
                let e = this.startNode();
                return this.scope.enter(je), this.expect(5), super.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
              }
              tsParseModuleOrNamespaceDeclaration(e) {
                let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (e.id = this.parseIdentifier(), s || this.checkIdentifier(e.id, yl), this.eat(16)) {
                  let i = this.startNode();
                  this.tsParseModuleOrNamespaceDeclaration(i, true), e.body = i;
                } else
                  this.scope.enter(Ue), this.prodParam.enter($e), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
                return this.finishNode(e, "TSModuleDeclaration");
              }
              tsParseAmbientExternalModuleDeclaration(e) {
                return this.isContextual(110) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(131) ? e.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(Ue), this.prodParam.enter($e), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
              }
              tsParseImportEqualsDeclaration(e, s) {
                e.isExport = s || false, e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Ye), this.expect(29);
                let i = this.tsParseModuleReference();
                return e.importKind === "type" && i.type !== "TSExternalModuleReference" && this.raise(w.ImportAliasHasImportType, { at: i }), e.moduleReference = i, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
              }
              tsIsExternalModuleReference() {
                return this.isContextual(117) && this.lookaheadCharCode() === 40;
              }
              tsParseModuleReference() {
                return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
              }
              tsParseExternalModuleReference() {
                let e = this.startNode();
                if (this.expectContextual(117), this.expect(10), !this.match(131))
                  throw this.unexpected();
                return e.expression = super.parseExprAtom(), this.expect(11), this.finishNode(e, "TSExternalModuleReference");
              }
              tsLookAhead(e) {
                let s = this.state.clone(), i = e();
                return this.state = s, i;
              }
              tsTryParseAndCatch(e) {
                let s = this.tryParse((i) => e() || i());
                if (!(s.aborted || !s.node))
                  return s.error && (this.state = s.failState), s.node;
              }
              tsTryParse(e) {
                let s = this.state.clone(), i = e();
                if (i !== void 0 && i !== false)
                  return i;
                this.state = s;
              }
              tsTryParseDeclare(e) {
                if (this.isLineTerminator())
                  return;
                let s = this.state.type, i;
                return this.isContextual(99) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
                  if (s === 68)
                    return e.declare = true, super.parseFunctionStatement(e, false, false);
                  if (s === 80)
                    return e.declare = true, this.parseClass(e, true, false);
                  if (s === 124)
                    return this.tsParseEnumDeclaration(e, { declare: true });
                  if (s === 110)
                    return this.tsParseAmbientExternalModuleDeclaration(e);
                  if (s === 75 || s === 74)
                    return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, i || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, { const: true, declare: true }));
                  if (s === 127) {
                    let a = this.tsParseInterfaceDeclaration(e, { declare: true });
                    if (a)
                      return a;
                  }
                  if (z(s))
                    return this.tsParseDeclaration(e, this.state.value, true, null);
                });
              }
              tsTryParseExportDeclaration() {
                return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
              }
              tsParseExpressionStatement(e, s, i) {
                switch (s.name) {
                  case "declare": {
                    let a = this.tsTryParseDeclare(e);
                    if (a)
                      return a.declare = true, a;
                    break;
                  }
                  case "global":
                    if (this.match(5)) {
                      this.scope.enter(Ue), this.prodParam.enter($e);
                      let a = e;
                      return a.global = true, a.id = s, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a, "TSModuleDeclaration");
                    }
                    break;
                  default:
                    return this.tsParseDeclaration(e, s.name, false, i);
                }
              }
              tsParseDeclaration(e, s, i, a) {
                switch (s) {
                  case "abstract":
                    if (this.tsCheckLineTerminator(i) && (this.match(80) || z(this.state.type)))
                      return this.tsParseAbstractDeclaration(e, a);
                    break;
                  case "module":
                    if (this.tsCheckLineTerminator(i)) {
                      if (this.match(131))
                        return this.tsParseAmbientExternalModuleDeclaration(e);
                      if (z(this.state.type))
                        return this.tsParseModuleOrNamespaceDeclaration(e);
                    }
                    break;
                  case "namespace":
                    if (this.tsCheckLineTerminator(i) && z(this.state.type))
                      return this.tsParseModuleOrNamespaceDeclaration(e);
                    break;
                  case "type":
                    if (this.tsCheckLineTerminator(i) && z(this.state.type))
                      return this.tsParseTypeAliasDeclaration(e);
                    break;
                }
              }
              tsCheckLineTerminator(e) {
                return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
              }
              tsTryParseGenericAsyncArrowFunction(e) {
                if (!this.match(47))
                  return;
                let s = this.state.maybeInArrowParameters;
                this.state.maybeInArrowParameters = true;
                let i = this.tsTryParseAndCatch(() => {
                  let a = this.startNodeAt(e);
                  return a.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), a;
                });
                if (this.state.maybeInArrowParameters = s, !!i)
                  return super.parseArrowExpression(i, null, true);
              }
              tsParseTypeArgumentsInExpression() {
                if (this.reScan_lt() === 47)
                  return this.tsParseTypeArguments();
              }
              tsParseTypeArguments() {
                let e = this.startNode();
                return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 && this.raise(w.EmptyTypeArguments, { at: e }), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
              }
              tsIsDeclarationStart() {
                return el(this.state.type);
              }
              isExportDefaultSpecifier() {
                return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
              }
              parseAssignableListItem(e, s) {
                let i = this.state.startLoc, a, n = false, o = false;
                if (e !== void 0) {
                  let m = {};
                  this.tsParseModifiers({ modified: m, allowedModifiers: ["public", "private", "protected", "override", "readonly"] }), a = m.accessibility, o = m.override, n = m.readonly, e === false && (a || n || o) && this.raise(w.UnexpectedParameterModifier, { at: i });
                }
                let c = this.parseMaybeDefault();
                this.parseAssignableListItemTypes(c);
                let p = this.parseMaybeDefault(c.loc.start, c);
                if (a || n || o) {
                  let m = this.startNodeAt(i);
                  return s.length && (m.decorators = s), a && (m.accessibility = a), n && (m.readonly = n), o && (m.override = o), p.type !== "Identifier" && p.type !== "AssignmentPattern" && this.raise(w.UnsupportedParameterPropertyKind, { at: m }), m.parameter = p, this.finishNode(m, "TSParameterProperty");
                }
                return s.length && (c.decorators = s), p;
              }
              isSimpleParameter(e) {
                return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
              }
              parseFunctionBodyAndFinish(e, s) {
                let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
                let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
                return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, a) : a === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(w.DeclareFunctionHasImplementation, { at: e }), e.declare) ? super.parseFunctionBodyAndFinish(e, a, i) : super.parseFunctionBodyAndFinish(e, s, i);
              }
              registerFunctionStatementId(e) {
                !e.body && e.id ? this.checkIdentifier(e.id, Lr) : super.registerFunctionStatementId(e);
              }
              tsCheckForInvalidTypeCasts(e) {
                e.forEach((s) => {
                  (s == null ? void 0 : s.type) === "TSTypeCastExpression" && this.raise(w.UnexpectedTypeAnnotation, { at: s.typeAnnotation });
                });
              }
              toReferencedList(e, s) {
                return this.tsCheckForInvalidTypeCasts(e), e;
              }
              parseArrayLike(e, s, i, a) {
                let n = super.parseArrayLike(e, s, i, a);
                return n.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(n.elements), n;
              }
              parseSubscript(e, s, i, a) {
                if (!this.hasPrecedingLineBreak() && this.match(35)) {
                  this.state.canStartJSXElement = false, this.next();
                  let o = this.startNodeAt(s);
                  return o.expression = e, this.finishNode(o, "TSNonNullExpression");
                }
                let n = false;
                if (this.match(18) && this.lookaheadCharCode() === 60) {
                  if (i)
                    return a.stop = true, e;
                  a.optionalChainMember = n = true, this.next();
                }
                if (this.match(47) || this.match(51)) {
                  let o, c = this.tsTryParseAndCatch(() => {
                    if (!i && this.atPossibleAsyncArrow(e)) {
                      let A = this.tsTryParseGenericAsyncArrowFunction(s);
                      if (A)
                        return A;
                    }
                    let p = this.tsParseTypeArgumentsInExpression();
                    if (!p)
                      return;
                    if (n && !this.match(10)) {
                      o = this.state.curPosition();
                      return;
                    }
                    if (ct(this.state.type)) {
                      let A = super.parseTaggedTemplateExpression(e, s, a);
                      return A.typeParameters = p, A;
                    }
                    if (!i && this.eat(10)) {
                      let A = this.startNodeAt(s);
                      return A.callee = e, A.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(A.arguments), A.typeParameters = p, a.optionalChainMember && (A.optional = n), this.finishCallExpression(A, a.optionalChainMember);
                    }
                    let m = this.state.type;
                    if (m === 48 || m === 52 || m !== 10 && Xt(m) && !this.hasPrecedingLineBreak())
                      return;
                    let x = this.startNodeAt(s);
                    return x.expression = e, x.typeParameters = p, this.finishNode(x, "TSInstantiationExpression");
                  });
                  if (o && this.unexpected(o, 10), c)
                    return c.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(w.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }), c;
                }
                return super.parseSubscript(e, s, i, a);
              }
              parseNewCallee(e) {
                var s;
                super.parseNewCallee(e);
                let { callee: i } = e;
                i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (e.typeParameters = i.typeParameters, e.callee = i.expression);
              }
              parseExprOp(e, s, i) {
                let a;
                if (ut(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(118)))) {
                  let n = this.startNodeAt(s);
                  return n.expression = e, n.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(u.UnexpectedKeyword, { at: this.state.startLoc, keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n, s, i);
                }
                return super.parseExprOp(e, s, i);
              }
              checkReservedWord(e, s, i, a) {
                this.state.isAmbientContext || super.checkReservedWord(e, s, i, a);
              }
              checkImportReflection(e) {
                super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(w.ImportReflectionHasImportType, { at: e.specifiers[0].loc.start });
              }
              checkDuplicateExports() {
              }
              parseImport(e) {
                if (e.importKind = "value", z(this.state.type) || this.match(55) || this.match(5)) {
                  let i = this.lookahead();
                  if (this.isContextual(128) && i.type !== 12 && i.type !== 97 && i.type !== 29 && (e.importKind = "type", this.next(), i = this.lookahead()), z(this.state.type) && i.type === 29)
                    return this.tsParseImportEqualsDeclaration(e);
                }
                let s = super.parseImport(e);
                return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(w.TypeImportCannotSpecifyDefaultAndNamed, { at: s }), s;
              }
              parseExport(e, s) {
                if (this.match(83))
                  return this.next(), this.isContextual(128) && this.lookaheadCharCode() !== 61 ? (e.importKind = "type", this.next()) : e.importKind = "value", this.tsParseImportEqualsDeclaration(e, true);
                if (this.eat(29)) {
                  let i = e;
                  return i.expression = super.parseExpression(), this.semicolon(), this.finishNode(i, "TSExportAssignment");
                } else if (this.eatContextual(93)) {
                  let i = e;
                  return this.expectContextual(126), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
                } else
                  return this.isContextual(128) && this.lookahead().type === 5 ? (this.next(), e.exportKind = "type") : e.exportKind = "value", super.parseExport(e, s);
              }
              isAbstractClass() {
                return this.isContextual(122) && this.lookahead().type === 80;
              }
              parseExportDefaultExpression() {
                if (this.isAbstractClass()) {
                  let e = this.startNode();
                  return this.next(), e.abstract = true, this.parseClass(e, true, true);
                }
                if (this.match(127)) {
                  let e = this.tsParseInterfaceDeclaration(this.startNode());
                  if (e)
                    return e;
                }
                return super.parseExportDefaultExpression();
              }
              parseVarStatement(e, s) {
                let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, { isAmbientContext: a } = this.state, n = super.parseVarStatement(e, s, i || a);
                if (!a)
                  return n;
                for (let { id: o, init: c } of n.declarations)
                  c && (s !== "const" || o.typeAnnotation ? this.raise(w.InitializerNotAllowedInAmbientContext, { at: c }) : c.type !== "StringLiteral" && c.type !== "BooleanLiteral" && c.type !== "NumericLiteral" && c.type !== "BigIntLiteral" && (c.type !== "TemplateLiteral" || c.expressions.length > 0) && !hh(c) && this.raise(w.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: c }));
                return n;
              }
              parseStatementContent(e, s) {
                if (this.match(75) && this.isLookaheadContextual("enum")) {
                  let i = this.startNode();
                  return this.expect(75), this.tsParseEnumDeclaration(i, { const: true });
                }
                if (this.isContextual(124))
                  return this.tsParseEnumDeclaration(this.startNode());
                if (this.isContextual(127)) {
                  let i = this.tsParseInterfaceDeclaration(this.startNode());
                  if (i)
                    return i;
                }
                return super.parseStatementContent(e, s);
              }
              parseAccessModifier() {
                return this.tsParseModifier(["public", "protected", "private"]);
              }
              tsHasSomeModifiers(e, s) {
                return s.some((i) => Xr(i) ? e.accessibility === i : !!e[i]);
              }
              tsIsStartOfStaticBlocks() {
                return this.isContextual(104) && this.lookaheadCharCode() === 123;
              }
              parseClassMember(e, s, i) {
                let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
                this.tsParseModifiers({ modified: s, allowedModifiers: a, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: w.InvalidModifierOnTypeParameterPositions });
                let n = () => {
                  this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(w.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), super.parseClassStaticBlock(e, s)) : this.parseClassMemberWithIsStatic(e, s, i, !!s.static);
                };
                s.declare ? this.tsInAmbientContext(n) : n();
              }
              parseClassMemberWithIsStatic(e, s, i, a) {
                let n = this.tsTryParseIndexSignature(s);
                if (n) {
                  e.body.push(n), s.abstract && this.raise(w.IndexSignatureHasAbstract, { at: s }), s.accessibility && this.raise(w.IndexSignatureHasAccessibility, { at: s, modifier: s.accessibility }), s.declare && this.raise(w.IndexSignatureHasDeclare, { at: s }), s.override && this.raise(w.IndexSignatureHasOverride, { at: s });
                  return;
                }
                !this.state.inAbstractClass && s.abstract && this.raise(w.NonAbstractClassHasAbstractMethod, { at: s }), s.override && (i.hadSuperClass || this.raise(w.OverrideNotInSubClass, { at: s })), super.parseClassMemberWithIsStatic(e, s, i, a);
              }
              parsePostMemberNameModifiers(e) {
                this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(w.ClassMethodHasReadonly, { at: e }), e.declare && this.match(10) && this.raise(w.ClassMethodHasDeclare, { at: e });
              }
              parseExpressionStatement(e, s, i) {
                return (s.type === "Identifier" ? this.tsParseExpressionStatement(e, s, i) : void 0) || super.parseExpressionStatement(e, s, i);
              }
              shouldParseExportDeclaration() {
                return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
              }
              parseConditional(e, s, i) {
                if (!this.state.maybeInArrowParameters || !this.match(17))
                  return super.parseConditional(e, s, i);
                let a = this.tryParse(() => super.parseConditional(e, s));
                return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), e);
              }
              parseParenItem(e, s) {
                if (e = super.parseParenItem(e, s), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
                  let i = this.startNodeAt(s);
                  return i.expression = e, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
                }
                return e;
              }
              parseExportDeclaration(e) {
                if (!this.state.isAmbientContext && this.isContextual(123))
                  return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
                let s = this.state.startLoc, i = this.eatContextual(123);
                if (i && (this.isContextual(123) || !this.shouldParseExportDeclaration()))
                  throw this.raise(w.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
                let n = z(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
                return n ? ((n.type === "TSInterfaceDeclaration" || n.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && (this.resetStartLocation(n, s), n.declare = true), n) : null;
              }
              parseClassId(e, s, i, a) {
                if ((!s || i) && this.isContextual(111))
                  return;
                super.parseClassId(e, s, i, e.declare ? Lr : kr);
                let n = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
                n && (e.typeParameters = n);
              }
              parseClassPropertyAnnotation(e) {
                e.optional || (this.eat(35) ? e.definite = true : this.eat(17) && (e.optional = true));
                let s = this.tsTryParseTypeAnnotation();
                s && (e.typeAnnotation = s);
              }
              parseClassProperty(e) {
                if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(w.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), e.abstract && this.match(29)) {
                  let { key: s } = e;
                  this.raise(w.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: s.type === "Identifier" && !e.computed ? s.name : `[${this.input.slice(s.start, s.end)}]` });
                }
                return super.parseClassProperty(e);
              }
              parseClassPrivateProperty(e) {
                return e.abstract && this.raise(w.PrivateElementHasAbstract, { at: e }), e.accessibility && this.raise(w.PrivateElementHasAccessibility, { at: e, modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
              }
              parseClassAccessorProperty(e) {
                return this.parseClassPropertyAnnotation(e), e.optional && this.raise(w.AccessorCannotBeOptional, { at: e }), super.parseClassAccessorProperty(e);
              }
              pushClassMethod(e, s, i, a, n, o) {
                let c = this.tsTryParseTypeParameters();
                c && n && this.raise(w.ConstructorHasTypeParameters, { at: c });
                let { declare: p = false, kind: m } = s;
                p && (m === "get" || m === "set") && this.raise(w.DeclareAccessor, { at: s, kind: m }), c && (s.typeParameters = c), super.pushClassMethod(e, s, i, a, n, o);
              }
              pushClassPrivateMethod(e, s, i, a) {
                let n = this.tsTryParseTypeParameters();
                n && (s.typeParameters = n), super.pushClassPrivateMethod(e, s, i, a);
              }
              declareClassPrivateMethodInScope(e, s) {
                e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !e.value.body || super.declareClassPrivateMethodInScope(e, s));
              }
              parseClassSuper(e) {
                super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(111) && (e.implements = this.tsParseHeritageClause("implements"));
              }
              parseObjPropValue(e, s, i, a, n, o, c) {
                let p = this.tsTryParseTypeParameters();
                return p && (e.typeParameters = p), super.parseObjPropValue(e, s, i, a, n, o, c);
              }
              parseFunctionParams(e, s) {
                let i = this.tsTryParseTypeParameters();
                i && (e.typeParameters = i), super.parseFunctionParams(e, s);
              }
              parseVarId(e, s) {
                super.parseVarId(e, s), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
                let i = this.tsTryParseTypeAnnotation();
                i && (e.id.typeAnnotation = i, this.resetEndLocation(e.id));
              }
              parseAsyncArrowFromCallExpression(e, s) {
                return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, s);
              }
              parseMaybeAssign(e, s) {
                var i, a, n, o, c, p, m;
                let x, A, b;
                if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                  if (x = this.state.clone(), A = this.tryParse(() => super.parseMaybeAssign(e, s), x), !A.error)
                    return A.node;
                  let { context: Y } = this.state, Q = Y[Y.length - 1];
                  (Q === $.j_oTag || Q === $.j_expr) && Y.pop();
                }
                if (!((i = A) != null && i.error) && !this.match(47))
                  return super.parseMaybeAssign(e, s);
                (!x || x === this.state) && (x = this.state.clone());
                let O, R4 = this.tryParse((Y) => {
                  var Q, J;
                  O = this.tsParseTypeParameters();
                  let se = super.parseMaybeAssign(e, s);
                  return (se.type !== "ArrowFunctionExpression" || (Q = se.extra) != null && Q.parenthesized) && Y(), ((J = O) == null ? void 0 : J.params.length) !== 0 && this.resetStartLocationFromNode(se, O), se.typeParameters = O, se;
                }, x);
                if (!R4.error && !R4.aborted)
                  return O && this.reportReservedArrowTypeParam(O), R4.node;
                if (!A && (Jr(!this.hasPlugin("jsx")), b = this.tryParse(() => super.parseMaybeAssign(e, s), x), !b.error))
                  return b.node;
                if ((a = A) != null && a.node)
                  return this.state = A.failState, A.node;
                if (R4.node)
                  return this.state = R4.failState, O && this.reportReservedArrowTypeParam(O), R4.node;
                if ((n = b) != null && n.node)
                  return this.state = b.failState, b.node;
                throw (o = A) != null && o.thrown ? A.error : R4.thrown ? R4.error : (c = b) != null && c.thrown ? b.error : ((p = A) == null ? void 0 : p.error) || R4.error || ((m = b) == null ? void 0 : m.error);
              }
              reportReservedArrowTypeParam(e) {
                var s;
                e.params.length === 1 && !((s = e.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(w.ReservedArrowTypeParam, { at: e });
              }
              parseMaybeUnary(e, s) {
                return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, s);
              }
              parseArrow(e) {
                if (this.match(14)) {
                  let s = this.tryParse((i) => {
                    let a = this.tsParseTypeOrTypePredicateAnnotation(14);
                    return (this.canInsertSemicolon() || !this.match(19)) && i(), a;
                  });
                  if (s.aborted)
                    return;
                  s.thrown || (s.error && (this.state = s.failState), e.returnType = s.node);
                }
                return super.parseArrow(e);
              }
              parseAssignableListItemTypes(e) {
                this.eat(17) && (e.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType && this.raise(w.PatternIsOptional, { at: e }), e.optional = true);
                let s = this.tsTryParseTypeAnnotation();
                return s && (e.typeAnnotation = s), this.resetEndLocation(e), e;
              }
              isAssignable(e, s) {
                switch (e.type) {
                  case "TSTypeCastExpression":
                    return this.isAssignable(e.expression, s);
                  case "TSParameterProperty":
                    return true;
                  default:
                    return super.isAssignable(e, s);
                }
              }
              toAssignable(e) {
                let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                switch (e.type) {
                  case "ParenthesizedExpression":
                    this.toAssignableParenthesizedExpression(e, s);
                    break;
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "TSTypeAssertion":
                    s ? this.expressionScope.recordArrowParameterBindingError(w.UnexpectedTypeCastInParameter, { at: e }) : this.raise(w.UnexpectedTypeCastInParameter, { at: e }), this.toAssignable(e.expression, s);
                    break;
                  case "AssignmentExpression":
                    !s && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
                  default:
                    super.toAssignable(e, s);
                }
              }
              toAssignableParenthesizedExpression(e, s) {
                switch (e.expression.type) {
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "TSTypeAssertion":
                  case "ParenthesizedExpression":
                    this.toAssignable(e.expression, s);
                    break;
                  default:
                    super.toAssignable(e, s);
                }
              }
              checkToRestConversion(e, s) {
                switch (e.type) {
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSTypeAssertion":
                  case "TSNonNullExpression":
                    this.checkToRestConversion(e.expression, false);
                    break;
                  default:
                    super.checkToRestConversion(e, s);
                }
              }
              isValidLVal(e, s, i) {
                return ih({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (i !== be || !s) && ["expression", true], TSSatisfiesExpression: (i !== be || !s) && ["expression", true], TSTypeAssertion: (i !== be || !s) && ["expression", true] }, e) || super.isValidLVal(e, s, i);
              }
              parseBindingAtom() {
                switch (this.state.type) {
                  case 78:
                    return this.parseIdentifier(true);
                  default:
                    return super.parseBindingAtom();
                }
              }
              parseMaybeDecoratorArguments(e) {
                if (this.match(47) || this.match(51)) {
                  let s = this.tsParseTypeArgumentsInExpression();
                  if (this.match(10)) {
                    let i = super.parseMaybeDecoratorArguments(e);
                    return i.typeParameters = s, i;
                  }
                  this.unexpected(null, 10);
                }
                return super.parseMaybeDecoratorArguments(e);
              }
              checkCommaAfterRest(e) {
                return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
              }
              isClassMethod() {
                return this.match(47) || super.isClassMethod();
              }
              isClassProperty() {
                return this.match(35) || this.match(14) || super.isClassProperty();
              }
              parseMaybeDefault(e, s) {
                let i = super.parseMaybeDefault(e, s);
                return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(w.TypeAnnotationAfterAssign, { at: i.typeAnnotation }), i;
              }
              getTokenFromCode(e) {
                if (this.state.inType) {
                  if (e === 62)
                    return this.finishOp(48, 1);
                  if (e === 60)
                    return this.finishOp(47, 1);
                }
                return super.getTokenFromCode(e);
              }
              reScan_lt_gt() {
                let { type: e } = this.state;
                e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
              }
              reScan_lt() {
                let { type: e } = this.state;
                return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
              }
              toAssignableList(e, s, i) {
                for (let a = 0; a < e.length; a++) {
                  let n = e[a];
                  (n == null ? void 0 : n.type) === "TSTypeCastExpression" && (e[a] = this.typeCastToParameter(n));
                }
                super.toAssignableList(e, s, i);
              }
              typeCastToParameter(e) {
                return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
              }
              shouldParseArrow(e) {
                return this.match(14) ? e.every((s) => this.isAssignable(s, true)) : super.shouldParseArrow(e);
              }
              shouldParseAsyncArrow() {
                return this.match(14) || super.shouldParseAsyncArrow();
              }
              canHaveLeadingDecorator() {
                return super.canHaveLeadingDecorator() || this.isAbstractClass();
              }
              jsxParseOpeningElementAfterName(e) {
                if (this.match(47) || this.match(51)) {
                  let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
                  s && (e.typeParameters = s);
                }
                return super.jsxParseOpeningElementAfterName(e);
              }
              getGetterSetterExpectedParamCount(e) {
                let s = super.getGetterSetterExpectedParamCount(e), a = this.getObjectOrClassMethodParams(e)[0];
                return a && this.isThisParam(a) ? s + 1 : s;
              }
              parseCatchClauseParam() {
                let e = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
                return s && (e.typeAnnotation = s, this.resetEndLocation(e)), e;
              }
              tsInAmbientContext(e) {
                let s = this.state.isAmbientContext;
                this.state.isAmbientContext = true;
                try {
                  return e();
                } finally {
                  this.state.isAmbientContext = s;
                }
              }
              parseClass(e, s, i) {
                let a = this.state.inAbstractClass;
                this.state.inAbstractClass = !!e.abstract;
                try {
                  return super.parseClass(e, s, i);
                } finally {
                  this.state.inAbstractClass = a;
                }
              }
              tsParseAbstractDeclaration(e, s) {
                if (this.match(80))
                  return e.abstract = true, this.maybeTakeDecorators(s, this.parseClass(e, true, false));
                if (this.isContextual(127)) {
                  if (!this.hasFollowingLineBreak())
                    return e.abstract = true, this.raise(w.NonClassMethodPropertyHasAbstractModifer, { at: e }), this.tsParseInterfaceDeclaration(e);
                } else
                  this.unexpected(null, 80);
              }
              parseMethod(e, s, i, a, n, o, c) {
                let p = super.parseMethod(e, s, i, a, n, o, c);
                if (p.abstract && (this.hasPlugin("estree") ? !!p.value.body : !!p.body)) {
                  let { key: x } = p;
                  this.raise(w.AbstractMethodHasImplementation, { at: p, methodName: x.type === "Identifier" && !p.computed ? x.name : `[${this.input.slice(x.start, x.end)}]` });
                }
                return p;
              }
              tsParseTypeParameterName() {
                return this.parseIdentifier().name;
              }
              shouldParseAsAmbientContext() {
                return !!this.getPluginOption("typescript", "dts");
              }
              parse() {
                return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
              }
              getExpression() {
                return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
              }
              parseExportSpecifier(e, s, i, a) {
                return !s && a ? (this.parseTypeOnlyImportExportSpecifier(e, false, i), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, s, i, a));
              }
              parseImportSpecifier(e, s, i, a, n) {
                return !s && a ? (this.parseTypeOnlyImportExportSpecifier(e, true, i), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, s, i, a, i ? Or : Ye));
              }
              parseTypeOnlyImportExportSpecifier(e, s, i) {
                let a = s ? "imported" : "local", n = s ? "local" : "exported", o = e[a], c, p = false, m = true, x = o.loc.start;
                if (this.isContextual(93)) {
                  let b = this.parseIdentifier();
                  if (this.isContextual(93)) {
                    let O = this.parseIdentifier();
                    ye(this.state.type) ? (p = true, o = b, c = s ? this.parseIdentifier() : this.parseModuleExportName(), m = false) : (c = O, m = false);
                  } else
                    ye(this.state.type) ? (m = false, c = s ? this.parseIdentifier() : this.parseModuleExportName()) : (p = true, o = b);
                } else
                  ye(this.state.type) && (p = true, s ? (o = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, true, true)) : o = this.parseModuleExportName());
                p && i && this.raise(s ? w.TypeModifierIsUsedInTypeImports : w.TypeModifierIsUsedInTypeExports, { at: x }), e[a] = o, e[n] = c;
                let A = s ? "importKind" : "exportKind";
                e[A] = p ? "type" : "value", m && this.eatContextual(93) && (e[n] = s ? this.parseIdentifier() : this.parseModuleExportName()), e[n] || (e[n] = Te(e[a])), s && this.checkIdentifier(e[n], p ? Or : Ye);
              }
            };
            function hh(t4) {
              if (t4.type !== "MemberExpression")
                return false;
              let { computed: r, property: e } = t4;
              return r && e.type !== "StringLiteral" && (e.type !== "TemplateLiteral" || e.expressions.length > 0) ? false : Yr(t4.object);
            }
            function Yr(t4) {
              return t4.type === "Identifier" ? true : t4.type !== "MemberExpression" || t4.computed ? false : Yr(t4.object);
            }
            var Qr = _`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), uh = (t4) => class extends t4 {
              parsePlaceholder(e) {
                if (this.match(142)) {
                  let s = this.startNode();
                  return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(142), this.finishPlaceholder(s, e);
                }
              }
              finishPlaceholder(e, s) {
                let i = !!(e.expectedNode && e.type === "Placeholder");
                return e.expectedNode = s, i ? e : this.finishNode(e, "Placeholder");
              }
              getTokenFromCode(e) {
                return e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(142, 2) : super.getTokenFromCode(e);
              }
              parseExprAtom(e) {
                return this.parsePlaceholder("Expression") || super.parseExprAtom(e);
              }
              parseIdentifier(e) {
                return this.parsePlaceholder("Identifier") || super.parseIdentifier(e);
              }
              checkReservedWord(e, s, i, a) {
                e !== void 0 && super.checkReservedWord(e, s, i, a);
              }
              parseBindingAtom() {
                return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
              }
              isValidLVal(e, s, i) {
                return e === "Placeholder" || super.isValidLVal(e, s, i);
              }
              toAssignable(e, s) {
                e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(e, s);
              }
              chStartsBindingIdentifier(e, s) {
                return !!(super.chStartsBindingIdentifier(e, s) || this.lookahead().type === 142);
              }
              verifyBreakContinue(e, s) {
                e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(e, s);
              }
              parseExpressionStatement(e, s) {
                if (s.type !== "Placeholder" || s.extra && s.extra.parenthesized)
                  return super.parseExpressionStatement(e, s);
                if (this.match(14)) {
                  let i = e;
                  return i.label = this.finishPlaceholder(s, "Identifier"), this.next(), i.body = super.parseStatementOrFunctionDeclaration(false), this.finishNode(i, "LabeledStatement");
                }
                return this.semicolon(), e.name = s.name, this.finishPlaceholder(e, "Statement");
              }
              parseBlock(e, s, i) {
                return this.parsePlaceholder("BlockStatement") || super.parseBlock(e, s, i);
              }
              parseFunctionId(e) {
                return this.parsePlaceholder("Identifier") || super.parseFunctionId(e);
              }
              parseClass(e, s, i) {
                let a = s ? "ClassDeclaration" : "ClassExpression";
                this.next();
                let n = this.state.strict, o = this.parsePlaceholder("Identifier");
                if (o)
                  if (this.match(81) || this.match(142) || this.match(5))
                    e.id = o;
                  else {
                    if (i || !s)
                      return e.id = null, e.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(e, a);
                    throw this.raise(Qr.ClassNameIsRequired, { at: this.state.startLoc });
                  }
                else
                  this.parseClassId(e, s, i);
                return super.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e.superClass, n), this.finishNode(e, a);
              }
              parseExport(e, s) {
                let i = this.parsePlaceholder("Identifier");
                if (!i)
                  return super.parseExport(e, s);
                if (!this.isContextual(97) && !this.match(12))
                  return e.specifiers = [], e.source = null, e.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(e, "ExportNamedDeclaration");
                this.expectPlugin("exportDefaultFrom");
                let a = this.startNode();
                return a.exported = i, e.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(e, s);
              }
              isExportDefaultSpecifier() {
                if (this.match(65)) {
                  let e = this.nextTokenStart();
                  if (this.isUnparsedContextual(e, "from") && this.input.startsWith(Ee(142), this.nextTokenStartSince(e + 4)))
                    return true;
                }
                return super.isExportDefaultSpecifier();
              }
              maybeParseExportDefaultSpecifier(e) {
                return e.specifiers && e.specifiers.length > 0 ? true : super.maybeParseExportDefaultSpecifier(e);
              }
              checkExport(e) {
                let { specifiers: s } = e;
                s != null && s.length && (e.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = s;
              }
              parseImport(e) {
                let s = this.parsePlaceholder("Identifier");
                if (!s)
                  return super.parseImport(e);
                if (e.specifiers = [], !this.isContextual(97) && !this.match(12))
                  return e.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
                let i = this.startNodeAtNode(s);
                return i.local = s, e.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(97), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
              }
              parseImportSource() {
                return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
              }
              assertNoSpace() {
                this.state.start > this.state.lastTokEndLoc.index && this.raise(Qr.UnexpectedSpace, { at: this.state.lastTokEndLoc });
              }
            }, ch = (t4) => class extends t4 {
              parseV8Intrinsic() {
                if (this.match(54)) {
                  let e = this.state.startLoc, s = this.startNode();
                  if (this.next(), z(this.state.type)) {
                    let i = this.parseIdentifierName(), a = this.createIdentifier(s, i);
                    if (a.type = "V8IntrinsicIdentifier", this.match(10))
                      return a;
                  }
                  this.unexpected(e);
                }
              }
              parseExprAtom(e) {
                return this.parseV8Intrinsic() || super.parseExprAtom(e);
              }
            };
            function te(t4, r) {
              let [e, s] = typeof r == "string" ? [r, {}] : r, i = Object.keys(s), a = i.length === 0;
              return t4.some((n) => {
                if (typeof n == "string")
                  return a && n === e;
                {
                  let [o, c] = n;
                  if (o !== e)
                    return false;
                  for (let p of i)
                    if (c[p] !== s[p])
                      return false;
                  return true;
                }
              });
            }
            function Le(t4, r, e) {
              let s = t4.find((i) => Array.isArray(i) ? i[0] === r : i === r);
              return s && Array.isArray(s) && s.length > 1 ? s[1][e] : null;
            }
            var Zr = ["minimal", "fsharp", "hack", "smart"], ei = ["^^", "@@", "^", "%", "#"], ti = ["hash", "bar"];
            function ph(t4) {
              if (te(t4, "decorators")) {
                if (te(t4, "decorators-legacy"))
                  throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                let r = Le(t4, "decorators", "decoratorsBeforeExport");
                if (r != null && typeof r != "boolean")
                  throw new Error("'decoratorsBeforeExport' must be a boolean.");
                let e = Le(t4, "decorators", "allowCallParenthesized");
                if (e != null && typeof e != "boolean")
                  throw new Error("'allowCallParenthesized' must be a boolean.");
              }
              if (te(t4, "flow") && te(t4, "typescript"))
                throw new Error("Cannot combine flow and typescript plugins.");
              if (te(t4, "placeholders") && te(t4, "v8intrinsic"))
                throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
              if (te(t4, "pipelineOperator")) {
                let r = Le(t4, "pipelineOperator", "proposal");
                if (!Zr.includes(r)) {
                  let s = Zr.map((i) => `"${i}"`).join(", ");
                  throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s}.`);
                }
                let e = te(t4, ["recordAndTuple", { syntaxType: "hash" }]);
                if (r === "hack") {
                  if (te(t4, "placeholders"))
                    throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                  if (te(t4, "v8intrinsic"))
                    throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                  let s = Le(t4, "pipelineOperator", "topicToken");
                  if (!ei.includes(s)) {
                    let i = ei.map((a) => `"${a}"`).join(", ");
                    throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i}.`);
                  }
                  if (s === "#" && e)
                    throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
                } else if (r === "smart" && e)
                  throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
              }
              if (te(t4, "moduleAttributes")) {
                if (te(t4, "importAssertions"))
                  throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
                if (Le(t4, "moduleAttributes", "version") !== "may-2020")
                  throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
              }
              if (te(t4, "recordAndTuple") && Le(t4, "recordAndTuple", "syntaxType") != null && !ti.includes(Le(t4, "recordAndTuple", "syntaxType")))
                throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + ti.map((r) => `'${r}'`).join(", "));
              if (te(t4, "asyncDoExpressions") && !te(t4, "doExpressions")) {
                let r = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
                throw r.missingPlugins = "doExpressions", r;
              }
            }
            var si = { estree: _e, jsx: th, flow: Zl, typescript: lh, v8intrinsic: ch, placeholders: uh }, fh = Object.keys(si), ri = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true };
            function dh(t4) {
              let r = {};
              for (let e of Object.keys(ri))
                r[e] = t4 && t4[e] != null ? t4[e] : ri[e];
              return r;
            }
            var mh = (t4, r) => Object.hasOwnProperty.call(t4, r) && t4[r], ii = (t4) => t4.type === "ParenthesizedExpression" ? ii(t4.expression) : t4, yh = class extends Wl {
              toAssignable(t4) {
                let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                var e, s;
                let i;
                switch ((t4.type === "ParenthesizedExpression" || (e = t4.extra) != null && e.parenthesized) && (i = ii(t4), r ? i.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(u.InvalidParenthesizedAssignment, { at: t4 }) : i.type !== "MemberExpression" && this.raise(u.InvalidParenthesizedAssignment, { at: t4 }) : this.raise(u.InvalidParenthesizedAssignment, { at: t4 })), t4.type) {
                  case "Identifier":
                  case "ObjectPattern":
                  case "ArrayPattern":
                  case "AssignmentPattern":
                  case "RestElement":
                    break;
                  case "ObjectExpression":
                    t4.type = "ObjectPattern";
                    for (let n = 0, o = t4.properties.length, c = o - 1; n < o; n++) {
                      var a;
                      let p = t4.properties[n], m = n === c;
                      this.toAssignableObjectExpressionProp(p, m, r), m && p.type === "RestElement" && (a = t4.extra) != null && a.trailingCommaLoc && this.raise(u.RestTrailingComma, { at: t4.extra.trailingCommaLoc });
                    }
                    break;
                  case "ObjectProperty": {
                    let { key: n, value: o } = t4;
                    this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(o, r);
                    break;
                  }
                  case "SpreadElement":
                    throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
                  case "ArrayExpression":
                    t4.type = "ArrayPattern", this.toAssignableList(t4.elements, (s = t4.extra) == null ? void 0 : s.trailingCommaLoc, r);
                    break;
                  case "AssignmentExpression":
                    t4.operator !== "=" && this.raise(u.MissingEqInAssignment, { at: t4.left.loc.end }), t4.type = "AssignmentPattern", delete t4.operator, this.toAssignable(t4.left, r);
                    break;
                  case "ParenthesizedExpression":
                    this.toAssignable(i, r);
                    break;
                }
              }
              toAssignableObjectExpressionProp(t4, r, e) {
                if (t4.type === "ObjectMethod")
                  this.raise(t4.kind === "get" || t4.kind === "set" ? u.PatternHasAccessor : u.PatternHasMethod, { at: t4.key });
                else if (t4.type === "SpreadElement") {
                  t4.type = "RestElement";
                  let s = t4.argument;
                  this.checkToRestConversion(s, false), this.toAssignable(s, e), r || this.raise(u.RestTrailingComma, { at: t4 });
                } else
                  this.toAssignable(t4, e);
              }
              toAssignableList(t4, r, e) {
                let s = t4.length - 1;
                for (let i = 0; i <= s; i++) {
                  let a = t4[i];
                  if (a) {
                    if (a.type === "SpreadElement") {
                      a.type = "RestElement";
                      let n = a.argument;
                      this.checkToRestConversion(n, true), this.toAssignable(n, e);
                    } else
                      this.toAssignable(a, e);
                    a.type === "RestElement" && (i < s ? this.raise(u.RestTrailingComma, { at: a }) : r && this.raise(u.RestTrailingComma, { at: r }));
                  }
                }
              }
              isAssignable(t4, r) {
                switch (t4.type) {
                  case "Identifier":
                  case "ObjectPattern":
                  case "ArrayPattern":
                  case "AssignmentPattern":
                  case "RestElement":
                    return true;
                  case "ObjectExpression": {
                    let e = t4.properties.length - 1;
                    return t4.properties.every((s, i) => s.type !== "ObjectMethod" && (i === e || s.type !== "SpreadElement") && this.isAssignable(s));
                  }
                  case "ObjectProperty":
                    return this.isAssignable(t4.value);
                  case "SpreadElement":
                    return this.isAssignable(t4.argument);
                  case "ArrayExpression":
                    return t4.elements.every((e) => e === null || this.isAssignable(e));
                  case "AssignmentExpression":
                    return t4.operator === "=";
                  case "ParenthesizedExpression":
                    return this.isAssignable(t4.expression);
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return !r;
                  default:
                    return false;
                }
              }
              toReferencedList(t4, r) {
                return t4;
              }
              toReferencedListDeep(t4, r) {
                this.toReferencedList(t4, r);
                for (let e of t4)
                  (e == null ? void 0 : e.type) === "ArrayExpression" && this.toReferencedListDeep(e.elements);
              }
              parseSpread(t4) {
                let r = this.startNode();
                return this.next(), r.argument = this.parseMaybeAssignAllowIn(t4, void 0), this.finishNode(r, "SpreadElement");
              }
              parseRestBinding() {
                let t4 = this.startNode();
                return this.next(), t4.argument = this.parseBindingAtom(), this.finishNode(t4, "RestElement");
              }
              parseBindingAtom() {
                switch (this.state.type) {
                  case 0: {
                    let t4 = this.startNode();
                    return this.next(), t4.elements = this.parseBindingList(3, 93, true), this.finishNode(t4, "ArrayPattern");
                  }
                  case 5:
                    return this.parseObjectLike(8, true);
                }
                return this.parseIdentifier();
              }
              parseBindingList(t4, r, e, s) {
                let i = [], a = true;
                for (; !this.eat(t4); )
                  if (a ? a = false : this.expect(12), e && this.match(12))
                    i.push(null);
                  else {
                    if (this.eat(t4))
                      break;
                    if (this.match(21)) {
                      if (i.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(r)) {
                        this.expect(t4);
                        break;
                      }
                    } else {
                      let n = [];
                      for (this.match(26) && this.hasPlugin("decorators") && this.raise(u.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); )
                        n.push(this.parseDecorator());
                      i.push(this.parseAssignableListItem(s, n));
                    }
                  }
                return i;
              }
              parseBindingRestProperty(t4) {
                return this.next(), t4.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t4, "RestElement");
              }
              parseBindingProperty() {
                let t4 = this.startNode(), { type: r, startLoc: e } = this.state;
                return r === 21 ? this.parseBindingRestProperty(t4) : (r === 136 ? (this.expectPlugin("destructuringPrivate", e), this.classScope.usePrivateName(this.state.value, e), t4.key = this.parsePrivateName()) : this.parsePropertyName(t4), t4.method = false, this.parseObjPropValue(t4, e, false, false, true, false));
              }
              parseAssignableListItem(t4, r) {
                let e = this.parseMaybeDefault();
                this.parseAssignableListItemTypes(e);
                let s = this.parseMaybeDefault(e.loc.start, e);
                return r.length && (e.decorators = r), s;
              }
              parseAssignableListItemTypes(t4) {
                return t4;
              }
              parseMaybeDefault(t4, r) {
                var e, s;
                if ((e = t4) != null || (t4 = this.state.startLoc), r = (s = r) != null ? s : this.parseBindingAtom(), !this.eat(29))
                  return r;
                let i = this.startNodeAt(t4);
                return i.left = r, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
              }
              isValidLVal(t4, r, e) {
                return mh({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t4);
              }
              checkLVal(t4, r) {
                let { in: e, binding: s = be, checkClashes: i = false, strictModeChanged: a = false, allowingSloppyLetBinding: n = !(s & Ce), hasParenthesizedAncestor: o = false } = r;
                var c;
                let p = t4.type;
                if (this.isObjectMethod(t4))
                  return;
                if (p === "MemberExpression") {
                  s !== be && this.raise(u.InvalidPropertyBindingPattern, { at: t4 });
                  return;
                }
                if (t4.type === "Identifier") {
                  this.checkIdentifier(t4, s, a, n);
                  let { name: O } = t4;
                  i && (i.has(O) ? this.raise(u.ParamDupe, { at: t4 }) : i.add(O));
                  return;
                }
                let m = this.isValidLVal(t4.type, !(o || (c = t4.extra) != null && c.parenthesized) && e.type === "AssignmentExpression", s);
                if (m === true)
                  return;
                if (m === false) {
                  let O = s === be ? u.InvalidLhs : u.InvalidLhsBinding;
                  this.raise(O, { at: t4, ancestor: e.type === "UpdateExpression" ? { type: "UpdateExpression", prefix: e.prefix } : { type: e.type } });
                  return;
                }
                let [x, A] = Array.isArray(m) ? m : [m, p === "ParenthesizedExpression"], b = t4.type === "ArrayPattern" || t4.type === "ObjectPattern" || t4.type === "ParenthesizedExpression" ? t4 : e;
                for (let O of [].concat(t4[x]))
                  O && this.checkLVal(O, { in: b, binding: s, checkClashes: i, allowingSloppyLetBinding: n, strictModeChanged: a, hasParenthesizedAncestor: A });
              }
              checkIdentifier(t4, r) {
                let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !(r & Ce);
                this.state.strict && (e ? br(t4.name, this.inModule) : Cr(t4.name)) && (r === be ? this.raise(u.StrictEvalArguments, { at: t4, referenceName: t4.name }) : this.raise(u.StrictEvalArgumentsBinding, { at: t4, bindingName: t4.name })), !s && t4.name === "let" && this.raise(u.LetInLexicalBinding, { at: t4 }), r & be || this.declareNameFromIdentifier(t4, r);
              }
              declareNameFromIdentifier(t4, r) {
                this.scope.declareName(t4.name, r, t4.loc.start);
              }
              checkToRestConversion(t4, r) {
                switch (t4.type) {
                  case "ParenthesizedExpression":
                    this.checkToRestConversion(t4.expression, r);
                    break;
                  case "Identifier":
                  case "MemberExpression":
                    break;
                  case "ArrayExpression":
                  case "ObjectExpression":
                    if (r)
                      break;
                  default:
                    this.raise(u.InvalidRestAssignmentPattern, { at: t4 });
                }
              }
              checkCommaAfterRest(t4) {
                return this.match(12) ? (this.raise(this.lookaheadCharCode() === t4 ? u.RestTrailingComma : u.ElementAfterRest, { at: this.state.startLoc }), true) : false;
              }
            }, xh = class extends yh {
              checkProto(t4, r, e, s) {
                if (t4.type === "SpreadElement" || this.isObjectMethod(t4) || t4.computed || t4.shorthand)
                  return;
                let i = t4.key;
                if ((i.type === "Identifier" ? i.name : i.value) === "__proto__") {
                  if (r) {
                    this.raise(u.RecordNoProto, { at: i });
                    return;
                  }
                  e.used && (s ? s.doubleProtoLoc === null && (s.doubleProtoLoc = i.loc.start) : this.raise(u.DuplicateProto, { at: i })), e.used = true;
                }
              }
              shouldExitDescending(t4, r) {
                return t4.type === "ArrowFunctionExpression" && t4.start === r;
              }
              getExpression() {
                this.enterInitialScopes(), this.nextToken();
                let t4 = this.parseExpression();
                return this.match(137) || this.unexpected(), this.finalizeRemainingComments(), t4.comments = this.state.comments, t4.errors = this.state.errors, this.options.tokens && (t4.tokens = this.tokens), t4;
              }
              parseExpression(t4, r) {
                return t4 ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
              }
              parseExpressionBase(t4) {
                let r = this.state.startLoc, e = this.parseMaybeAssign(t4);
                if (this.match(12)) {
                  let s = this.startNodeAt(r);
                  for (s.expressions = [e]; this.eat(12); )
                    s.expressions.push(this.parseMaybeAssign(t4));
                  return this.toReferencedList(s.expressions), this.finishNode(s, "SequenceExpression");
                }
                return e;
              }
              parseMaybeAssignDisallowIn(t4, r) {
                return this.disallowInAnd(() => this.parseMaybeAssign(t4, r));
              }
              parseMaybeAssignAllowIn(t4, r) {
                return this.allowInAnd(() => this.parseMaybeAssign(t4, r));
              }
              setOptionalParametersError(t4, r) {
                var e;
                t4.optionalParametersLoc = (e = r == null ? void 0 : r.loc) != null ? e : this.state.startLoc;
              }
              parseMaybeAssign(t4, r) {
                let e = this.state.startLoc;
                if (this.isContextual(106) && this.prodParam.hasYield) {
                  let n = this.parseYield();
                  return r && (n = r.call(this, n, e)), n;
                }
                let s;
                t4 ? s = false : (t4 = new Ct(), s = true);
                let { type: i } = this.state;
                (i === 10 || z(i)) && (this.state.potentialArrowAt = this.state.start);
                let a = this.parseMaybeConditional(t4);
                if (r && (a = r.call(this, a, e)), Go(this.state.type)) {
                  let n = this.startNodeAt(e), o = this.state.value;
                  if (n.operator = o, this.match(29)) {
                    this.toAssignable(a, true), n.left = a;
                    let c = e.index;
                    t4.doubleProtoLoc != null && t4.doubleProtoLoc.index >= c && (t4.doubleProtoLoc = null), t4.shorthandAssignLoc != null && t4.shorthandAssignLoc.index >= c && (t4.shorthandAssignLoc = null), t4.privateKeyLoc != null && t4.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(t4), t4.privateKeyLoc = null);
                  } else
                    n.left = a;
                  return this.next(), n.right = this.parseMaybeAssign(), this.checkLVal(a, { in: this.finishNode(n, "AssignmentExpression") }), n;
                } else
                  s && this.checkExpressionErrors(t4, true);
                return a;
              }
              parseMaybeConditional(t4) {
                let r = this.state.startLoc, e = this.state.potentialArrowAt, s = this.parseExprOps(t4);
                return this.shouldExitDescending(s, e) ? s : this.parseConditional(s, r, t4);
              }
              parseConditional(t4, r, e) {
                if (this.eat(17)) {
                  let s = this.startNodeAt(r);
                  return s.test = t4, s.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), s.alternate = this.parseMaybeAssign(), this.finishNode(s, "ConditionalExpression");
                }
                return t4;
              }
              parseMaybeUnaryOrPrivate(t4) {
                return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(t4);
              }
              parseExprOps(t4) {
                let r = this.state.startLoc, e = this.state.potentialArrowAt, s = this.parseMaybeUnaryOrPrivate(t4);
                return this.shouldExitDescending(s, e) ? s : this.parseExprOp(s, r, -1);
              }
              parseExprOp(t4, r, e) {
                if (this.isPrivateName(t4)) {
                  let i = this.getPrivateNameSV(t4);
                  (e >= ut(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(u.PrivateInExpectedIn, { at: t4, identifierName: i }), this.classScope.usePrivateName(i, t4.loc.start);
                }
                let s = this.state.type;
                if (Xo(s) && (this.prodParam.hasIn || !this.match(58))) {
                  let i = ut(s);
                  if (i > e) {
                    if (s === 39) {
                      if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                        return t4;
                      this.checkPipelineAtInfixOperator(t4, r);
                    }
                    let a = this.startNodeAt(r);
                    a.left = t4, a.operator = this.state.value;
                    let n = s === 41 || s === 42, o = s === 40;
                    if (o && (i = ut(42)), this.next(), s === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
                      throw this.raise(u.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
                    a.right = this.parseExprOpRightExpr(s, i);
                    let c = this.finishNode(a, n || o ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
                    if (o && (p === 41 || p === 42) || n && p === 40)
                      throw this.raise(u.MixingCoalesceWithLogical, { at: this.state.startLoc });
                    return this.parseExprOp(c, r, e);
                  }
                }
                return t4;
              }
              parseExprOpRightExpr(t4, r) {
                let e = this.state.startLoc;
                switch (t4) {
                  case 39:
                    switch (this.getPluginOption("pipelineOperator", "proposal")) {
                      case "hack":
                        return this.withTopicBindingContext(() => this.parseHackPipeBody());
                      case "smart":
                        return this.withTopicBindingContext(() => {
                          if (this.prodParam.hasYield && this.isContextual(106))
                            throw this.raise(u.PipeBodyIsTighter, { at: this.state.startLoc });
                          return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t4, r), e);
                        });
                      case "fsharp":
                        return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
                    }
                  default:
                    return this.parseExprOpBaseRightExpr(t4, r);
                }
              }
              parseExprOpBaseRightExpr(t4, r) {
                let e = this.state.startLoc;
                return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, tl(t4) ? r - 1 : r);
              }
              parseHackPipeBody() {
                var t4;
                let { startLoc: r } = this.state, e = this.parseMaybeAssign();
                return j.has(e.type) && !((t4 = e.extra) != null && t4.parenthesized) && this.raise(u.PipeUnparenthesizedBody, { at: r, type: e.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(u.PipeTopicUnused, { at: r }), e;
              }
              checkExponentialAfterUnary(t4) {
                this.match(57) && this.raise(u.UnexpectedTokenUnaryExponentiation, { at: t4.argument });
              }
              parseMaybeUnary(t4, r) {
                let e = this.state.startLoc, s = this.isContextual(96);
                if (s && this.isAwaitAllowed()) {
                  this.next();
                  let o = this.parseAwait(e);
                  return r || this.checkExponentialAfterUnary(o), o;
                }
                let i = this.match(34), a = this.startNode();
                if (Qo(this.state.type)) {
                  a.operator = this.state.value, a.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
                  let o = this.match(89);
                  if (this.next(), a.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t4, true), this.state.strict && o) {
                    let c = a.argument;
                    c.type === "Identifier" ? this.raise(u.StrictDelete, { at: a }) : this.hasPropertyAsPrivateName(c) && this.raise(u.DeletePrivateField, { at: a });
                  }
                  if (!i)
                    return r || this.checkExponentialAfterUnary(a), this.finishNode(a, "UnaryExpression");
                }
                let n = this.parseUpdate(a, i, t4);
                if (s) {
                  let { type: o } = this.state;
                  if ((this.hasPlugin("v8intrinsic") ? Xt(o) : Xt(o) && !this.match(54)) && !this.isAmbiguousAwait())
                    return this.raiseOverwrite(u.AwaitNotInAsyncContext, { at: e }), this.parseAwait(e);
                }
                return n;
              }
              parseUpdate(t4, r, e) {
                if (r) {
                  let a = t4;
                  return this.checkLVal(a.argument, { in: this.finishNode(a, "UpdateExpression") }), t4;
                }
                let s = this.state.startLoc, i = this.parseExprSubscripts(e);
                if (this.checkExpressionErrors(e, false))
                  return i;
                for (; Yo(this.state.type) && !this.canInsertSemicolon(); ) {
                  let a = this.startNodeAt(s);
                  a.operator = this.state.value, a.prefix = false, a.argument = i, this.next(), this.checkLVal(i, { in: i = this.finishNode(a, "UpdateExpression") });
                }
                return i;
              }
              parseExprSubscripts(t4) {
                let r = this.state.startLoc, e = this.state.potentialArrowAt, s = this.parseExprAtom(t4);
                return this.shouldExitDescending(s, e) ? s : this.parseSubscripts(s, r);
              }
              parseSubscripts(t4, r, e) {
                let s = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t4), stop: false };
                do
                  t4 = this.parseSubscript(t4, r, e, s), s.maybeAsyncArrow = false;
                while (!s.stop);
                return t4;
              }
              parseSubscript(t4, r, e, s) {
                let { type: i } = this.state;
                if (!e && i === 15)
                  return this.parseBind(t4, r, e, s);
                if (ct(i))
                  return this.parseTaggedTemplateExpression(t4, r, s);
                let a = false;
                if (i === 18) {
                  if (e && this.lookaheadCharCode() === 40)
                    return s.stop = true, t4;
                  s.optionalChainMember = a = true, this.next();
                }
                if (!e && this.match(10))
                  return this.parseCoverCallAndAsyncArrowHead(t4, r, s, a);
                {
                  let n = this.eat(0);
                  return n || a || this.eat(16) ? this.parseMember(t4, r, s, n, a) : (s.stop = true, t4);
                }
              }
              parseMember(t4, r, e, s, i) {
                let a = this.startNodeAt(r);
                return a.object = t4, a.computed = s, s ? (a.property = this.parseExpression(), this.expect(3)) : this.match(136) ? (t4.type === "Super" && this.raise(u.SuperPrivateField, { at: r }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(true), e.optionalChainMember ? (a.optional = i, this.finishNode(a, "OptionalMemberExpression")) : this.finishNode(a, "MemberExpression");
              }
              parseBind(t4, r, e, s) {
                let i = this.startNodeAt(r);
                return i.object = t4, this.next(), i.callee = this.parseNoCallExpr(), s.stop = true, this.parseSubscripts(this.finishNode(i, "BindExpression"), r, e);
              }
              parseCoverCallAndAsyncArrowHead(t4, r, e, s) {
                let i = this.state.maybeInArrowParameters, a = null;
                this.state.maybeInArrowParameters = true, this.next();
                let n = this.startNodeAt(r);
                n.callee = t4;
                let { maybeAsyncArrow: o, optionalChainMember: c } = e;
                o && (this.expressionScope.enter($l()), a = new Ct()), c && (n.optional = s), s ? n.arguments = this.parseCallExpressionArguments(11) : n.arguments = this.parseCallExpressionArguments(11, t4.type === "Import", t4.type !== "Super", n, a);
                let p = this.finishCallExpression(n, c);
                return o && this.shouldParseAsyncArrow() && !s ? (e.stop = true, this.checkDestructuringPrivate(a), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (o && (this.checkExpressionErrors(a, true), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = i, p;
              }
              toReferencedArguments(t4, r) {
                this.toReferencedListDeep(t4.arguments, r);
              }
              parseTaggedTemplateExpression(t4, r, e) {
                let s = this.startNodeAt(r);
                return s.tag = t4, s.quasi = this.parseTemplate(true), e.optionalChainMember && this.raise(u.OptionalChainingNoTemplate, { at: r }), this.finishNode(s, "TaggedTemplateExpression");
              }
              atPossibleAsyncArrow(t4) {
                return t4.type === "Identifier" && t4.name === "async" && this.state.lastTokEndLoc.index === t4.end && !this.canInsertSemicolon() && t4.end - t4.start === 5 && t4.start === this.state.potentialArrowAt;
              }
              finishCallExpression(t4, r) {
                if (t4.callee.type === "Import")
                  if (t4.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), t4.arguments.length === 0 || t4.arguments.length > 2)
                    this.raise(u.ImportCallArity, { at: t4, maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
                  else
                    for (let e of t4.arguments)
                      e.type === "SpreadElement" && this.raise(u.ImportCallSpreadArgument, { at: e });
                return this.finishNode(t4, r ? "OptionalCallExpression" : "CallExpression");
              }
              parseCallExpressionArguments(t4, r, e, s, i) {
                let a = [], n = true, o = this.state.inFSharpPipelineDirectBody;
                for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t4); ) {
                  if (n)
                    n = false;
                  else if (this.expect(12), this.match(t4)) {
                    r && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(u.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), s && this.addTrailingCommaExtraToNode(s), this.next();
                    break;
                  }
                  a.push(this.parseExprListItem(false, i, e));
                }
                return this.state.inFSharpPipelineDirectBody = o, a;
              }
              shouldParseAsyncArrow() {
                return this.match(19) && !this.canInsertSemicolon();
              }
              parseAsyncArrowFromCallExpression(t4, r) {
                var e;
                return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t4, r.arguments, true, (e = r.extra) == null ? void 0 : e.trailingCommaLoc), r.innerComments && Qe(t4, r.innerComments), r.callee.trailingComments && Qe(t4, r.callee.trailingComments), t4;
              }
              parseNoCallExpr() {
                let t4 = this.state.startLoc;
                return this.parseSubscripts(this.parseExprAtom(), t4, true);
              }
              parseExprAtom(t4) {
                let r, e = null, { type: s } = this.state;
                switch (s) {
                  case 79:
                    return this.parseSuper();
                  case 83:
                    return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : (this.match(10) || this.raise(u.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(r, "Import"));
                  case 78:
                    return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
                  case 90:
                    return this.parseDo(this.startNode(), false);
                  case 56:
                  case 31:
                    return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
                  case 132:
                    return this.parseNumericLiteral(this.state.value);
                  case 133:
                    return this.parseBigIntLiteral(this.state.value);
                  case 134:
                    return this.parseDecimalLiteral(this.state.value);
                  case 131:
                    return this.parseStringLiteral(this.state.value);
                  case 84:
                    return this.parseNullLiteral();
                  case 85:
                    return this.parseBooleanLiteral(true);
                  case 86:
                    return this.parseBooleanLiteral(false);
                  case 10: {
                    let i = this.state.potentialArrowAt === this.state.start;
                    return this.parseParenAndDistinguishExpression(i);
                  }
                  case 2:
                  case 1:
                    return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
                  case 0:
                    return this.parseArrayLike(3, true, false, t4);
                  case 6:
                  case 7:
                    return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
                  case 5:
                    return this.parseObjectLike(8, false, false, t4);
                  case 68:
                    return this.parseFunctionOrFunctionSent();
                  case 26:
                    e = this.parseDecorators();
                  case 80:
                    return this.parseClass(this.maybeTakeDecorators(e, this.startNode()), false);
                  case 77:
                    return this.parseNewOrNewTarget();
                  case 25:
                  case 24:
                    return this.parseTemplate(false);
                  case 15: {
                    r = this.startNode(), this.next(), r.object = null;
                    let i = r.callee = this.parseNoCallExpr();
                    if (i.type === "MemberExpression")
                      return this.finishNode(r, "BindExpression");
                    throw this.raise(u.UnsupportedBind, { at: i });
                  }
                  case 136:
                    return this.raise(u.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
                  case 33:
                    return this.parseTopicReferenceThenEqualsSign(54, "%");
                  case 32:
                    return this.parseTopicReferenceThenEqualsSign(44, "^");
                  case 37:
                  case 38:
                    return this.parseTopicReference("hack");
                  case 44:
                  case 54:
                  case 27: {
                    let i = this.getPluginOption("pipelineOperator", "proposal");
                    if (i)
                      return this.parseTopicReference(i);
                    throw this.unexpected();
                  }
                  case 47: {
                    let i = this.input.codePointAt(this.nextTokenStart());
                    if (ge(i) || i === 62) {
                      this.expectOnePlugin(["jsx", "flow", "typescript"]);
                      break;
                    } else
                      throw this.unexpected();
                  }
                  default:
                    if (z(s)) {
                      if (this.isContextual(125) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
                        return this.parseModuleExpression();
                      let i = this.state.potentialArrowAt === this.state.start, a = this.state.containsEsc, n = this.parseIdentifier();
                      if (!a && n.name === "async" && !this.canInsertSemicolon()) {
                        let { type: o } = this.state;
                        if (o === 68)
                          return this.resetPreviousNodeTrailingComments(n), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(n));
                        if (z(o))
                          return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(n)) : n;
                        if (o === 90)
                          return this.resetPreviousNodeTrailingComments(n), this.parseDo(this.startNodeAtNode(n), true);
                      }
                      return i && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(n), [n], false)) : n;
                    } else
                      throw this.unexpected();
                }
              }
              parseTopicReferenceThenEqualsSign(t4, r) {
                let e = this.getPluginOption("pipelineOperator", "proposal");
                if (e)
                  return this.state.type = t4, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = y(this.state.endLoc, -1), this.parseTopicReference(e);
                throw this.unexpected();
              }
              parseTopicReference(t4) {
                let r = this.startNode(), e = this.state.startLoc, s = this.state.type;
                return this.next(), this.finishTopicReference(r, e, t4, s);
              }
              finishTopicReference(t4, r, e, s) {
                if (this.testTopicReferenceConfiguration(e, r, s)) {
                  let i = e === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
                  return this.topicReferenceIsAllowedInCurrentContext() || this.raise(e === "smart" ? u.PrimaryTopicNotAllowed : u.PipeTopicUnbound, { at: r }), this.registerTopicReference(), this.finishNode(t4, i);
                } else
                  throw this.raise(u.PipeTopicUnconfiguredToken, { at: r, token: Ee(s) });
              }
              testTopicReferenceConfiguration(t4, r, e) {
                switch (t4) {
                  case "hack":
                    return this.hasPlugin(["pipelineOperator", { topicToken: Ee(e) }]);
                  case "smart":
                    return e === 27;
                  default:
                    throw this.raise(u.PipeTopicRequiresHackPipes, { at: r });
                }
              }
              parseAsyncArrowUnaryFunction(t4) {
                this.prodParam.enter(Et(true, this.prodParam.hasYield));
                let r = [this.parseIdentifier()];
                return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(u.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(t4, r, true);
              }
              parseDo(t4, r) {
                this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t4.async = r, this.next();
                let e = this.state.labels;
                return this.state.labels = [], r ? (this.prodParam.enter(vt), t4.body = this.parseBlock(), this.prodParam.exit()) : t4.body = this.parseBlock(), this.state.labels = e, this.finishNode(t4, "DoExpression");
              }
              parseSuper() {
                let t4 = this.startNode();
                return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(u.SuperNotAllowed, { at: t4 }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(u.UnexpectedSuper, { at: t4 }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(u.UnsupportedSuper, { at: t4 }), this.finishNode(t4, "Super");
              }
              parsePrivateName() {
                let t4 = this.startNode(), r = this.startNodeAt(y(this.state.startLoc, 1)), e = this.state.value;
                return this.next(), t4.id = this.createIdentifier(r, e), this.finishNode(t4, "PrivateName");
              }
              parseFunctionOrFunctionSent() {
                let t4 = this.startNode();
                if (this.next(), this.prodParam.hasYield && this.match(16)) {
                  let r = this.createIdentifier(this.startNodeAtNode(t4), "function");
                  return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t4, r, "sent");
                }
                return this.parseFunction(t4);
              }
              parseMetaProperty(t4, r, e) {
                t4.meta = r;
                let s = this.state.containsEsc;
                return t4.property = this.parseIdentifier(true), (t4.property.name !== e || s) && this.raise(u.UnsupportedMetaProperty, { at: t4.property, target: r.name, onlyValidPropertyName: e }), this.finishNode(t4, "MetaProperty");
              }
              parseImportMetaProperty(t4) {
                let r = this.createIdentifier(this.startNodeAtNode(t4), "import");
                return this.next(), this.isContextual(100) && (this.inModule || this.raise(u.ImportMetaOutsideModule, { at: r }), this.sawUnambiguousESM = true), this.parseMetaProperty(t4, r, "meta");
              }
              parseLiteralAtNode(t4, r, e) {
                return this.addExtra(e, "rawValue", t4), this.addExtra(e, "raw", this.input.slice(e.start, this.state.end)), e.value = t4, this.next(), this.finishNode(e, r);
              }
              parseLiteral(t4, r) {
                let e = this.startNode();
                return this.parseLiteralAtNode(t4, r, e);
              }
              parseStringLiteral(t4) {
                return this.parseLiteral(t4, "StringLiteral");
              }
              parseNumericLiteral(t4) {
                return this.parseLiteral(t4, "NumericLiteral");
              }
              parseBigIntLiteral(t4) {
                return this.parseLiteral(t4, "BigIntLiteral");
              }
              parseDecimalLiteral(t4) {
                return this.parseLiteral(t4, "DecimalLiteral");
              }
              parseRegExpLiteral(t4) {
                let r = this.parseLiteral(t4.value, "RegExpLiteral");
                return r.pattern = t4.pattern, r.flags = t4.flags, r;
              }
              parseBooleanLiteral(t4) {
                let r = this.startNode();
                return r.value = t4, this.next(), this.finishNode(r, "BooleanLiteral");
              }
              parseNullLiteral() {
                let t4 = this.startNode();
                return this.next(), this.finishNode(t4, "NullLiteral");
              }
              parseParenAndDistinguishExpression(t4) {
                let r = this.state.startLoc, e;
                this.next(), this.expressionScope.enter(Ul());
                let s = this.state.maybeInArrowParameters, i = this.state.inFSharpPipelineDirectBody;
                this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
                let a = this.state.startLoc, n = [], o = new Ct(), c = true, p, m;
                for (; !this.match(11); ) {
                  if (c)
                    c = false;
                  else if (this.expect(12, o.optionalParametersLoc === null ? null : o.optionalParametersLoc), this.match(11)) {
                    m = this.state.startLoc;
                    break;
                  }
                  if (this.match(21)) {
                    let b = this.state.startLoc;
                    if (p = this.state.startLoc, n.push(this.parseParenItem(this.parseRestBinding(), b)), !this.checkCommaAfterRest(41))
                      break;
                  } else
                    n.push(this.parseMaybeAssignAllowIn(o, this.parseParenItem));
                }
                let x = this.state.lastTokEndLoc;
                this.expect(11), this.state.maybeInArrowParameters = s, this.state.inFSharpPipelineDirectBody = i;
                let A = this.startNodeAt(r);
                return t4 && this.shouldParseArrow(n) && (A = this.parseArrow(A)) ? (this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(A, n, false), A) : (this.expressionScope.exit(), n.length || this.unexpected(this.state.lastTokStartLoc), m && this.unexpected(m), p && this.unexpected(p), this.checkExpressionErrors(o, true), this.toReferencedListDeep(n, true), n.length > 1 ? (e = this.startNodeAt(a), e.expressions = n, this.finishNode(e, "SequenceExpression"), this.resetEndLocation(e, x)) : e = n[0], this.wrapParenthesis(r, e));
              }
              wrapParenthesis(t4, r) {
                if (!this.options.createParenthesizedExpressions)
                  return this.addExtra(r, "parenthesized", true), this.addExtra(r, "parenStart", t4.index), this.takeSurroundingComments(r, t4.index, this.state.lastTokEndLoc.index), r;
                let e = this.startNodeAt(t4);
                return e.expression = r, this.finishNode(e, "ParenthesizedExpression");
              }
              shouldParseArrow(t4) {
                return !this.canInsertSemicolon();
              }
              parseArrow(t4) {
                if (this.eat(19))
                  return t4;
              }
              parseParenItem(t4, r) {
                return t4;
              }
              parseNewOrNewTarget() {
                let t4 = this.startNode();
                if (this.next(), this.match(16)) {
                  let r = this.createIdentifier(this.startNodeAtNode(t4), "new");
                  this.next();
                  let e = this.parseMetaProperty(t4, r, "target");
                  return !this.scope.inNonArrowFunction && !this.scope.inClass && this.raise(u.UnexpectedNewTarget, { at: e }), e;
                }
                return this.parseNew(t4);
              }
              parseNew(t4) {
                if (this.parseNewCallee(t4), this.eat(10)) {
                  let r = this.parseExprList(11);
                  this.toReferencedList(r), t4.arguments = r;
                } else
                  t4.arguments = [];
                return this.finishNode(t4, "NewExpression");
              }
              parseNewCallee(t4) {
                t4.callee = this.parseNoCallExpr(), t4.callee.type === "Import" ? this.raise(u.ImportCallNotNewExpression, { at: t4.callee }) : this.isOptionalChain(t4.callee) ? this.raise(u.OptionalChainingNoNew, { at: this.state.lastTokEndLoc }) : this.eat(18) && this.raise(u.OptionalChainingNoNew, { at: this.state.startLoc });
              }
              parseTemplateElement(t4) {
                let { start: r, startLoc: e, end: s, value: i } = this.state, a = r + 1, n = this.startNodeAt(y(e, 1));
                i === null && (t4 || this.raise(u.InvalidEscapeSequenceTemplate, { at: y(this.state.firstInvalidTemplateEscapePos, 1) }));
                let o = this.match(24), c = o ? -1 : -2, p = s + c;
                n.value = { raw: this.input.slice(a, p).replace(/\r\n?/g, `
`), cooked: i === null ? null : i.slice(1, c) }, n.tail = o, this.next();
                let m = this.finishNode(n, "TemplateElement");
                return this.resetEndLocation(m, y(this.state.lastTokEndLoc, c)), m;
              }
              parseTemplate(t4) {
                let r = this.startNode();
                r.expressions = [];
                let e = this.parseTemplateElement(t4);
                for (r.quasis = [e]; !e.tail; )
                  r.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.quasis.push(e = this.parseTemplateElement(t4));
                return this.finishNode(r, "TemplateLiteral");
              }
              parseTemplateSubstitution() {
                return this.parseExpression();
              }
              parseObjectLike(t4, r, e, s) {
                e && this.expectPlugin("recordAndTuple");
                let i = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = false;
                let a = /* @__PURE__ */ Object.create(null), n = true, o = this.startNode();
                for (o.properties = [], this.next(); !this.match(t4); ) {
                  if (n)
                    n = false;
                  else if (this.expect(12), this.match(t4)) {
                    this.addTrailingCommaExtraToNode(o);
                    break;
                  }
                  let p;
                  r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(s), this.checkProto(p, e, a, s)), e && !this.isObjectProperty(p) && p.type !== "SpreadElement" && this.raise(u.InvalidRecordProperty, { at: p }), p.shorthand && this.addExtra(p, "shorthand", true), o.properties.push(p);
                }
                this.next(), this.state.inFSharpPipelineDirectBody = i;
                let c = "ObjectExpression";
                return r ? c = "ObjectPattern" : e && (c = "RecordExpression"), this.finishNode(o, c);
              }
              addTrailingCommaExtraToNode(t4) {
                this.addExtra(t4, "trailingComma", this.state.lastTokStart), this.addExtra(t4, "trailingCommaLoc", this.state.lastTokStartLoc, false);
              }
              maybeAsyncOrAccessorProp(t4) {
                return !t4.computed && t4.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
              }
              parsePropertyDefinition(t4) {
                let r = [];
                if (this.match(26))
                  for (this.hasPlugin("decorators") && this.raise(u.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); )
                    r.push(this.parseDecorator());
                let e = this.startNode(), s = false, i = false, a;
                if (this.match(21))
                  return r.length && this.unexpected(), this.parseSpread();
                r.length && (e.decorators = r, r = []), e.method = false, t4 && (a = this.state.startLoc);
                let n = this.eat(55);
                this.parsePropertyNamePrefixOperator(e);
                let o = this.state.containsEsc, c = this.parsePropertyName(e, t4);
                if (!n && !o && this.maybeAsyncOrAccessorProp(e)) {
                  let p = c.name;
                  p === "async" && !this.hasPrecedingLineBreak() && (s = true, this.resetPreviousNodeTrailingComments(c), n = this.eat(55), this.parsePropertyName(e)), (p === "get" || p === "set") && (i = true, this.resetPreviousNodeTrailingComments(c), e.kind = p, this.match(55) && (n = true, this.raise(u.AccessorIsGenerator, { at: this.state.curPosition(), kind: p }), this.next()), this.parsePropertyName(e));
                }
                return this.parseObjPropValue(e, a, n, s, false, i, t4);
              }
              getGetterSetterExpectedParamCount(t4) {
                return t4.kind === "get" ? 0 : 1;
              }
              getObjectOrClassMethodParams(t4) {
                return t4.params;
              }
              checkGetterSetterParams(t4) {
                var r;
                let e = this.getGetterSetterExpectedParamCount(t4), s = this.getObjectOrClassMethodParams(t4);
                s.length !== e && this.raise(t4.kind === "get" ? u.BadGetterArity : u.BadSetterArity, { at: t4 }), t4.kind === "set" && ((r = s[s.length - 1]) == null ? void 0 : r.type) === "RestElement" && this.raise(u.BadSetterRestParameter, { at: t4 });
              }
              parseObjectMethod(t4, r, e, s, i) {
                if (i) {
                  let a = this.parseMethod(t4, r, false, false, false, "ObjectMethod");
                  return this.checkGetterSetterParams(a), a;
                }
                if (e || r || this.match(10))
                  return s && this.unexpected(), t4.kind = "method", t4.method = true, this.parseMethod(t4, r, e, false, false, "ObjectMethod");
              }
              parseObjectProperty(t4, r, e, s) {
                if (t4.shorthand = false, this.eat(14))
                  return t4.value = e ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(s), this.finishNode(t4, "ObjectProperty");
                if (!t4.computed && t4.key.type === "Identifier") {
                  if (this.checkReservedWord(t4.key.name, t4.key.loc.start, true, false), e)
                    t4.value = this.parseMaybeDefault(r, Te(t4.key));
                  else if (this.match(29)) {
                    let i = this.state.startLoc;
                    s != null ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = i) : this.raise(u.InvalidCoverInitializedName, { at: i }), t4.value = this.parseMaybeDefault(r, Te(t4.key));
                  } else
                    t4.value = Te(t4.key);
                  return t4.shorthand = true, this.finishNode(t4, "ObjectProperty");
                }
              }
              parseObjPropValue(t4, r, e, s, i, a, n) {
                let o = this.parseObjectMethod(t4, e, s, i, a) || this.parseObjectProperty(t4, r, i, n);
                return o || this.unexpected(), o;
              }
              parsePropertyName(t4, r) {
                if (this.eat(0))
                  t4.computed = true, t4.key = this.parseMaybeAssignAllowIn(), this.expect(3);
                else {
                  let { type: e, value: s } = this.state, i;
                  if (ye(e))
                    i = this.parseIdentifier(true);
                  else
                    switch (e) {
                      case 132:
                        i = this.parseNumericLiteral(s);
                        break;
                      case 131:
                        i = this.parseStringLiteral(s);
                        break;
                      case 133:
                        i = this.parseBigIntLiteral(s);
                        break;
                      case 134:
                        i = this.parseDecimalLiteral(s);
                        break;
                      case 136: {
                        let a = this.state.startLoc;
                        r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = a) : this.raise(u.UnexpectedPrivateField, { at: a }), i = this.parsePrivateName();
                        break;
                      }
                      default:
                        throw this.unexpected();
                    }
                  t4.key = i, e !== 136 && (t4.computed = false);
                }
                return t4.key;
              }
              initFunction(t4, r) {
                t4.id = null, t4.generator = false, t4.async = r;
              }
              parseMethod(t4, r, e, s, i, a) {
                let n = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
                this.initFunction(t4, e), t4.generator = r;
                let o = s;
                this.scope.enter(Pe | pt | (n ? Ne : 0) | (i ? wr : 0)), this.prodParam.enter(Et(e, t4.generator)), this.parseFunctionParams(t4, o);
                let c = this.parseFunctionBodyAndFinish(t4, a, true);
                return this.prodParam.exit(), this.scope.exit(), c;
              }
              parseArrayLike(t4, r, e, s) {
                e && this.expectPlugin("recordAndTuple");
                let i = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = false;
                let a = this.startNode();
                return this.next(), a.elements = this.parseExprList(t4, !e, s, a), this.state.inFSharpPipelineDirectBody = i, this.finishNode(a, e ? "TupleExpression" : "ArrayExpression");
              }
              parseArrowExpression(t4, r, e, s) {
                this.scope.enter(Pe | ts);
                let i = Et(e, false);
                !this.match(5) && this.prodParam.hasIn && (i |= He), this.prodParam.enter(i), this.initFunction(t4, e);
                let a = this.state.maybeInArrowParameters;
                return r && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t4, r, s)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t4, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a, this.finishNode(t4, "ArrowFunctionExpression");
              }
              setArrowFunctionParameters(t4, r, e) {
                this.toAssignableList(r, e, false), t4.params = r;
              }
              parseFunctionBodyAndFinish(t4, r) {
                let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                return this.parseFunctionBody(t4, false, e), this.finishNode(t4, r);
              }
              parseFunctionBody(t4, r) {
                let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s = r && !this.match(5);
                if (this.expressionScope.enter(Vr()), s)
                  t4.body = this.parseMaybeAssign(), this.checkParams(t4, false, r, false);
                else {
                  let i = this.state.strict, a = this.state.labels;
                  this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | Wr), t4.body = this.parseBlock(true, false, (n) => {
                    let o = !this.isSimpleParamList(t4.params);
                    n && o && this.raise(u.IllegalLanguageModeDirective, { at: (t4.kind === "method" || t4.kind === "constructor") && t4.key ? t4.key.loc.end : t4 });
                    let c = !i && this.state.strict;
                    this.checkParams(t4, !this.state.strict && !r && !e && !o, r, c), this.state.strict && t4.id && this.checkIdentifier(t4.id, dl, c);
                  }), this.prodParam.exit(), this.state.labels = a;
                }
                this.expressionScope.exit();
              }
              isSimpleParameter(t4) {
                return t4.type === "Identifier";
              }
              isSimpleParamList(t4) {
                for (let r = 0, e = t4.length; r < e; r++)
                  if (!this.isSimpleParameter(t4[r]))
                    return false;
                return true;
              }
              checkParams(t4, r, e) {
                let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, i = !r && /* @__PURE__ */ new Set(), a = { type: "FormalParameters" };
                for (let n of t4.params)
                  this.checkLVal(n, { in: a, binding: xt, checkClashes: i, strictModeChanged: s });
              }
              parseExprList(t4, r, e, s) {
                let i = [], a = true;
                for (; !this.eat(t4); ) {
                  if (a)
                    a = false;
                  else if (this.expect(12), this.match(t4)) {
                    s && this.addTrailingCommaExtraToNode(s), this.next();
                    break;
                  }
                  i.push(this.parseExprListItem(r, e));
                }
                return i;
              }
              parseExprListItem(t4, r, e) {
                let s;
                if (this.match(12))
                  t4 || this.raise(u.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), s = null;
                else if (this.match(21)) {
                  let i = this.state.startLoc;
                  s = this.parseParenItem(this.parseSpread(r), i);
                } else if (this.match(17)) {
                  this.expectPlugin("partialApplication"), e || this.raise(u.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
                  let i = this.startNode();
                  this.next(), s = this.finishNode(i, "ArgumentPlaceholder");
                } else
                  s = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
                return s;
              }
              parseIdentifier(t4) {
                let r = this.startNode(), e = this.parseIdentifierName(t4);
                return this.createIdentifier(r, e);
              }
              createIdentifier(t4, r) {
                return t4.name = r, t4.loc.identifierName = r, this.finishNode(t4, "Identifier");
              }
              parseIdentifierName(t4) {
                let r, { startLoc: e, type: s } = this.state;
                if (ye(s))
                  r = this.state.value;
                else
                  throw this.unexpected();
                let i = Ko(s);
                return t4 ? i && this.replaceToken(130) : this.checkReservedWord(r, e, i, false), this.next(), r;
              }
              checkReservedWord(t4, r, e, s) {
                if (t4.length > 10 || !cl(t4))
                  return;
                if (t4 === "yield") {
                  if (this.prodParam.hasYield) {
                    this.raise(u.YieldBindingIdentifier, { at: r });
                    return;
                  }
                } else if (t4 === "await") {
                  if (this.prodParam.hasAwait) {
                    this.raise(u.AwaitBindingIdentifier, { at: r });
                    return;
                  }
                  if (this.scope.inStaticBlock) {
                    this.raise(u.AwaitBindingIdentifierInStaticBlock, { at: r });
                    return;
                  }
                  this.expressionScope.recordAsyncArrowParametersError({ at: r });
                } else if (t4 === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
                  this.raise(u.ArgumentsInClass, { at: r });
                  return;
                }
                if (e && ll(t4)) {
                  this.raise(u.UnexpectedKeyword, { at: r, keyword: t4 });
                  return;
                }
                (this.state.strict ? s ? br : Er : vr)(t4, this.inModule) && this.raise(u.UnexpectedReservedWord, { at: r, reservedWord: t4 });
              }
              isAwaitAllowed() {
                return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
              }
              parseAwait(t4) {
                let r = this.startNodeAt(t4);
                return this.expressionScope.recordParameterInitializerError(u.AwaitExpressionFormalParameter, { at: r }), this.eat(55) && this.raise(u.ObsoleteAwaitStar, { at: r }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, true)), this.finishNode(r, "AwaitExpression");
              }
              isAmbiguousAwait() {
                if (this.hasPrecedingLineBreak())
                  return true;
                let { type: t4 } = this.state;
                return t4 === 53 || t4 === 10 || t4 === 0 || ct(t4) || t4 === 101 && !this.state.containsEsc || t4 === 135 || t4 === 56 || this.hasPlugin("v8intrinsic") && t4 === 54;
              }
              parseYield() {
                let t4 = this.startNode();
                this.expressionScope.recordParameterInitializerError(u.YieldInParameter, { at: t4 }), this.next();
                let r = false, e = null;
                if (!this.hasPrecedingLineBreak())
                  switch (r = this.eat(55), this.state.type) {
                    case 13:
                    case 137:
                    case 8:
                    case 11:
                    case 3:
                    case 9:
                    case 14:
                    case 12:
                      if (!r)
                        break;
                    default:
                      e = this.parseMaybeAssign();
                  }
                return t4.delegate = r, t4.argument = e, this.finishNode(t4, "YieldExpression");
              }
              checkPipelineAtInfixOperator(t4, r) {
                this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t4.type === "SequenceExpression" && this.raise(u.PipelineHeadSequenceExpression, { at: r });
              }
              parseSmartPipelineBodyInStyle(t4, r) {
                if (this.isSimpleReference(t4)) {
                  let e = this.startNodeAt(r);
                  return e.callee = t4, this.finishNode(e, "PipelineBareFunction");
                } else {
                  let e = this.startNodeAt(r);
                  return this.checkSmartPipeTopicBodyEarlyErrors(r), e.expression = t4, this.finishNode(e, "PipelineTopicExpression");
                }
              }
              isSimpleReference(t4) {
                switch (t4.type) {
                  case "MemberExpression":
                    return !t4.computed && this.isSimpleReference(t4.object);
                  case "Identifier":
                    return true;
                  default:
                    return false;
                }
              }
              checkSmartPipeTopicBodyEarlyErrors(t4) {
                if (this.match(19))
                  throw this.raise(u.PipelineBodyNoArrow, { at: this.state.startLoc });
                this.topicReferenceWasUsedInCurrentContext() || this.raise(u.PipelineTopicUnused, { at: t4 });
              }
              withTopicBindingContext(t4) {
                let r = this.state.topicContext;
                this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
                try {
                  return t4();
                } finally {
                  this.state.topicContext = r;
                }
              }
              withSmartMixTopicForbiddingContext(t4) {
                if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
                  let r = this.state.topicContext;
                  this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
                  try {
                    return t4();
                  } finally {
                    this.state.topicContext = r;
                  }
                } else
                  return t4();
              }
              withSoloAwaitPermittingContext(t4) {
                let r = this.state.soloAwait;
                this.state.soloAwait = true;
                try {
                  return t4();
                } finally {
                  this.state.soloAwait = r;
                }
              }
              allowInAnd(t4) {
                let r = this.prodParam.currentFlags();
                if (He & ~r) {
                  this.prodParam.enter(r | He);
                  try {
                    return t4();
                  } finally {
                    this.prodParam.exit();
                  }
                }
                return t4();
              }
              disallowInAnd(t4) {
                let r = this.prodParam.currentFlags();
                if (He & r) {
                  this.prodParam.enter(r & ~He);
                  try {
                    return t4();
                  } finally {
                    this.prodParam.exit();
                  }
                }
                return t4();
              }
              registerTopicReference() {
                this.state.topicContext.maxTopicIndex = 0;
              }
              topicReferenceIsAllowedInCurrentContext() {
                return this.state.topicContext.maxNumOfResolvableTopics >= 1;
              }
              topicReferenceWasUsedInCurrentContext() {
                return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
              }
              parseFSharpPipelineBody(t4) {
                let r = this.state.startLoc;
                this.state.potentialArrowAt = this.state.start;
                let e = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = true;
                let s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t4);
                return this.state.inFSharpPipelineDirectBody = e, s;
              }
              parseModuleExpression() {
                this.expectPlugin("moduleBlocks");
                let t4 = this.startNode();
                this.next(), this.match(5) || this.unexpected(null, 5);
                let r = this.startNodeAt(this.state.endLoc);
                this.next();
                let e = this.initializeScopes(true);
                this.enterInitialScopes();
                try {
                  t4.body = this.parseProgram(r, 8, "module");
                } finally {
                  e();
                }
                return this.finishNode(t4, "ModuleExpression");
              }
              parsePropertyNamePrefixOperator(t4) {
              }
            }, gs = { kind: "loop" }, gh = { kind: "switch" }, ie = { Expression: 0, Declaration: 1, HangingDeclaration: 2, NullableId: 4, Async: 8 }, ae = { StatementOnly: 0, AllowImportExport: 1, AllowDeclaration: 2, AllowFunctionDeclaration: 4, AllowLabeledFunction: 8 }, Ph = /[\uD800-\uDFFF]/u, Ps = /in(?:stanceof)?/y;
            function Ah(t4, r) {
              for (let e = 0; e < t4.length; e++) {
                let s = t4[e], { type: i } = s;
                if (typeof i == "number") {
                  {
                    if (i === 136) {
                      let { loc: a, start: n, value: o, end: c } = s, p = n + 1, m = y(a.start, 1);
                      t4.splice(e, 1, new Se({ type: xe(27), value: "#", start: n, end: p, startLoc: a.start, endLoc: m }), new Se({ type: xe(130), value: o, start: p, end: c, startLoc: m, endLoc: a.end })), e++;
                      continue;
                    }
                    if (ct(i)) {
                      let { loc: a, start: n, value: o, end: c } = s, p = n + 1, m = y(a.start, 1), x;
                      r.charCodeAt(n) === 96 ? x = new Se({ type: xe(22), value: "`", start: n, end: p, startLoc: a.start, endLoc: m }) : x = new Se({ type: xe(8), value: "}", start: n, end: p, startLoc: a.start, endLoc: m });
                      let A, b, O, R4;
                      i === 24 ? (b = c - 1, O = y(a.end, -1), A = o === null ? null : o.slice(1, -1), R4 = new Se({ type: xe(22), value: "`", start: b, end: c, startLoc: O, endLoc: a.end })) : (b = c - 2, O = y(a.end, -2), A = o === null ? null : o.slice(1, -2), R4 = new Se({ type: xe(23), value: "${", start: b, end: c, startLoc: O, endLoc: a.end })), t4.splice(e, 1, x, new Se({ type: xe(20), value: A, start: p, end: b, startLoc: m, endLoc: O }), R4), e += 2;
                      continue;
                    }
                  }
                  s.type = xe(i);
                }
              }
              return t4;
            }
            var Th = class extends xh {
              parseTopLevel(t4, r) {
                return t4.program = this.parseProgram(r), t4.comments = this.state.comments, this.options.tokens && (t4.tokens = Ah(this.tokens, this.input)), this.finishNode(t4, "File");
              }
              parseProgram(t4) {
                let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 137, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
                if (t4.sourceType = e, t4.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t4, true, true, r), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
                  for (let [i, a] of Array.from(this.scope.undefinedExports))
                    this.raise(u.ModuleExportUndefined, { at: a, localName: i });
                let s;
                return r === 137 ? s = this.finishNode(t4, "Program") : s = this.finishNodeAt(t4, "Program", y(this.state.startLoc, -1)), s;
              }
              stmtToDirective(t4) {
                let r = t4;
                r.type = "Directive", r.value = r.expression, delete r.expression;
                let e = r.value, s = e.value, i = this.input.slice(e.start, e.end), a = e.value = i.slice(1, -1);
                return this.addExtra(e, "raw", i), this.addExtra(e, "rawValue", a), this.addExtra(e, "expressionValue", s), e.type = "DirectiveLiteral", r;
              }
              parseInterpreterDirective() {
                if (!this.match(28))
                  return null;
                let t4 = this.startNode();
                return t4.value = this.state.value, this.next(), this.finishNode(t4, "InterpreterDirective");
              }
              isLet() {
                return this.isContextual(99) ? this.hasFollowingBindingAtom() : false;
              }
              chStartsBindingIdentifier(t4, r) {
                if (ge(t4)) {
                  if (Ps.lastIndex = r, Ps.test(this.input)) {
                    let e = this.codePointAtPos(Ps.lastIndex);
                    if (!Re(e) && e !== 92)
                      return false;
                  }
                  return true;
                } else
                  return t4 === 92;
              }
              chStartsBindingPattern(t4) {
                return t4 === 91 || t4 === 123;
              }
              hasFollowingBindingAtom() {
                let t4 = this.nextTokenStart(), r = this.codePointAtPos(t4);
                return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t4);
              }
              hasFollowingBindingIdentifier() {
                let t4 = this.nextTokenStart(), r = this.codePointAtPos(t4);
                return this.chStartsBindingIdentifier(r, t4);
              }
              startsUsingForOf() {
                let t4 = this.lookahead();
                return t4.type === 101 && !t4.containsEsc ? false : (this.expectPlugin("explicitResourceManagement"), true);
              }
              parseModuleItem() {
                return this.parseStatementLike(ae.AllowImportExport | ae.AllowDeclaration | ae.AllowFunctionDeclaration | ae.AllowLabeledFunction);
              }
              parseStatementListItem() {
                return this.parseStatementLike(ae.AllowDeclaration | ae.AllowFunctionDeclaration | ae.AllowLabeledFunction);
              }
              parseStatementOrFunctionDeclaration(t4) {
                return this.parseStatementLike(ae.AllowFunctionDeclaration | (t4 ? 0 : ae.AllowLabeledFunction));
              }
              parseStatement() {
                return this.parseStatementLike(ae.StatementOnly);
              }
              parseStatementLike(t4) {
                let r = null;
                return this.match(26) && (r = this.parseDecorators(true)), this.parseStatementContent(t4, r);
              }
              parseStatementContent(t4, r) {
                let e = this.state.type, s = this.startNode(), i = !!(t4 & ae.AllowDeclaration), a = !!(t4 & ae.AllowFunctionDeclaration), n = t4 & ae.AllowImportExport;
                switch (e) {
                  case 60:
                    return this.parseBreakContinueStatement(s, true);
                  case 63:
                    return this.parseBreakContinueStatement(s, false);
                  case 64:
                    return this.parseDebuggerStatement(s);
                  case 90:
                    return this.parseDoWhileStatement(s);
                  case 91:
                    return this.parseForStatement(s);
                  case 68:
                    if (this.lookaheadCharCode() === 46)
                      break;
                    return i || (this.state.strict ? this.raise(u.StrictFunction, { at: this.state.startLoc }) : a || this.raise(u.SloppyFunction, { at: this.state.startLoc })), this.parseFunctionStatement(s, false, !i && a);
                  case 80:
                    return i || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, s), true);
                  case 69:
                    return this.parseIfStatement(s);
                  case 70:
                    return this.parseReturnStatement(s);
                  case 71:
                    return this.parseSwitchStatement(s);
                  case 72:
                    return this.parseThrowStatement(s);
                  case 73:
                    return this.parseTryStatement(s);
                  case 105:
                    if (this.hasFollowingLineBreak() || this.state.containsEsc || !this.hasFollowingBindingIdentifier())
                      break;
                    return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(u.UnexpectedUsingDeclaration, { at: this.state.startLoc }) : i || this.raise(u.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(s, "using");
                  case 99: {
                    if (this.state.containsEsc)
                      break;
                    let p = this.nextTokenStart(), m = this.codePointAtPos(p);
                    if (m !== 91 && (!i && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(m, p) && m !== 123))
                      break;
                  }
                  case 75:
                    i || this.raise(u.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
                  case 74: {
                    let p = this.state.value;
                    return this.parseVarStatement(s, p);
                  }
                  case 92:
                    return this.parseWhileStatement(s);
                  case 76:
                    return this.parseWithStatement(s);
                  case 5:
                    return this.parseBlock();
                  case 13:
                    return this.parseEmptyStatement(s);
                  case 83: {
                    let p = this.lookaheadCharCode();
                    if (p === 40 || p === 46)
                      break;
                  }
                  case 82: {
                    !this.options.allowImportExportEverywhere && !n && this.raise(u.UnexpectedImportExport, { at: this.state.startLoc }), this.next();
                    let p;
                    return e === 83 ? (p = this.parseImport(s), p.type === "ImportDeclaration" && (!p.importKind || p.importKind === "value") && (this.sawUnambiguousESM = true)) : (p = this.parseExport(s, r), (p.type === "ExportNamedDeclaration" && (!p.exportKind || p.exportKind === "value") || p.type === "ExportAllDeclaration" && (!p.exportKind || p.exportKind === "value") || p.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(p), p;
                  }
                  default:
                    if (this.isAsyncFunction())
                      return i || this.raise(u.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(s, true, !i && a);
                }
                let o = this.state.value, c = this.parseExpression();
                return z(e) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(s, o, c, t4) : this.parseExpressionStatement(s, c, r);
              }
              assertModuleNodeAllowed(t4) {
                !this.options.allowImportExportEverywhere && !this.inModule && this.raise(u.ImportOutsideModule, { at: t4 });
              }
              decoratorsEnabledBeforeExport() {
                return this.hasPlugin("decorators-legacy") ? true : this.hasPlugin("decorators") && !!this.getPluginOption("decorators", "decoratorsBeforeExport");
              }
              maybeTakeDecorators(t4, r, e) {
                return t4 && (r.decorators = t4, this.resetStartLocationFromNode(r, t4[0]), e && this.resetStartLocationFromNode(e, r)), r;
              }
              canHaveLeadingDecorator() {
                return this.match(80);
              }
              parseDecorators(t4) {
                let r = [];
                do
                  r.push(this.parseDecorator());
                while (this.match(26));
                if (this.match(82))
                  t4 || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(u.DecoratorExportClass, { at: this.state.startLoc });
                else if (!this.canHaveLeadingDecorator())
                  throw this.raise(u.UnexpectedLeadingDecorator, { at: this.state.startLoc });
                return r;
              }
              parseDecorator() {
                this.expectOnePlugin(["decorators", "decorators-legacy"]);
                let t4 = this.startNode();
                if (this.next(), this.hasPlugin("decorators")) {
                  let r = this.state.startLoc, e;
                  if (this.match(10)) {
                    let s = this.state.startLoc;
                    this.next(), e = this.parseExpression(), this.expect(11), e = this.wrapParenthesis(s, e);
                    let i = this.state.startLoc;
                    t4.expression = this.parseMaybeDecoratorArguments(e), this.getPluginOption("decorators", "allowCallParenthesized") === false && t4.expression !== e && this.raise(u.DecoratorArgumentsOutsideParentheses, { at: i });
                  } else {
                    for (e = this.parseIdentifier(false); this.eat(16); ) {
                      let s = this.startNodeAt(r);
                      s.object = e, this.match(136) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), s.property = this.parsePrivateName()) : s.property = this.parseIdentifier(true), s.computed = false, e = this.finishNode(s, "MemberExpression");
                    }
                    t4.expression = this.parseMaybeDecoratorArguments(e);
                  }
                } else
                  t4.expression = this.parseExprSubscripts();
                return this.finishNode(t4, "Decorator");
              }
              parseMaybeDecoratorArguments(t4) {
                if (this.eat(10)) {
                  let r = this.startNodeAtNode(t4);
                  return r.callee = t4, r.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(r.arguments), this.finishNode(r, "CallExpression");
                }
                return t4;
              }
              parseBreakContinueStatement(t4, r) {
                return this.next(), this.isLineTerminator() ? t4.label = null : (t4.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t4, r), this.finishNode(t4, r ? "BreakStatement" : "ContinueStatement");
              }
              verifyBreakContinue(t4, r) {
                let e;
                for (e = 0; e < this.state.labels.length; ++e) {
                  let s = this.state.labels[e];
                  if ((t4.label == null || s.name === t4.label.name) && (s.kind != null && (r || s.kind === "loop") || t4.label && r))
                    break;
                }
                if (e === this.state.labels.length) {
                  let s = r ? "BreakStatement" : "ContinueStatement";
                  this.raise(u.IllegalBreakContinue, { at: t4, type: s });
                }
              }
              parseDebuggerStatement(t4) {
                return this.next(), this.semicolon(), this.finishNode(t4, "DebuggerStatement");
              }
              parseHeaderExpression() {
                this.expect(10);
                let t4 = this.parseExpression();
                return this.expect(11), t4;
              }
              parseDoWhileStatement(t4) {
                return this.next(), this.state.labels.push(gs), t4.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t4.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t4, "DoWhileStatement");
              }
              parseForStatement(t4) {
                this.next(), this.state.labels.push(gs);
                let r = null;
                if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(je), this.expect(10), this.match(13))
                  return r !== null && this.unexpected(r), this.parseFor(t4, null);
                let e = this.isContextual(99), s = this.isContextual(105) && !this.hasFollowingLineBreak(), i = e && this.hasFollowingBindingAtom() || s && this.hasFollowingBindingIdentifier() && this.startsUsingForOf();
                if (this.match(74) || this.match(75) || i) {
                  let p = this.startNode(), m = this.state.value;
                  this.next(), this.parseVar(p, true, m);
                  let x = this.finishNode(p, "VariableDeclaration"), A = this.match(58);
                  return A && s && this.raise(u.ForInUsing, { at: x }), (A || this.isContextual(101)) && x.declarations.length === 1 ? this.parseForIn(t4, x, r) : (r !== null && this.unexpected(r), this.parseFor(t4, x));
                }
                let a = this.isContextual(95), n = new Ct(), o = this.parseExpression(true, n), c = this.isContextual(101);
                if (c && (e && this.raise(u.ForOfLet, { at: o }), r === null && a && o.type === "Identifier" && this.raise(u.ForOfAsync, { at: o })), c || this.match(58)) {
                  this.checkDestructuringPrivate(n), this.toAssignable(o, true);
                  let p = c ? "ForOfStatement" : "ForInStatement";
                  return this.checkLVal(o, { in: { type: p } }), this.parseForIn(t4, o, r);
                } else
                  this.checkExpressionErrors(n, true);
                return r !== null && this.unexpected(r), this.parseFor(t4, o);
              }
              parseFunctionStatement(t4, r, e) {
                return this.next(), this.parseFunction(t4, ie.Declaration | (e ? ie.HangingDeclaration : 0) | (r ? ie.Async : 0));
              }
              parseIfStatement(t4) {
                return this.next(), t4.test = this.parseHeaderExpression(), t4.consequent = this.parseStatementOrFunctionDeclaration(true), t4.alternate = this.eat(66) ? this.parseStatementOrFunctionDeclaration(true) : null, this.finishNode(t4, "IfStatement");
              }
              parseReturnStatement(t4) {
                return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(u.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? t4.argument = null : (t4.argument = this.parseExpression(), this.semicolon()), this.finishNode(t4, "ReturnStatement");
              }
              parseSwitchStatement(t4) {
                this.next(), t4.discriminant = this.parseHeaderExpression();
                let r = t4.cases = [];
                this.expect(5), this.state.labels.push(gh), this.scope.enter(je);
                let e;
                for (let s; !this.match(8); )
                  if (this.match(61) || this.match(65)) {
                    let i = this.match(61);
                    e && this.finishNode(e, "SwitchCase"), r.push(e = this.startNode()), e.consequent = [], this.next(), i ? e.test = this.parseExpression() : (s && this.raise(u.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), s = true, e.test = null), this.expect(14);
                  } else
                    e ? e.consequent.push(this.parseStatementListItem()) : this.unexpected();
                return this.scope.exit(), e && this.finishNode(e, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t4, "SwitchStatement");
              }
              parseThrowStatement(t4) {
                return this.next(), this.hasPrecedingLineBreak() && this.raise(u.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), t4.argument = this.parseExpression(), this.semicolon(), this.finishNode(t4, "ThrowStatement");
              }
              parseCatchClauseParam() {
                let t4 = this.parseBindingAtom(), r = t4.type === "Identifier";
                return this.scope.enter(r ? Sr : 0), this.checkLVal(t4, { in: { type: "CatchClause" }, binding: De, allowingSloppyLetBinding: true }), t4;
              }
              parseTryStatement(t4) {
                if (this.next(), t4.block = this.parseBlock(), t4.handler = null, this.match(62)) {
                  let r = this.startNode();
                  this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.enter(je)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t4.handler = this.finishNode(r, "CatchClause");
                }
                return t4.finalizer = this.eat(67) ? this.parseBlock() : null, !t4.handler && !t4.finalizer && this.raise(u.NoCatchOrFinally, { at: t4 }), this.finishNode(t4, "TryStatement");
              }
              parseVarStatement(t4, r) {
                let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                return this.next(), this.parseVar(t4, false, r, e), this.semicolon(), this.finishNode(t4, "VariableDeclaration");
              }
              parseWhileStatement(t4) {
                return this.next(), t4.test = this.parseHeaderExpression(), this.state.labels.push(gs), t4.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t4, "WhileStatement");
              }
              parseWithStatement(t4) {
                return this.state.strict && this.raise(u.StrictWith, { at: this.state.startLoc }), this.next(), t4.object = this.parseHeaderExpression(), t4.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t4, "WithStatement");
              }
              parseEmptyStatement(t4) {
                return this.next(), this.finishNode(t4, "EmptyStatement");
              }
              parseLabeledStatement(t4, r, e, s) {
                for (let a of this.state.labels)
                  a.name === r && this.raise(u.LabelRedeclaration, { at: e, labelName: r });
                let i = Jo(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
                for (let a = this.state.labels.length - 1; a >= 0; a--) {
                  let n = this.state.labels[a];
                  if (n.statementStart === t4.start)
                    n.statementStart = this.state.start, n.kind = i;
                  else
                    break;
                }
                return this.state.labels.push({ name: r, kind: i, statementStart: this.state.start }), t4.body = s & ae.AllowLabeledFunction ? this.parseStatementOrFunctionDeclaration(false) : this.parseStatement(), this.state.labels.pop(), t4.label = e, this.finishNode(t4, "LabeledStatement");
              }
              parseExpressionStatement(t4, r, e) {
                return t4.expression = r, this.semicolon(), this.finishNode(t4, "ExpressionStatement");
              }
              parseBlock() {
                let t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, e = arguments.length > 2 ? arguments[2] : void 0, s = this.startNode();
                return t4 && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(je), this.parseBlockBody(s, t4, false, 8, e), r && this.scope.exit(), this.finishNode(s, "BlockStatement");
              }
              isValidDirective(t4) {
                return t4.type === "ExpressionStatement" && t4.expression.type === "StringLiteral" && !t4.expression.extra.parenthesized;
              }
              parseBlockBody(t4, r, e, s, i) {
                let a = t4.body = [], n = t4.directives = [];
                this.parseBlockOrModuleBlockBody(a, r ? n : void 0, e, s, i);
              }
              parseBlockOrModuleBlockBody(t4, r, e, s, i) {
                let a = this.state.strict, n = false, o = false;
                for (; !this.match(s); ) {
                  let c = e ? this.parseModuleItem() : this.parseStatementListItem();
                  if (r && !o) {
                    if (this.isValidDirective(c)) {
                      let p = this.stmtToDirective(c);
                      r.push(p), !n && p.value.value === "use strict" && (n = true, this.setStrict(true));
                      continue;
                    }
                    o = true, this.state.strictErrors.clear();
                  }
                  t4.push(c);
                }
                i && i.call(this, n), a || this.setStrict(false), this.next();
              }
              parseFor(t4, r) {
                return t4.init = r, this.semicolon(false), t4.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t4.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t4.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t4, "ForStatement");
              }
              parseForIn(t4, r, e) {
                let s = this.match(58);
                return this.next(), s ? e !== null && this.unexpected(e) : t4.await = e !== null, r.type === "VariableDeclaration" && r.declarations[0].init != null && (!s || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") && this.raise(u.ForInOfLoopInitializer, { at: r, type: s ? "ForInStatement" : "ForOfStatement" }), r.type === "AssignmentPattern" && this.raise(u.InvalidLhs, { at: r, ancestor: { type: "ForStatement" } }), t4.left = r, t4.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t4.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t4, s ? "ForInStatement" : "ForOfStatement");
              }
              parseVar(t4, r, e) {
                let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, i = t4.declarations = [];
                for (t4.kind = e; ; ) {
                  let a = this.startNode();
                  if (this.parseVarId(a, e), a.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a.init === null && !s && (a.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(101))) ? this.raise(u.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" }) : e === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(u.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" })), i.push(this.finishNode(a, "VariableDeclarator")), !this.eat(12))
                    break;
                }
                return t4;
              }
              parseVarId(t4, r) {
                let e = this.parseBindingAtom();
                this.checkLVal(e, { in: { type: "VariableDeclarator" }, binding: r === "var" ? xt : De }), t4.id = e;
              }
              parseAsyncFunctionExpression(t4) {
                return this.parseFunction(t4, ie.Async);
              }
              parseFunction(t4) {
                let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ie.Expression, e = r & ie.HangingDeclaration, s = !!(r & ie.Declaration), i = s && !(r & ie.NullableId), a = !!(r & ie.Async);
                this.initFunction(t4, a), this.match(55) && (e && this.raise(u.GeneratorInSingleStatementContext, { at: this.state.startLoc }), this.next(), t4.generator = true), s && (t4.id = this.parseFunctionId(i));
                let n = this.state.maybeInArrowParameters;
                return this.state.maybeInArrowParameters = false, this.scope.enter(Pe), this.prodParam.enter(Et(a, t4.generator)), s || (t4.id = this.parseFunctionId()), this.parseFunctionParams(t4, false), this.withSmartMixTopicForbiddingContext(() => {
                  this.parseFunctionBodyAndFinish(t4, s ? "FunctionDeclaration" : "FunctionExpression");
                }), this.prodParam.exit(), this.scope.exit(), s && !e && this.registerFunctionStatementId(t4), this.state.maybeInArrowParameters = n, t4;
              }
              parseFunctionId(t4) {
                return t4 || z(this.state.type) ? this.parseIdentifier() : null;
              }
              parseFunctionParams(t4, r) {
                this.expect(10), this.expressionScope.enter(ql()), t4.params = this.parseBindingList(11, 41, false, r), this.expressionScope.exit();
              }
              registerFunctionStatementId(t4) {
                t4.id && this.scope.declareName(t4.id.name, this.state.strict || t4.generator || t4.async ? this.scope.treatFunctionsAsVar ? xt : De : Dr, t4.id.loc.start);
              }
              parseClass(t4, r, e) {
                this.next();
                let s = this.state.strict;
                return this.state.strict = true, this.parseClassId(t4, r, e), this.parseClassSuper(t4), t4.body = this.parseClassBody(!!t4.superClass, s), this.finishNode(t4, r ? "ClassDeclaration" : "ClassExpression");
              }
              isClassProperty() {
                return this.match(29) || this.match(13) || this.match(8);
              }
              isClassMethod() {
                return this.match(10);
              }
              isNonstaticConstructor(t4) {
                return !t4.computed && !t4.static && (t4.key.name === "constructor" || t4.key.value === "constructor");
              }
              parseClassBody(t4, r) {
                this.classScope.enter();
                let e = { hadConstructor: false, hadSuperClass: t4 }, s = [], i = this.startNode();
                if (i.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
                  for (; !this.match(8); ) {
                    if (this.eat(13)) {
                      if (s.length > 0)
                        throw this.raise(u.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                      continue;
                    }
                    if (this.match(26)) {
                      s.push(this.parseDecorator());
                      continue;
                    }
                    let a = this.startNode();
                    s.length && (a.decorators = s, this.resetStartLocationFromNode(a, s[0]), s = []), this.parseClassMember(i, a, e), a.kind === "constructor" && a.decorators && a.decorators.length > 0 && this.raise(u.DecoratorConstructor, { at: a });
                  }
                }), this.state.strict = r, this.next(), s.length)
                  throw this.raise(u.TrailingDecorator, { at: this.state.startLoc });
                return this.classScope.exit(), this.finishNode(i, "ClassBody");
              }
              parseClassMemberFromModifier(t4, r) {
                let e = this.parseIdentifier(true);
                if (this.isClassMethod()) {
                  let s = r;
                  return s.kind = "method", s.computed = false, s.key = e, s.static = false, this.pushClassMethod(t4, s, false, false, false, false), true;
                } else if (this.isClassProperty()) {
                  let s = r;
                  return s.computed = false, s.key = e, s.static = false, t4.body.push(this.parseClassProperty(s)), true;
                }
                return this.resetPreviousNodeTrailingComments(e), false;
              }
              parseClassMember(t4, r, e) {
                let s = this.isContextual(104);
                if (s) {
                  if (this.parseClassMemberFromModifier(t4, r))
                    return;
                  if (this.eat(5)) {
                    this.parseClassStaticBlock(t4, r);
                    return;
                  }
                }
                this.parseClassMemberWithIsStatic(t4, r, e, s);
              }
              parseClassMemberWithIsStatic(t4, r, e, s) {
                let i = r, a = r, n = r, o = r, c = r, p = i, m = i;
                if (r.static = s, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
                  p.kind = "method";
                  let R4 = this.match(136);
                  if (this.parseClassElementName(p), R4) {
                    this.pushClassPrivateMethod(t4, a, true, false);
                    return;
                  }
                  this.isNonstaticConstructor(i) && this.raise(u.ConstructorIsGenerator, { at: i.key }), this.pushClassMethod(t4, i, true, false, false, false);
                  return;
                }
                let x = z(this.state.type) && !this.state.containsEsc, A = this.match(136), b = this.parseClassElementName(r), O = this.state.startLoc;
                if (this.parsePostMemberNameModifiers(m), this.isClassMethod()) {
                  if (p.kind = "method", A) {
                    this.pushClassPrivateMethod(t4, a, false, false);
                    return;
                  }
                  let R4 = this.isNonstaticConstructor(i), Y = false;
                  R4 && (i.kind = "constructor", e.hadConstructor && !this.hasPlugin("typescript") && this.raise(u.DuplicateConstructor, { at: b }), R4 && this.hasPlugin("typescript") && r.override && this.raise(u.OverrideOnConstructor, { at: b }), e.hadConstructor = true, Y = e.hadSuperClass), this.pushClassMethod(t4, i, false, false, R4, Y);
                } else if (this.isClassProperty())
                  A ? this.pushClassPrivateProperty(t4, o) : this.pushClassProperty(t4, n);
                else if (x && b.name === "async" && !this.isLineTerminator()) {
                  this.resetPreviousNodeTrailingComments(b);
                  let R4 = this.eat(55);
                  m.optional && this.unexpected(O), p.kind = "method";
                  let Y = this.match(136);
                  this.parseClassElementName(p), this.parsePostMemberNameModifiers(m), Y ? this.pushClassPrivateMethod(t4, a, R4, true) : (this.isNonstaticConstructor(i) && this.raise(u.ConstructorIsAsync, { at: i.key }), this.pushClassMethod(t4, i, R4, true, false, false));
                } else if (x && (b.name === "get" || b.name === "set") && !(this.match(55) && this.isLineTerminator())) {
                  this.resetPreviousNodeTrailingComments(b), p.kind = b.name;
                  let R4 = this.match(136);
                  this.parseClassElementName(i), R4 ? this.pushClassPrivateMethod(t4, a, false, false) : (this.isNonstaticConstructor(i) && this.raise(u.ConstructorIsAccessor, { at: i.key }), this.pushClassMethod(t4, i, false, false, false, false)), this.checkGetterSetterParams(i);
                } else if (x && b.name === "accessor" && !this.isLineTerminator()) {
                  this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(b);
                  let R4 = this.match(136);
                  this.parseClassElementName(n), this.pushClassAccessorProperty(t4, c, R4);
                } else
                  this.isLineTerminator() ? A ? this.pushClassPrivateProperty(t4, o) : this.pushClassProperty(t4, n) : this.unexpected();
              }
              parseClassElementName(t4) {
                let { type: r, value: e } = this.state;
                if ((r === 130 || r === 131) && t4.static && e === "prototype" && this.raise(u.StaticPrototype, { at: this.state.startLoc }), r === 136) {
                  e === "constructor" && this.raise(u.ConstructorClassPrivateField, { at: this.state.startLoc });
                  let s = this.parsePrivateName();
                  return t4.key = s, s;
                }
                return this.parsePropertyName(t4);
              }
              parseClassStaticBlock(t4, r) {
                var e;
                this.scope.enter(Ne | ft | pt);
                let s = this.state.labels;
                this.state.labels = [], this.prodParam.enter($e);
                let i = r.body = [];
                this.parseBlockOrModuleBlockBody(i, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s, t4.body.push(this.finishNode(r, "StaticBlock")), (e = r.decorators) != null && e.length && this.raise(u.DecoratorStaticBlock, { at: r });
              }
              pushClassProperty(t4, r) {
                !r.computed && (r.key.name === "constructor" || r.key.value === "constructor") && this.raise(u.ConstructorClassField, { at: r.key }), t4.body.push(this.parseClassProperty(r));
              }
              pushClassPrivateProperty(t4, r) {
                let e = this.parseClassPrivateProperty(r);
                t4.body.push(e), this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), hs, e.key.loc.start);
              }
              pushClassAccessorProperty(t4, r, e) {
                if (!e && !r.computed) {
                  let i = r.key;
                  (i.name === "constructor" || i.value === "constructor") && this.raise(u.ConstructorClassField, { at: i });
                }
                let s = this.parseClassAccessorProperty(r);
                t4.body.push(s), e && this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), hs, s.key.loc.start);
              }
              pushClassMethod(t4, r, e, s, i, a) {
                t4.body.push(this.parseMethod(r, e, s, i, a, "ClassMethod", true));
              }
              pushClassPrivateMethod(t4, r, e, s) {
                let i = this.parseMethod(r, e, s, false, false, "ClassPrivateMethod", true);
                t4.body.push(i);
                let a = i.kind === "get" ? i.static ? gl : Al : i.kind === "set" ? i.static ? Pl : Tl : hs;
                this.declareClassPrivateMethodInScope(i, a);
              }
              declareClassPrivateMethodInScope(t4, r) {
                this.classScope.declarePrivateName(this.getPrivateNameSV(t4.key), r, t4.key.loc.start);
              }
              parsePostMemberNameModifiers(t4) {
              }
              parseClassPrivateProperty(t4) {
                return this.parseInitializer(t4), this.semicolon(), this.finishNode(t4, "ClassPrivateProperty");
              }
              parseClassProperty(t4) {
                return this.parseInitializer(t4), this.semicolon(), this.finishNode(t4, "ClassProperty");
              }
              parseClassAccessorProperty(t4) {
                return this.parseInitializer(t4), this.semicolon(), this.finishNode(t4, "ClassAccessorProperty");
              }
              parseInitializer(t4) {
                this.scope.enter(Ne | pt), this.expressionScope.enter(Vr()), this.prodParam.enter($e), t4.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
              }
              parseClassId(t4, r, e) {
                let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : kr;
                if (z(this.state.type))
                  t4.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t4.id, s);
                else if (e || !r)
                  t4.id = null;
                else
                  throw this.raise(u.MissingClassName, { at: this.state.startLoc });
              }
              parseClassSuper(t4) {
                t4.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
              }
              parseExport(t4, r) {
                let e = this.maybeParseExportDefaultSpecifier(t4), s = !e || this.eat(12), i = s && this.eatExportStar(t4), a = i && this.maybeParseExportNamespaceSpecifier(t4), n = s && (!a || this.eat(12)), o = e || i;
                if (i && !a) {
                  if (e && this.unexpected(), r)
                    throw this.raise(u.UnsupportedDecoratorExport, { at: t4 });
                  return this.parseExportFrom(t4, true), this.finishNode(t4, "ExportAllDeclaration");
                }
                let c = this.maybeParseExportNamedSpecifiers(t4);
                if (e && s && !i && !c || a && n && !c)
                  throw this.unexpected(null, 5);
                let p;
                if (o || c) {
                  if (p = false, r)
                    throw this.raise(u.UnsupportedDecoratorExport, { at: t4 });
                  this.parseExportFrom(t4, o);
                } else
                  p = this.maybeParseExportDeclaration(t4);
                if (o || c || p) {
                  var m;
                  let x = t4;
                  if (this.checkExport(x, true, false, !!x.source), ((m = x.declaration) == null ? void 0 : m.type) === "ClassDeclaration")
                    this.maybeTakeDecorators(r, x.declaration, x);
                  else if (r)
                    throw this.raise(u.UnsupportedDecoratorExport, { at: t4 });
                  return this.finishNode(x, "ExportNamedDeclaration");
                }
                if (this.eat(65)) {
                  let x = t4, A = this.parseExportDefaultExpression();
                  if (x.declaration = A, A.type === "ClassDeclaration")
                    this.maybeTakeDecorators(r, A, x);
                  else if (r)
                    throw this.raise(u.UnsupportedDecoratorExport, { at: t4 });
                  return this.checkExport(x, true, true), this.finishNode(x, "ExportDefaultDeclaration");
                }
                throw this.unexpected(null, 5);
              }
              eatExportStar(t4) {
                return this.eat(55);
              }
              maybeParseExportDefaultSpecifier(t4) {
                if (this.isExportDefaultSpecifier()) {
                  this.expectPlugin("exportDefaultFrom");
                  let r = this.startNode();
                  return r.exported = this.parseIdentifier(true), t4.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], true;
                }
                return false;
              }
              maybeParseExportNamespaceSpecifier(t4) {
                if (this.isContextual(93)) {
                  t4.specifiers || (t4.specifiers = []);
                  let r = this.startNodeAt(this.state.lastTokStartLoc);
                  return this.next(), r.exported = this.parseModuleExportName(), t4.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), true;
                }
                return false;
              }
              maybeParseExportNamedSpecifiers(t4) {
                if (this.match(5)) {
                  t4.specifiers || (t4.specifiers = []);
                  let r = t4.exportKind === "type";
                  return t4.specifiers.push(...this.parseExportSpecifiers(r)), t4.source = null, t4.declaration = null, this.hasPlugin("importAssertions") && (t4.assertions = []), true;
                }
                return false;
              }
              maybeParseExportDeclaration(t4) {
                return this.shouldParseExportDeclaration() ? (t4.specifiers = [], t4.source = null, this.hasPlugin("importAssertions") && (t4.assertions = []), t4.declaration = this.parseExportDeclaration(t4), true) : false;
              }
              isAsyncFunction() {
                if (!this.isContextual(95))
                  return false;
                let t4 = this.nextTokenStart();
                return !ps.test(this.input.slice(this.state.pos, t4)) && this.isUnparsedContextual(t4, "function");
              }
              parseExportDefaultExpression() {
                let t4 = this.startNode();
                if (this.match(68))
                  return this.next(), this.parseFunction(t4, ie.Declaration | ie.NullableId);
                if (this.isAsyncFunction())
                  return this.next(), this.next(), this.parseFunction(t4, ie.Declaration | ie.NullableId | ie.Async);
                if (this.match(80))
                  return this.parseClass(t4, true, true);
                if (this.match(26))
                  return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(u.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
                if (this.match(75) || this.match(74) || this.isLet())
                  throw this.raise(u.UnsupportedDefaultExport, { at: this.state.startLoc });
                let r = this.parseMaybeAssignAllowIn();
                return this.semicolon(), r;
              }
              parseExportDeclaration(t4) {
                return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
              }
              isExportDefaultSpecifier() {
                let { type: t4 } = this.state;
                if (z(t4)) {
                  if (t4 === 95 && !this.state.containsEsc || t4 === 99)
                    return false;
                  if ((t4 === 128 || t4 === 127) && !this.state.containsEsc) {
                    let { type: s } = this.lookahead();
                    if (z(s) && s !== 97 || s === 5)
                      return this.expectOnePlugin(["flow", "typescript"]), false;
                  }
                } else if (!this.match(65))
                  return false;
                let r = this.nextTokenStart(), e = this.isUnparsedContextual(r, "from");
                if (this.input.charCodeAt(r) === 44 || z(this.state.type) && e)
                  return true;
                if (this.match(65) && e) {
                  let s = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
                  return s === 34 || s === 39;
                }
                return false;
              }
              parseExportFrom(t4, r) {
                if (this.eatContextual(97)) {
                  t4.source = this.parseImportSource(), this.checkExport(t4);
                  let e = this.maybeParseImportAssertions();
                  e && (t4.assertions = e, this.checkJSONModuleImport(t4));
                } else
                  r && this.unexpected();
                this.semicolon();
              }
              shouldParseExportDeclaration() {
                let { type: t4 } = this.state;
                if (t4 === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
                  if (this.getPluginOption("decorators", "decoratorsBeforeExport"))
                    throw this.raise(u.DecoratorBeforeExport, { at: this.state.startLoc });
                  return true;
                }
                return t4 === 74 || t4 === 75 || t4 === 68 || t4 === 80 || this.isLet() || this.isAsyncFunction();
              }
              checkExport(t4, r, e, s) {
                if (r) {
                  if (e) {
                    if (this.checkDuplicateExports(t4, "default"), this.hasPlugin("exportDefaultFrom")) {
                      var i;
                      let a = t4.declaration;
                      a.type === "Identifier" && a.name === "from" && a.end - a.start === 4 && !((i = a.extra) != null && i.parenthesized) && this.raise(u.ExportDefaultFromAsIdentifier, { at: a });
                    }
                  } else if (t4.specifiers && t4.specifiers.length)
                    for (let a of t4.specifiers) {
                      let { exported: n } = a, o = n.type === "Identifier" ? n.name : n.value;
                      if (this.checkDuplicateExports(a, o), !s && a.local) {
                        let { local: c } = a;
                        c.type !== "Identifier" ? this.raise(u.ExportBindingIsString, { at: a, localName: c.value, exportName: o }) : (this.checkReservedWord(c.name, c.loc.start, true, false), this.scope.checkLocalExport(c));
                      }
                    }
                  else if (t4.declaration) {
                    if (t4.declaration.type === "FunctionDeclaration" || t4.declaration.type === "ClassDeclaration") {
                      let a = t4.declaration.id;
                      if (!a)
                        throw new Error("Assertion failure");
                      this.checkDuplicateExports(t4, a.name);
                    } else if (t4.declaration.type === "VariableDeclaration")
                      for (let a of t4.declaration.declarations)
                        this.checkDeclaration(a.id);
                  }
                }
              }
              checkDeclaration(t4) {
                if (t4.type === "Identifier")
                  this.checkDuplicateExports(t4, t4.name);
                else if (t4.type === "ObjectPattern")
                  for (let r of t4.properties)
                    this.checkDeclaration(r);
                else if (t4.type === "ArrayPattern")
                  for (let r of t4.elements)
                    r && this.checkDeclaration(r);
                else
                  t4.type === "ObjectProperty" ? this.checkDeclaration(t4.value) : t4.type === "RestElement" ? this.checkDeclaration(t4.argument) : t4.type === "AssignmentPattern" && this.checkDeclaration(t4.left);
              }
              checkDuplicateExports(t4, r) {
                this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(u.DuplicateDefaultExport, { at: t4 }) : this.raise(u.DuplicateExport, { at: t4, exportName: r })), this.exportedIdentifiers.add(r);
              }
              parseExportSpecifiers(t4) {
                let r = [], e = true;
                for (this.expect(5); !this.eat(8); ) {
                  if (e)
                    e = false;
                  else if (this.expect(12), this.eat(8))
                    break;
                  let s = this.isContextual(128), i = this.match(131), a = this.startNode();
                  a.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(a, i, t4, s));
                }
                return r;
              }
              parseExportSpecifier(t4, r, e, s) {
                return this.eatContextual(93) ? t4.exported = this.parseModuleExportName() : r ? t4.exported = Kl(t4.local) : t4.exported || (t4.exported = Te(t4.local)), this.finishNode(t4, "ExportSpecifier");
              }
              parseModuleExportName() {
                if (this.match(131)) {
                  let t4 = this.parseStringLiteral(this.state.value), r = t4.value.match(Ph);
                  return r && this.raise(u.ModuleExportNameHasLoneSurrogate, { at: t4, surrogateCharCode: r[0].charCodeAt(0) }), t4;
                }
                return this.parseIdentifier(true);
              }
              isJSONModuleImport(t4) {
                return t4.assertions != null ? t4.assertions.some((r) => {
                  let { key: e, value: s } = r;
                  return s.value === "json" && (e.type === "Identifier" ? e.name === "type" : e.value === "type");
                }) : false;
              }
              checkImportReflection(t4) {
                if (t4.module) {
                  var r;
                  (t4.specifiers.length !== 1 || t4.specifiers[0].type !== "ImportDefaultSpecifier") && this.raise(u.ImportReflectionNotBinding, { at: t4.specifiers[0].loc.start }), ((r = t4.assertions) == null ? void 0 : r.length) > 0 && this.raise(u.ImportReflectionHasAssertion, { at: t4.specifiers[0].loc.start });
                }
              }
              checkJSONModuleImport(t4) {
                if (this.isJSONModuleImport(t4) && t4.type !== "ExportAllDeclaration") {
                  let { specifiers: r } = t4;
                  if (r != null) {
                    let e = r.find((s) => {
                      let i;
                      if (s.type === "ExportSpecifier" ? i = s.local : s.type === "ImportSpecifier" && (i = s.imported), i !== void 0)
                        return i.type === "Identifier" ? i.name !== "default" : i.value !== "default";
                    });
                    e !== void 0 && this.raise(u.ImportJSONBindingNotDefault, { at: e.loc.start });
                  }
                }
              }
              parseMaybeImportReflection(t4) {
                let r = false;
                if (this.isContextual(125)) {
                  let e = this.lookahead(), s = e.type;
                  z(s) ? (s !== 97 || this.input.charCodeAt(this.nextTokenStartSince(e.end)) === 102) && (r = true) : s !== 12 && (r = true);
                }
                r ? (this.expectPlugin("importReflection"), this.next(), t4.module = true) : this.hasPlugin("importReflection") && (t4.module = false);
              }
              parseImport(t4) {
                if (t4.specifiers = [], !this.match(131)) {
                  this.parseMaybeImportReflection(t4);
                  let s = !this.maybeParseDefaultImportSpecifier(t4) || this.eat(12), i = s && this.maybeParseStarImportSpecifier(t4);
                  s && !i && this.parseNamedImportSpecifiers(t4), this.expectContextual(97);
                }
                t4.source = this.parseImportSource();
                let r = this.maybeParseImportAssertions();
                if (r)
                  t4.assertions = r;
                else {
                  let e = this.maybeParseModuleAttributes();
                  e && (t4.attributes = e);
                }
                return this.checkImportReflection(t4), this.checkJSONModuleImport(t4), this.semicolon(), this.finishNode(t4, "ImportDeclaration");
              }
              parseImportSource() {
                return this.match(131) || this.unexpected(), this.parseExprAtom();
              }
              shouldParseDefaultImport(t4) {
                return z(this.state.type);
              }
              parseImportSpecifierLocal(t4, r, e) {
                r.local = this.parseIdentifier(), t4.specifiers.push(this.finishImportSpecifier(r, e));
              }
              finishImportSpecifier(t4, r) {
                let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : De;
                return this.checkLVal(t4.local, { in: t4, binding: e }), this.finishNode(t4, r);
              }
              parseAssertEntries() {
                let t4 = [], r = /* @__PURE__ */ new Set();
                do {
                  if (this.match(8))
                    break;
                  let e = this.startNode(), s = this.state.value;
                  if (r.has(s) && this.raise(u.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: s }), r.add(s), this.match(131) ? e.key = this.parseStringLiteral(s) : e.key = this.parseIdentifier(true), this.expect(14), !this.match(131))
                    throw this.raise(u.ModuleAttributeInvalidValue, { at: this.state.startLoc });
                  e.value = this.parseStringLiteral(this.state.value), t4.push(this.finishNode(e, "ImportAttribute"));
                } while (this.eat(12));
                return t4;
              }
              maybeParseModuleAttributes() {
                if (this.match(76) && !this.hasPrecedingLineBreak())
                  this.expectPlugin("moduleAttributes"), this.next();
                else
                  return this.hasPlugin("moduleAttributes") ? [] : null;
                let t4 = [], r = /* @__PURE__ */ new Set();
                do {
                  let e = this.startNode();
                  if (e.key = this.parseIdentifier(true), e.key.name !== "type" && this.raise(u.ModuleAttributeDifferentFromType, { at: e.key }), r.has(e.key.name) && this.raise(u.ModuleAttributesWithDuplicateKeys, { at: e.key, key: e.key.name }), r.add(e.key.name), this.expect(14), !this.match(131))
                    throw this.raise(u.ModuleAttributeInvalidValue, { at: this.state.startLoc });
                  e.value = this.parseStringLiteral(this.state.value), this.finishNode(e, "ImportAttribute"), t4.push(e);
                } while (this.eat(12));
                return t4;
              }
              maybeParseImportAssertions() {
                if (this.isContextual(94) && !this.hasPrecedingLineBreak())
                  this.expectPlugin("importAssertions"), this.next();
                else
                  return this.hasPlugin("importAssertions") ? [] : null;
                this.eat(5);
                let t4 = this.parseAssertEntries();
                return this.eat(8), t4;
              }
              maybeParseDefaultImportSpecifier(t4) {
                return this.shouldParseDefaultImport(t4) ? (this.parseImportSpecifierLocal(t4, this.startNode(), "ImportDefaultSpecifier"), true) : false;
              }
              maybeParseStarImportSpecifier(t4) {
                if (this.match(55)) {
                  let r = this.startNode();
                  return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t4, r, "ImportNamespaceSpecifier"), true;
                }
                return false;
              }
              parseNamedImportSpecifiers(t4) {
                let r = true;
                for (this.expect(5); !this.eat(8); ) {
                  if (r)
                    r = false;
                  else {
                    if (this.eat(14))
                      throw this.raise(u.DestructureNamedImport, { at: this.state.startLoc });
                    if (this.expect(12), this.eat(8))
                      break;
                  }
                  let e = this.startNode(), s = this.match(131), i = this.isContextual(128);
                  e.imported = this.parseModuleExportName();
                  let a = this.parseImportSpecifier(e, s, t4.importKind === "type" || t4.importKind === "typeof", i, void 0);
                  t4.specifiers.push(a);
                }
              }
              parseImportSpecifier(t4, r, e, s, i) {
                if (this.eatContextual(93))
                  t4.local = this.parseIdentifier();
                else {
                  let { imported: a } = t4;
                  if (r)
                    throw this.raise(u.ImportBindingIsString, { at: t4, importName: a.value });
                  this.checkReservedWord(a.name, t4.loc.start, true, true), t4.local || (t4.local = Te(a));
                }
                return this.finishImportSpecifier(t4, "ImportSpecifier", i);
              }
              isThisParam(t4) {
                return t4.type === "Identifier" && t4.name === "this";
              }
            }, ai = class extends Th {
              constructor(t4, r) {
                t4 = dh(t4), super(t4, r), this.options = t4, this.initializeScopes(), this.plugins = vh(this.options.plugins), this.filename = t4.sourceFilename;
              }
              getScopeHandler() {
                return cs;
              }
              parse() {
                this.enterInitialScopes();
                let t4 = this.startNode(), r = this.startNode();
                return this.nextToken(), t4.errors = null, this.parseTopLevel(t4, r), t4.errors = this.state.errors, t4;
              }
            };
            function vh(t4) {
              let r = /* @__PURE__ */ new Map();
              for (let e of t4) {
                let [s, i] = Array.isArray(e) ? e : [e, {}];
                r.has(s) || r.set(s, i || {});
              }
              return r;
            }
            function Eh(t4, r) {
              var e;
              if (((e = r) == null ? void 0 : e.sourceType) === "unambiguous") {
                r = Object.assign({}, r);
                try {
                  r.sourceType = "module";
                  let s = st(r, t4), i = s.parse();
                  if (s.sawUnambiguousESM)
                    return i;
                  if (s.ambiguousScriptDifferentAst)
                    try {
                      return r.sourceType = "script", st(r, t4).parse();
                    } catch {
                    }
                  else
                    i.program.sourceType = "script";
                  return i;
                } catch (s) {
                  try {
                    return r.sourceType = "script", st(r, t4).parse();
                  } catch {
                  }
                  throw s;
                }
              } else
                return st(r, t4).parse();
            }
            function Ch(t4, r) {
              let e = st(r, t4);
              return e.options.strictMode && (e.state.strict = true), e.getExpression();
            }
            function bh(t4) {
              let r = {};
              for (let e of Object.keys(t4))
                r[e] = xe(t4[e]);
              return r;
            }
            var Sh = bh(Vo);
            function st(t4, r) {
              let e = ai;
              return t4 != null && t4.plugins && (ph(t4.plugins), e = wh(t4.plugins)), new e(t4, r);
            }
            var ni = {};
            function wh(t4) {
              let r = fh.filter((i) => te(t4, i)), e = r.join("/"), s = ni[e];
              if (!s) {
                s = ai;
                for (let i of r)
                  s = si[i](s);
                ni[e] = s;
              }
              return s;
            }
            l.parse = Eh, l.parseExpression = Ch, l.tokTypes = Sh;
          } }), Gf = K({ "src/language-js/parse/json.js"(l, h2) {
            "use strict";
            V();
            var f = mr(), d = yr(), y = _o(), P = Ro();
            function g() {
              let C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { allowComments: L = true } = C;
              return function(k) {
                let { parseExpression: H } = Uo(), W;
                try {
                  W = H(k, { tokens: true, ranges: true });
                } catch (B) {
                  throw P(B);
                }
                if (!L && f(W.comments))
                  throw T(W.comments[0], "Comment");
                return S(W), W;
              };
            }
            function T(C, L) {
              let [j, k] = [C.loc.start, C.loc.end].map((H) => {
                let { line: W, column: B } = H;
                return { line: W, column: B + 1 };
              });
              return d(`${L} is not allowed in JSON.`, { start: j, end: k });
            }
            function S(C) {
              switch (C.type) {
                case "ArrayExpression":
                  for (let L of C.elements)
                    L !== null && S(L);
                  return;
                case "ObjectExpression":
                  for (let L of C.properties)
                    S(L);
                  return;
                case "ObjectProperty":
                  if (C.computed)
                    throw T(C.key, "Computed key");
                  if (C.shorthand)
                    throw T(C.key, "Shorthand property");
                  C.key.type !== "Identifier" && S(C.key), S(C.value);
                  return;
                case "UnaryExpression": {
                  let { operator: L, argument: j } = C;
                  if (L !== "+" && L !== "-")
                    throw T(C, `Operator '${C.operator}'`);
                  if (j.type === "NumericLiteral" || j.type === "Identifier" && (j.name === "Infinity" || j.name === "NaN"))
                    return;
                  throw T(j, `Operator '${L}' before '${j.type}'`);
                }
                case "Identifier":
                  if (C.name !== "Infinity" && C.name !== "NaN" && C.name !== "undefined")
                    throw T(C, `Identifier '${C.name}'`);
                  return;
                case "TemplateLiteral":
                  if (f(C.expressions))
                    throw T(C.expressions[0], "'TemplateLiteral' with expression");
                  for (let L of C.quasis)
                    S(L);
                  return;
                case "NullLiteral":
                case "BooleanLiteral":
                case "NumericLiteral":
                case "StringLiteral":
                case "TemplateElement":
                  return;
                default:
                  throw T(C, `'${C.type}'`);
              }
            }
            var F4 = g(), I = { json: y({ parse: F4, hasPragma() {
              return true;
            } }), json5: y(F4), "json-stringify": y({ parse: g({ allowComments: false }), astFormat: "estree-json" }) };
            h2.exports = I;
          } });
          V();
          var Jf = Nf(), Xf = To(), Yf = Lf(), We = _o(), Qf = Ro(), Zf = Wf(), ed = Gf(), td = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", { decoratorsBeforeExport: false }], "importAssertions", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors"], tokens: true, ranges: true }, sd = ["recordAndTuple", { syntaxType: "hash" }], mo = "v8intrinsic", yo = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], de = function(l) {
            let h2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : td;
            return Object.assign(Object.assign({}, h2), {}, { plugins: [...h2.plugins, ...l] });
          }, rd = /@(?:no)?flow\b/;
          function id(l, h2) {
            if (h2.filepath && h2.filepath.endsWith(".js.flow"))
              return true;
            let f = Xf(l);
            f && (l = l.slice(f.length));
            let d = Yf(l, 0);
            return d !== false && (l = l.slice(0, d)), rd.test(l);
          }
          function ad(l, h2, f) {
            let d = Uo()[l], y = d(h2, f), P = y.errors.find((g) => !cd.has(g.reasonCode));
            if (P)
              throw P;
            return y;
          }
          function Ge(l) {
            for (var h2 = arguments.length, f = new Array(h2 > 1 ? h2 - 1 : 0), d = 1; d < h2; d++)
              f[d - 1] = arguments[d];
            return function(y, P) {
              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              if ((g.parser === "babel" || g.parser === "__babel_estree") && id(y, g))
                return g.parser = "babel-flow", $o(y, P, g);
              let T = f;
              g.__babelSourceType === "script" && (T = T.map((C) => Object.assign(Object.assign({}, C), {}, { sourceType: "script" }))), /#[[{]/.test(y) && (T = T.map((C) => de([sd], C)));
              let S = /%[A-Z]/.test(y);
              y.includes("|>") ? T = (S ? [...yo, mo] : yo).flatMap((L) => T.map((j) => de([L], j))) : S && (T = T.map((C) => de([mo], C)));
              let { result: F4, error: I } = Jf(...T.map((C) => () => ad(l, y, C)));
              if (!F4)
                throw Qf(I);
              return g.originalText = y, Zf(F4, g);
            };
          }
          var nd = Ge("parse", de(["jsx", "flow"])), $o = Ge("parse", de(["jsx", ["flow", { all: true, enums: true }]])), od = Ge("parse", de(["jsx", "typescript"]), de(["typescript"])), ld = Ge("parse", de(["jsx", "flow", "estree"])), hd = Ge("parseExpression", de(["jsx"])), ud = Ge("parseExpression", de(["typescript"])), cd = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), xo = We(nd), go = We(od), Po = We(hd), pd = We(ud);
          Ho.exports = { parsers: Object.assign(Object.assign({ babel: xo, "babel-flow": We($o), "babel-ts": go }, ed), {}, { __js_expression: Po, __vue_expression: Po, __vue_ts_expression: pd, __vue_event_binding: xo, __vue_ts_event_binding: go, __babel_estree: We(ld) }) };
        });
        return fd();
      });
    }
  });

  // node_modules/@babel/parser/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@babel/parser/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      var Position = class {
        constructor(line, col, index) {
          this.line = void 0;
          this.column = void 0;
          this.index = void 0;
          this.line = line;
          this.column = col;
          this.index = index;
        }
      };
      var SourceLocation = class {
        constructor(start, end) {
          this.start = void 0;
          this.end = void 0;
          this.filename = void 0;
          this.identifierName = void 0;
          this.start = start;
          this.end = end;
        }
      };
      function createPositionWithColumnOffset(position, columnOffset) {
        const {
          line,
          column,
          index
        } = position;
        return new Position(line, column + columnOffset, index + columnOffset);
      }
      var ParseErrorCode = {
        SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
        SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      };
      var reflect = (keys, last = keys.length - 1) => ({
        get() {
          return keys.reduce((object, key) => object[key], this);
        },
        set(value) {
          keys.reduce((item, key, i) => i === last ? item[key] = value : item[key], this);
        }
      });
      var instantiate = (constructor, properties2, descriptors) => Object.keys(descriptors).map((key) => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === "function" ? {
        value: descriptor,
        enumerable: false
      } : typeof descriptor.reflect === "string" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({
        configurable: true
      }, descriptor)), Object.assign(new constructor(), properties2));
      var ModuleErrors = {
        ImportMetaOutsideModule: {
          message: `import.meta may appear only with 'sourceType: "module"'`,
          code: ParseErrorCode.SourceTypeModuleError
        },
        ImportOutsideModule: {
          message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
          code: ParseErrorCode.SourceTypeModuleError
        }
      };
      var NodeDescriptions = {
        ArrayPattern: "array destructuring pattern",
        AssignmentExpression: "assignment expression",
        AssignmentPattern: "assignment expression",
        ArrowFunctionExpression: "arrow function expression",
        ConditionalExpression: "conditional expression",
        CatchClause: "catch clause",
        ForOfStatement: "for-of statement",
        ForInStatement: "for-in statement",
        ForStatement: "for-loop",
        FormalParameters: "function parameter list",
        Identifier: "identifier",
        ImportSpecifier: "import specifier",
        ImportDefaultSpecifier: "import default specifier",
        ImportNamespaceSpecifier: "import namespace specifier",
        ObjectPattern: "object destructuring pattern",
        ParenthesizedExpression: "parenthesized expression",
        RestElement: "rest element",
        UpdateExpression: {
          true: "prefix operation",
          false: "postfix operation"
        },
        VariableDeclarator: "variable declaration",
        YieldExpression: "yield expression"
      };
      var toNodeDescription = ({
        type,
        prefix: prefix2
      }) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];
      var StandardErrors = {
        AccessorIsGenerator: ({
          kind
        }) => `A ${kind}ter cannot be a generator.`,
        ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
        AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
        AwaitInUsingBinding: "'await' is not allowed to be used as a name in 'using' declarations.",
        AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accessor must not have any formal parameters.",
        BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
        BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
        ConstructorClassField: "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: "Class constructor may not be an accessor.",
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: ({
          kind
        }) => `Missing initializer in ${kind} declaration.`,
        DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
        DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
        DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
        DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeletePrivateField: "Deleting a private field is not allowed.",
        DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        DuplicateConstructor: "Duplicate constructor in the same class.",
        DuplicateDefaultExport: "Only one default export allowed per module.",
        DuplicateExport: ({
          exportName
        }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
        DuplicateProto: "Redefinition of __proto__ property.",
        DuplicateRegExpFlags: "Duplicate regular expression flag.",
        ElementAfterRest: "Rest element must be last element.",
        EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
        ExportBindingIsString: ({
          localName,
          exportName
        }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
        ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: ({
          type
        }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
        ForInUsing: "For-in loop may not start with 'using' declaration.",
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
        IllegalBreakContinue: ({
          type
        }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportBindingIsString: ({
          importName
        }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
        ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
        ImportCallArity: ({
          maxArgumentCount
        }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
        ImportCallNotNewExpression: "Cannot use new with import(...).",
        ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
        ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
        ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
        ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
        IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
        InvalidBigIntLiteral: "Invalid BigIntLiteral.",
        InvalidCodePoint: "Code point out of bounds.",
        InvalidCoverInitializedName: "Invalid shorthand property initializer.",
        InvalidDecimal: "Invalid decimal.",
        InvalidDigit: ({
          radix
        }) => `Expected number in radix ${radix}.`,
        InvalidEscapeSequence: "Bad character escape sequence.",
        InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
        InvalidEscapedReservedWord: ({
          reservedWord
        }) => `Escape sequence in keyword ${reservedWord}.`,
        InvalidIdentifier: ({
          identifierName
        }) => `Invalid identifier ${identifierName}.`,
        InvalidLhs: ({
          ancestor
        }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
        InvalidLhsBinding: ({
          ancestor
        }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
        InvalidNumber: "Invalid number.",
        InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: ({
          unexpected
        }) => `Unexpected character '${unexpected}'.`,
        InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
        InvalidPrivateFieldResolution: ({
          identifierName
        }) => `Private name #${identifierName} is not defined.`,
        InvalidPropertyBindingPattern: "Binding member expression.",
        InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: ({
          labelName
        }) => `Label '${labelName}' is already declared.`,
        LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: "Invalid regular expression flag.",
        MissingClassName: "A class name is required.",
        MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: "Missing semicolon.",
        MissingPlugin: ({
          missingPlugin
        }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name41) => JSON.stringify(name41)).join(", ")}.`,
        MissingOneOfPlugins: ({
          missingPlugin
        }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name41) => JSON.stringify(name41)).join(", ")}.`,
        MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
        MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
        ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
        ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
        ModuleAttributesWithDuplicateKeys: ({
          key
        }) => `Duplicate key "${key}" is not allowed in module attributes.`,
        ModuleExportNameHasLoneSurrogate: ({
          surrogateCharCode
        }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
        ModuleExportUndefined: ({
          localName
        }) => `Export '${localName}' is not defined.`,
        MultipleDefaultsInSwitch: "Multiple default clauses.",
        NewlineAfterThrow: "Illegal newline after throw.",
        NoCatchOrFinally: "Missing catch or finally clause.",
        NumberIdentifier: "Identifier directly after number.",
        NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
        ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
        OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
        OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: "Argument name clash.",
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PrivateInExpectedIn: ({
          identifierName
        }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
        PrivateNameRedeclaration: ({
          identifierName
        }) => `Duplicate private name #${identifierName}.`,
        RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: "Unexpected trailing comma after rest element.",
        SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
        StaticPrototype: "Classes may not have static property named prototype.",
        SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: "Decorators must be attached to a class element.",
        TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
        UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
        UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: ({
          keyword: keyword2
        }) => `Unexpected keyword '${keyword2}'.`,
        UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
        UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
        UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
        UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
        UnexpectedPrivateField: "Unexpected private name.",
        UnexpectedReservedWord: ({
          reservedWord
        }) => `Unexpected reserved word '${reservedWord}'.`,
        UnexpectedSuper: "'super' is only allowed in object methods and classes.",
        UnexpectedToken: ({
          expected,
          unexpected
        }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
        UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
        UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
        UnsupportedBind: "Binding should be performed on object property.",
        UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
        UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
        UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
        UnsupportedMetaProperty: ({
          target,
          onlyValidPropertyName
        }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
        UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
        UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
        UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: "Unterminated comment.",
        UnterminatedRegExp: "Unterminated regular expression.",
        UnterminatedString: "Unterminated string constant.",
        UnterminatedTemplate: "Unterminated template.",
        UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
        VarRedeclaration: ({
          identifierName
        }) => `Identifier '${identifierName}' has already been declared.`,
        YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter: "Yield expression is not allowed in formal parameters.",
        ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
      };
      var StrictModeErrors = {
        StrictDelete: "Deleting local variable in strict mode.",
        StrictEvalArguments: ({
          referenceName
        }) => `Assigning to '${referenceName}' in strict mode.`,
        StrictEvalArgumentsBinding: ({
          bindingName
        }) => `Binding '${bindingName}' in strict mode.`,
        StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
        StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
        StrictWith: "'with' in strict mode."
      };
      var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
      var PipelineOperatorErrors = {
        PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
        PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
        PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
        PipeTopicUnconfiguredToken: ({
          token
        }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
        PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
        PipeUnparenthesizedBody: ({
          type
        }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
          type
        })}; please wrap it in parentheses.`,
        PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
        PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
        PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
        PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
        PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
      };
      var _excluded$1 = ["toMessage"];
      var _excluded2$1 = ["message"];
      function toParseErrorConstructor(_ref) {
        let {
          toMessage
        } = _ref, properties2 = _objectWithoutPropertiesLoose(_ref, _excluded$1);
        return function constructor({
          loc,
          details
        }) {
          return instantiate(SyntaxError, Object.assign({}, properties2, {
            loc
          }), {
            clone(overrides = {}) {
              const loc2 = overrides.loc || {};
              return constructor({
                loc: new Position("line" in loc2 ? loc2.line : this.loc.line, "column" in loc2 ? loc2.column : this.loc.column, "index" in loc2 ? loc2.index : this.loc.index),
                details: Object.assign({}, this.details, overrides.details)
              });
            },
            details: {
              value: details,
              enumerable: false
            },
            message: {
              get() {
                return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;
              },
              set(value) {
                Object.defineProperty(this, "message", {
                  value
                });
              }
            },
            pos: {
              reflect: "loc.index",
              enumerable: true
            },
            missingPlugin: "missingPlugin" in details && {
              reflect: "details.missingPlugin",
              enumerable: true
            }
          });
        };
      }
      function ParseErrorEnum(argument, syntaxPlugin) {
        if (Array.isArray(argument)) {
          return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
        }
        const ParseErrorConstructors = {};
        for (const reasonCode of Object.keys(argument)) {
          const template = argument[reasonCode];
          const _ref2 = typeof template === "string" ? {
            message: () => template
          } : typeof template === "function" ? {
            message: template
          } : template, {
            message
          } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
          const toMessage = typeof message === "string" ? () => message : message;
          ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
            code: ParseErrorCode.SyntaxError,
            reasonCode,
            toMessage
          }, syntaxPlugin ? {
            syntaxPlugin
          } : {}, rest));
        }
        return ParseErrorConstructors;
      }
      var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
      var {
        defineProperty
      } = Object;
      var toUnenumerable = (object, key) => defineProperty(object, key, {
        enumerable: false,
        value: object[key]
      });
      function toESTreeLocation(node) {
        node.loc.start && toUnenumerable(node.loc.start, "index");
        node.loc.end && toUnenumerable(node.loc.end, "index");
        return node;
      }
      var estree = (superClass) => class ESTreeParserMixin extends superClass {
        parse() {
          const file = toESTreeLocation(super.parse());
          if (this.options.tokens) {
            file.tokens = file.tokens.map(toESTreeLocation);
          }
          return file;
        }
        parseRegExpLiteral({
          pattern,
          flags
        }) {
          let regex = null;
          try {
            regex = new RegExp(pattern, flags);
          } catch (e) {
          }
          const node = this.estreeParseLiteral(regex);
          node.regex = {
            pattern,
            flags
          };
          return node;
        }
        parseBigIntLiteral(value) {
          let bigInt;
          try {
            bigInt = BigInt(value);
          } catch (_unused) {
            bigInt = null;
          }
          const node = this.estreeParseLiteral(bigInt);
          node.bigint = String(node.value || value);
          return node;
        }
        parseDecimalLiteral(value) {
          const decimal = null;
          const node = this.estreeParseLiteral(decimal);
          node.decimal = String(node.value || value);
          return node;
        }
        estreeParseLiteral(value) {
          return this.parseLiteral(value, "Literal");
        }
        parseStringLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNumericLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNullLiteral() {
          return this.estreeParseLiteral(null);
        }
        parseBooleanLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        directiveToStmt(directive) {
          const expression = directive.value;
          delete directive.value;
          expression.type = "Literal";
          expression.raw = expression.extra.raw;
          expression.value = expression.extra.expressionValue;
          const stmt = directive;
          stmt.type = "ExpressionStatement";
          stmt.expression = expression;
          stmt.directive = expression.extra.rawValue;
          delete expression.extra;
          return stmt;
        }
        initFunction(node, isAsync) {
          super.initFunction(node, isAsync);
          node.expression = false;
        }
        checkDeclaration(node) {
          if (node != null && this.isObjectProperty(node)) {
            this.checkDeclaration(node.value);
          } else {
            super.checkDeclaration(node);
          }
        }
        getObjectOrClassMethodParams(method) {
          return method.value.params;
        }
        isValidDirective(stmt) {
          var _stmt$expression$extr;
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
          const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
          node.body = directiveStatements.concat(node.body);
          delete node.directives;
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
          if (method.typeParameters) {
            method.value.typeParameters = method.typeParameters;
            delete method.typeParameters;
          }
          classBody.body.push(method);
        }
        parsePrivateName() {
          const node = super.parsePrivateName();
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return node;
            }
          }
          return this.convertPrivateNameToPrivateIdentifier(node);
        }
        convertPrivateNameToPrivateIdentifier(node) {
          const name41 = super.getPrivateNameSV(node);
          node = node;
          delete node.id;
          node.name = name41;
          node.type = "PrivateIdentifier";
          return node;
        }
        isPrivateName(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.isPrivateName(node);
            }
          }
          return node.type === "PrivateIdentifier";
        }
        getPrivateNameSV(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.getPrivateNameSV(node);
            }
          }
          return node.name;
        }
        parseLiteral(value, type) {
          const node = super.parseLiteral(value, type);
          node.raw = node.extra.raw;
          delete node.extra;
          return node;
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
          super.parseFunctionBody(node, allowExpression, isMethod);
          node.expression = node.body.type !== "BlockStatement";
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
          let funcNode = this.startNode();
          funcNode.kind = node.kind;
          funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          funcNode.type = "FunctionExpression";
          delete funcNode.kind;
          node.value = funcNode;
          if (type === "ClassPrivateMethod") {
            node.computed = false;
          }
          return this.finishNode(node, "MethodDefinition");
        }
        parseClassProperty(...args) {
          const propertyNode = super.parseClassProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          return propertyNode;
        }
        parseClassPrivateProperty(...args) {
          const propertyNode = super.parseClassPrivateProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          propertyNode.computed = false;
          return propertyNode;
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
          if (node) {
            node.type = "Property";
            if (node.kind === "method") {
              node.kind = "init";
            }
            node.shorthand = false;
          }
          return node;
        }
        parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
          const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
          if (node) {
            node.kind = "init";
            node.type = "Property";
          }
          return node;
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        isAssignable(node, isBinding) {
          if (node != null && this.isObjectProperty(node)) {
            return this.isAssignable(node.value, isBinding);
          }
          return super.isAssignable(node, isBinding);
        }
        toAssignable(node, isLHS = false) {
          if (node != null && this.isObjectProperty(node)) {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
          } else {
            super.toAssignable(node, isLHS);
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(Errors.PatternHasAccessor, {
              at: prop.key
            });
          } else if (prop.method) {
            this.raise(Errors.PatternHasMethod, {
              at: prop.key
            });
          } else {
            super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
          }
        }
        finishCallExpression(unfinished, optional) {
          const node = super.finishCallExpression(unfinished, optional);
          if (node.callee.type === "Import") {
            node.type = "ImportExpression";
            node.source = node.arguments[0];
            if (this.hasPlugin("importAssertions")) {
              var _node$arguments$;
              node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
            }
            delete node.arguments;
            delete node.callee;
          }
          return node;
        }
        toReferencedArguments(node) {
          if (node.type === "ImportExpression") {
            return;
          }
          super.toReferencedArguments(node);
        }
        parseExport(unfinished, decorators) {
          const exportStartLoc = this.state.lastTokStartLoc;
          const node = super.parseExport(unfinished, decorators);
          switch (node.type) {
            case "ExportAllDeclaration":
              node.exported = null;
              break;
            case "ExportNamedDeclaration":
              if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                node.type = "ExportAllDeclaration";
                node.exported = node.specifiers[0].exported;
                delete node.specifiers;
              }
            case "ExportDefaultDeclaration":
              {
                var _declaration$decorato;
                const {
                  declaration
                } = node;
                if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                  this.resetStartLocation(node, exportStartLoc);
                }
              }
              break;
          }
          return node;
        }
        parseSubscript(base, startLoc, noCalls, state) {
          const node = super.parseSubscript(base, startLoc, noCalls, state);
          if (state.optionalChainMember) {
            if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
              node.type = node.type.substring(8);
            }
            if (state.stop) {
              const chain = this.startNodeAtNode(node);
              chain.expression = node;
              return this.finishNode(chain, "ChainExpression");
            }
          } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
            node.optional = false;
          }
          return node;
        }
        hasPropertyAsPrivateName(node) {
          if (node.type === "ChainExpression") {
            node = node.expression;
          }
          return super.hasPropertyAsPrivateName(node);
        }
        isOptionalChain(node) {
          return node.type === "ChainExpression";
        }
        isObjectProperty(node) {
          return node.type === "Property" && node.kind === "init" && !node.method;
        }
        isObjectMethod(node) {
          return node.method || node.kind === "get" || node.kind === "set";
        }
        finishNodeAt(node, type, endLoc) {
          return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
        }
        resetStartLocation(node, startLoc) {
          super.resetStartLocation(node, startLoc);
          toESTreeLocation(node);
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          super.resetEndLocation(node, endLoc);
          toESTreeLocation(node);
        }
      };
      var TokContext = class {
        constructor(token, preserveSpace) {
          this.token = void 0;
          this.preserveSpace = void 0;
          this.token = token;
          this.preserveSpace = !!preserveSpace;
        }
      };
      var types = {
        brace: new TokContext("{"),
        j_oTag: new TokContext("<tag"),
        j_cTag: new TokContext("</tag"),
        j_expr: new TokContext("<tag>...</tag>", true)
      };
      {
        types.template = new TokContext("`", true);
      }
      var beforeExpr = true;
      var startsExpr = true;
      var isLoop = true;
      var isAssign = true;
      var prefix = true;
      var postfix = true;
      var ExportedTokenType = class {
        constructor(label, conf = {}) {
          this.label = void 0;
          this.keyword = void 0;
          this.beforeExpr = void 0;
          this.startsExpr = void 0;
          this.rightAssociative = void 0;
          this.isLoop = void 0;
          this.isAssign = void 0;
          this.prefix = void 0;
          this.postfix = void 0;
          this.binop = void 0;
          this.label = label;
          this.keyword = conf.keyword;
          this.beforeExpr = !!conf.beforeExpr;
          this.startsExpr = !!conf.startsExpr;
          this.rightAssociative = !!conf.rightAssociative;
          this.isLoop = !!conf.isLoop;
          this.isAssign = !!conf.isAssign;
          this.prefix = !!conf.prefix;
          this.postfix = !!conf.postfix;
          this.binop = conf.binop != null ? conf.binop : null;
          {
            this.updateContext = null;
          }
        }
      };
      var keywords$1 = /* @__PURE__ */ new Map();
      function createKeyword(name41, options = {}) {
        options.keyword = name41;
        const token = createToken(name41, options);
        keywords$1.set(name41, token);
        return token;
      }
      function createBinop(name41, binop) {
        return createToken(name41, {
          beforeExpr,
          binop
        });
      }
      var tokenTypeCounter = -1;
      var tokenTypes = [];
      var tokenLabels = [];
      var tokenBinops = [];
      var tokenBeforeExprs = [];
      var tokenStartsExprs = [];
      var tokenPrefixes = [];
      function createToken(name41, options = {}) {
        var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
        ++tokenTypeCounter;
        tokenLabels.push(name41);
        tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
        tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
        tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
        tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
        tokenTypes.push(new ExportedTokenType(name41, options));
        return tokenTypeCounter;
      }
      function createKeywordLike(name41, options = {}) {
        var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
        ++tokenTypeCounter;
        keywords$1.set(name41, tokenTypeCounter);
        tokenLabels.push(name41);
        tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
        tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
        tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
        tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
        tokenTypes.push(new ExportedTokenType("name", options));
        return tokenTypeCounter;
      }
      var tt = {
        bracketL: createToken("[", {
          beforeExpr,
          startsExpr
        }),
        bracketHashL: createToken("#[", {
          beforeExpr,
          startsExpr
        }),
        bracketBarL: createToken("[|", {
          beforeExpr,
          startsExpr
        }),
        bracketR: createToken("]"),
        bracketBarR: createToken("|]"),
        braceL: createToken("{", {
          beforeExpr,
          startsExpr
        }),
        braceBarL: createToken("{|", {
          beforeExpr,
          startsExpr
        }),
        braceHashL: createToken("#{", {
          beforeExpr,
          startsExpr
        }),
        braceR: createToken("}"),
        braceBarR: createToken("|}"),
        parenL: createToken("(", {
          beforeExpr,
          startsExpr
        }),
        parenR: createToken(")"),
        comma: createToken(",", {
          beforeExpr
        }),
        semi: createToken(";", {
          beforeExpr
        }),
        colon: createToken(":", {
          beforeExpr
        }),
        doubleColon: createToken("::", {
          beforeExpr
        }),
        dot: createToken("."),
        question: createToken("?", {
          beforeExpr
        }),
        questionDot: createToken("?."),
        arrow: createToken("=>", {
          beforeExpr
        }),
        template: createToken("template"),
        ellipsis: createToken("...", {
          beforeExpr
        }),
        backQuote: createToken("`", {
          startsExpr
        }),
        dollarBraceL: createToken("${", {
          beforeExpr,
          startsExpr
        }),
        templateTail: createToken("...`", {
          startsExpr
        }),
        templateNonTail: createToken("...${", {
          beforeExpr,
          startsExpr
        }),
        at: createToken("@"),
        hash: createToken("#", {
          startsExpr
        }),
        interpreterDirective: createToken("#!..."),
        eq: createToken("=", {
          beforeExpr,
          isAssign
        }),
        assign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        slashAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        xorAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        moduloAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        incDec: createToken("++/--", {
          prefix,
          postfix,
          startsExpr
        }),
        bang: createToken("!", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        tilde: createToken("~", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        doubleCaret: createToken("^^", {
          startsExpr
        }),
        doubleAt: createToken("@@", {
          startsExpr
        }),
        pipeline: createBinop("|>", 0),
        nullishCoalescing: createBinop("??", 1),
        logicalOR: createBinop("||", 1),
        logicalAND: createBinop("&&", 2),
        bitwiseOR: createBinop("|", 3),
        bitwiseXOR: createBinop("^", 4),
        bitwiseAND: createBinop("&", 5),
        equality: createBinop("==/!=/===/!==", 6),
        lt: createBinop("</>/<=/>=", 7),
        gt: createBinop("</>/<=/>=", 7),
        relational: createBinop("</>/<=/>=", 7),
        bitShift: createBinop("<</>>/>>>", 8),
        bitShiftL: createBinop("<</>>/>>>", 8),
        bitShiftR: createBinop("<</>>/>>>", 8),
        plusMin: createToken("+/-", {
          beforeExpr,
          binop: 9,
          prefix,
          startsExpr
        }),
        modulo: createToken("%", {
          binop: 10,
          startsExpr
        }),
        star: createToken("*", {
          binop: 10
        }),
        slash: createBinop("/", 10),
        exponent: createToken("**", {
          beforeExpr,
          binop: 11,
          rightAssociative: true
        }),
        _in: createKeyword("in", {
          beforeExpr,
          binop: 7
        }),
        _instanceof: createKeyword("instanceof", {
          beforeExpr,
          binop: 7
        }),
        _break: createKeyword("break"),
        _case: createKeyword("case", {
          beforeExpr
        }),
        _catch: createKeyword("catch"),
        _continue: createKeyword("continue"),
        _debugger: createKeyword("debugger"),
        _default: createKeyword("default", {
          beforeExpr
        }),
        _else: createKeyword("else", {
          beforeExpr
        }),
        _finally: createKeyword("finally"),
        _function: createKeyword("function", {
          startsExpr
        }),
        _if: createKeyword("if"),
        _return: createKeyword("return", {
          beforeExpr
        }),
        _switch: createKeyword("switch"),
        _throw: createKeyword("throw", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _try: createKeyword("try"),
        _var: createKeyword("var"),
        _const: createKeyword("const"),
        _with: createKeyword("with"),
        _new: createKeyword("new", {
          beforeExpr,
          startsExpr
        }),
        _this: createKeyword("this", {
          startsExpr
        }),
        _super: createKeyword("super", {
          startsExpr
        }),
        _class: createKeyword("class", {
          startsExpr
        }),
        _extends: createKeyword("extends", {
          beforeExpr
        }),
        _export: createKeyword("export"),
        _import: createKeyword("import", {
          startsExpr
        }),
        _null: createKeyword("null", {
          startsExpr
        }),
        _true: createKeyword("true", {
          startsExpr
        }),
        _false: createKeyword("false", {
          startsExpr
        }),
        _typeof: createKeyword("typeof", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _void: createKeyword("void", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _delete: createKeyword("delete", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _do: createKeyword("do", {
          isLoop,
          beforeExpr
        }),
        _for: createKeyword("for", {
          isLoop
        }),
        _while: createKeyword("while", {
          isLoop
        }),
        _as: createKeywordLike("as", {
          startsExpr
        }),
        _assert: createKeywordLike("assert", {
          startsExpr
        }),
        _async: createKeywordLike("async", {
          startsExpr
        }),
        _await: createKeywordLike("await", {
          startsExpr
        }),
        _from: createKeywordLike("from", {
          startsExpr
        }),
        _get: createKeywordLike("get", {
          startsExpr
        }),
        _let: createKeywordLike("let", {
          startsExpr
        }),
        _meta: createKeywordLike("meta", {
          startsExpr
        }),
        _of: createKeywordLike("of", {
          startsExpr
        }),
        _sent: createKeywordLike("sent", {
          startsExpr
        }),
        _set: createKeywordLike("set", {
          startsExpr
        }),
        _static: createKeywordLike("static", {
          startsExpr
        }),
        _using: createKeywordLike("using", {
          startsExpr
        }),
        _yield: createKeywordLike("yield", {
          startsExpr
        }),
        _asserts: createKeywordLike("asserts", {
          startsExpr
        }),
        _checks: createKeywordLike("checks", {
          startsExpr
        }),
        _exports: createKeywordLike("exports", {
          startsExpr
        }),
        _global: createKeywordLike("global", {
          startsExpr
        }),
        _implements: createKeywordLike("implements", {
          startsExpr
        }),
        _intrinsic: createKeywordLike("intrinsic", {
          startsExpr
        }),
        _infer: createKeywordLike("infer", {
          startsExpr
        }),
        _is: createKeywordLike("is", {
          startsExpr
        }),
        _mixins: createKeywordLike("mixins", {
          startsExpr
        }),
        _proto: createKeywordLike("proto", {
          startsExpr
        }),
        _require: createKeywordLike("require", {
          startsExpr
        }),
        _satisfies: createKeywordLike("satisfies", {
          startsExpr
        }),
        _keyof: createKeywordLike("keyof", {
          startsExpr
        }),
        _readonly: createKeywordLike("readonly", {
          startsExpr
        }),
        _unique: createKeywordLike("unique", {
          startsExpr
        }),
        _abstract: createKeywordLike("abstract", {
          startsExpr
        }),
        _declare: createKeywordLike("declare", {
          startsExpr
        }),
        _enum: createKeywordLike("enum", {
          startsExpr
        }),
        _module: createKeywordLike("module", {
          startsExpr
        }),
        _namespace: createKeywordLike("namespace", {
          startsExpr
        }),
        _interface: createKeywordLike("interface", {
          startsExpr
        }),
        _type: createKeywordLike("type", {
          startsExpr
        }),
        _opaque: createKeywordLike("opaque", {
          startsExpr
        }),
        name: createToken("name", {
          startsExpr
        }),
        string: createToken("string", {
          startsExpr
        }),
        num: createToken("num", {
          startsExpr
        }),
        bigint: createToken("bigint", {
          startsExpr
        }),
        decimal: createToken("decimal", {
          startsExpr
        }),
        regexp: createToken("regexp", {
          startsExpr
        }),
        privateName: createToken("#name", {
          startsExpr
        }),
        eof: createToken("eof"),
        jsxName: createToken("jsxName"),
        jsxText: createToken("jsxText", {
          beforeExpr: true
        }),
        jsxTagStart: createToken("jsxTagStart", {
          startsExpr: true
        }),
        jsxTagEnd: createToken("jsxTagEnd"),
        placeholder: createToken("%%", {
          startsExpr: true
        })
      };
      function tokenIsIdentifier(token) {
        return token >= 93 && token <= 130;
      }
      function tokenKeywordOrIdentifierIsKeyword(token) {
        return token <= 92;
      }
      function tokenIsKeywordOrIdentifier(token) {
        return token >= 58 && token <= 130;
      }
      function tokenIsLiteralPropertyName(token) {
        return token >= 58 && token <= 134;
      }
      function tokenComesBeforeExpression(token) {
        return tokenBeforeExprs[token];
      }
      function tokenCanStartExpression(token) {
        return tokenStartsExprs[token];
      }
      function tokenIsAssignment(token) {
        return token >= 29 && token <= 33;
      }
      function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
        return token >= 127 && token <= 129;
      }
      function tokenIsLoop(token) {
        return token >= 90 && token <= 92;
      }
      function tokenIsKeyword(token) {
        return token >= 58 && token <= 92;
      }
      function tokenIsOperator(token) {
        return token >= 39 && token <= 59;
      }
      function tokenIsPostfix(token) {
        return token === 34;
      }
      function tokenIsPrefix(token) {
        return tokenPrefixes[token];
      }
      function tokenIsTSTypeOperator(token) {
        return token >= 119 && token <= 121;
      }
      function tokenIsTSDeclarationStart(token) {
        return token >= 122 && token <= 128;
      }
      function tokenLabelName(token) {
        return tokenLabels[token];
      }
      function tokenOperatorPrecedence(token) {
        return tokenBinops[token];
      }
      function tokenIsRightAssociative(token) {
        return token === 57;
      }
      function tokenIsTemplate(token) {
        return token >= 24 && token <= 25;
      }
      function getExportedToken(token) {
        return tokenTypes[token];
      }
      {
        tokenTypes[8].updateContext = (context) => {
          context.pop();
        };
        tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
          context.push(types.brace);
        };
        tokenTypes[22].updateContext = (context) => {
          if (context[context.length - 1] === types.template) {
            context.pop();
          } else {
            context.push(types.template);
          }
        };
        tokenTypes[140].updateContext = (context) => {
          context.push(types.j_expr, types.j_oTag);
        };
      }
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code2, set) {
        let pos = 65536;
        for (let i = 0, length = set.length; i < length; i += 2) {
          pos += set[i];
          if (pos > code2)
            return false;
          pos += set[i + 1];
          if (pos >= code2)
            return true;
        }
        return false;
      }
      function isIdentifierStart2(code2) {
        if (code2 < 65)
          return code2 === 36;
        if (code2 <= 90)
          return true;
        if (code2 < 97)
          return code2 === 95;
        if (code2 <= 122)
          return true;
        if (code2 <= 65535) {
          return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
        }
        return isInAstralSet(code2, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code2) {
        if (code2 < 48)
          return code2 === 36;
        if (code2 < 58)
          return true;
        if (code2 < 65)
          return false;
        if (code2 <= 90)
          return true;
        if (code2 < 97)
          return code2 === 95;
        if (code2 <= 122)
          return true;
        if (code2 <= 65535) {
          return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
        }
        return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
      }
      var reservedWords = {
        keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
        strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
        strictBind: ["eval", "arguments"]
      };
      var keywords2 = new Set(reservedWords.keyword);
      var reservedWordsStrictSet = new Set(reservedWords.strict);
      var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
      function isReservedWord(word, inModule) {
        return inModule && word === "await" || word === "enum";
      }
      function isStrictReservedWord(word, inModule) {
        return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
      }
      function isStrictBindOnlyReservedWord(word) {
        return reservedWordsStrictBindSet.has(word);
      }
      function isStrictBindReservedWord(word, inModule) {
        return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
      }
      function isKeyword2(word) {
        return keywords2.has(word);
      }
      function isIteratorStart(current, next, next2) {
        return current === 64 && next === 64 && isIdentifierStart2(next2);
      }
      var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
      function canBeReservedWord(word) {
        return reservedWordLikeSet.has(word);
      }
      var SCOPE_OTHER = 0;
      var SCOPE_PROGRAM = 1;
      var SCOPE_FUNCTION = 2;
      var SCOPE_ARROW = 4;
      var SCOPE_SIMPLE_CATCH = 8;
      var SCOPE_SUPER = 16;
      var SCOPE_DIRECT_SUPER = 32;
      var SCOPE_CLASS = 64;
      var SCOPE_STATIC_BLOCK = 128;
      var SCOPE_TS_MODULE = 256;
      var SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_STATIC_BLOCK | SCOPE_TS_MODULE;
      var BIND_KIND_VALUE = 1;
      var BIND_KIND_TYPE = 2;
      var BIND_SCOPE_VAR = 4;
      var BIND_SCOPE_LEXICAL = 8;
      var BIND_SCOPE_FUNCTION = 16;
      var BIND_FLAGS_NONE = 64;
      var BIND_FLAGS_CLASS = 128;
      var BIND_FLAGS_TS_ENUM = 256;
      var BIND_FLAGS_TS_CONST_ENUM = 512;
      var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
      var BIND_FLAGS_FLOW_DECLARE_FN = 2048;
      var BIND_FLAGS_TS_IMPORT = 4096;
      var BIND_FLAGS_NO_LET_IN_LEXICAL = 8192;
      var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS | BIND_FLAGS_NO_LET_IN_LEXICAL;
      var BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | BIND_FLAGS_NO_LET_IN_LEXICAL;
      var BIND_CATCH_PARAM = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
      var BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
      var BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
      var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
      var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
      var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM | BIND_FLAGS_NO_LET_IN_LEXICAL;
      var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
      var BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE;
      var BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
      var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
      var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
      var BIND_TS_TYPE_IMPORT = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_TS_IMPORT;
      var BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
      var CLASS_ELEMENT_FLAG_STATIC = 4;
      var CLASS_ELEMENT_KIND_GETTER = 2;
      var CLASS_ELEMENT_KIND_SETTER = 1;
      var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
      var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
      var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
      var CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER;
      var CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER;
      var CLASS_ELEMENT_OTHER = 0;
      var Scope = class {
        constructor(flags) {
          this.var = /* @__PURE__ */ new Set();
          this.lexical = /* @__PURE__ */ new Set();
          this.functions = /* @__PURE__ */ new Set();
          this.flags = flags;
        }
      };
      var ScopeHandler = class {
        constructor(parser, inModule) {
          this.parser = void 0;
          this.scopeStack = [];
          this.inModule = void 0;
          this.undefinedExports = /* @__PURE__ */ new Map();
          this.parser = parser;
          this.inModule = inModule;
        }
        get inTopLevel() {
          return (this.currentScope().flags & SCOPE_PROGRAM) > 0;
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
        }
        get inClass() {
          return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          const flags = this.currentThisScopeFlags();
          return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
        }
        get inStaticBlock() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & SCOPE_STATIC_BLOCK) {
              return true;
            }
            if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
              return false;
            }
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(flags) {
          return new Scope(flags);
        }
        enter(flags) {
          this.scopeStack.push(this.createScope(flags));
        }
        exit() {
          const scope = this.scopeStack.pop();
          return scope.flags;
        }
        treatFunctionsAsVarInScope(scope) {
          return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);
        }
        declareName(name41, bindingType, loc) {
          let scope = this.currentScope();
          if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
            this.checkRedeclarationInScope(scope, name41, bindingType, loc);
            if (bindingType & BIND_SCOPE_FUNCTION) {
              scope.functions.add(name41);
            } else {
              scope.lexical.add(name41);
            }
            if (bindingType & BIND_SCOPE_LEXICAL) {
              this.maybeExportDefined(scope, name41);
            }
          } else if (bindingType & BIND_SCOPE_VAR) {
            for (let i = this.scopeStack.length - 1; i >= 0; --i) {
              scope = this.scopeStack[i];
              this.checkRedeclarationInScope(scope, name41, bindingType, loc);
              scope.var.add(name41);
              this.maybeExportDefined(scope, name41);
              if (scope.flags & SCOPE_VAR)
                break;
            }
          }
          if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name41);
          }
        }
        maybeExportDefined(scope, name41) {
          if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name41);
          }
        }
        checkRedeclarationInScope(scope, name41, bindingType, loc) {
          if (this.isRedeclaredInScope(scope, name41, bindingType)) {
            this.parser.raise(Errors.VarRedeclaration, {
              at: loc,
              identifierName: name41
            });
          }
        }
        isRedeclaredInScope(scope, name41, bindingType) {
          if (!(bindingType & BIND_KIND_VALUE))
            return false;
          if (bindingType & BIND_SCOPE_LEXICAL) {
            return scope.lexical.has(name41) || scope.functions.has(name41) || scope.var.has(name41);
          }
          if (bindingType & BIND_SCOPE_FUNCTION) {
            return scope.lexical.has(name41) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name41);
          }
          return scope.lexical.has(name41) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name41) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name41);
        }
        checkLocalExport(id) {
          const {
            name: name41
          } = id;
          const topLevelScope = this.scopeStack[0];
          if (!topLevelScope.lexical.has(name41) && !topLevelScope.var.has(name41) && !topLevelScope.functions.has(name41)) {
            this.undefinedExports.set(name41, id.loc.start);
          }
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & SCOPE_VAR) {
              return flags;
            }
          }
        }
        currentThisScopeFlags() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
              return flags;
            }
          }
        }
      };
      var FlowScope = class extends Scope {
        constructor(...args) {
          super(...args);
          this.declareFunctions = /* @__PURE__ */ new Set();
        }
      };
      var FlowScopeHandler = class extends ScopeHandler {
        createScope(flags) {
          return new FlowScope(flags);
        }
        declareName(name41, bindingType, loc) {
          const scope = this.currentScope();
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            this.checkRedeclarationInScope(scope, name41, bindingType, loc);
            this.maybeExportDefined(scope, name41);
            scope.declareFunctions.add(name41);
            return;
          }
          super.declareName(name41, bindingType, loc);
        }
        isRedeclaredInScope(scope, name41, bindingType) {
          if (super.isRedeclaredInScope(scope, name41, bindingType))
            return true;
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            return !scope.declareFunctions.has(name41) && (scope.lexical.has(name41) || scope.functions.has(name41));
          }
          return false;
        }
        checkLocalExport(id) {
          if (!this.scopeStack[0].declareFunctions.has(id.name)) {
            super.checkLocalExport(id);
          }
        }
      };
      var BaseParser = class {
        constructor() {
          this.sawUnambiguousESM = false;
          this.ambiguousScriptDifferentAst = false;
        }
        hasPlugin(pluginConfig) {
          if (typeof pluginConfig === "string") {
            return this.plugins.has(pluginConfig);
          } else {
            const [pluginName, pluginOptions] = pluginConfig;
            if (!this.hasPlugin(pluginName)) {
              return false;
            }
            const actualOptions = this.plugins.get(pluginName);
            for (const key of Object.keys(pluginOptions)) {
              if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
                return false;
              }
            }
            return true;
          }
        }
        getPluginOption(plugin, name41) {
          var _this$plugins$get;
          return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name41];
        }
      };
      function setTrailingComments(node, comments) {
        if (node.trailingComments === void 0) {
          node.trailingComments = comments;
        } else {
          node.trailingComments.unshift(...comments);
        }
      }
      function setLeadingComments(node, comments) {
        if (node.leadingComments === void 0) {
          node.leadingComments = comments;
        } else {
          node.leadingComments.unshift(...comments);
        }
      }
      function setInnerComments(node, comments) {
        if (node.innerComments === void 0) {
          node.innerComments = comments;
        } else {
          node.innerComments.unshift(...comments);
        }
      }
      function adjustInnerComments(node, elements, commentWS) {
        let lastElement = null;
        let i = elements.length;
        while (lastElement === null && i > 0) {
          lastElement = elements[--i];
        }
        if (lastElement === null || lastElement.start > commentWS.start) {
          setInnerComments(node, commentWS.comments);
        } else {
          setTrailingComments(lastElement, commentWS.comments);
        }
      }
      var CommentsParser = class extends BaseParser {
        addComment(comment) {
          if (this.filename)
            comment.loc.filename = this.filename;
          this.state.comments.push(comment);
        }
        processComment(node) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0)
            return;
          let i = commentStackLength - 1;
          const lastCommentWS = commentStack[i];
          if (lastCommentWS.start === node.end) {
            lastCommentWS.leadingNode = node;
            i--;
          }
          const {
            start: nodeStart
          } = node;
          for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            if (commentEnd > nodeStart) {
              commentWS.containingNode = node;
              this.finalizeComment(commentWS);
              commentStack.splice(i, 1);
            } else {
              if (commentEnd === nodeStart) {
                commentWS.trailingNode = node;
              }
              break;
            }
          }
        }
        finalizeComment(commentWS) {
          const {
            comments
          } = commentWS;
          if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
            if (commentWS.leadingNode !== null) {
              setTrailingComments(commentWS.leadingNode, comments);
            }
            if (commentWS.trailingNode !== null) {
              setLeadingComments(commentWS.trailingNode, comments);
            }
          } else {
            const {
              containingNode: node,
              start: commentStart
            } = commentWS;
            if (this.input.charCodeAt(commentStart - 1) === 44) {
              switch (node.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  adjustInnerComments(node, node.properties, commentWS);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  adjustInnerComments(node, node.arguments, commentWS);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  adjustInnerComments(node, node.params, commentWS);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  adjustInnerComments(node, node.elements, commentWS);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  adjustInnerComments(node, node.specifiers, commentWS);
                  break;
                default: {
                  setInnerComments(node, comments);
                }
              }
            } else {
              setInnerComments(node, comments);
            }
          }
        }
        finalizeRemainingComments() {
          const {
            commentStack
          } = this.state;
          for (let i = commentStack.length - 1; i >= 0; i--) {
            this.finalizeComment(commentStack[i]);
          }
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(node) {
          const {
            commentStack
          } = this.state;
          const {
            length
          } = commentStack;
          if (length === 0)
            return;
          const commentWS = commentStack[length - 1];
          if (commentWS.leadingNode === node) {
            commentWS.leadingNode = null;
          }
        }
        takeSurroundingComments(node, start, end) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0)
            return;
          let i = commentStackLength - 1;
          for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            const commentStart = commentWS.start;
            if (commentStart === end) {
              commentWS.leadingNode = node;
            } else if (commentEnd === start) {
              commentWS.trailingNode = node;
            } else if (commentEnd < start) {
              break;
            }
          }
        }
      };
      var lineBreak = /\r\n?|[\n\u2028\u2029]/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code2) {
        switch (code2) {
          case 10:
          case 13:
          case 8232:
          case 8233:
            return true;
          default:
            return false;
        }
      }
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
      var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
      function isWhitespace(code2) {
        switch (code2) {
          case 9:
          case 11:
          case 12:
          case 32:
          case 160:
          case 5760:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }
      var State = class {
        constructor() {
          this.strict = void 0;
          this.curLine = void 0;
          this.lineStart = void 0;
          this.startLoc = void 0;
          this.endLoc = void 0;
          this.errors = [];
          this.potentialArrowAt = -1;
          this.noArrowAt = [];
          this.noArrowParamsConversionAt = [];
          this.maybeInArrowParameters = false;
          this.inType = false;
          this.noAnonFunctionType = false;
          this.hasFlowComment = false;
          this.isAmbientContext = false;
          this.inAbstractClass = false;
          this.inDisallowConditionalTypesContext = false;
          this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          this.soloAwait = false;
          this.inFSharpPipelineDirectBody = false;
          this.labels = [];
          this.comments = [];
          this.commentStack = [];
          this.pos = 0;
          this.type = 137;
          this.value = null;
          this.start = 0;
          this.end = 0;
          this.lastTokEndLoc = null;
          this.lastTokStartLoc = null;
          this.lastTokStart = 0;
          this.context = [types.brace];
          this.canStartJSXElement = true;
          this.containsEsc = false;
          this.firstInvalidTemplateEscapePos = null;
          this.strictErrors = /* @__PURE__ */ new Map();
          this.tokensLength = 0;
        }
        init({
          strictMode,
          sourceType,
          startLine,
          startColumn
        }) {
          this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
          this.curLine = startLine;
          this.lineStart = -startColumn;
          this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
        }
        curPosition() {
          return new Position(this.curLine, this.pos - this.lineStart, this.pos);
        }
        clone(skipArrays) {
          const state = new State();
          const keys = Object.keys(this);
          for (let i = 0, length = keys.length; i < length; i++) {
            const key = keys[i];
            let val = this[key];
            if (!skipArrays && Array.isArray(val)) {
              val = val.slice();
            }
            state[key] = val;
          }
          return state;
        }
      };
      var _isDigit = function isDigit2(code2) {
        return code2 >= 48 && code2 <= 57;
      };
      var forbiddenNumericSeparatorSiblings = {
        decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
      };
      var isAllowedNumericSeparatorSibling = {
        bin: (ch) => ch === 48 || ch === 49,
        oct: (ch) => ch >= 48 && ch <= 55,
        dec: (ch) => ch >= 48 && ch <= 57,
        hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
      };
      function readStringContents(type, input, pos, lineStart, curLine, errors) {
        const initialPos = pos;
        const initialLineStart = lineStart;
        const initialCurLine = curLine;
        let out = "";
        let firstInvalidLoc = null;
        let chunkStart = pos;
        const {
          length
        } = input;
        for (; ; ) {
          if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
          }
          const ch = input.charCodeAt(pos);
          if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
          }
          if (ch === 92) {
            out += input.slice(chunkStart, pos);
            const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
            if (res.ch === null && !firstInvalidLoc) {
              firstInvalidLoc = {
                pos,
                lineStart,
                curLine
              };
            } else {
              out += res.ch;
            }
            ({
              pos,
              lineStart,
              curLine
            } = res);
            chunkStart = pos;
          } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
          } else if (ch === 10 || ch === 13) {
            if (type === "template") {
              out += input.slice(chunkStart, pos) + "\n";
              ++pos;
              if (ch === 13 && input.charCodeAt(pos) === 10) {
                ++pos;
              }
              ++curLine;
              chunkStart = lineStart = pos;
            } else {
              errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
          } else {
            ++pos;
          }
        }
        return {
          pos,
          str: out,
          firstInvalidLoc,
          lineStart,
          curLine,
          containsInvalid: !!firstInvalidLoc
        };
      }
      function isStringEnd(type, ch, input, pos) {
        if (type === "template") {
          return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
        }
        return ch === (type === "double" ? 34 : 39);
      }
      function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
        const throwOnInvalid = !inTemplate;
        pos++;
        const res = (ch2) => ({
          pos,
          ch: ch2,
          lineStart,
          curLine
        });
        const ch = input.charCodeAt(pos++);
        switch (ch) {
          case 110:
            return res("\n");
          case 114:
            return res("\r");
          case 120: {
            let code2;
            ({
              code: code2,
              pos
            } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
            return res(code2 === null ? null : String.fromCharCode(code2));
          }
          case 117: {
            let code2;
            ({
              code: code2,
              pos
            } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
            return res(code2 === null ? null : String.fromCodePoint(code2));
          }
          case 116:
            return res("	");
          case 98:
            return res("\b");
          case 118:
            return res("\v");
          case 102:
            return res("\f");
          case 13:
            if (input.charCodeAt(pos) === 10) {
              ++pos;
            }
          case 10:
            lineStart = pos;
            ++curLine;
          case 8232:
          case 8233:
            return res("");
          case 56:
          case 57:
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(pos - 1, lineStart, curLine);
            }
          default:
            if (ch >= 48 && ch <= 55) {
              const startPos = pos - 1;
              const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
              let octalStr = match[0];
              let octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              pos += octalStr.length - 1;
              const next = input.charCodeAt(pos);
              if (octalStr !== "0" || next === 56 || next === 57) {
                if (inTemplate) {
                  return res(null);
                } else {
                  errors.strictNumericEscape(startPos, lineStart, curLine);
                }
              }
              return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
        }
      }
      function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
        const initialPos = pos;
        let n;
        ({
          n,
          pos
        } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
        if (n === null) {
          if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
          } else {
            pos = initialPos - 1;
          }
        }
        return {
          code: n,
          pos
        };
      }
      function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
        const start = pos;
        const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
        let invalid = false;
        let total = 0;
        for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          const code2 = input.charCodeAt(pos);
          let val;
          if (code2 === 95 && allowNumSeparator !== "bail") {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
              if (bailOnError)
                return {
                  n: null,
                  pos
                };
              errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
              if (bailOnError)
                return {
                  n: null,
                  pos
                };
              errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
          }
          if (code2 >= 97) {
            val = code2 - 97 + 10;
          } else if (code2 >= 65) {
            val = code2 - 65 + 10;
          } else if (_isDigit(code2)) {
            val = code2 - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            if (val <= 9 && bailOnError) {
              return {
                n: null,
                pos
              };
            } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
              val = 0;
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }
          ++pos;
          total = total * radix + val;
        }
        if (pos === start || len != null && pos - start !== len || invalid) {
          return {
            n: null,
            pos
          };
        }
        return {
          n: total,
          pos
        };
      }
      function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
        const ch = input.charCodeAt(pos);
        let code2;
        if (ch === 123) {
          ++pos;
          ({
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
          ++pos;
          if (code2 !== null && code2 > 1114111) {
            if (throwOnInvalid) {
              errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
              return {
                code: null,
                pos
              };
            }
          }
        } else {
          ({
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
        }
        return {
          code: code2,
          pos
        };
      }
      var _excluded = ["at"];
      var _excluded2 = ["at"];
      function buildPosition(pos, lineStart, curLine) {
        return new Position(curLine, pos - lineStart, pos);
      }
      var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
      var Token = class {
        constructor(state) {
          this.type = state.type;
          this.value = state.value;
          this.start = state.start;
          this.end = state.end;
          this.loc = new SourceLocation(state.startLoc, state.endLoc);
        }
      };
      var Tokenizer2 = class extends CommentsParser {
        constructor(options, input) {
          super();
          this.isLookahead = void 0;
          this.tokens = [];
          this.errorHandlers_readInt = {
            invalidDigit: (pos, lineStart, curLine, radix) => {
              if (!this.options.errorRecovery)
                return false;
              this.raise(Errors.InvalidDigit, {
                at: buildPosition(pos, lineStart, curLine),
                radix
              });
              return true;
            },
            numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
            unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
          };
          this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
            invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
            invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
          });
          this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: (pos, lineStart, curLine) => {
              this.recordStrictModeErrors(Errors.StrictNumericEscape, {
                at: buildPosition(pos, lineStart, curLine)
              });
            },
            unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedString, {
                at: buildPosition(pos - 1, lineStart, curLine)
              });
            }
          });
          this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
            unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedTemplate, {
                at: buildPosition(pos, lineStart, curLine)
              });
            }
          });
          this.state = new State();
          this.state.init(options);
          this.input = input;
          this.length = input.length;
          this.isLookahead = false;
        }
        pushToken(token) {
          this.tokens.length = this.state.tokensLength;
          this.tokens.push(token);
          ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes();
          if (this.options.tokens) {
            this.pushToken(new Token(this.state));
          }
          this.state.lastTokStart = this.state.start;
          this.state.lastTokEndLoc = this.state.endLoc;
          this.state.lastTokStartLoc = this.state.startLoc;
          this.nextToken();
        }
        eat(type) {
          if (this.match(type)) {
            this.next();
            return true;
          } else {
            return false;
          }
        }
        match(type) {
          return this.state.type === type;
        }
        createLookaheadState(state) {
          return {
            pos: state.pos,
            value: null,
            type: state.type,
            start: state.start,
            end: state.end,
            context: [this.curContext()],
            inType: state.inType,
            startLoc: state.startLoc,
            lastTokEndLoc: state.lastTokEndLoc,
            curLine: state.curLine,
            lineStart: state.lineStart,
            curPosition: state.curPosition
          };
        }
        lookahead() {
          const old = this.state;
          this.state = this.createLookaheadState(old);
          this.isLookahead = true;
          this.nextToken();
          this.isLookahead = false;
          const curr = this.state;
          this.state = old;
          return curr;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(pos) {
          skipWhiteSpace.lastIndex = pos;
          return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        codePointAtPos(pos) {
          let cp = this.input.charCodeAt(pos);
          if ((cp & 64512) === 55296 && ++pos < this.input.length) {
            const trail = this.input.charCodeAt(pos);
            if ((trail & 64512) === 56320) {
              cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
          }
          return cp;
        }
        setStrict(strict) {
          this.state.strict = strict;
          if (strict) {
            this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {
              at
            }));
            this.state.strictErrors.clear();
          }
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          this.skipSpace();
          this.state.start = this.state.pos;
          if (!this.isLookahead)
            this.state.startLoc = this.state.curPosition();
          if (this.state.pos >= this.length) {
            this.finishToken(137);
            return;
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment(commentEnd) {
          let startLoc;
          if (!this.isLookahead)
            startLoc = this.state.curPosition();
          const start = this.state.pos;
          const end = this.input.indexOf(commentEnd, start + 2);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
          this.state.pos = end + commentEnd.length;
          lineBreakG.lastIndex = start + 2;
          while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
            ++this.state.curLine;
            this.state.lineStart = lineBreakG.lastIndex;
          }
          if (this.isLookahead)
            return;
          const comment = {
            type: "CommentBlock",
            value: this.input.slice(start + 2, end),
            start,
            end: end + commentEnd.length,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens)
            this.pushToken(comment);
          return comment;
        }
        skipLineComment(startSkip) {
          const start = this.state.pos;
          let startLoc;
          if (!this.isLookahead)
            startLoc = this.state.curPosition();
          let ch = this.input.charCodeAt(this.state.pos += startSkip);
          if (this.state.pos < this.length) {
            while (!isNewLine(ch) && ++this.state.pos < this.length) {
              ch = this.input.charCodeAt(this.state.pos);
            }
          }
          if (this.isLookahead)
            return;
          const end = this.state.pos;
          const value = this.input.slice(start + startSkip, end);
          const comment = {
            type: "CommentLine",
            value,
            start,
            end,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens)
            this.pushToken(comment);
          return comment;
        }
        skipSpace() {
          const spaceStart = this.state.pos;
          const comments = [];
          loop:
            while (this.state.pos < this.length) {
              const ch = this.input.charCodeAt(this.state.pos);
              switch (ch) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                    ++this.state.pos;
                  }
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos;
                  ++this.state.curLine;
                  this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      const comment = this.skipBlockComment("*/");
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                      break;
                    }
                    case 47: {
                      const comment = this.skipLineComment(2);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                      break;
                    }
                    default:
                      break loop;
                  }
                  break;
                default:
                  if (isWhitespace(ch)) {
                    ++this.state.pos;
                  } else if (ch === 45 && !this.inModule) {
                    const pos = this.state.pos;
                    if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                      const comment = this.skipLineComment(3);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                    } else {
                      break loop;
                    }
                  } else if (ch === 60 && !this.inModule) {
                    const pos = this.state.pos;
                    if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                      const comment = this.skipLineComment(4);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                    } else {
                      break loop;
                    }
                  } else {
                    break loop;
                  }
              }
            }
          if (comments.length > 0) {
            const end = this.state.pos;
            const commentWhitespace = {
              start: spaceStart,
              end,
              comments,
              leadingNode: null,
              trailingNode: null,
              containingNode: null
            };
            this.state.commentStack.push(commentWhitespace);
          }
        }
        finishToken(type, val) {
          this.state.end = this.state.pos;
          this.state.endLoc = this.state.curPosition();
          const prevType = this.state.type;
          this.state.type = type;
          this.state.value = val;
          if (!this.isLookahead) {
            this.updateContext(prevType);
          }
        }
        replaceToken(type) {
          this.state.type = type;
          this.updateContext();
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) {
            return;
          }
          const nextPos = this.state.pos + 1;
          const next = this.codePointAtPos(nextPos);
          if (next >= 48 && next <= 57) {
            throw this.raise(Errors.UnexpectedDigitAfterHash, {
              at: this.state.curPosition()
            });
          }
          if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
            this.expectPlugin("recordAndTuple");
            if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
              throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            if (next === 123) {
              this.finishToken(7);
            } else {
              this.finishToken(1);
            }
          } else if (isIdentifierStart2(next)) {
            ++this.state.pos;
            this.finishToken(136, this.readWord1(next));
          } else if (next === 92) {
            ++this.state.pos;
            this.finishToken(136, this.readWord1());
          } else {
            this.finishOp(27, 1);
          }
        }
        readToken_dot() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next >= 48 && next <= 57) {
            this.readNumber(true);
            return;
          }
          if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(21);
          } else {
            ++this.state.pos;
            this.finishToken(16);
          }
        }
        readToken_slash() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61) {
            this.finishOp(31, 2);
          } else {
            this.finishOp(56, 1);
          }
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2)
            return false;
          let ch = this.input.charCodeAt(this.state.pos + 1);
          if (ch !== 33)
            return false;
          const start = this.state.pos;
          this.state.pos += 1;
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
          const value = this.input.slice(start + 2, this.state.pos);
          this.finishToken(28, value);
          return true;
        }
        readToken_mult_modulo(code2) {
          let type = code2 === 42 ? 55 : 54;
          let width = 1;
          let next = this.input.charCodeAt(this.state.pos + 1);
          if (code2 === 42 && next === 42) {
            width++;
            next = this.input.charCodeAt(this.state.pos + 2);
            type = 57;
          }
          if (next === 61 && !this.state.inType) {
            width++;
            type = code2 === 37 ? 33 : 30;
          }
          this.finishOp(type, width);
        }
        readToken_pipe_amp(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === code2) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(code2 === 124 ? 41 : 42, 2);
            }
            return;
          }
          if (code2 === 124) {
            if (next === 62) {
              this.finishOp(39, 2);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 125) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(9);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 93) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(4);
              return;
            }
          }
          if (next === 61) {
            this.finishOp(30, 2);
            return;
          }
          this.finishOp(code2 === 124 ? 43 : 45, 1);
        }
        readToken_caret() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61 && !this.state.inType) {
            this.finishOp(32, 2);
          } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "^^"
          }])) {
            this.finishOp(37, 2);
            const lookaheadCh = this.input.codePointAt(this.state.pos);
            if (lookaheadCh === 94) {
              throw this.unexpected();
            }
          } else {
            this.finishOp(44, 1);
          }
        }
        readToken_atSign() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 64 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "@@"
          }])) {
            this.finishOp(38, 2);
          } else {
            this.finishOp(26, 1);
          }
        }
        readToken_plus_min(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === code2) {
            this.finishOp(34, 2);
            return;
          }
          if (next === 61) {
            this.finishOp(30, 2);
          } else {
            this.finishOp(53, 1);
          }
        }
        readToken_lt() {
          const {
            pos
          } = this.state;
          const next = this.input.charCodeAt(pos + 1);
          if (next === 60) {
            if (this.input.charCodeAt(pos + 2) === 61) {
              this.finishOp(30, 3);
              return;
            }
            this.finishOp(51, 2);
            return;
          }
          if (next === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(47, 1);
        }
        readToken_gt() {
          const {
            pos
          } = this.state;
          const next = this.input.charCodeAt(pos + 1);
          if (next === 62) {
            const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(pos + size) === 61) {
              this.finishOp(30, size + 1);
              return;
            }
            this.finishOp(52, size);
            return;
          }
          if (next === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(48, 1);
        }
        readToken_eq_excl(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61) {
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
          }
          if (code2 === 61 && next === 62) {
            this.state.pos += 2;
            this.finishToken(19);
            return;
          }
          this.finishOp(code2 === 61 ? 29 : 35, 1);
        }
        readToken_question() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          const next2 = this.input.charCodeAt(this.state.pos + 2);
          if (next === 63) {
            if (next2 === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(40, 2);
            }
          } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
            this.state.pos += 2;
            this.finishToken(18);
          } else {
            ++this.state.pos;
            this.finishToken(17);
          }
        }
        getTokenFromCode(code2) {
          switch (code2) {
            case 46:
              this.readToken_dot();
              return;
            case 40:
              ++this.state.pos;
              this.finishToken(10);
              return;
            case 41:
              ++this.state.pos;
              this.finishToken(11);
              return;
            case 59:
              ++this.state.pos;
              this.finishToken(13);
              return;
            case 44:
              ++this.state.pos;
              this.finishToken(12);
              return;
            case 91:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(2);
              } else {
                ++this.state.pos;
                this.finishToken(0);
              }
              return;
            case 93:
              ++this.state.pos;
              this.finishToken(3);
              return;
            case 123:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(6);
              } else {
                ++this.state.pos;
                this.finishToken(5);
              }
              return;
            case 125:
              ++this.state.pos;
              this.finishToken(8);
              return;
            case 58:
              if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                this.finishOp(15, 2);
              } else {
                ++this.state.pos;
                this.finishToken(14);
              }
              return;
            case 63:
              this.readToken_question();
              return;
            case 96:
              this.readTemplateToken();
              return;
            case 48: {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 120 || next === 88) {
                this.readRadixNumber(16);
                return;
              }
              if (next === 111 || next === 79) {
                this.readRadixNumber(8);
                return;
              }
              if (next === 98 || next === 66) {
                this.readRadixNumber(2);
                return;
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(false);
              return;
            case 34:
            case 39:
              this.readString(code2);
              return;
            case 47:
              this.readToken_slash();
              return;
            case 37:
            case 42:
              this.readToken_mult_modulo(code2);
              return;
            case 124:
            case 38:
              this.readToken_pipe_amp(code2);
              return;
            case 94:
              this.readToken_caret();
              return;
            case 43:
            case 45:
              this.readToken_plus_min(code2);
              return;
            case 60:
              this.readToken_lt();
              return;
            case 62:
              this.readToken_gt();
              return;
            case 61:
            case 33:
              this.readToken_eq_excl(code2);
              return;
            case 126:
              this.finishOp(36, 1);
              return;
            case 64:
              this.readToken_atSign();
              return;
            case 35:
              this.readToken_numberSign();
              return;
            case 92:
              this.readWord();
              return;
            default:
              if (isIdentifierStart2(code2)) {
                this.readWord(code2);
                return;
              }
          }
          throw this.raise(Errors.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(code2)
          });
        }
        finishOp(type, size) {
          const str = this.input.slice(this.state.pos, this.state.pos + size);
          this.state.pos += size;
          this.finishToken(type, str);
        }
        readRegexp() {
          const startLoc = this.state.startLoc;
          const start = this.state.start + 1;
          let escaped, inClass;
          let {
            pos
          } = this.state;
          for (; ; ++pos) {
            if (pos >= this.length) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            const ch = this.input.charCodeAt(pos);
            if (isNewLine(ch)) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            if (escaped) {
              escaped = false;
            } else {
              if (ch === 91) {
                inClass = true;
              } else if (ch === 93 && inClass) {
                inClass = false;
              } else if (ch === 47 && !inClass) {
                break;
              }
              escaped = ch === 92;
            }
          }
          const content = this.input.slice(start, pos);
          ++pos;
          let mods = "";
          const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
          while (pos < this.length) {
            const cp = this.codePointAtPos(pos);
            const char = String.fromCharCode(cp);
            if (VALID_REGEX_FLAGS.has(cp)) {
              if (cp === 118) {
                this.expectPlugin("regexpUnicodeSets", nextPos());
                if (mods.includes("u")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              } else if (cp === 117) {
                if (mods.includes("v")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              }
              if (mods.includes(char)) {
                this.raise(Errors.DuplicateRegExpFlags, {
                  at: nextPos()
                });
              }
            } else if (isIdentifierChar(cp) || cp === 92) {
              this.raise(Errors.MalformedRegExpFlags, {
                at: nextPos()
              });
            } else {
              break;
            }
            ++pos;
            mods += char;
          }
          this.state.pos = pos;
          this.finishToken(135, {
            pattern: content,
            flags: mods
          });
        }
        readInt(radix, len, forceLen = false, allowNumSeparator = true) {
          const {
            n,
            pos
          } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
          this.state.pos = pos;
          return n;
        }
        readRadixNumber(radix) {
          const startLoc = this.state.curPosition();
          let isBigInt = false;
          this.state.pos += 2;
          const val = this.readInt(radix);
          if (val == null) {
            this.raise(Errors.InvalidDigit, {
              at: createPositionWithColumnOffset(startLoc, 2),
              radix
            });
          }
          const next = this.input.charCodeAt(this.state.pos);
          if (next === 110) {
            ++this.state.pos;
            isBigInt = true;
          } else if (next === 109) {
            throw this.raise(Errors.InvalidDecimal, {
              at: startLoc
            });
          }
          if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          if (isBigInt) {
            const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
            this.finishToken(133, str);
            return;
          }
          this.finishToken(132, val);
        }
        readNumber(startsWithDot) {
          const start = this.state.pos;
          const startLoc = this.state.curPosition();
          let isFloat = false;
          let isBigInt = false;
          let isDecimal = false;
          let hasExponent = false;
          let isOctal = false;
          if (!startsWithDot && this.readInt(10) === null) {
            this.raise(Errors.InvalidNumber, {
              at: this.state.curPosition()
            });
          }
          const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
          if (hasLeadingZero) {
            const integer2 = this.input.slice(start, this.state.pos);
            this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
              at: startLoc
            });
            if (!this.state.strict) {
              const underscorePos = integer2.indexOf("_");
              if (underscorePos > 0) {
                this.raise(Errors.ZeroDigitNumericSeparator, {
                  at: createPositionWithColumnOffset(startLoc, underscorePos)
                });
              }
            }
            isOctal = hasLeadingZero && !/[89]/.test(integer2);
          }
          let next = this.input.charCodeAt(this.state.pos);
          if (next === 46 && !isOctal) {
            ++this.state.pos;
            this.readInt(10);
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
          }
          if ((next === 69 || next === 101) && !isOctal) {
            next = this.input.charCodeAt(++this.state.pos);
            if (next === 43 || next === 45) {
              ++this.state.pos;
            }
            if (this.readInt(10) === null) {
              this.raise(Errors.InvalidOrMissingExponent, {
                at: startLoc
              });
            }
            isFloat = true;
            hasExponent = true;
            next = this.input.charCodeAt(this.state.pos);
          }
          if (next === 110) {
            if (isFloat || hasLeadingZero) {
              this.raise(Errors.InvalidBigIntLiteral, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isBigInt = true;
          }
          if (next === 109) {
            this.expectPlugin("decimal", this.state.curPosition());
            if (hasExponent || hasLeadingZero) {
              this.raise(Errors.InvalidDecimal, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isDecimal = true;
          }
          if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
          if (isBigInt) {
            this.finishToken(133, str);
            return;
          }
          if (isDecimal) {
            this.finishToken(134, str);
            return;
          }
          const val = isOctal ? parseInt(str, 8) : parseFloat(str);
          this.finishToken(132, val);
        }
        readCodePoint(throwOnInvalid) {
          const {
            code: code2,
            pos
          } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
          this.state.pos = pos;
          return code2;
        }
        readString(quote) {
          const {
            str,
            pos,
            curLine,
            lineStart
          } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
          this.state.pos = pos + 1;
          this.state.lineStart = lineStart;
          this.state.curLine = curLine;
          this.finishToken(131, str);
        }
        readTemplateContinuation() {
          if (!this.match(8)) {
            this.unexpected(null, 8);
          }
          this.state.pos--;
          this.readTemplateToken();
        }
        readTemplateToken() {
          const opening = this.input[this.state.pos];
          const {
            str,
            firstInvalidLoc,
            pos,
            curLine,
            lineStart
          } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
          this.state.pos = pos + 1;
          this.state.lineStart = lineStart;
          this.state.curLine = curLine;
          if (firstInvalidLoc) {
            this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
          }
          if (this.input.codePointAt(pos) === 96) {
            this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
          } else {
            this.state.pos++;
            this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
          }
        }
        recordStrictModeErrors(toParseError, {
          at
        }) {
          const index = at.index;
          if (this.state.strict && !this.state.strictErrors.has(index)) {
            this.raise(toParseError, {
              at
            });
          } else {
            this.state.strictErrors.set(index, [toParseError, at]);
          }
        }
        readWord1(firstCode) {
          this.state.containsEsc = false;
          let word = "";
          const start = this.state.pos;
          let chunkStart = this.state.pos;
          if (firstCode !== void 0) {
            this.state.pos += firstCode <= 65535 ? 1 : 2;
          }
          while (this.state.pos < this.length) {
            const ch = this.codePointAtPos(this.state.pos);
            if (isIdentifierChar(ch)) {
              this.state.pos += ch <= 65535 ? 1 : 2;
            } else if (ch === 92) {
              this.state.containsEsc = true;
              word += this.input.slice(chunkStart, this.state.pos);
              const escStart = this.state.curPosition();
              const identifierCheck = this.state.pos === start ? isIdentifierStart2 : isIdentifierChar;
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(Errors.MissingUnicodeEscape, {
                  at: this.state.curPosition()
                });
                chunkStart = this.state.pos - 1;
                continue;
              }
              ++this.state.pos;
              const esc = this.readCodePoint(true);
              if (esc !== null) {
                if (!identifierCheck(esc)) {
                  this.raise(Errors.EscapedCharNotAnIdentifier, {
                    at: escStart
                  });
                }
                word += String.fromCodePoint(esc);
              }
              chunkStart = this.state.pos;
            } else {
              break;
            }
          }
          return word + this.input.slice(chunkStart, this.state.pos);
        }
        readWord(firstCode) {
          const word = this.readWord1(firstCode);
          const type = keywords$1.get(word);
          if (type !== void 0) {
            this.finishToken(type, tokenLabelName(type));
          } else {
            this.finishToken(130, word);
          }
        }
        checkKeywordEscapes() {
          const {
            type
          } = this.state;
          if (tokenIsKeyword(type) && this.state.containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.startLoc,
              reservedWord: tokenLabelName(type)
            });
          }
        }
        raise(toParseError, raiseProperties) {
          const {
            at
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
          const loc = at instanceof Position ? at : at.loc.start;
          const error = toParseError({
            loc,
            details
          });
          if (!this.options.errorRecovery)
            throw error;
          if (!this.isLookahead)
            this.state.errors.push(error);
          return error;
        }
        raiseOverwrite(toParseError, raiseProperties) {
          const {
            at
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
          const loc = at instanceof Position ? at : at.loc.start;
          const pos = loc.index;
          const errors = this.state.errors;
          for (let i = errors.length - 1; i >= 0; i--) {
            const error = errors[i];
            if (error.loc.index === pos) {
              return errors[i] = toParseError({
                loc,
                details
              });
            }
            if (error.loc.index < pos)
              break;
          }
          return this.raise(toParseError, raiseProperties);
        }
        updateContext(prevType) {
        }
        unexpected(loc, type) {
          throw this.raise(Errors.UnexpectedToken, {
            expected: type ? tokenLabelName(type) : null,
            at: loc != null ? loc : this.state.startLoc
          });
        }
        expectPlugin(pluginName, loc) {
          if (this.hasPlugin(pluginName)) {
            return true;
          }
          throw this.raise(Errors.MissingPlugin, {
            at: loc != null ? loc : this.state.startLoc,
            missingPlugin: [pluginName]
          });
        }
        expectOnePlugin(pluginNames) {
          if (!pluginNames.some((name41) => this.hasPlugin(name41))) {
            throw this.raise(Errors.MissingOneOfPlugins, {
              at: this.state.startLoc,
              missingPlugin: pluginNames
            });
          }
        }
        errorBuilder(error) {
          return (pos, lineStart, curLine) => {
            this.raise(error, {
              at: buildPosition(pos, lineStart, curLine)
            });
          };
        }
      };
      var ClassScope = class {
        constructor() {
          this.privateNames = /* @__PURE__ */ new Set();
          this.loneAccessors = /* @__PURE__ */ new Map();
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        }
      };
      var ClassScopeHandler = class {
        constructor(parser) {
          this.parser = void 0;
          this.stack = [];
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          this.parser = parser;
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new ClassScope());
        }
        exit() {
          const oldClassScope = this.stack.pop();
          const current = this.current();
          for (const [name41, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
            if (current) {
              if (!current.undefinedPrivateNames.has(name41)) {
                current.undefinedPrivateNames.set(name41, loc);
              }
            } else {
              this.parser.raise(Errors.InvalidPrivateFieldResolution, {
                at: loc,
                identifierName: name41
              });
            }
          }
        }
        declarePrivateName(name41, elementType, loc) {
          const {
            privateNames,
            loneAccessors,
            undefinedPrivateNames
          } = this.current();
          let redefined = privateNames.has(name41);
          if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
            const accessor = redefined && loneAccessors.get(name41);
            if (accessor) {
              const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
              const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
              const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
              const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
              redefined = oldKind === newKind || oldStatic !== newStatic;
              if (!redefined)
                loneAccessors.delete(name41);
            } else if (!redefined) {
              loneAccessors.set(name41, elementType);
            }
          }
          if (redefined) {
            this.parser.raise(Errors.PrivateNameRedeclaration, {
              at: loc,
              identifierName: name41
            });
          }
          privateNames.add(name41);
          undefinedPrivateNames.delete(name41);
        }
        usePrivateName(name41, loc) {
          let classScope;
          for (classScope of this.stack) {
            if (classScope.privateNames.has(name41))
              return;
          }
          if (classScope) {
            classScope.undefinedPrivateNames.set(name41, loc);
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, {
              at: loc,
              identifierName: name41
            });
          }
        }
      };
      var kExpression = 0;
      var kMaybeArrowParameterDeclaration = 1;
      var kMaybeAsyncArrowParameterDeclaration = 2;
      var kParameterDeclaration = 3;
      var ExpressionScope = class {
        constructor(type = kExpression) {
          this.type = void 0;
          this.type = type;
        }
        canBeArrowParameterDeclaration() {
          return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
        }
        isCertainlyParameterDeclaration() {
          return this.type === kParameterDeclaration;
        }
      };
      var ArrowHeadParsingScope = class extends ExpressionScope {
        constructor(type) {
          super(type);
          this.declarationErrors = /* @__PURE__ */ new Map();
        }
        recordDeclarationError(ParsingErrorClass, {
          at
        }) {
          const index = at.index;
          this.declarationErrors.set(index, [ParsingErrorClass, at]);
        }
        clearDeclarationError(index) {
          this.declarationErrors.delete(index);
        }
        iterateErrors(iterator) {
          this.declarationErrors.forEach(iterator);
        }
      };
      var ExpressionScopeHandler = class {
        constructor(parser) {
          this.parser = void 0;
          this.stack = [new ExpressionScope()];
          this.parser = parser;
        }
        enter(scope) {
          this.stack.push(scope);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(toParseError, {
          at: node
        }) {
          const origin = {
            at: node.loc.start
          };
          const {
            stack
          } = this;
          let i = stack.length - 1;
          let scope = stack[i];
          while (!scope.isCertainlyParameterDeclaration()) {
            if (scope.canBeArrowParameterDeclaration()) {
              scope.recordDeclarationError(toParseError, origin);
            } else {
              return;
            }
            scope = stack[--i];
          }
          this.parser.raise(toParseError, origin);
        }
        recordArrowParameterBindingError(error, {
          at: node
        }) {
          const {
            stack
          } = this;
          const scope = stack[stack.length - 1];
          const origin = {
            at: node.loc.start
          };
          if (scope.isCertainlyParameterDeclaration()) {
            this.parser.raise(error, origin);
          } else if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(error, origin);
          } else {
            return;
          }
        }
        recordAsyncArrowParametersError({
          at
        }) {
          const {
            stack
          } = this;
          let i = stack.length - 1;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
              scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
                at
              });
            }
            scope = stack[--i];
          }
        }
        validateAsPattern() {
          const {
            stack
          } = this;
          const currentScope = stack[stack.length - 1];
          if (!currentScope.canBeArrowParameterDeclaration())
            return;
          currentScope.iterateErrors(([toParseError, loc]) => {
            this.parser.raise(toParseError, {
              at: loc
            });
            let i = stack.length - 2;
            let scope = stack[i];
            while (scope.canBeArrowParameterDeclaration()) {
              scope.clearDeclarationError(loc.index);
              scope = stack[--i];
            }
          });
        }
      };
      function newParameterDeclarationScope() {
        return new ExpressionScope(kParameterDeclaration);
      }
      function newArrowHeadScope() {
        return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
      }
      function newAsyncArrowScope() {
        return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
      }
      function newExpressionScope() {
        return new ExpressionScope();
      }
      var PARAM = 0;
      var PARAM_YIELD = 1;
      var PARAM_AWAIT = 2;
      var PARAM_RETURN = 4;
      var PARAM_IN = 8;
      var ProductionParameterHandler = class {
        constructor() {
          this.stacks = [];
        }
        enter(flags) {
          this.stacks.push(flags);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (this.currentFlags() & PARAM_AWAIT) > 0;
        }
        get hasYield() {
          return (this.currentFlags() & PARAM_YIELD) > 0;
        }
        get hasReturn() {
          return (this.currentFlags() & PARAM_RETURN) > 0;
        }
        get hasIn() {
          return (this.currentFlags() & PARAM_IN) > 0;
        }
      };
      function functionFlags(isAsync, isGenerator) {
        return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
      }
      var UtilParser = class extends Tokenizer2 {
        addExtra(node, key, value, enumerable = true) {
          if (!node)
            return;
          const extra = node.extra = node.extra || {};
          if (enumerable) {
            extra[key] = value;
          } else {
            Object.defineProperty(extra, key, {
              enumerable,
              value
            });
          }
        }
        isContextual(token) {
          return this.state.type === token && !this.state.containsEsc;
        }
        isUnparsedContextual(nameStart, name41) {
          const nameEnd = nameStart + name41.length;
          if (this.input.slice(nameStart, nameEnd) === name41) {
            const nextCh = this.input.charCodeAt(nameEnd);
            return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
          }
          return false;
        }
        isLookaheadContextual(name41) {
          const next = this.nextTokenStart();
          return this.isUnparsedContextual(next, name41);
        }
        eatContextual(token) {
          if (this.isContextual(token)) {
            this.next();
            return true;
          }
          return false;
        }
        expectContextual(token, toParseError) {
          if (!this.eatContextual(token)) {
            if (toParseError != null) {
              throw this.raise(toParseError, {
                at: this.state.startLoc
              });
            }
            throw this.unexpected(null, token);
          }
        }
        canInsertSemicolon() {
          return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
          return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
        }
        hasFollowingLineBreak() {
          skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
          return skipWhiteSpaceToLineBreak.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(allowAsi = true) {
          if (allowAsi ? this.isLineTerminator() : this.eat(13))
            return;
          this.raise(Errors.MissingSemicolon, {
            at: this.state.lastTokEndLoc
          });
        }
        expect(type, loc) {
          this.eat(type) || this.unexpected(loc, type);
        }
        tryParse(fn, oldState = this.state.clone()) {
          const abortSignal = {
            node: null
          };
          try {
            const node = fn((node2 = null) => {
              abortSignal.node = node2;
              throw abortSignal;
            });
            if (this.state.errors.length > oldState.errors.length) {
              const failState = this.state;
              this.state = oldState;
              this.state.tokensLength = failState.tokensLength;
              return {
                node,
                error: failState.errors[oldState.errors.length],
                thrown: false,
                aborted: false,
                failState
              };
            }
            return {
              node,
              error: null,
              thrown: false,
              aborted: false,
              failState: null
            };
          } catch (error) {
            const failState = this.state;
            this.state = oldState;
            if (error instanceof SyntaxError) {
              return {
                node: null,
                error,
                thrown: true,
                aborted: false,
                failState
              };
            }
            if (error === abortSignal) {
              return {
                node: abortSignal.node,
                error: null,
                thrown: false,
                aborted: true,
                failState
              };
            }
            throw error;
          }
        }
        checkExpressionErrors(refExpressionErrors, andThrow) {
          if (!refExpressionErrors)
            return false;
          const {
            shorthandAssignLoc,
            doubleProtoLoc,
            privateKeyLoc,
            optionalParametersLoc
          } = refExpressionErrors;
          const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
          if (!andThrow) {
            return hasErrors;
          }
          if (shorthandAssignLoc != null) {
            this.raise(Errors.InvalidCoverInitializedName, {
              at: shorthandAssignLoc
            });
          }
          if (doubleProtoLoc != null) {
            this.raise(Errors.DuplicateProto, {
              at: doubleProtoLoc
            });
          }
          if (privateKeyLoc != null) {
            this.raise(Errors.UnexpectedPrivateField, {
              at: privateKeyLoc
            });
          }
          if (optionalParametersLoc != null) {
            this.unexpected(optionalParametersLoc);
          }
        }
        isLiteralPropertyName() {
          return tokenIsLiteralPropertyName(this.state.type);
        }
        isPrivateName(node) {
          return node.type === "PrivateName";
        }
        getPrivateNameSV(node) {
          return node.id.name;
        }
        hasPropertyAsPrivateName(node) {
          return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
        }
        isOptionalChain(node) {
          return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
        }
        isObjectProperty(node) {
          return node.type === "ObjectProperty";
        }
        isObjectMethod(node) {
          return node.type === "ObjectMethod";
        }
        initializeScopes(inModule = this.options.sourceType === "module") {
          const oldLabels = this.state.labels;
          this.state.labels = [];
          const oldExportedIdentifiers = this.exportedIdentifiers;
          this.exportedIdentifiers = /* @__PURE__ */ new Set();
          const oldInModule = this.inModule;
          this.inModule = inModule;
          const oldScope = this.scope;
          const ScopeHandler2 = this.getScopeHandler();
          this.scope = new ScopeHandler2(this, inModule);
          const oldProdParam = this.prodParam;
          this.prodParam = new ProductionParameterHandler();
          const oldClassScope = this.classScope;
          this.classScope = new ClassScopeHandler(this);
          const oldExpressionScope = this.expressionScope;
          this.expressionScope = new ExpressionScopeHandler(this);
          return () => {
            this.state.labels = oldLabels;
            this.exportedIdentifiers = oldExportedIdentifiers;
            this.inModule = oldInModule;
            this.scope = oldScope;
            this.prodParam = oldProdParam;
            this.classScope = oldClassScope;
            this.expressionScope = oldExpressionScope;
          };
        }
        enterInitialScopes() {
          let paramFlags = PARAM;
          if (this.inModule) {
            paramFlags |= PARAM_AWAIT;
          }
          this.scope.enter(SCOPE_PROGRAM);
          this.prodParam.enter(paramFlags);
        }
        checkDestructuringPrivate(refExpressionErrors) {
          const {
            privateKeyLoc
          } = refExpressionErrors;
          if (privateKeyLoc !== null) {
            this.expectPlugin("destructuringPrivate", privateKeyLoc);
          }
        }
      };
      var ExpressionErrors = class {
        constructor() {
          this.shorthandAssignLoc = null;
          this.doubleProtoLoc = null;
          this.privateKeyLoc = null;
          this.optionalParametersLoc = null;
        }
      };
      var Node = class {
        constructor(parser, pos, loc) {
          this.type = "";
          this.start = pos;
          this.end = 0;
          this.loc = new SourceLocation(loc);
          if (parser != null && parser.options.ranges)
            this.range = [pos, 0];
          if (parser != null && parser.filename)
            this.loc.filename = parser.filename;
        }
      };
      var NodePrototype = Node.prototype;
      {
        NodePrototype.__clone = function() {
          const newNode = new Node(void 0, this.start, this.loc.start);
          const keys = Object.keys(this);
          for (let i = 0, length = keys.length; i < length; i++) {
            const key = keys[i];
            if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
              newNode[key] = this[key];
            }
          }
          return newNode;
        };
      }
      function clonePlaceholder(node) {
        return cloneIdentifier(node);
      }
      function cloneIdentifier(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra,
          name: name41
        } = node;
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.extra = extra;
        cloned.name = name41;
        if (type === "Placeholder") {
          cloned.expectedNode = node.expectedNode;
        }
        return cloned;
      }
      function cloneStringLiteral(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra
        } = node;
        if (type === "Placeholder") {
          return clonePlaceholder(node);
        }
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        if (node.raw !== void 0) {
          cloned.raw = node.raw;
        } else {
          cloned.extra = extra;
        }
        cloned.value = node.value;
        return cloned;
      }
      var NodeUtils = class extends UtilParser {
        startNode() {
          return new Node(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(loc) {
          return new Node(this, loc.index, loc);
        }
        startNodeAtNode(type) {
          return this.startNodeAt(type.loc.start);
        }
        finishNode(node, type) {
          return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
        }
        finishNodeAt(node, type, endLoc) {
          node.type = type;
          node.end = endLoc.index;
          node.loc.end = endLoc;
          if (this.options.ranges)
            node.range[1] = endLoc.index;
          if (this.options.attachComment)
            this.processComment(node);
          return node;
        }
        resetStartLocation(node, startLoc) {
          node.start = startLoc.index;
          node.loc.start = startLoc;
          if (this.options.ranges)
            node.range[0] = startLoc.index;
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          node.end = endLoc.index;
          node.loc.end = endLoc;
          if (this.options.ranges)
            node.range[1] = endLoc.index;
        }
        resetStartLocationFromNode(node, locationNode) {
          this.resetStartLocation(node, locationNode.loc.start);
        }
      };
      var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
      var FlowErrors = ParseErrorEnum`flow`({
        AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
        AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
        AssignReservedType: ({
          reservedType
        }) => `Cannot overwrite reserved type ${reservedType}.`,
        DeclareClassElement: "The `declare` modifier can only appear on class fields.",
        DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
        DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
        EnumBooleanMemberNotInitialized: ({
          memberName,
          enumName
        }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
        EnumDuplicateMemberName: ({
          memberName,
          enumName
        }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
        EnumInconsistentMemberValues: ({
          enumName
        }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
        EnumInvalidExplicitType: ({
          invalidEnumType,
          enumName
        }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
        EnumInvalidExplicitTypeUnknownSupplied: ({
          enumName
        }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
        EnumInvalidMemberInitializerPrimaryType: ({
          enumName,
          memberName,
          explicitType
        }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
        EnumInvalidMemberInitializerSymbolType: ({
          enumName,
          memberName
        }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
        EnumInvalidMemberInitializerUnknownType: ({
          enumName,
          memberName
        }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
        EnumInvalidMemberName: ({
          enumName,
          memberName,
          suggestion
        }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
        EnumNumberMemberNotInitialized: ({
          enumName,
          memberName
        }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
        EnumStringMemberInconsistentlyInitailized: ({
          enumName
        }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
        GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
        ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
        ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
        InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
        InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
        InexactVariance: "Explicit inexact syntax cannot have variance.",
        InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
        MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
        NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
        NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
        PatternIsOptional: Object.assign({
          message: "A binding pattern parameter cannot be optional in an implementation signature."
        }, {
          reasonCode: "OptionalBindingPattern"
        }),
        SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
        SpreadVariance: "Spread properties cannot have variance.",
        ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
        ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
        ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
        ThisParamNoDefault: "The `this` parameter may not have a default value.",
        TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
        UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
        UnexpectedReservedType: ({
          reservedType
        }) => `Unexpected reserved type ${reservedType}.`,
        UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
        UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
        UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
        UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
        UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
        UnsupportedDeclareExportKind: ({
          unsupportedExportKind,
          suggestion
        }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
        UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
        UnterminatedFlowComment: "Unterminated flow-comment."
      });
      function isEsModuleType(bodyElement) {
        return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
      }
      function hasTypeImportKind(node) {
        return node.importKind === "type" || node.importKind === "typeof";
      }
      function isMaybeDefaultImport(type) {
        return tokenIsKeywordOrIdentifier(type) && type !== 97;
      }
      var exportSuggestions = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
      };
      function partition(list, test) {
        const list1 = [];
        const list2 = [];
        for (let i = 0; i < list.length; i++) {
          (test(list[i], i, list) ? list1 : list2).push(list[i]);
        }
        return [list1, list2];
      }
      var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
      var flow = (superClass) => class FlowParserMixin extends superClass {
        constructor(...args) {
          super(...args);
          this.flowPragma = void 0;
        }
        getScopeHandler() {
          return FlowScopeHandler;
        }
        shouldParseTypes() {
          return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
        shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
        }
        finishToken(type, val) {
          if (type !== 131 && type !== 13 && type !== 28) {
            if (this.flowPragma === void 0) {
              this.flowPragma = null;
            }
          }
          return super.finishToken(type, val);
        }
        addComment(comment) {
          if (this.flowPragma === void 0) {
            const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
            if (!matches)
              ;
            else if (matches[1] === "flow") {
              this.flowPragma = "flow";
            } else if (matches[1] === "noflow") {
              this.flowPragma = "noflow";
            } else {
              throw new Error("Unexpected flow pragma");
            }
          }
          return super.addComment(comment);
        }
        flowParseTypeInitialiser(tok) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(tok || 14);
          const type = this.flowParseType();
          this.state.inType = oldInType;
          return type;
        }
        flowParsePredicate() {
          const node = this.startNode();
          const moduloLoc = this.state.startLoc;
          this.next();
          this.expectContextual(108);
          if (this.state.lastTokStart > moduloLoc.index + 1) {
            this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
              at: moduloLoc
            });
          }
          if (this.eat(10)) {
            node.value = super.parseExpression();
            this.expect(11);
            return this.finishNode(node, "DeclaredPredicate");
          } else {
            return this.finishNode(node, "InferredPredicate");
          }
        }
        flowParseTypeAndPredicateInitialiser() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(14);
          let type = null;
          let predicate = null;
          if (this.match(54)) {
            this.state.inType = oldInType;
            predicate = this.flowParsePredicate();
          } else {
            type = this.flowParseType();
            this.state.inType = oldInType;
            if (this.match(54)) {
              predicate = this.flowParsePredicate();
            }
          }
          return [type, predicate];
        }
        flowParseDeclareClass(node) {
          this.next();
          this.flowParseInterfaceish(node, true);
          return this.finishNode(node, "DeclareClass");
        }
        flowParseDeclareFunction(node) {
          this.next();
          const id = node.id = this.parseIdentifier();
          const typeNode = this.startNode();
          const typeContainer = this.startNode();
          if (this.match(47)) {
            typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            typeNode.typeParameters = null;
          }
          this.expect(10);
          const tmp = this.flowParseFunctionTypeParams();
          typeNode.params = tmp.params;
          typeNode.rest = tmp.rest;
          typeNode.this = tmp._this;
          this.expect(11);
          [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
          id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
          this.resetEndLocation(id);
          this.semicolon();
          this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);
          return this.finishNode(node, "DeclareFunction");
        }
        flowParseDeclare(node, insideModule) {
          if (this.match(80)) {
            return this.flowParseDeclareClass(node);
          } else if (this.match(68)) {
            return this.flowParseDeclareFunction(node);
          } else if (this.match(74)) {
            return this.flowParseDeclareVariable(node);
          } else if (this.eatContextual(125)) {
            if (this.match(16)) {
              return this.flowParseDeclareModuleExports(node);
            } else {
              if (insideModule) {
                this.raise(FlowErrors.NestedDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.flowParseDeclareModule(node);
            }
          } else if (this.isContextual(128)) {
            return this.flowParseDeclareTypeAlias(node);
          } else if (this.isContextual(129)) {
            return this.flowParseDeclareOpaqueType(node);
          } else if (this.isContextual(127)) {
            return this.flowParseDeclareInterface(node);
          } else if (this.match(82)) {
            return this.flowParseDeclareExportDeclaration(node, insideModule);
          } else {
            throw this.unexpected();
          }
        }
        flowParseDeclareVariable(node) {
          this.next();
          node.id = this.flowParseTypeAnnotatableIdentifier(true);
          this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
          this.semicolon();
          return this.finishNode(node, "DeclareVariable");
        }
        flowParseDeclareModule(node) {
          this.scope.enter(SCOPE_OTHER);
          if (this.match(131)) {
            node.id = super.parseExprAtom();
          } else {
            node.id = this.parseIdentifier();
          }
          const bodyNode = node.body = this.startNode();
          const body = bodyNode.body = [];
          this.expect(5);
          while (!this.match(8)) {
            let bodyNode2 = this.startNode();
            if (this.match(83)) {
              this.next();
              if (!this.isContextual(128) && !this.match(87)) {
                this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              super.parseImport(bodyNode2);
            } else {
              this.expectContextual(123, FlowErrors.UnsupportedStatementInDeclareModule);
              bodyNode2 = this.flowParseDeclare(bodyNode2, true);
            }
            body.push(bodyNode2);
          }
          this.scope.exit();
          this.expect(8);
          this.finishNode(bodyNode, "BlockStatement");
          let kind = null;
          let hasModuleExport = false;
          body.forEach((bodyElement) => {
            if (isEsModuleType(bodyElement)) {
              if (kind === "CommonJS") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "ES";
            } else if (bodyElement.type === "DeclareModuleExports") {
              if (hasModuleExport) {
                this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                  at: bodyElement
                });
              }
              if (kind === "ES") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "CommonJS";
              hasModuleExport = true;
            }
          });
          node.kind = kind || "CommonJS";
          return this.finishNode(node, "DeclareModule");
        }
        flowParseDeclareExportDeclaration(node, insideModule) {
          this.expect(82);
          if (this.eat(65)) {
            if (this.match(68) || this.match(80)) {
              node.declaration = this.flowParseDeclare(this.startNode());
            } else {
              node.declaration = this.flowParseType();
              this.semicolon();
            }
            node.default = true;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else {
            if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !insideModule) {
              const label = this.state.value;
              throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: label,
                suggestion: exportSuggestions[label]
              });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129)) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node.default = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129)) {
              node = this.parseExport(node, null);
              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node.default = false;
                delete node.exportKind;
              }
              node.type = "Declare" + node.type;
              return node;
            }
          }
          throw this.unexpected();
        }
        flowParseDeclareModuleExports(node) {
          this.next();
          this.expectContextual(109);
          node.typeAnnotation = this.flowParseTypeAnnotation();
          this.semicolon();
          return this.finishNode(node, "DeclareModuleExports");
        }
        flowParseDeclareTypeAlias(node) {
          this.next();
          const finished = this.flowParseTypeAlias(node);
          finished.type = "DeclareTypeAlias";
          return finished;
        }
        flowParseDeclareOpaqueType(node) {
          this.next();
          const finished = this.flowParseOpaqueType(node, true);
          finished.type = "DeclareOpaqueType";
          return finished;
        }
        flowParseDeclareInterface(node) {
          this.next();
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "DeclareInterface");
        }
        flowParseInterfaceish(node, isClass = false) {
          node.id = this.flowParseRestrictedIdentifier(!isClass, true);
          this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.extends = [];
          node.implements = [];
          node.mixins = [];
          if (this.eat(81)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(12));
          }
          if (this.isContextual(115)) {
            this.next();
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.isContextual(111)) {
            this.next();
            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node.body = this.flowParseObjectType({
            allowStatic: isClass,
            allowExact: false,
            allowSpread: false,
            allowProto: isClass,
            allowInexact: false
          });
        }
        flowParseInterfaceExtends() {
          const node = this.startNode();
          node.id = this.flowParseQualifiedTypeIdentifier();
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }
          return this.finishNode(node, "InterfaceExtends");
        }
        flowParseInterface(node) {
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "InterfaceDeclaration");
        }
        checkNotUnderscore(word) {
          if (word === "_") {
            this.raise(FlowErrors.UnexpectedReservedUnderscore, {
              at: this.state.startLoc
            });
          }
        }
        checkReservedType(word, startLoc, declaration) {
          if (!reservedTypes.has(word))
            return;
          this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
            at: startLoc,
            reservedType: word
          });
        }
        flowParseRestrictedIdentifier(liberal, declaration) {
          this.checkReservedType(this.state.value, this.state.startLoc, declaration);
          return this.parseIdentifier(liberal);
        }
        flowParseTypeAlias(node) {
          node.id = this.flowParseRestrictedIdentifier(false, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.right = this.flowParseTypeInitialiser(29);
          this.semicolon();
          return this.finishNode(node, "TypeAlias");
        }
        flowParseOpaqueType(node, declare) {
          this.expectContextual(128);
          node.id = this.flowParseRestrictedIdentifier(true, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.supertype = null;
          if (this.match(14)) {
            node.supertype = this.flowParseTypeInitialiser(14);
          }
          node.impltype = null;
          if (!declare) {
            node.impltype = this.flowParseTypeInitialiser(29);
          }
          this.semicolon();
          return this.finishNode(node, "OpaqueType");
        }
        flowParseTypeParameter(requireDefault = false) {
          const nodeStartLoc = this.state.startLoc;
          const node = this.startNode();
          const variance = this.flowParseVariance();
          const ident = this.flowParseTypeAnnotatableIdentifier();
          node.name = ident.name;
          node.variance = variance;
          node.bound = ident.typeAnnotation;
          if (this.match(29)) {
            this.eat(29);
            node.default = this.flowParseType();
          } else {
            if (requireDefault) {
              this.raise(FlowErrors.MissingTypeParamDefault, {
                at: nodeStartLoc
              });
            }
          }
          return this.finishNode(node, "TypeParameter");
        }
        flowParseTypeParameterDeclaration() {
          const oldInType = this.state.inType;
          const node = this.startNode();
          node.params = [];
          this.state.inType = true;
          if (this.match(47) || this.match(140)) {
            this.next();
          } else {
            this.unexpected();
          }
          let defaultRequired = false;
          do {
            const typeParameter = this.flowParseTypeParameter(defaultRequired);
            node.params.push(typeParameter);
            if (typeParameter.default) {
              defaultRequired = true;
            }
            if (!this.match(48)) {
              this.expect(12);
            }
          } while (!this.match(48));
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterDeclaration");
        }
        flowParseTypeParameterInstantiation() {
          const node = this.startNode();
          const oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseTypeParameterInstantiationCallOrNew() {
          const node = this.startNode();
          const oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          while (!this.match(48)) {
            node.params.push(this.flowParseTypeOrImplicitInstantiation());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseInterfaceType() {
          const node = this.startNode();
          this.expectContextual(127);
          node.extends = [];
          if (this.eat(81)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node.body = this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: false,
            allowProto: false,
            allowInexact: false
          });
          return this.finishNode(node, "InterfaceTypeAnnotation");
        }
        flowParseObjectPropertyKey() {
          return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
        }
        flowParseObjectTypeIndexer(node, isStatic, variance) {
          node.static = isStatic;
          if (this.lookahead().type === 14) {
            node.id = this.flowParseObjectPropertyKey();
            node.key = this.flowParseTypeInitialiser();
          } else {
            node.id = null;
            node.key = this.flowParseType();
          }
          this.expect(3);
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
          return this.finishNode(node, "ObjectTypeIndexer");
        }
        flowParseObjectTypeInternalSlot(node, isStatic) {
          node.static = isStatic;
          node.id = this.flowParseObjectPropertyKey();
          this.expect(3);
          this.expect(3);
          if (this.match(47) || this.match(10)) {
            node.method = true;
            node.optional = false;
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
          } else {
            node.method = false;
            if (this.eat(17)) {
              node.optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
          }
          return this.finishNode(node, "ObjectTypeInternalSlot");
        }
        flowParseObjectTypeMethodish(node) {
          node.params = [];
          node.rest = null;
          node.typeParameters = null;
          node.this = null;
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          this.expect(10);
          if (this.match(78)) {
            node.this = this.flowParseFunctionTypeParam(true);
            node.this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            node.params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            node.rest = this.flowParseFunctionTypeParam(false);
          }
          this.expect(11);
          node.returnType = this.flowParseTypeInitialiser();
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        flowParseObjectTypeCallProperty(node, isStatic) {
          const valueNode = this.startNode();
          node.static = isStatic;
          node.value = this.flowParseObjectTypeMethodish(valueNode);
          return this.finishNode(node, "ObjectTypeCallProperty");
        }
        flowParseObjectType({
          allowStatic,
          allowExact,
          allowSpread,
          allowProto,
          allowInexact
        }) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const nodeStart = this.startNode();
          nodeStart.callProperties = [];
          nodeStart.properties = [];
          nodeStart.indexers = [];
          nodeStart.internalSlots = [];
          let endDelim;
          let exact;
          let inexact = false;
          if (allowExact && this.match(6)) {
            this.expect(6);
            endDelim = 9;
            exact = true;
          } else {
            this.expect(5);
            endDelim = 8;
            exact = false;
          }
          nodeStart.exact = exact;
          while (!this.match(endDelim)) {
            let isStatic = false;
            let protoStartLoc = null;
            let inexactStartLoc = null;
            const node = this.startNode();
            if (allowProto && this.isContextual(116)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                protoStartLoc = this.state.startLoc;
                allowStatic = false;
              }
            }
            if (allowStatic && this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                isStatic = true;
              }
            }
            const variance = this.flowParseVariance();
            if (this.eat(0)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (this.eat(0)) {
                if (variance) {
                  this.unexpected(variance.loc.start);
                }
                nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
              } else {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              }
            } else if (this.match(10) || this.match(47)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
            } else {
              let kind = "init";
              if (this.isContextual(98) || this.isContextual(103)) {
                const lookahead = this.lookahead();
                if (tokenIsLiteralPropertyName(lookahead.type)) {
                  kind = this.state.value;
                  this.next();
                }
              }
              const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
              if (propOrInexact === null) {
                inexact = true;
                inexactStartLoc = this.state.lastTokStartLoc;
              } else {
                nodeStart.properties.push(propOrInexact);
              }
            }
            this.flowObjectTypeSemicolon();
            if (inexactStartLoc && !this.match(8) && !this.match(9)) {
              this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
                at: inexactStartLoc
              });
            }
          }
          this.expect(endDelim);
          if (allowSpread) {
            nodeStart.inexact = inexact;
          }
          const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
          this.state.inType = oldInType;
          return out;
        }
        flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
          if (this.eat(21)) {
            const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
            if (isInexactToken) {
              if (!allowSpread) {
                this.raise(FlowErrors.InexactInsideNonObject, {
                  at: this.state.lastTokStartLoc
                });
              } else if (!allowInexact) {
                this.raise(FlowErrors.InexactInsideExact, {
                  at: this.state.lastTokStartLoc
                });
              }
              if (variance) {
                this.raise(FlowErrors.InexactVariance, {
                  at: variance
                });
              }
              return null;
            }
            if (!allowSpread) {
              this.raise(FlowErrors.UnexpectedSpreadType, {
                at: this.state.lastTokStartLoc
              });
            }
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.SpreadVariance, {
                at: variance
              });
            }
            node.argument = this.flowParseType();
            return this.finishNode(node, "ObjectTypeSpreadProperty");
          } else {
            node.key = this.flowParseObjectPropertyKey();
            node.static = isStatic;
            node.proto = protoStartLoc != null;
            node.kind = kind;
            let optional = false;
            if (this.match(47) || this.match(10)) {
              node.method = true;
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
              if (kind === "get" || kind === "set") {
                this.flowCheckGetterSetterParams(node);
              }
              if (!allowSpread && node.key.name === "constructor" && node.value.this) {
                this.raise(FlowErrors.ThisParamBannedInConstructor, {
                  at: node.value.this
                });
              }
            } else {
              if (kind !== "init")
                this.unexpected();
              node.method = false;
              if (this.eat(17)) {
                optional = true;
              }
              node.value = this.flowParseTypeInitialiser();
              node.variance = variance;
            }
            node.optional = optional;
            return this.finishNode(node, "ObjectTypeProperty");
          }
        }
        flowCheckGetterSetterParams(property2) {
          const paramCount = property2.kind === "get" ? 0 : 1;
          const length = property2.value.params.length + (property2.value.rest ? 1 : 0);
          if (property2.value.this) {
            this.raise(property2.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
              at: property2.value.this
            });
          }
          if (length !== paramCount) {
            this.raise(property2.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: property2
            });
          }
          if (property2.kind === "set" && property2.value.rest) {
            this.raise(Errors.BadSetterRestParameter, {
              at: property2
            });
          }
        }
        flowObjectTypeSemicolon() {
          if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
            this.unexpected();
          }
        }
        flowParseQualifiedTypeIdentifier(startLoc, id) {
          var _startLoc;
          (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
          let node = id || this.flowParseRestrictedIdentifier(true);
          while (this.eat(16)) {
            const node2 = this.startNodeAt(startLoc);
            node2.qualification = node;
            node2.id = this.flowParseRestrictedIdentifier(true);
            node = this.finishNode(node2, "QualifiedTypeIdentifier");
          }
          return node;
        }
        flowParseGenericType(startLoc, id) {
          const node = this.startNodeAt(startLoc);
          node.typeParameters = null;
          node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          }
          return this.finishNode(node, "GenericTypeAnnotation");
        }
        flowParseTypeofType() {
          const node = this.startNode();
          this.expect(87);
          node.argument = this.flowParsePrimaryType();
          return this.finishNode(node, "TypeofTypeAnnotation");
        }
        flowParseTupleType() {
          const node = this.startNode();
          node.types = [];
          this.expect(0);
          while (this.state.pos < this.length && !this.match(3)) {
            node.types.push(this.flowParseType());
            if (this.match(3))
              break;
            this.expect(12);
          }
          this.expect(3);
          return this.finishNode(node, "TupleTypeAnnotation");
        }
        flowParseFunctionTypeParam(first) {
          let name41 = null;
          let optional = false;
          let typeAnnotation = null;
          const node = this.startNode();
          const lh = this.lookahead();
          const isThis = this.state.type === 78;
          if (lh.type === 14 || lh.type === 17) {
            if (isThis && !first) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node
              });
            }
            name41 = this.parseIdentifier(isThis);
            if (this.eat(17)) {
              optional = true;
              if (isThis) {
                this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                  at: node
                });
              }
            }
            typeAnnotation = this.flowParseTypeInitialiser();
          } else {
            typeAnnotation = this.flowParseType();
          }
          node.name = name41;
          node.optional = optional;
          node.typeAnnotation = typeAnnotation;
          return this.finishNode(node, "FunctionTypeParam");
        }
        reinterpretTypeAsFunctionTypeParam(type) {
          const node = this.startNodeAt(type.loc.start);
          node.name = null;
          node.optional = false;
          node.typeAnnotation = type;
          return this.finishNode(node, "FunctionTypeParam");
        }
        flowParseFunctionTypeParams(params = []) {
          let rest = null;
          let _this = null;
          if (this.match(78)) {
            _this = this.flowParseFunctionTypeParam(true);
            _this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            rest = this.flowParseFunctionTypeParam(false);
          }
          return {
            params,
            rest,
            _this
          };
        }
        flowIdentToTypeAnnotation(startLoc, node, id) {
          switch (id.name) {
            case "any":
              return this.finishNode(node, "AnyTypeAnnotation");
            case "bool":
            case "boolean":
              return this.finishNode(node, "BooleanTypeAnnotation");
            case "mixed":
              return this.finishNode(node, "MixedTypeAnnotation");
            case "empty":
              return this.finishNode(node, "EmptyTypeAnnotation");
            case "number":
              return this.finishNode(node, "NumberTypeAnnotation");
            case "string":
              return this.finishNode(node, "StringTypeAnnotation");
            case "symbol":
              return this.finishNode(node, "SymbolTypeAnnotation");
            default:
              this.checkNotUnderscore(id.name);
              return this.flowParseGenericType(startLoc, id);
          }
        }
        flowParsePrimaryType() {
          const startLoc = this.state.startLoc;
          const node = this.startNode();
          let tmp;
          let type;
          let isGroupedType = false;
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          switch (this.state.type) {
            case 5:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: true,
                allowProto: false,
                allowInexact: true
              });
            case 6:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: true,
                allowSpread: true,
                allowProto: false,
                allowInexact: false
              });
            case 0:
              this.state.noAnonFunctionType = false;
              type = this.flowParseTupleType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              return type;
            case 47:
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(10);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");
            case 10:
              this.next();
              if (!this.match(11) && !this.match(21)) {
                if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                  const token = this.lookahead().type;
                  isGroupedType = token !== 17 && token !== 14;
                } else {
                  isGroupedType = true;
                }
              }
              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                  this.expect(11);
                  return type;
                } else {
                  this.eat(12);
                }
              }
              if (type) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              node.typeParameters = null;
              return this.finishNode(node, "FunctionTypeAnnotation");
            case 131:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
            case 85:
            case 86:
              node.value = this.match(85);
              this.next();
              return this.finishNode(node, "BooleanLiteralTypeAnnotation");
            case 53:
              if (this.state.value === "-") {
                this.next();
                if (this.match(132)) {
                  return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                }
                if (this.match(133)) {
                  return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                }
                throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                  at: this.state.startLoc
                });
              }
              throw this.unexpected();
            case 132:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
            case 133:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
            case 88:
              this.next();
              return this.finishNode(node, "VoidTypeAnnotation");
            case 84:
              this.next();
              return this.finishNode(node, "NullLiteralTypeAnnotation");
            case 78:
              this.next();
              return this.finishNode(node, "ThisTypeAnnotation");
            case 55:
              this.next();
              return this.finishNode(node, "ExistsTypeAnnotation");
            case 87:
              return this.flowParseTypeofType();
            default:
              if (tokenIsKeyword(this.state.type)) {
                const label = tokenLabelName(this.state.type);
                this.next();
                return super.createIdentifier(node, label);
              } else if (tokenIsIdentifier(this.state.type)) {
                if (this.isContextual(127)) {
                  return this.flowParseInterfaceType();
                }
                return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
              }
          }
          throw this.unexpected();
        }
        flowParsePostfixType() {
          const startLoc = this.state.startLoc;
          let type = this.flowParsePrimaryType();
          let seenOptionalIndexedAccess = false;
          while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
            const node = this.startNodeAt(startLoc);
            const optional = this.eat(18);
            seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
            this.expect(0);
            if (!optional && this.match(3)) {
              node.elementType = type;
              this.next();
              type = this.finishNode(node, "ArrayTypeAnnotation");
            } else {
              node.objectType = type;
              node.indexType = this.flowParseType();
              this.expect(3);
              if (seenOptionalIndexedAccess) {
                node.optional = optional;
                type = this.finishNode(node, "OptionalIndexedAccessType");
              } else {
                type = this.finishNode(node, "IndexedAccessType");
              }
            }
          }
          return type;
        }
        flowParsePrefixType() {
          const node = this.startNode();
          if (this.eat(17)) {
            node.typeAnnotation = this.flowParsePrefixType();
            return this.finishNode(node, "NullableTypeAnnotation");
          } else {
            return this.flowParsePostfixType();
          }
        }
        flowParseAnonFunctionWithoutParens() {
          const param = this.flowParsePrefixType();
          if (!this.state.noAnonFunctionType && this.eat(19)) {
            const node = this.startNodeAt(param.loc.start);
            node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
            node.rest = null;
            node.this = null;
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          }
          return param;
        }
        flowParseIntersectionType() {
          const node = this.startNode();
          this.eat(45);
          const type = this.flowParseAnonFunctionWithoutParens();
          node.types = [type];
          while (this.eat(45)) {
            node.types.push(this.flowParseAnonFunctionWithoutParens());
          }
          return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        }
        flowParseUnionType() {
          const node = this.startNode();
          this.eat(43);
          const type = this.flowParseIntersectionType();
          node.types = [type];
          while (this.eat(43)) {
            node.types.push(this.flowParseIntersectionType());
          }
          return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        }
        flowParseType() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const type = this.flowParseUnionType();
          this.state.inType = oldInType;
          return type;
        }
        flowParseTypeOrImplicitInstantiation() {
          if (this.state.type === 130 && this.state.value === "_") {
            const startLoc = this.state.startLoc;
            const node = this.parseIdentifier();
            return this.flowParseGenericType(startLoc, node);
          } else {
            return this.flowParseType();
          }
        }
        flowParseTypeAnnotation() {
          const node = this.startNode();
          node.typeAnnotation = this.flowParseTypeInitialiser();
          return this.finishNode(node, "TypeAnnotation");
        }
        flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
          const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
          if (this.match(14)) {
            ident.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(ident);
          }
          return ident;
        }
        typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
        flowParseVariance() {
          let variance = null;
          if (this.match(53)) {
            variance = this.startNode();
            if (this.state.value === "+") {
              variance.kind = "plus";
            } else {
              variance.kind = "minus";
            }
            this.next();
            return this.finishNode(variance, "Variance");
          }
          return variance;
        }
        parseFunctionBody(node, allowExpressionBody, isMethod = false) {
          if (allowExpressionBody) {
            return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
          }
          return super.parseFunctionBody(node, false, isMethod);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          if (this.match(14)) {
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
          }
          return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        parseStatementLike(flags) {
          if (this.state.strict && this.isContextual(127)) {
            const lookahead = this.lookahead();
            if (tokenIsKeywordOrIdentifier(lookahead.type)) {
              const node = this.startNode();
              this.next();
              return this.flowParseInterface(node);
            }
          } else if (this.shouldParseEnums() && this.isContextual(124)) {
            const node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }
          const stmt = super.parseStatementLike(flags);
          if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
            this.flowPragma = null;
          }
          return stmt;
        }
        parseExpressionStatement(node, expr, decorators) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                return this.flowParseDeclare(node);
              }
            } else if (tokenIsIdentifier(this.state.type)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node, false);
              }
            }
          }
          return super.parseExpressionStatement(node, expr, decorators);
        }
        shouldParseExportDeclaration() {
          const {
            type
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) {
            return !this.state.containsEsc;
          }
          return super.shouldParseExportDeclaration();
        }
        isExportDefaultSpecifier() {
          const {
            type
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) {
            return this.state.containsEsc;
          }
          return super.isExportDefaultSpecifier();
        }
        parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual(124)) {
            const node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }
          return super.parseExportDefaultExpression();
        }
        parseConditional(expr, startLoc, refExpressionErrors) {
          if (!this.match(17))
            return expr;
          if (this.state.maybeInArrowParameters) {
            const nextCh = this.lookaheadCharCode();
            if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
              this.setOptionalParametersError(refExpressionErrors);
              return expr;
            }
          }
          this.expect(17);
          const state = this.state.clone();
          const originalNoArrowAt = this.state.noArrowAt;
          const node = this.startNodeAt(startLoc);
          let {
            consequent,
            failed
          } = this.tryParseConditionalConsequent();
          let [valid, invalid] = this.getArrowLikeExpressions(consequent);
          if (failed || invalid.length > 0) {
            const noArrowAt = [...originalNoArrowAt];
            if (invalid.length > 0) {
              this.state = state;
              this.state.noArrowAt = noArrowAt;
              for (let i = 0; i < invalid.length; i++) {
                noArrowAt.push(invalid[i].start);
              }
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
              [valid, invalid] = this.getArrowLikeExpressions(consequent);
            }
            if (failed && valid.length > 1) {
              this.raise(FlowErrors.AmbiguousConditionalArrow, {
                at: state.startLoc
              });
            }
            if (failed && valid.length === 1) {
              this.state = state;
              noArrowAt.push(valid[0].start);
              this.state.noArrowAt = noArrowAt;
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
            }
          }
          this.getArrowLikeExpressions(consequent, true);
          this.state.noArrowAt = originalNoArrowAt;
          this.expect(14);
          node.test = expr;
          node.consequent = consequent;
          node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
          return this.finishNode(node, "ConditionalExpression");
        }
        tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          const consequent = this.parseMaybeAssignAllowIn();
          const failed = !this.match(14);
          this.state.noArrowParamsConversionAt.pop();
          return {
            consequent,
            failed
          };
        }
        getArrowLikeExpressions(node, disallowInvalid) {
          const stack = [node];
          const arrows = [];
          while (stack.length !== 0) {
            const node2 = stack.pop();
            if (node2.type === "ArrowFunctionExpression") {
              if (node2.typeParameters || !node2.returnType) {
                this.finishArrowValidation(node2);
              } else {
                arrows.push(node2);
              }
              stack.push(node2.body);
            } else if (node2.type === "ConditionalExpression") {
              stack.push(node2.consequent);
              stack.push(node2.alternate);
            }
          }
          if (disallowInvalid) {
            arrows.forEach((node2) => this.finishArrowValidation(node2));
            return [arrows, []];
          }
          return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
        }
        finishArrowValidation(node) {
          var _node$extra;
          this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          super.checkParams(node, false, true);
          this.scope.exit();
        }
        forwardNoArrowParamsConversionAt(node, parse45) {
          let result;
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            result = parse45();
            this.state.noArrowParamsConversionAt.pop();
          } else {
            result = parse45();
          }
          return result;
        }
        parseParenItem(node, startLoc) {
          node = super.parseParenItem(node, startLoc);
          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }
          return node;
        }
        assertModuleNodeAllowed(node) {
          if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
            return;
          }
          super.assertModuleNodeAllowed(node);
        }
        parseExport(node, decorators) {
          const decl = super.parseExport(node, decorators);
          if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
            decl.exportKind = decl.exportKind || "value";
          }
          return decl;
        }
        parseExportDeclaration(node) {
          if (this.isContextual(128)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            if (this.match(5)) {
              node.specifiers = this.parseExportSpecifiers(true);
              super.parseExportFrom(node);
              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual(129)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseOpaqueType(declarationNode, false);
          } else if (this.isContextual(127)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseInterface(declarationNode);
          } else if (this.shouldParseEnums() && this.isContextual(124)) {
            node.exportKind = "value";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(declarationNode);
          } else {
            return super.parseExportDeclaration(node);
          }
        }
        eatExportStar(node) {
          if (super.eatExportStar(node))
            return true;
          if (this.isContextual(128) && this.lookahead().type === 55) {
            node.exportKind = "type";
            this.next();
            this.next();
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
          const {
            startLoc
          } = this.state;
          const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
          if (hasNamespace && node.exportKind === "type") {
            this.unexpected(startLoc);
          }
          return hasNamespace;
        }
        parseClassId(node, isStatement, optionalId) {
          super.parseClassId(node, isStatement, optionalId);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        }
        parseClassMember(classBody, member, state) {
          const {
            startLoc
          } = this.state;
          if (this.isContextual(123)) {
            if (super.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            member.declare = true;
          }
          super.parseClassMember(classBody, member, state);
          if (member.declare) {
            if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
              this.raise(FlowErrors.DeclareClassElement, {
                at: startLoc
              });
            } else if (member.value) {
              this.raise(FlowErrors.DeclareClassFieldInitializer, {
                at: member.value
              });
            }
          }
        }
        isIterator(word) {
          return word === "iterator" || word === "asyncIterator";
        }
        readIterator() {
          const word = super.readWord1();
          const fullWord = "@@" + word;
          if (!this.isIterator(word) || !this.state.inType) {
            this.raise(Errors.InvalidIdentifier, {
              at: this.state.curPosition(),
              identifierName: fullWord
            });
          }
          this.finishToken(130, fullWord);
        }
        getTokenFromCode(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code2 === 123 && next === 124) {
            return this.finishOp(6, 2);
          } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
            return this.finishOp(code2 === 62 ? 48 : 47, 1);
          } else if (this.state.inType && code2 === 63) {
            if (next === 46) {
              return this.finishOp(18, 2);
            }
            return this.finishOp(17, 1);
          } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
            this.state.pos += 2;
            return this.readIterator();
          } else {
            return super.getTokenFromCode(code2);
          }
        }
        isAssignable(node, isBinding) {
          if (node.type === "TypeCastExpression") {
            return this.isAssignable(node.expression, isBinding);
          } else {
            return super.isAssignable(node, isBinding);
          }
        }
        toAssignable(node, isLHS = false) {
          if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
            node.left = this.typeCastToParameter(node.left);
          }
          super.toAssignable(node, isLHS);
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i = 0; i < exprList.length; i++) {
            const expr = exprList[i];
            if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          for (let i = 0; i < exprList.length; i++) {
            var _expr$extra;
            const expr = exprList[i];
            if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
              this.raise(FlowErrors.TypeCastInPattern, {
                at: expr.typeAnnotation
              });
            }
          }
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (canBePattern && !this.state.maybeInArrowParameters) {
            this.toReferencedList(node.elements);
          }
          return node;
        }
        isValidLVal(type, isParenthesized, binding) {
          return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
        }
        parseClassProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassPrivateProperty(node);
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(14) || super.isClassProperty();
        }
        isNonstaticConstructor(method) {
          return !this.match(14) && super.isNonstaticConstructor(method);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }
          delete method.variance;
          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
          if (method.params && isConstructor) {
            const params = method.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
            const params = method.value.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          }
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }
          delete method.variance;
          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        parseClassSuper(node) {
          super.parseClassSuper(node);
          if (node.superClass && this.match(47)) {
            node.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }
          if (this.isContextual(111)) {
            this.next();
            const implemented = node.implements = [];
            do {
              const node2 = this.startNode();
              node2.id = this.flowParseRestrictedIdentifier(true);
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                node2.typeParameters = null;
              }
              implemented.push(this.finishNode(node2, "ClassImplements"));
            } while (this.eat(12));
          }
        }
        checkGetterSetterParams(method) {
          super.checkGetterSetterParams(method);
          const params = this.getObjectOrClassMethodParams(method);
          if (params.length > 0) {
            const param = params[0];
            if (this.isThisParam(param) && method.kind === "get") {
              this.raise(FlowErrors.GetterMayNotHaveThisParam, {
                at: param
              });
            } else if (this.isThisParam(param)) {
              this.raise(FlowErrors.SetterMayNotHaveThisParam, {
                at: param
              });
            }
          }
        }
        parsePropertyNamePrefixOperator(node) {
          node.variance = this.flowParseVariance();
        }
        parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          if (prop.variance) {
            this.unexpected(prop.variance.loc.start);
          }
          delete prop.variance;
          let typeParameters;
          if (this.match(47) && !isAccessor) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(10))
              this.unexpected();
          }
          const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
          if (typeParameters) {
            (result.value || result).typeParameters = typeParameters;
          }
          return result;
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier") {
              this.raise(FlowErrors.PatternIsOptional, {
                at: param
              });
            }
            if (this.isThisParam(param)) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          if (this.match(14)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamAnnotationRequired, {
              at: param
            });
          }
          if (this.match(29) && this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamNoDefault, {
              at: param
            });
          }
          this.resetEndLocation(param);
          return param;
        }
        parseMaybeDefault(startLoc, left) {
          const node = super.parseMaybeDefault(startLoc, left);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(FlowErrors.TypeBeforeInitializer, {
              at: node.typeAnnotation
            });
          }
          return node;
        }
        shouldParseDefaultImport(node) {
          if (!hasTypeImportKind(node)) {
            return super.shouldParseDefaultImport(node);
          }
          return isMaybeDefaultImport(this.state.type);
        }
        checkImportReflection(node) {
          super.checkImportReflection(node);
          if (node.module && node.importKind !== "value") {
            this.raise(FlowErrors.ImportReflectionHasImportType, {
              at: node.specifiers[0].loc.start
            });
          }
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        maybeParseDefaultImportSpecifier(node) {
          node.importKind = "value";
          let kind = null;
          if (this.match(87)) {
            kind = "typeof";
          } else if (this.isContextual(128)) {
            kind = "type";
          }
          if (kind) {
            const lh = this.lookahead();
            const {
              type
            } = lh;
            if (kind === "type" && type === 55) {
              this.unexpected(null, lh.type);
            }
            if (isMaybeDefaultImport(type) || type === 5 || type === 55) {
              this.next();
              node.importKind = kind;
            }
          }
          return super.maybeParseDefaultImportSpecifier(node);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
          const firstIdent = specifier.imported;
          let specifierTypeKind = null;
          if (firstIdent.type === "Identifier") {
            if (firstIdent.name === "type") {
              specifierTypeKind = "type";
            } else if (firstIdent.name === "typeof") {
              specifierTypeKind = "typeof";
            }
          }
          let isBinding = false;
          if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
            const as_ident = this.parseIdentifier(true);
            if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = cloneIdentifier(as_ident);
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else {
            if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = this.parseIdentifier(true);
              specifier.importKind = specifierTypeKind;
            } else {
              if (importedIsString) {
                throw this.raise(Errors.ImportBindingIsString, {
                  at: specifier,
                  importName: firstIdent.value
                });
              }
              specifier.imported = firstIdent;
              specifier.importKind = null;
            }
            if (this.eatContextual(93)) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = cloneIdentifier(specifier.imported);
            }
          }
          const specifierIsTypeImport = hasTypeImportKind(specifier);
          if (isInTypeOnlyImport && specifierIsTypeImport) {
            this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
              at: specifier
            });
          }
          if (isInTypeOnlyImport || specifierIsTypeImport) {
            this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
          }
          if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
            this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseFunctionParams(node, allowModifiers) {
          const kind = node.kind;
          if (kind !== "get" && kind !== "set" && this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.parseFunctionParams(node, allowModifiers);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (this.match(14)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }
          return super.parseAsyncArrowFromCallExpression(node, call);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx;
          let state = null;
          let jsx2;
          if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error)
              return jsx2.node;
            const {
              context
            } = this.state;
            const currentContext = context[context.length - 1];
            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context.pop();
            }
          }
          if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
            var _jsx2, _jsx3;
            state = state || this.state.clone();
            let typeParameters;
            const arrow = this.tryParse((abort) => {
              var _arrowExpression$extr;
              typeParameters = this.flowParseTypeParameterDeclaration();
              const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
                const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                this.resetStartLocationFromNode(result, typeParameters);
                return result;
              });
              if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
                abort();
              const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
              if (expr.type !== "ArrowFunctionExpression")
                abort();
              expr.typeParameters = typeParameters;
              this.resetStartLocationFromNode(expr, typeParameters);
              return arrowExpression2;
            }, state);
            let arrowExpression = null;
            if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
              if (!arrow.error && !arrow.aborted) {
                if (arrow.node.async) {
                  this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                    at: typeParameters
                  });
                }
                return arrow.node;
              }
              arrowExpression = arrow.node;
            }
            if ((_jsx2 = jsx2) != null && _jsx2.node) {
              this.state = jsx2.failState;
              return jsx2.node;
            }
            if (arrowExpression) {
              this.state = arrow.failState;
              return arrowExpression;
            }
            if ((_jsx3 = jsx2) != null && _jsx3.thrown)
              throw jsx2.error;
            if (arrow.thrown)
              throw arrow.error;
            throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
              at: typeParameters
            });
          }
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        parseArrow(node) {
          if (this.match(14)) {
            const result = this.tryParse(() => {
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true;
              const typeNode = this.startNode();
              [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.canInsertSemicolon())
                this.unexpected();
              if (!this.match(19))
                this.unexpected();
              return typeNode;
            });
            if (result.thrown)
              return null;
            if (result.error)
              this.state = result.failState;
            node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
          }
          return super.parseArrow(node);
        }
        shouldParseArrow(params) {
          return this.match(14) || super.shouldParseArrow(params);
        }
        setArrowFunctionParameters(node, params) {
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            node.params = params;
          } else {
            super.setArrowFunctionParameters(node, params);
          }
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            return;
          }
          for (let i = 0; i < node.params.length; i++) {
            if (this.isThisParam(node.params[i]) && i > 0) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node.params[i]
              });
            }
          }
          return super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
        parseSubscripts(base, startLoc, noCalls) {
          if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
            this.next();
            const node = this.startNodeAt(startLoc);
            node.callee = base;
            node.arguments = super.parseCallExpressionArguments(11, false);
            base = this.finishNode(node, "CallExpression");
          } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
            const state = this.state.clone();
            const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
            if (!arrow.error && !arrow.aborted)
              return arrow.node;
            const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
            if (result.node && !result.error)
              return result.node;
            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }
            if (result.node) {
              this.state = result.failState;
              return result.node;
            }
            throw arrow.error || result.error;
          }
          return super.parseSubscripts(base, startLoc, noCalls);
        }
        parseSubscript(base, startLoc, noCalls, subscriptState) {
          if (this.match(18) && this.isLookaheadToken_lt()) {
            subscriptState.optionalChainMember = true;
            if (noCalls) {
              subscriptState.stop = true;
              return base;
            }
            this.next();
            const node = this.startNodeAt(startLoc);
            node.callee = base;
            node.typeArguments = this.flowParseTypeParameterInstantiation();
            this.expect(10);
            node.arguments = this.parseCallExpressionArguments(11, false);
            node.optional = true;
            return this.finishCallExpression(node, true);
          } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
            const node = this.startNodeAt(startLoc);
            node.callee = base;
            const result = this.tryParse(() => {
              node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
              this.expect(10);
              node.arguments = super.parseCallExpressionArguments(11, false);
              if (subscriptState.optionalChainMember) {
                node.optional = false;
              }
              return this.finishCallExpression(node, subscriptState.optionalChainMember);
            });
            if (result.node) {
              if (result.error)
                this.state = result.failState;
              return result.node;
            }
          }
          return super.parseSubscript(base, startLoc, noCalls, subscriptState);
        }
        parseNewCallee(node) {
          super.parseNewCallee(node);
          let targs = null;
          if (this.shouldParseTypes() && this.match(47)) {
            targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
          }
          node.typeArguments = targs;
        }
        parseAsyncArrowWithTypeParameters(startLoc) {
          const node = this.startNodeAt(startLoc);
          this.parseFunctionParams(node);
          if (!this.parseArrow(node))
            return;
          return super.parseArrowExpression(node, void 0, true);
        }
        readToken_mult_modulo(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
            this.state.hasFlowComment = false;
            this.state.pos += 2;
            this.nextToken();
            return;
          }
          super.readToken_mult_modulo(code2);
        }
        readToken_pipe_amp(code2) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code2 === 124 && next === 125) {
            this.finishOp(9, 2);
            return;
          }
          super.readToken_pipe_amp(code2);
        }
        parseTopLevel(file, program2) {
          const fileNode = super.parseTopLevel(file, program2);
          if (this.state.hasFlowComment) {
            this.raise(FlowErrors.UnterminatedFlowComment, {
              at: this.state.curPosition()
            });
          }
          return fileNode;
        }
        skipBlockComment() {
          if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
            if (this.state.hasFlowComment) {
              throw this.raise(FlowErrors.NestedFlowComment, {
                at: this.state.startLoc
              });
            }
            this.hasFlowCommentCompletion();
            const commentSkip = this.skipFlowComment();
            if (commentSkip) {
              this.state.pos += commentSkip;
              this.state.hasFlowComment = true;
            }
            return;
          }
          return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
        }
        skipFlowComment() {
          const {
            pos
          } = this.state;
          let shiftToFirstNonWhiteSpace = 2;
          while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
            shiftToFirstNonWhiteSpace++;
          }
          const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
          const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
          if (ch2 === 58 && ch3 === 58) {
            return shiftToFirstNonWhiteSpace + 2;
          }
          if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
            return shiftToFirstNonWhiteSpace + 12;
          }
          if (ch2 === 58 && ch3 !== 58) {
            return shiftToFirstNonWhiteSpace;
          }
          return false;
        }
        hasFlowCommentCompletion() {
          const end = this.input.indexOf("*/", this.state.pos);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
        }
        flowEnumErrorBooleanMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
            at: loc,
            memberName,
            enumName
          });
        }
        flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
          return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
            at: loc
          }, enumContext));
        }
        flowEnumErrorNumberMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
            at: loc,
            enumName,
            memberName
          });
        }
        flowEnumErrorStringMemberInconsistentlyInitailized(node, {
          enumName
        }) {
          this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
            at: node,
            enumName
          });
        }
        flowEnumMemberInit() {
          const startLoc = this.state.startLoc;
          const endOfInit = () => this.match(12) || this.match(8);
          switch (this.state.type) {
            case 132: {
              const literal = this.parseNumericLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "number",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 131: {
              const literal = this.parseStringLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "string",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 85:
            case 86: {
              const literal = this.parseBooleanLiteral(this.match(85));
              if (endOfInit()) {
                return {
                  type: "boolean",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            default:
              return {
                type: "invalid",
                loc: startLoc
              };
          }
        }
        flowEnumMemberRaw() {
          const loc = this.state.startLoc;
          const id = this.parseIdentifier(true);
          const init = this.eat(29) ? this.flowEnumMemberInit() : {
            type: "none",
            loc
          };
          return {
            id,
            init
          };
        }
        flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
          const {
            explicitType
          } = context;
          if (explicitType === null) {
            return;
          }
          if (explicitType !== expectedType) {
            this.flowEnumErrorInvalidMemberInitializer(loc, context);
          }
        }
        flowEnumMembers({
          enumName,
          explicitType
        }) {
          const seenNames = /* @__PURE__ */ new Set();
          const members = {
            booleanMembers: [],
            numberMembers: [],
            stringMembers: [],
            defaultedMembers: []
          };
          let hasUnknownMembers = false;
          while (!this.match(8)) {
            if (this.eat(21)) {
              hasUnknownMembers = true;
              break;
            }
            const memberNode = this.startNode();
            const {
              id,
              init
            } = this.flowEnumMemberRaw();
            const memberName = id.name;
            if (memberName === "") {
              continue;
            }
            if (/^[a-z]/.test(memberName)) {
              this.raise(FlowErrors.EnumInvalidMemberName, {
                at: id,
                memberName,
                suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                enumName
              });
            }
            if (seenNames.has(memberName)) {
              this.raise(FlowErrors.EnumDuplicateMemberName, {
                at: id,
                memberName,
                enumName
              });
            }
            seenNames.add(memberName);
            const context = {
              enumName,
              explicitType,
              memberName
            };
            memberNode.id = id;
            switch (init.type) {
              case "boolean": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
                memberNode.init = init.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }
              case "number": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
                memberNode.init = init.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }
              case "string": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
                memberNode.init = init.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }
              case "invalid": {
                throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
              }
              case "none": {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                    break;
                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                    break;
                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
            }
            if (!this.match(8)) {
              this.expect(12);
            }
          }
          return {
            members,
            hasUnknownMembers
          };
        }
        flowEnumStringMembers(initializedMembers, defaultedMembers, {
          enumName
        }) {
          if (initializedMembers.length === 0) {
            return defaultedMembers;
          } else if (defaultedMembers.length === 0) {
            return initializedMembers;
          } else if (defaultedMembers.length > initializedMembers.length) {
            for (const member of initializedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return defaultedMembers;
          } else {
            for (const member of defaultedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return initializedMembers;
          }
        }
        flowEnumParseExplicitType({
          enumName
        }) {
          if (!this.eatContextual(101))
            return null;
          if (!tokenIsIdentifier(this.state.type)) {
            throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
              at: this.state.startLoc,
              enumName
            });
          }
          const {
            value
          } = this.state;
          this.next();
          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.raise(FlowErrors.EnumInvalidExplicitType, {
              at: this.state.startLoc,
              enumName,
              invalidEnumType: value
            });
          }
          return value;
        }
        flowEnumBody(node, id) {
          const enumName = id.name;
          const nameLoc = id.loc.start;
          const explicitType = this.flowEnumParseExplicitType({
            enumName
          });
          this.expect(5);
          const {
            members,
            hasUnknownMembers
          } = this.flowEnumMembers({
            enumName,
            explicitType
          });
          node.hasUnknownMembers = hasUnknownMembers;
          switch (explicitType) {
            case "boolean":
              node.explicitType = true;
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            case "number":
              node.explicitType = true;
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            case "string":
              node.explicitType = true;
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            case "symbol":
              node.members = members.defaultedMembers;
              this.expect(8);
              return this.finishNode(node, "EnumSymbolBody");
            default: {
              const empty = () => {
                node.members = [];
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              };
              node.explicitType = false;
              const boolsLen = members.booleanMembers.length;
              const numsLen = members.numberMembers.length;
              const strsLen = members.stringMembers.length;
              const defaultedLen = members.defaultedMembers.length;
              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName
                });
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.booleanMembers;
                this.expect(8);
                return this.finishNode(node, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.numberMembers;
                this.expect(8);
                return this.finishNode(node, "EnumNumberBody");
              } else {
                this.raise(FlowErrors.EnumInconsistentMemberValues, {
                  at: nameLoc,
                  enumName
                });
                return empty();
              }
            }
          }
        }
        flowParseEnumDeclaration(node) {
          const id = this.parseIdentifier();
          node.id = id;
          node.body = this.flowEnumBody(this.startNode(), id);
          return this.finishNode(node, "EnumDeclaration");
        }
        isLookaheadToken_lt() {
          const next = this.nextTokenStart();
          if (this.input.charCodeAt(next) === 60) {
            const afterNext = this.input.charCodeAt(next + 1);
            return afterNext !== 60 && afterNext !== 61;
          }
          return false;
        }
        maybeUnwrapTypeCastExpression(node) {
          return node.type === "TypeCastExpression" ? node.expression : node;
        }
      };
      var entities = {
        __proto__: null,
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02C6",
        tilde: "\u02DC",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        oline: "\u203E",
        frasl: "\u2044",
        euro: "\u20AC",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
      };
      var JsxErrors = ParseErrorEnum`jsx`({
        AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
        MissingClosingTagElement: ({
          openingTagName
        }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
        MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
        UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
        UnexpectedToken: ({
          unexpected,
          HTMLEntity
        }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
        UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
        UnterminatedJsxContent: "Unterminated JSX contents.",
        UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
      });
      function isFragment(object) {
        return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
      }
      function getQualifiedJSXName(object) {
        if (object.type === "JSXIdentifier") {
          return object.name;
        }
        if (object.type === "JSXNamespacedName") {
          return object.namespace.name + ":" + object.name.name;
        }
        if (object.type === "JSXMemberExpression") {
          return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
        }
        throw new Error("Node had unexpected type: " + object.type);
      }
      var jsx = (superClass) => class JSXParserMixin extends superClass {
        jsxReadToken() {
          let out = "";
          let chunkStart = this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(JsxErrors.UnterminatedJsxContent, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.state.pos === this.state.start) {
                  if (ch === 60 && this.state.canStartJSXElement) {
                    ++this.state.pos;
                    return this.finishToken(140);
                  }
                  return super.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.state.pos);
                return this.finishToken(139, out);
              case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;
              case 62:
              case 125:
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(true);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
            }
          }
        }
        jsxReadNewLine(normalizeCRLF) {
          const ch = this.input.charCodeAt(this.state.pos);
          let out;
          ++this.state.pos;
          if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          return out;
        }
        jsxReadString(quote) {
          let out = "";
          let chunkStart = ++this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote)
              break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(false);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }
          out += this.input.slice(chunkStart, this.state.pos++);
          return this.finishToken(131, out);
        }
        jsxReadEntity() {
          const startPos = ++this.state.pos;
          if (this.codePointAtPos(this.state.pos) === 35) {
            ++this.state.pos;
            let radix = 10;
            if (this.codePointAtPos(this.state.pos) === 120) {
              radix = 16;
              ++this.state.pos;
            }
            const codePoint = this.readInt(radix, void 0, false, "bail");
            if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
              ++this.state.pos;
              return String.fromCodePoint(codePoint);
            }
          } else {
            let count = 0;
            let semi = false;
            while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
              ++this.state.pos;
            }
            if (semi) {
              const desc = this.input.slice(startPos, this.state.pos);
              const entity = entities[desc];
              ++this.state.pos;
              if (entity) {
                return entity;
              }
            }
          }
          this.state.pos = startPos;
          return "&";
        }
        jsxReadWord() {
          let ch;
          const start = this.state.pos;
          do {
            ch = this.input.charCodeAt(++this.state.pos);
          } while (isIdentifierChar(ch) || ch === 45);
          return this.finishToken(138, this.input.slice(start, this.state.pos));
        }
        jsxParseIdentifier() {
          const node = this.startNode();
          if (this.match(138)) {
            node.name = this.state.value;
          } else if (tokenIsKeyword(this.state.type)) {
            node.name = tokenLabelName(this.state.type);
          } else {
            this.unexpected();
          }
          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
        jsxParseNamespacedName() {
          const startLoc = this.state.startLoc;
          const name41 = this.jsxParseIdentifier();
          if (!this.eat(14))
            return name41;
          const node = this.startNodeAt(startLoc);
          node.namespace = name41;
          node.name = this.jsxParseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
        jsxParseElementName() {
          const startLoc = this.state.startLoc;
          let node = this.jsxParseNamespacedName();
          if (node.type === "JSXNamespacedName") {
            return node;
          }
          while (this.eat(16)) {
            const newNode = this.startNodeAt(startLoc);
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node;
        }
        jsxParseAttributeValue() {
          let node;
          switch (this.state.type) {
            case 5:
              node = this.startNode();
              this.setContext(types.brace);
              this.next();
              node = this.jsxParseExpressionContainer(node, types.j_oTag);
              if (node.expression.type === "JSXEmptyExpression") {
                this.raise(JsxErrors.AttributeIsEmpty, {
                  at: node
                });
              }
              return node;
            case 140:
            case 131:
              return this.parseExprAtom();
            default:
              throw this.raise(JsxErrors.UnsupportedJsxValue, {
                at: this.state.startLoc
              });
          }
        }
        jsxParseEmptyExpression() {
          const node = this.startNodeAt(this.state.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
        }
        jsxParseSpreadChild(node) {
          this.next();
          node.expression = this.parseExpression();
          this.setContext(types.j_expr);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadChild");
        }
        jsxParseExpressionContainer(node, previousContext) {
          if (this.match(8)) {
            node.expression = this.jsxParseEmptyExpression();
          } else {
            const expression = this.parseExpression();
            node.expression = expression;
          }
          this.setContext(previousContext);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXExpressionContainer");
        }
        jsxParseAttribute() {
          const node = this.startNode();
          if (this.match(5)) {
            this.setContext(types.brace);
            this.next();
            this.expect(21);
            node.argument = this.parseMaybeAssignAllowIn();
            this.setContext(types.j_oTag);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(node, "JSXSpreadAttribute");
          }
          node.name = this.jsxParseNamespacedName();
          node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
        jsxParseOpeningElementAt(startLoc) {
          const node = this.startNodeAt(startLoc);
          if (this.eat(141)) {
            return this.finishNode(node, "JSXOpeningFragment");
          }
          node.name = this.jsxParseElementName();
          return this.jsxParseOpeningElementAfterName(node);
        }
        jsxParseOpeningElementAfterName(node) {
          const attributes = [];
          while (!this.match(56) && !this.match(141)) {
            attributes.push(this.jsxParseAttribute());
          }
          node.attributes = attributes;
          node.selfClosing = this.eat(56);
          this.expect(141);
          return this.finishNode(node, "JSXOpeningElement");
        }
        jsxParseClosingElementAt(startLoc) {
          const node = this.startNodeAt(startLoc);
          if (this.eat(141)) {
            return this.finishNode(node, "JSXClosingFragment");
          }
          node.name = this.jsxParseElementName();
          this.expect(141);
          return this.finishNode(node, "JSXClosingElement");
        }
        jsxParseElementAt(startLoc) {
          const node = this.startNodeAt(startLoc);
          const children = [];
          const openingElement = this.jsxParseOpeningElementAt(startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents:
              for (; ; ) {
                switch (this.state.type) {
                  case 140:
                    startLoc = this.state.startLoc;
                    this.next();
                    if (this.eat(56)) {
                      closingElement = this.jsxParseClosingElementAt(startLoc);
                      break contents;
                    }
                    children.push(this.jsxParseElementAt(startLoc));
                    break;
                  case 139:
                    children.push(this.parseExprAtom());
                    break;
                  case 5: {
                    const node2 = this.startNode();
                    this.setContext(types.brace);
                    this.next();
                    if (this.match(21)) {
                      children.push(this.jsxParseSpreadChild(node2));
                    } else {
                      children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                    }
                    break;
                  }
                  default:
                    throw this.unexpected();
                }
              }
            if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
              this.raise(JsxErrors.MissingClosingTagFragment, {
                at: closingElement
              });
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
              this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(JsxErrors.MissingClosingTagElement, {
                  at: closingElement,
                  openingTagName: getQualifiedJSXName(openingElement.name)
                });
              }
            }
          }
          if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
          } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
          }
          node.children = children;
          if (this.match(47)) {
            throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
              at: this.state.startLoc
            });
          }
          return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        }
        jsxParseElement() {
          const startLoc = this.state.startLoc;
          this.next();
          return this.jsxParseElementAt(startLoc);
        }
        setContext(newContext) {
          const {
            context
          } = this.state;
          context[context.length - 1] = newContext;
        }
        parseExprAtom(refExpressionErrors) {
          if (this.match(139)) {
            return this.parseLiteral(this.state.value, "JSXText");
          } else if (this.match(140)) {
            return this.jsxParseElement();
          } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
            this.replaceToken(140);
            return this.jsxParseElement();
          } else {
            return super.parseExprAtom(refExpressionErrors);
          }
        }
        skipSpace() {
          const curContext = this.curContext();
          if (!curContext.preserveSpace)
            super.skipSpace();
        }
        getTokenFromCode(code2) {
          const context = this.curContext();
          if (context === types.j_expr) {
            return this.jsxReadToken();
          }
          if (context === types.j_oTag || context === types.j_cTag) {
            if (isIdentifierStart2(code2)) {
              return this.jsxReadWord();
            }
            if (code2 === 62) {
              ++this.state.pos;
              return this.finishToken(141);
            }
            if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {
              return this.jsxReadString(code2);
            }
          }
          if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            return this.finishToken(140);
          }
          return super.getTokenFromCode(code2);
        }
        updateContext(prevType) {
          const {
            context,
            type
          } = this.state;
          if (type === 56 && prevType === 140) {
            context.splice(-2, 2, types.j_cTag);
            this.state.canStartJSXElement = false;
          } else if (type === 140) {
            context.push(types.j_oTag);
          } else if (type === 141) {
            const out = context[context.length - 1];
            if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
              context.pop();
              this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
            } else {
              this.setContext(types.j_expr);
              this.state.canStartJSXElement = true;
            }
          } else {
            this.state.canStartJSXElement = tokenComesBeforeExpression(type);
          }
        }
      };
      var TypeScriptScope = class extends Scope {
        constructor(...args) {
          super(...args);
          this.types = /* @__PURE__ */ new Set();
          this.enums = /* @__PURE__ */ new Set();
          this.constEnums = /* @__PURE__ */ new Set();
          this.classes = /* @__PURE__ */ new Set();
          this.exportOnlyBindings = /* @__PURE__ */ new Set();
        }
      };
      var TypeScriptScopeHandler = class extends ScopeHandler {
        constructor(...args) {
          super(...args);
          this.importsStack = [];
        }
        createScope(flags) {
          this.importsStack.push(/* @__PURE__ */ new Set());
          return new TypeScriptScope(flags);
        }
        enter(flags) {
          if (flags == SCOPE_TS_MODULE) {
            this.importsStack.push(/* @__PURE__ */ new Set());
          }
          super.enter(flags);
        }
        exit() {
          const flags = super.exit();
          if (flags == SCOPE_TS_MODULE) {
            this.importsStack.pop();
          }
          return flags;
        }
        hasImport(name41, allowShadow) {
          const len = this.importsStack.length;
          if (this.importsStack[len - 1].has(name41)) {
            return true;
          }
          if (!allowShadow && len > 1) {
            for (let i = 0; i < len - 1; i++) {
              if (this.importsStack[i].has(name41))
                return true;
            }
          }
          return false;
        }
        declareName(name41, bindingType, loc) {
          if (bindingType & BIND_FLAGS_TS_IMPORT) {
            if (this.hasImport(name41, true)) {
              this.parser.raise(Errors.VarRedeclaration, {
                at: loc,
                identifierName: name41
              });
            }
            this.importsStack[this.importsStack.length - 1].add(name41);
            return;
          }
          const scope = this.currentScope();
          if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
            this.maybeExportDefined(scope, name41);
            scope.exportOnlyBindings.add(name41);
            return;
          }
          super.declareName(name41, bindingType, loc);
          if (bindingType & BIND_KIND_TYPE) {
            if (!(bindingType & BIND_KIND_VALUE)) {
              this.checkRedeclarationInScope(scope, name41, bindingType, loc);
              this.maybeExportDefined(scope, name41);
            }
            scope.types.add(name41);
          }
          if (bindingType & BIND_FLAGS_TS_ENUM)
            scope.enums.add(name41);
          if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
            scope.constEnums.add(name41);
          if (bindingType & BIND_FLAGS_CLASS)
            scope.classes.add(name41);
        }
        isRedeclaredInScope(scope, name41, bindingType) {
          if (scope.enums.has(name41)) {
            if (bindingType & BIND_FLAGS_TS_ENUM) {
              const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
              const wasConst = scope.constEnums.has(name41);
              return isConst !== wasConst;
            }
            return true;
          }
          if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name41)) {
            if (scope.lexical.has(name41)) {
              return !!(bindingType & BIND_KIND_VALUE);
            } else {
              return false;
            }
          }
          if (bindingType & BIND_KIND_TYPE && scope.types.has(name41)) {
            return true;
          }
          return super.isRedeclaredInScope(scope, name41, bindingType);
        }
        checkLocalExport(id) {
          const {
            name: name41
          } = id;
          if (this.hasImport(name41))
            return;
          const len = this.scopeStack.length;
          for (let i = len - 1; i >= 0; i--) {
            const scope = this.scopeStack[i];
            if (scope.types.has(name41) || scope.exportOnlyBindings.has(name41))
              return;
          }
          super.checkLocalExport(id);
        }
      };
      var getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
      function nonNull(x) {
        if (x == null) {
          throw new Error(`Unexpected ${x} value.`);
        }
        return x;
      }
      function assert(x) {
        if (!x) {
          throw new Error("Assert fail");
        }
      }
      var TSErrors = ParseErrorEnum`typescript`({
        AbstractMethodHasImplementation: ({
          methodName
        }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
        AbstractPropertyHasInitializer: ({
          propertyName
        }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
        AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
        AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
        AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
        ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
        ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
        ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
        ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
        DeclareAccessor: ({
          kind
        }) => `'declare' is not allowed in ${kind}ters.`,
        DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
        DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
        DuplicateAccessibilityModifier: ({
          modifier
        }) => `Accessibility modifier already seen.`,
        DuplicateModifier: ({
          modifier
        }) => `Duplicate modifier: '${modifier}'.`,
        EmptyHeritageClauseType: ({
          token
        }) => `'${token}' list cannot be empty.`,
        EmptyTypeArguments: "Type argument list cannot be empty.",
        EmptyTypeParameters: "Type parameter list cannot be empty.",
        ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
        ImportAliasHasImportType: "An import alias can not use 'import type'.",
        ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
        IncompatibleModifiers: ({
          modifiers
        }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
        IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
        IndexSignatureHasAccessibility: ({
          modifier
        }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
        IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
        IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
        IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
        InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
        InvalidModifierOnTypeMember: ({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type member.`,
        InvalidModifierOnTypeParameter: ({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type parameter.`,
        InvalidModifierOnTypeParameterPositions: ({
          modifier
        }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
        InvalidModifiersOrder: ({
          orderedModifiers
        }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
        InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
        InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
        MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
        MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
        NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
        NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
        OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
        OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
        PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
        PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
        PrivateElementHasAccessibility: ({
          modifier
        }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
        ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
        ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
        ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
        SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
        SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
        SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
        SingleTypeParameterWithoutTrailingComma: ({
          typeParameterName
        }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
        StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
        TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
        TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
        TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
        UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
        UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
        UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
        UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
        UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
        UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
        UnsupportedSignatureParameterKind: ({
          type
        }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
      });
      function keywordTypeFromName(value) {
        switch (value) {
          case "any":
            return "TSAnyKeyword";
          case "boolean":
            return "TSBooleanKeyword";
          case "bigint":
            return "TSBigIntKeyword";
          case "never":
            return "TSNeverKeyword";
          case "number":
            return "TSNumberKeyword";
          case "object":
            return "TSObjectKeyword";
          case "string":
            return "TSStringKeyword";
          case "symbol":
            return "TSSymbolKeyword";
          case "undefined":
            return "TSUndefinedKeyword";
          case "unknown":
            return "TSUnknownKeyword";
          default:
            return void 0;
        }
      }
      function tsIsAccessModifier(modifier) {
        return modifier === "private" || modifier === "public" || modifier === "protected";
      }
      function tsIsVarianceAnnotations(modifier) {
        return modifier === "in" || modifier === "out";
      }
      var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
        getScopeHandler() {
          return TypeScriptScopeHandler;
        }
        tsIsIdentifier() {
          return tokenIsIdentifier(this.state.type);
        }
        tsTokenCanFollowModifier() {
          return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
        }
        tsNextTokenCanFollowModifier() {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
          if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {
            return void 0;
          }
          const modifier = this.state.value;
          if (allowedModifiers.indexOf(modifier) !== -1) {
            if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
              return void 0;
            }
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
              return modifier;
            }
          }
          return void 0;
        }
        tsParseModifiers({
          modified,
          allowedModifiers,
          disallowedModifiers,
          stopOnStartOfClassStaticBlock,
          errorTemplate = TSErrors.InvalidModifierOnTypeMember
        }) {
          const enforceOrder = (loc, modifier, before, after) => {
            if (modifier === before && modified[after]) {
              this.raise(TSErrors.InvalidModifiersOrder, {
                at: loc,
                orderedModifiers: [before, after]
              });
            }
          };
          const incompatible = (loc, modifier, mod1, mod2) => {
            if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
              this.raise(TSErrors.IncompatibleModifiers, {
                at: loc,
                modifiers: [mod1, mod2]
              });
            }
          };
          for (; ; ) {
            const {
              startLoc
            } = this.state;
            const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
            if (!modifier)
              break;
            if (tsIsAccessModifier(modifier)) {
              if (modified.accessibility) {
                this.raise(TSErrors.DuplicateAccessibilityModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, modifier, "override");
                enforceOrder(startLoc, modifier, modifier, "static");
                enforceOrder(startLoc, modifier, modifier, "readonly");
                modified.accessibility = modifier;
              }
            } else if (tsIsVarianceAnnotations(modifier)) {
              if (modified[modifier]) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              }
              modified[modifier] = true;
              enforceOrder(startLoc, modifier, "in", "out");
            } else {
              if (Object.hasOwnProperty.call(modified, modifier)) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, "static", "readonly");
                enforceOrder(startLoc, modifier, "static", "override");
                enforceOrder(startLoc, modifier, "override", "readonly");
                enforceOrder(startLoc, modifier, "abstract", "override");
                incompatible(startLoc, modifier, "declare", "override");
                incompatible(startLoc, modifier, "static", "abstract");
              }
              modified[modifier] = true;
            }
            if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
              this.raise(errorTemplate, {
                at: startLoc,
                modifier
              });
            }
          }
        }
        tsIsListTerminator(kind) {
          switch (kind) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(8);
            case "HeritageClauseElement":
              return this.match(5);
            case "TupleElementTypes":
              return this.match(3);
            case "TypeParametersOrArguments":
              return this.match(48);
          }
          throw new Error("Unreachable");
        }
        tsParseList(kind, parseElement) {
          const result = [];
          while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
          }
          return result;
        }
        tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
          return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
        }
        tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
          const result = [];
          let trailingCommaPos = -1;
          for (; ; ) {
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            trailingCommaPos = -1;
            const element = parseElement();
            if (element == null) {
              return void 0;
            }
            result.push(element);
            if (this.eat(12)) {
              trailingCommaPos = this.state.lastTokStart;
              continue;
            }
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            if (expectSuccess) {
              this.expect(12);
            }
            return void 0;
          }
          if (refTrailingCommaPos) {
            refTrailingCommaPos.value = trailingCommaPos;
          }
          return result;
        }
        tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
          if (!skipFirstToken) {
            if (bracket) {
              this.expect(0);
            } else {
              this.expect(47);
            }
          }
          const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
          if (bracket) {
            this.expect(3);
          } else {
            this.expect(48);
          }
          return result;
        }
        tsParseImportType() {
          const node = this.startNode();
          this.expect(83);
          this.expect(10);
          if (!this.match(131)) {
            this.raise(TSErrors.UnsupportedImportTypeArgument, {
              at: this.state.startLoc
            });
          }
          node.argument = super.parseExprAtom();
          this.expect(11);
          if (this.eat(16)) {
            node.qualifier = this.tsParseEntityName();
          }
          if (this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSImportType");
        }
        tsParseEntityName(allowReservedWords = true) {
          let entity = this.parseIdentifier(allowReservedWords);
          while (this.eat(16)) {
            const node = this.startNodeAtNode(entity);
            node.left = entity;
            node.right = this.parseIdentifier(allowReservedWords);
            entity = this.finishNode(node, "TSQualifiedName");
          }
          return entity;
        }
        tsParseTypeReference() {
          const node = this.startNode();
          node.typeName = this.tsParseEntityName();
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSTypeReference");
        }
        tsParseThisTypePredicate(lhs) {
          this.next();
          const node = this.startNodeAtNode(lhs);
          node.parameterName = lhs;
          node.typeAnnotation = this.tsParseTypeAnnotation(false);
          node.asserts = false;
          return this.finishNode(node, "TSTypePredicate");
        }
        tsParseThisTypeNode() {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "TSThisType");
        }
        tsParseTypeQuery() {
          const node = this.startNode();
          this.expect(87);
          if (this.match(83)) {
            node.exprName = this.tsParseImportType();
          } else {
            node.exprName = this.tsParseEntityName();
          }
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSTypeQuery");
        }
        tsParseInOutModifiers(node) {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["in", "out"],
            disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
          });
        }
        tsParseNoneModifiers(node) {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: [],
            disallowedModifiers: ["in", "out"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
        }
        tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
          const node = this.startNode();
          parseModifiers(node);
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsEatThenParseType(81);
          node.default = this.tsEatThenParseType(29);
          return this.finishNode(node, "TSTypeParameter");
        }
        tsTryParseTypeParameters(parseModifiers) {
          if (this.match(47)) {
            return this.tsParseTypeParameters(parseModifiers);
          }
        }
        tsParseTypeParameters(parseModifiers) {
          const node = this.startNode();
          if (this.match(47) || this.match(140)) {
            this.next();
          } else {
            this.unexpected();
          }
          const refTrailingCommaPos = {
            value: -1
          };
          node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeParameters, {
              at: node
            });
          }
          if (refTrailingCommaPos.value !== -1) {
            this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
          }
          return this.finishNode(node, "TSTypeParameterDeclaration");
        }
        tsFillSignature(returnToken, signature) {
          const returnTokenRequired = returnToken === 19;
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          signature.typeParameters = this.tsTryParseTypeParameters();
          this.expect(10);
          signature[paramsKey] = this.tsParseBindingListForSignature();
          if (returnTokenRequired) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          } else if (this.match(returnToken)) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          }
        }
        tsParseBindingListForSignature() {
          return super.parseBindingList(11, 41).map((pattern) => {
            if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
              this.raise(TSErrors.UnsupportedSignatureParameterKind, {
                at: pattern,
                type: pattern.type
              });
            }
            return pattern;
          });
        }
        tsParseTypeMemberSemicolon() {
          if (!this.eat(12) && !this.isLineTerminator()) {
            this.expect(13);
          }
        }
        tsParseSignatureMember(kind, node) {
          this.tsFillSignature(14, node);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, kind);
        }
        tsIsUnambiguouslyIndexSignature() {
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            this.next();
            return this.match(14);
          }
          return false;
        }
        tsTryParseIndexSignature(node) {
          if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return void 0;
          }
          this.expect(0);
          const id = this.parseIdentifier();
          id.typeAnnotation = this.tsParseTypeAnnotation();
          this.resetEndLocation(id);
          this.expect(3);
          node.parameters = [id];
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            node.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, "TSIndexSignature");
        }
        tsParsePropertyOrMethodSignature(node, readonly) {
          if (this.eat(17))
            node.optional = true;
          const nodeAny = node;
          if (this.match(10) || this.match(47)) {
            if (readonly) {
              this.raise(TSErrors.ReadonlyForMethodSignature, {
                at: node
              });
            }
            const method = nodeAny;
            if (method.kind && this.match(47)) {
              this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
                at: this.state.curPosition()
              });
            }
            this.tsFillSignature(14, method);
            this.tsParseTypeMemberSemicolon();
            const paramsKey = "parameters";
            const returnTypeKey = "typeAnnotation";
            if (method.kind === "get") {
              if (method[paramsKey].length > 0) {
                this.raise(Errors.BadGetterArity, {
                  at: this.state.curPosition()
                });
                if (this.isThisParam(method[paramsKey][0])) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
            } else if (method.kind === "set") {
              if (method[paramsKey].length !== 1) {
                this.raise(Errors.BadSetterArity, {
                  at: this.state.curPosition()
                });
              } else {
                const firstParameter = method[paramsKey][0];
                if (this.isThisParam(firstParameter)) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "Identifier" && firstParameter.optional) {
                  this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "RestElement") {
                  this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
              if (method[returnTypeKey]) {
                this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                  at: method[returnTypeKey]
                });
              }
            } else {
              method.kind = "method";
            }
            return this.finishNode(method, "TSMethodSignature");
          } else {
            const property2 = nodeAny;
            if (readonly)
              property2.readonly = true;
            const type = this.tsTryParseTypeAnnotation();
            if (type)
              property2.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property2, "TSPropertySignature");
          }
        }
        tsParseTypeMember() {
          const node = this.startNode();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
          }
          if (this.match(77)) {
            const id = this.startNode();
            this.next();
            if (this.match(10) || this.match(47)) {
              return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
            } else {
              node.key = this.createIdentifier(id, "new");
              return this.tsParsePropertyOrMethodSignature(node, false);
            }
          }
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["readonly"],
            disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
          });
          const idx = this.tsTryParseIndexSignature(node);
          if (idx) {
            return idx;
          }
          super.parsePropertyName(node);
          if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
            node.kind = node.key.name;
            super.parsePropertyName(node);
          }
          return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
        }
        tsParseTypeLiteral() {
          const node = this.startNode();
          node.members = this.tsParseObjectTypeMembers();
          return this.finishNode(node, "TSTypeLiteral");
        }
        tsParseObjectTypeMembers() {
          this.expect(5);
          const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          this.expect(8);
          return members;
        }
        tsIsStartOfMappedType() {
          this.next();
          if (this.eat(53)) {
            return this.isContextual(120);
          }
          if (this.isContextual(120)) {
            this.next();
          }
          if (!this.match(0)) {
            return false;
          }
          this.next();
          if (!this.tsIsIdentifier()) {
            return false;
          }
          this.next();
          return this.match(58);
        }
        tsParseMappedTypeParameter() {
          const node = this.startNode();
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsExpectThenParseType(58);
          return this.finishNode(node, "TSTypeParameter");
        }
        tsParseMappedType() {
          const node = this.startNode();
          this.expect(5);
          if (this.match(53)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual(120);
          } else if (this.eatContextual(120)) {
            node.readonly = true;
          }
          this.expect(0);
          node.typeParameter = this.tsParseMappedTypeParameter();
          node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
          this.expect(3);
          if (this.match(53)) {
            node.optional = this.state.value;
            this.next();
            this.expect(17);
          } else if (this.eat(17)) {
            node.optional = true;
          }
          node.typeAnnotation = this.tsTryParseType();
          this.semicolon();
          this.expect(8);
          return this.finishNode(node, "TSMappedType");
        }
        tsParseTupleType() {
          const node = this.startNode();
          node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
          let seenOptionalElement = false;
          let labeledElements = null;
          node.elementTypes.forEach((elementNode) => {
            var _labeledElements;
            const {
              type
            } = elementNode;
            if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
              this.raise(TSErrors.OptionalTypeBeforeRequired, {
                at: elementNode
              });
            }
            seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
            let checkType = type;
            if (type === "TSRestType") {
              elementNode = elementNode.typeAnnotation;
              checkType = elementNode.type;
            }
            const isLabeled = checkType === "TSNamedTupleMember";
            (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;
            if (labeledElements !== isLabeled) {
              this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
                at: elementNode
              });
            }
          });
          return this.finishNode(node, "TSTupleType");
        }
        tsParseTupleElementType() {
          const {
            startLoc
          } = this.state;
          const rest = this.eat(21);
          let type = this.tsParseType();
          const optional = this.eat(17);
          const labeled = this.eat(14);
          if (labeled) {
            const labeledNode = this.startNodeAtNode(type);
            labeledNode.optional = optional;
            if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
              labeledNode.label = type.typeName;
            } else {
              this.raise(TSErrors.InvalidTupleMemberLabel, {
                at: type
              });
              labeledNode.label = type;
            }
            labeledNode.elementType = this.tsParseType();
            type = this.finishNode(labeledNode, "TSNamedTupleMember");
          } else if (optional) {
            const optionalTypeNode = this.startNodeAtNode(type);
            optionalTypeNode.typeAnnotation = type;
            type = this.finishNode(optionalTypeNode, "TSOptionalType");
          }
          if (rest) {
            const restNode = this.startNodeAt(startLoc);
            restNode.typeAnnotation = type;
            type = this.finishNode(restNode, "TSRestType");
          }
          return type;
        }
        tsParseParenthesizedType() {
          const node = this.startNode();
          this.expect(10);
          node.typeAnnotation = this.tsParseType();
          this.expect(11);
          return this.finishNode(node, "TSParenthesizedType");
        }
        tsParseFunctionOrConstructorType(type, abstract) {
          const node = this.startNode();
          if (type === "TSConstructorType") {
            node.abstract = !!abstract;
            if (abstract)
              this.next();
            this.next();
          }
          this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
          return this.finishNode(node, type);
        }
        tsParseLiteralTypeNode() {
          const node = this.startNode();
          node.literal = (() => {
            switch (this.state.type) {
              case 132:
              case 133:
              case 131:
              case 85:
              case 86:
                return super.parseExprAtom();
              default:
                throw this.unexpected();
            }
          })();
          return this.finishNode(node, "TSLiteralType");
        }
        tsParseTemplateLiteralType() {
          const node = this.startNode();
          node.literal = super.parseTemplate(false);
          return this.finishNode(node, "TSLiteralType");
        }
        parseTemplateSubstitution() {
          if (this.state.inType)
            return this.tsParseType();
          return super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
          const thisKeyword = this.tsParseThisTypeNode();
          if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        }
        tsParseNonArrayType() {
          switch (this.state.type) {
            case 131:
            case 132:
            case 133:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode();
            case 53:
              if (this.state.value === "-") {
                const node = this.startNode();
                const nextToken = this.lookahead();
                if (nextToken.type !== 132 && nextToken.type !== 133) {
                  throw this.unexpected();
                }
                node.literal = this.parseMaybeUnary();
                return this.finishNode(node, "TSLiteralType");
              }
              break;
            case 78:
              return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
              return this.tsParseTypeQuery();
            case 83:
              return this.tsParseImportType();
            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
            case 0:
              return this.tsParseTupleType();
            case 10:
              return this.tsParseParenthesizedType();
            case 25:
            case 24:
              return this.tsParseTemplateLiteralType();
            default: {
              const {
                type
              } = this.state;
              if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                  const node = this.startNode();
                  this.next();
                  return this.finishNode(node, nodeType);
                }
                return this.tsParseTypeReference();
              }
            }
          }
          throw this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
          let type = this.tsParseNonArrayType();
          while (!this.hasPrecedingLineBreak() && this.eat(0)) {
            if (this.match(3)) {
              const node = this.startNodeAtNode(type);
              node.elementType = type;
              this.expect(3);
              type = this.finishNode(node, "TSArrayType");
            } else {
              const node = this.startNodeAtNode(type);
              node.objectType = type;
              node.indexType = this.tsParseType();
              this.expect(3);
              type = this.finishNode(node, "TSIndexedAccessType");
            }
          }
          return type;
        }
        tsParseTypeOperator() {
          const node = this.startNode();
          const operator = this.state.value;
          this.next();
          node.operator = operator;
          node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
          if (operator === "readonly") {
            this.tsCheckTypeAnnotationForReadOnly(node);
          }
          return this.finishNode(node, "TSTypeOperator");
        }
        tsCheckTypeAnnotationForReadOnly(node) {
          switch (node.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;
            default:
              this.raise(TSErrors.UnexpectedReadonly, {
                at: node
              });
          }
        }
        tsParseInferType() {
          const node = this.startNode();
          this.expectContextual(113);
          const typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
          return this.finishNode(node, "TSInferType");
        }
        tsParseConstraintForInferType() {
          if (this.eat(81)) {
            const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
              return constraint;
            }
          }
        }
        tsParseTypeOperatorOrHigher() {
          const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
          return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
        }
        tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
          const node = this.startNode();
          const hasLeadingOperator = this.eat(operator);
          const types2 = [];
          do {
            types2.push(parseConstituentType());
          } while (this.eat(operator));
          if (types2.length === 1 && !hasLeadingOperator) {
            return types2[0];
          }
          node.types = types2;
          return this.finishNode(node, kind);
        }
        tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
        }
        tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
        }
        tsIsStartOfFunctionType() {
          if (this.match(47)) {
            return true;
          }
          return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
        tsSkipParameterStart() {
          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
            this.next();
            return true;
          }
          if (this.match(5)) {
            const {
              errors
            } = this.state;
            const previousErrorCount = errors.length;
            try {
              this.parseObjectLike(8, true);
              return errors.length === previousErrorCount;
            } catch (_unused) {
              return false;
            }
          }
          if (this.match(0)) {
            this.next();
            const {
              errors
            } = this.state;
            const previousErrorCount = errors.length;
            try {
              super.parseBindingList(3, 93, true);
              return errors.length === previousErrorCount;
            } catch (_unused2) {
              return false;
            }
          }
          return false;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
          this.next();
          if (this.match(11) || this.match(21)) {
            return true;
          }
          if (this.tsSkipParameterStart()) {
            if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
              return true;
            }
            if (this.match(11)) {
              this.next();
              if (this.match(19)) {
                return true;
              }
            }
          }
          return false;
        }
        tsParseTypeOrTypePredicateAnnotation(returnToken) {
          return this.tsInType(() => {
            const t4 = this.startNode();
            this.expect(returnToken);
            const node = this.startNode();
            const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            if (asserts && this.match(78)) {
              let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
              if (thisTypePredicate.type === "TSThisType") {
                node.parameterName = thisTypePredicate;
                node.asserts = true;
                node.typeAnnotation = null;
                thisTypePredicate = this.finishNode(node, "TSTypePredicate");
              } else {
                this.resetStartLocationFromNode(thisTypePredicate, node);
                thisTypePredicate.asserts = true;
              }
              t4.typeAnnotation = thisTypePredicate;
              return this.finishNode(t4, "TSTypeAnnotation");
            }
            const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!typePredicateVariable) {
              if (!asserts) {
                return this.tsParseTypeAnnotation(false, t4);
              }
              node.parameterName = this.parseIdentifier();
              node.asserts = asserts;
              node.typeAnnotation = null;
              t4.typeAnnotation = this.finishNode(node, "TSTypePredicate");
              return this.finishNode(t4, "TSTypeAnnotation");
            }
            const type = this.tsParseTypeAnnotation(false);
            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t4.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t4, "TSTypeAnnotation");
          });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
          return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
        }
        tsTryParseTypeAnnotation() {
          return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
        }
        tsTryParseType() {
          return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
          const id = this.parseIdentifier();
          if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
          }
        }
        tsParseTypePredicateAsserts() {
          if (this.state.type !== 107) {
            return false;
          }
          const containsEsc = this.state.containsEsc;
          this.next();
          if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
            return false;
          }
          if (containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.lastTokStartLoc,
              reservedWord: "asserts"
            });
          }
          return true;
        }
        tsParseTypeAnnotation(eatColon = true, t4 = this.startNode()) {
          this.tsInType(() => {
            if (eatColon)
              this.expect(14);
            t4.typeAnnotation = this.tsParseType();
          });
          return this.finishNode(t4, "TSTypeAnnotation");
        }
        tsParseType() {
          assert(this.state.inType);
          const type = this.tsParseNonConditionalType();
          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
            return type;
          }
          const node = this.startNodeAtNode(type);
          node.checkType = type;
          node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
          this.expect(17);
          node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          this.expect(14);
          node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          return this.finishNode(node, "TSConditionalType");
        }
        isAbstractConstructorSignature() {
          return this.isContextual(122) && this.lookahead().type === 77;
        }
        tsParseNonConditionalType() {
          if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType("TSFunctionType");
          }
          if (this.match(77)) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType");
          } else if (this.isAbstractConstructorSignature()) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
          }
          return this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
          if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedTypeAssertion, {
              at: this.state.startLoc
            });
          }
          const node = this.startNode();
          node.typeAnnotation = this.tsInType(() => {
            this.next();
            return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
          });
          this.expect(48);
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        }
        tsParseHeritageClause(token) {
          const originalStartLoc = this.state.startLoc;
          const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
            const node = this.startNode();
            node.expression = this.tsParseEntityName();
            if (this.match(47)) {
              node.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node, "TSExpressionWithTypeArguments");
          });
          if (!delimitedList.length) {
            this.raise(TSErrors.EmptyHeritageClauseType, {
              at: originalStartLoc,
              token
            });
          }
          return delimitedList;
        }
        tsParseInterfaceDeclaration(node, properties2 = {}) {
          if (this.hasFollowingLineBreak())
            return null;
          this.expectContextual(127);
          if (properties2.declare)
            node.declare = true;
          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            this.checkIdentifier(node.id, BIND_TS_INTERFACE);
          } else {
            node.id = null;
            this.raise(TSErrors.MissingInterfaceName, {
              at: this.state.startLoc
            });
          }
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (this.eat(81)) {
            node.extends = this.tsParseHeritageClause("extends");
          }
          const body = this.startNode();
          body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
          node.body = this.finishNode(body, "TSInterfaceBody");
          return this.finishNode(node, "TSInterfaceDeclaration");
        }
        tsParseTypeAliasDeclaration(node) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_TS_TYPE);
          node.typeAnnotation = this.tsInType(() => {
            node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
            this.expect(29);
            if (this.isContextual(112) && this.lookahead().type !== 16) {
              const node2 = this.startNode();
              this.next();
              return this.finishNode(node2, "TSIntrinsicKeyword");
            }
            return this.tsParseType();
          });
          this.semicolon();
          return this.finishNode(node, "TSTypeAliasDeclaration");
        }
        tsInNoContext(cb) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        }
        tsInType(cb) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          try {
            return cb();
          } finally {
            this.state.inType = oldInType;
          }
        }
        tsInDisallowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = true;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsInAllowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = false;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsEatThenParseType(token) {
          return !this.match(token) ? void 0 : this.tsNextThenParseType();
        }
        tsExpectThenParseType(token) {
          return this.tsDoThenParseType(() => this.expect(token));
        }
        tsNextThenParseType() {
          return this.tsDoThenParseType(() => this.next());
        }
        tsDoThenParseType(cb) {
          return this.tsInType(() => {
            cb();
            return this.tsParseType();
          });
        }
        tsParseEnumMember() {
          const node = this.startNode();
          node.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
          if (this.eat(29)) {
            node.initializer = super.parseMaybeAssignAllowIn();
          }
          return this.finishNode(node, "TSEnumMember");
        }
        tsParseEnumDeclaration(node, properties2 = {}) {
          if (properties2.const)
            node.const = true;
          if (properties2.declare)
            node.declare = true;
          this.expectContextual(124);
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
          this.expect(5);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
          return this.finishNode(node, "TSEnumDeclaration");
        }
        tsParseModuleBlock() {
          const node = this.startNode();
          this.scope.enter(SCOPE_OTHER);
          this.expect(5);
          super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
          this.scope.exit();
          return this.finishNode(node, "TSModuleBlock");
        }
        tsParseModuleOrNamespaceDeclaration(node, nested = false) {
          node.id = this.parseIdentifier();
          if (!nested) {
            this.checkIdentifier(node.id, BIND_TS_NAMESPACE);
          }
          if (this.eat(16)) {
            const inner = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(inner, true);
            node.body = inner;
          } else {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          }
          return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseAmbientExternalModuleDeclaration(node) {
          if (this.isContextual(110)) {
            node.global = true;
            node.id = this.parseIdentifier();
          } else if (this.match(131)) {
            node.id = super.parseStringLiteral(this.state.value);
          } else {
            this.unexpected();
          }
          if (this.match(5)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          } else {
            this.semicolon();
          }
          return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseImportEqualsDeclaration(node, isExport) {
          node.isExport = isExport || false;
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_FLAGS_TS_IMPORT);
          this.expect(29);
          const moduleReference = this.tsParseModuleReference();
          if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
            this.raise(TSErrors.ImportAliasHasImportType, {
              at: moduleReference
            });
          }
          node.moduleReference = moduleReference;
          this.semicolon();
          return this.finishNode(node, "TSImportEqualsDeclaration");
        }
        tsIsExternalModuleReference() {
          return this.isContextual(117) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
        tsParseExternalModuleReference() {
          const node = this.startNode();
          this.expectContextual(117);
          this.expect(10);
          if (!this.match(131)) {
            throw this.unexpected();
          }
          node.expression = super.parseExprAtom();
          this.expect(11);
          return this.finishNode(node, "TSExternalModuleReference");
        }
        tsLookAhead(f) {
          const state = this.state.clone();
          const res = f();
          this.state = state;
          return res;
        }
        tsTryParseAndCatch(f) {
          const result = this.tryParse((abort) => f() || abort());
          if (result.aborted || !result.node)
            return void 0;
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
        tsTryParse(f) {
          const state = this.state.clone();
          const result = f();
          if (result !== void 0 && result !== false) {
            return result;
          } else {
            this.state = state;
            return void 0;
          }
        }
        tsTryParseDeclare(nany) {
          if (this.isLineTerminator()) {
            return;
          }
          let starttype = this.state.type;
          let kind;
          if (this.isContextual(99)) {
            starttype = 74;
            kind = "let";
          }
          return this.tsInAmbientContext(() => {
            if (starttype === 68) {
              nany.declare = true;
              return super.parseFunctionStatement(nany, false, false);
            }
            if (starttype === 80) {
              nany.declare = true;
              return this.parseClass(nany, true, false);
            }
            if (starttype === 124) {
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            }
            if (starttype === 110) {
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            }
            if (starttype === 75 || starttype === 74) {
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            }
            if (starttype === 127) {
              const result = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result)
                return result;
            }
            if (tokenIsIdentifier(starttype)) {
              return this.tsParseDeclaration(nany, this.state.value, true, null);
            }
          });
        }
        tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
        }
        tsParseExpressionStatement(node, expr, decorators) {
          switch (expr.name) {
            case "declare": {
              const declaration = this.tsTryParseDeclare(node);
              if (declaration) {
                declaration.declare = true;
                return declaration;
              }
              break;
            }
            case "global":
              if (this.match(5)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                const mod = node;
                mod.global = true;
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                this.prodParam.exit();
                return this.finishNode(mod, "TSModuleDeclaration");
              }
              break;
            default:
              return this.tsParseDeclaration(node, expr.name, false, decorators);
          }
        }
        tsParseDeclaration(node, value, next, decorators) {
          switch (value) {
            case "abstract":
              if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                return this.tsParseAbstractDeclaration(node, decorators);
              }
              break;
            case "module":
              if (this.tsCheckLineTerminator(next)) {
                if (this.match(131)) {
                  return this.tsParseAmbientExternalModuleDeclaration(node);
                } else if (tokenIsIdentifier(this.state.type)) {
                  return this.tsParseModuleOrNamespaceDeclaration(node);
                }
              }
              break;
            case "namespace":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
              break;
            case "type":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseTypeAliasDeclaration(node);
              }
              break;
          }
        }
        tsCheckLineTerminator(next) {
          if (next) {
            if (this.hasFollowingLineBreak())
              return false;
            this.next();
            return true;
          }
          return !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(startLoc) {
          if (!this.match(47)) {
            return void 0;
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = true;
          const res = this.tsTryParseAndCatch(() => {
            const node = this.startNodeAt(startLoc);
            node.typeParameters = this.tsParseTypeParameters();
            super.parseFunctionParams(node);
            node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
            this.expect(19);
            return node;
          });
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          if (!res) {
            return void 0;
          }
          return super.parseArrowExpression(res, null, true);
        }
        tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() !== 47) {
            return void 0;
          }
          return this.tsParseTypeArguments();
        }
        tsParseTypeArguments() {
          const node = this.startNode();
          node.params = this.tsInType(() => this.tsInNoContext(() => {
            this.expect(47);
            return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
          }));
          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeArguments, {
              at: node
            });
          }
          this.expect(48);
          return this.finishNode(node, "TSTypeParameterInstantiation");
        }
        tsIsDeclarationStart() {
          return tokenIsTSDeclarationStart(this.state.type);
        }
        isExportDefaultSpecifier() {
          if (this.tsIsDeclarationStart())
            return false;
          return super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const startLoc = this.state.startLoc;
          let accessibility;
          let readonly = false;
          let override = false;
          if (allowModifiers !== void 0) {
            const modified = {};
            this.tsParseModifiers({
              modified,
              allowedModifiers: ["public", "private", "protected", "override", "readonly"]
            });
            accessibility = modified.accessibility;
            override = modified.override;
            readonly = modified.readonly;
            if (allowModifiers === false && (accessibility || readonly || override)) {
              this.raise(TSErrors.UnexpectedParameterModifier, {
                at: startLoc
              });
            }
          }
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.loc.start, left);
          if (accessibility || readonly || override) {
            const pp = this.startNodeAt(startLoc);
            if (decorators.length) {
              pp.decorators = decorators;
            }
            if (accessibility)
              pp.accessibility = accessibility;
            if (readonly)
              pp.readonly = readonly;
            if (override)
              pp.override = override;
            if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
              this.raise(TSErrors.UnsupportedParameterPropertyKind, {
                at: pp
              });
            }
            pp.parameter = elt;
            return this.finishNode(pp, "TSParameterProperty");
          }
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        isSimpleParameter(node) {
          return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
          if (bodilessType && !this.match(5) && this.isLineTerminator()) {
            return this.finishNode(node, bodilessType);
          }
          if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
            this.raise(TSErrors.DeclareFunctionHasImplementation, {
              at: node
            });
            if (node.declare) {
              return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
            }
          }
          return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        registerFunctionStatementId(node) {
          if (!node.body && node.id) {
            this.checkIdentifier(node.id, BIND_TS_AMBIENT);
          } else {
            super.registerFunctionStatementId(node);
          }
        }
        tsCheckForInvalidTypeCasts(items) {
          items.forEach((node) => {
            if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
              this.raise(TSErrors.UnexpectedTypeAnnotation, {
                at: node.typeAnnotation
              });
            }
          });
        }
        toReferencedList(exprList, isInParens) {
          this.tsCheckForInvalidTypeCasts(exprList);
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (node.type === "ArrayExpression") {
            this.tsCheckForInvalidTypeCasts(node.elements);
          }
          return node;
        }
        parseSubscript(base, startLoc, noCalls, state) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            this.state.canStartJSXElement = false;
            this.next();
            const nonNullExpression = this.startNodeAt(startLoc);
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, "TSNonNullExpression");
          }
          let isOptionalCall = false;
          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (noCalls) {
              state.stop = true;
              return base;
            }
            state.optionalChainMember = isOptionalCall = true;
            this.next();
          }
          if (this.match(47) || this.match(51)) {
            let missingParenErrorLoc;
            const result = this.tsTryParseAndCatch(() => {
              if (!noCalls && this.atPossibleAsyncArrow(base)) {
                const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
                if (asyncArrowFn) {
                  return asyncArrowFn;
                }
              }
              const typeArguments = this.tsParseTypeArgumentsInExpression();
              if (!typeArguments)
                return;
              if (isOptionalCall && !this.match(10)) {
                missingParenErrorLoc = this.state.curPosition();
                return;
              }
              if (tokenIsTemplate(this.state.type)) {
                const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
                result2.typeParameters = typeArguments;
                return result2;
              }
              if (!noCalls && this.eat(10)) {
                const node2 = this.startNodeAt(startLoc);
                node2.callee = base;
                node2.arguments = this.parseCallExpressionArguments(11, false);
                this.tsCheckForInvalidTypeCasts(node2.arguments);
                node2.typeParameters = typeArguments;
                if (state.optionalChainMember) {
                  node2.optional = isOptionalCall;
                }
                return this.finishCallExpression(node2, state.optionalChainMember);
              }
              const tokenType2 = this.state.type;
              if (tokenType2 === 48 || tokenType2 === 52 || tokenType2 !== 10 && tokenCanStartExpression(tokenType2) && !this.hasPrecedingLineBreak()) {
                return;
              }
              const node = this.startNodeAt(startLoc);
              node.expression = base;
              node.typeParameters = typeArguments;
              return this.finishNode(node, "TSInstantiationExpression");
            });
            if (missingParenErrorLoc) {
              this.unexpected(missingParenErrorLoc, 10);
            }
            if (result) {
              if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                  at: this.state.startLoc
                });
              }
              return result;
            }
          }
          return super.parseSubscript(base, startLoc, noCalls, state);
        }
        parseNewCallee(node) {
          var _callee$extra;
          super.parseNewCallee(node);
          const {
            callee
          } = node;
          if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
            node.typeParameters = callee.typeParameters;
            node.callee = callee.expression;
          }
        }
        parseExprOp(left, leftStartLoc, minPrec) {
          let isSatisfies;
          if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(118)))) {
            const node = this.startNodeAt(leftStartLoc);
            node.expression = left;
            node.typeAnnotation = this.tsInType(() => {
              this.next();
              if (this.match(75)) {
                if (isSatisfies) {
                  this.raise(Errors.UnexpectedKeyword, {
                    at: this.state.startLoc,
                    keyword: "const"
                  });
                }
                return this.tsParseTypeReference();
              }
              return this.tsParseType();
            });
            this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartLoc, minPrec);
          }
          return super.parseExprOp(left, leftStartLoc, minPrec);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (!this.state.isAmbientContext) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
        }
        checkImportReflection(node) {
          super.checkImportReflection(node);
          if (node.module && node.importKind !== "value") {
            this.raise(TSErrors.ImportReflectionHasImportType, {
              at: node.specifiers[0].loc.start
            });
          }
        }
        checkDuplicateExports() {
        }
        parseImport(node) {
          node.importKind = "value";
          if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
            let ahead = this.lookahead();
            if (this.isContextual(128) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
              node.importKind = "type";
              this.next();
              ahead = this.lookahead();
            }
            if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
              return this.tsParseImportEqualsDeclaration(node);
            }
          }
          const importNode = super.parseImport(node);
          if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
            this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
              at: importNode
            });
          }
          return importNode;
        }
        parseExport(node, decorators) {
          if (this.match(83)) {
            this.next();
            if (this.isContextual(128) && this.lookaheadCharCode() !== 61) {
              node.importKind = "type";
              this.next();
            } else {
              node.importKind = "value";
            }
            return this.tsParseImportEqualsDeclaration(node, true);
          } else if (this.eat(29)) {
            const assign2 = node;
            assign2.expression = super.parseExpression();
            this.semicolon();
            return this.finishNode(assign2, "TSExportAssignment");
          } else if (this.eatContextual(93)) {
            const decl = node;
            this.expectContextual(126);
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, "TSNamespaceExportDeclaration");
          } else {
            if (this.isContextual(128) && this.lookahead().type === 5) {
              this.next();
              node.exportKind = "type";
            } else {
              node.exportKind = "value";
            }
            return super.parseExport(node, decorators);
          }
        }
        isAbstractClass() {
          return this.isContextual(122) && this.lookahead().type === 80;
        }
        parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            const cls = this.startNode();
            this.next();
            cls.abstract = true;
            return this.parseClass(cls, true, true);
          }
          if (this.match(127)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result)
              return result;
          }
          return super.parseExportDefaultExpression();
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
          const {
            isAmbientContext
          } = this.state;
          const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
          if (!isAmbientContext)
            return declaration;
          for (const {
            id,
            init
          } of declaration.declarations) {
            if (!init)
              continue;
            if (kind !== "const" || !!id.typeAnnotation) {
              this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
                at: init
              });
            } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
              this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                at: init
              });
            }
          }
          return declaration;
        }
        parseStatementContent(flags, decorators) {
          if (this.match(75) && this.isLookaheadContextual("enum")) {
            const node = this.startNode();
            this.expect(75);
            return this.tsParseEnumDeclaration(node, {
              const: true
            });
          }
          if (this.isContextual(124)) {
            return this.tsParseEnumDeclaration(this.startNode());
          }
          if (this.isContextual(127)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result)
              return result;
          }
          return super.parseStatementContent(flags, decorators);
        }
        parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        }
        tsHasSomeModifiers(member, modifiers) {
          return modifiers.some((modifier) => {
            if (tsIsAccessModifier(modifier)) {
              return member.accessibility === modifier;
            }
            return !!member[modifier];
          });
        }
        tsIsStartOfStaticBlocks() {
          return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(classBody, member, state) {
          const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
          this.tsParseModifiers({
            modified: member,
            allowedModifiers: modifiers,
            disallowedModifiers: ["in", "out"],
            stopOnStartOfClassStaticBlock: true,
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
          const callParseClassMemberWithIsStatic = () => {
            if (this.tsIsStartOfStaticBlocks()) {
              this.next();
              this.next();
              if (this.tsHasSomeModifiers(member, modifiers)) {
                this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                  at: this.state.curPosition()
                });
              }
              super.parseClassStaticBlock(classBody, member);
            } else {
              this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
            }
          };
          if (member.declare) {
            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
          } else {
            callParseClassMemberWithIsStatic();
          }
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const idx = this.tsTryParseIndexSignature(member);
          if (idx) {
            classBody.body.push(idx);
            if (member.abstract) {
              this.raise(TSErrors.IndexSignatureHasAbstract, {
                at: member
              });
            }
            if (member.accessibility) {
              this.raise(TSErrors.IndexSignatureHasAccessibility, {
                at: member,
                modifier: member.accessibility
              });
            }
            if (member.declare) {
              this.raise(TSErrors.IndexSignatureHasDeclare, {
                at: member
              });
            }
            if (member.override) {
              this.raise(TSErrors.IndexSignatureHasOverride, {
                at: member
              });
            }
            return;
          }
          if (!this.state.inAbstractClass && member.abstract) {
            this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
              at: member
            });
          }
          if (member.override) {
            if (!state.hadSuperClass) {
              this.raise(TSErrors.OverrideNotInSubClass, {
                at: member
              });
            }
          }
          super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parsePostMemberNameModifiers(methodOrProp) {
          const optional = this.eat(17);
          if (optional)
            methodOrProp.optional = true;
          if (methodOrProp.readonly && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasReadonly, {
              at: methodOrProp
            });
          }
          if (methodOrProp.declare && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasDeclare, {
              at: methodOrProp
            });
          }
        }
        parseExpressionStatement(node, expr, decorators) {
          const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
          return decl || super.parseExpressionStatement(node, expr, decorators);
        }
        shouldParseExportDeclaration() {
          if (this.tsIsDeclarationStart())
            return true;
          return super.shouldParseExportDeclaration();
        }
        parseConditional(expr, startLoc, refExpressionErrors) {
          if (!this.state.maybeInArrowParameters || !this.match(17)) {
            return super.parseConditional(expr, startLoc, refExpressionErrors);
          }
          const result = this.tryParse(() => super.parseConditional(expr, startLoc));
          if (!result.node) {
            if (result.error) {
              super.setOptionalParametersError(refExpressionErrors, result.error);
            }
            return expr;
          }
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
        parseParenItem(node, startLoc) {
          node = super.parseParenItem(node, startLoc);
          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TSTypeCastExpression");
          }
          return node;
        }
        parseExportDeclaration(node) {
          if (!this.state.isAmbientContext && this.isContextual(123)) {
            return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
          }
          const startLoc = this.state.startLoc;
          const isDeclare = this.eatContextual(123);
          if (isDeclare && (this.isContextual(123) || !this.shouldParseExportDeclaration())) {
            throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
              at: this.state.startLoc
            });
          }
          const isIdentifier2 = tokenIsIdentifier(this.state.type);
          const declaration = isIdentifier2 && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
          if (!declaration)
            return null;
          if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
            node.exportKind = "type";
          }
          if (isDeclare) {
            this.resetStartLocation(declaration, startLoc);
            declaration.declare = true;
          }
          return declaration;
        }
        parseClassId(node, isStatement, optionalId, bindingType) {
          if ((!isStatement || optionalId) && this.isContextual(111)) {
            return;
          }
          super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
          const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (typeParameters)
            node.typeParameters = typeParameters;
        }
        parseClassPropertyAnnotation(node) {
          if (!node.optional) {
            if (this.eat(35)) {
              node.definite = true;
            } else if (this.eat(17)) {
              node.optional = true;
            }
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            node.typeAnnotation = type;
        }
        parseClassProperty(node) {
          this.parseClassPropertyAnnotation(node);
          if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
            this.raise(TSErrors.DeclareClassFieldHasInitializer, {
              at: this.state.startLoc
            });
          }
          if (node.abstract && this.match(29)) {
            const {
              key
            } = node;
            this.raise(TSErrors.AbstractPropertyHasInitializer, {
              at: this.state.startLoc,
              propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
            });
          }
          return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
          if (node.abstract) {
            this.raise(TSErrors.PrivateElementHasAbstract, {
              at: node
            });
          }
          if (node.accessibility) {
            this.raise(TSErrors.PrivateElementHasAccessibility, {
              at: node,
              modifier: node.accessibility
            });
          }
          this.parseClassPropertyAnnotation(node);
          return super.parseClassPrivateProperty(node);
        }
        parseClassAccessorProperty(node) {
          this.parseClassPropertyAnnotation(node);
          if (node.optional) {
            this.raise(TSErrors.AccessorCannotBeOptional, {
              at: node
            });
          }
          return super.parseClassAccessorProperty(node);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters && isConstructor) {
            this.raise(TSErrors.ConstructorHasTypeParameters, {
              at: typeParameters
            });
          }
          const {
            declare = false,
            kind
          } = method;
          if (declare && (kind === "get" || kind === "set")) {
            this.raise(TSErrors.DeclareAccessor, {
              at: method,
              kind
            });
          }
          if (typeParameters)
            method.typeParameters = typeParameters;
          super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            method.typeParameters = typeParameters;
          super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        declareClassPrivateMethodInScope(node, kind) {
          if (node.type === "TSDeclareMethod")
            return;
          if (node.type === "MethodDefinition" && !node.value.body)
            return;
          super.declareClassPrivateMethodInScope(node, kind);
        }
        parseClassSuper(node) {
          super.parseClassSuper(node);
          if (node.superClass && (this.match(47) || this.match(51))) {
            node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
          if (this.eatContextual(111)) {
            node.implements = this.tsParseHeritageClause("implements");
          }
        }
        parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            prop.typeParameters = typeParameters;
          return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        }
        parseFunctionParams(node, allowModifiers) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            node.typeParameters = typeParameters;
          super.parseFunctionParams(node, allowModifiers);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
            decl.definite = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeAnnotation();
          }
          return super.parseAsyncArrowFromCallExpression(node, call);
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
          let state;
          let jsx2;
          let typeCast;
          if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error)
              return jsx2.node;
            const {
              context
            } = this.state;
            const currentContext = context[context.length - 1];
            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context.pop();
            }
          }
          if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          }
          if (!state || state === this.state)
            state = this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _expr$extra, _typeParameters;
            typeParameters = this.tsParseTypeParameters();
            const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
              abort();
            }
            if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
              this.resetStartLocationFromNode(expr, typeParameters);
            }
            expr.typeParameters = typeParameters;
            return expr;
          }, state);
          if (!arrow.error && !arrow.aborted) {
            if (typeParameters)
              this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if (!jsx2) {
            assert(!this.hasPlugin("jsx"));
            typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!typeCast.error)
              return typeCast.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrow.node) {
            this.state = arrow.failState;
            if (typeParameters)
              this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if ((_typeCast = typeCast) != null && _typeCast.node) {
            this.state = typeCast.failState;
            return typeCast.node;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown)
            throw jsx2.error;
          if (arrow.thrown)
            throw arrow.error;
          if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
            throw typeCast.error;
          throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
        }
        reportReservedArrowTypeParam(node) {
          var _node$extra;
          if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedArrowTypeParam, {
              at: node
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          if (!this.hasPlugin("jsx") && this.match(47)) {
            return this.tsParseTypeAssertion();
          } else {
            return super.parseMaybeUnary(refExpressionErrors, sawUnary);
          }
        }
        parseArrow(node) {
          if (this.match(14)) {
            const result = this.tryParse((abort) => {
              const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
              if (this.canInsertSemicolon() || !this.match(19))
                abort();
              return returnType;
            });
            if (result.aborted)
              return;
            if (!result.thrown) {
              if (result.error)
                this.state = result.failState;
              node.returnType = result.node;
            }
          }
          return super.parseArrow(node);
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
              this.raise(TSErrors.PatternIsOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            param.typeAnnotation = type;
          this.resetEndLocation(param);
          return param;
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
            case "TSTypeCastExpression":
              return this.isAssignable(node.expression, isBinding);
            case "TSParameterProperty":
              return true;
            default:
              return super.isAssignable(node, isBinding);
          }
        }
        toAssignable(node, isLHS = false) {
          switch (node.type) {
            case "ParenthesizedExpression":
              this.toAssignableParenthesizedExpression(node, isLHS);
              break;
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              if (isLHS) {
                this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              } else {
                this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              }
              this.toAssignable(node.expression, isLHS);
              break;
            case "AssignmentExpression":
              if (!isLHS && node.left.type === "TSTypeCastExpression") {
                node.left = this.typeCastToParameter(node.left);
              }
            default:
              super.toAssignable(node, isLHS);
          }
        }
        toAssignableParenthesizedExpression(node, isLHS) {
          switch (node.expression.type) {
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isLHS);
              break;
            default:
              super.toAssignable(node, isLHS);
          }
        }
        checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              this.checkToRestConversion(node.expression, false);
              break;
            default:
              super.checkToRestConversion(node, allowPattern);
          }
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn$1({
            TSTypeCastExpression: true,
            TSParameterProperty: "parameter",
            TSNonNullExpression: "expression",
            TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
            TSSatisfiesExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
            TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true]
          }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
              const call = super.parseMaybeDecoratorArguments(expr);
              call.typeParameters = typeArguments;
              return call;
            }
            this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(expr);
        }
        checkCommaAfterRest(close) {
          if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
            this.next();
            return false;
          } else {
            return super.checkCommaAfterRest(close);
          }
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(startLoc, left) {
          const node = super.parseMaybeDefault(startLoc, left);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(TSErrors.TypeAnnotationAfterAssign, {
              at: node.typeAnnotation
            });
          }
          return node;
        }
        getTokenFromCode(code2) {
          if (this.state.inType) {
            if (code2 === 62) {
              return this.finishOp(48, 1);
            }
            if (code2 === 60) {
              return this.finishOp(47, 1);
            }
          }
          return super.getTokenFromCode(code2);
        }
        reScan_lt_gt() {
          const {
            type
          } = this.state;
          if (type === 47) {
            this.state.pos -= 1;
            this.readToken_lt();
          } else if (type === 48) {
            this.state.pos -= 1;
            this.readToken_gt();
          }
        }
        reScan_lt() {
          const {
            type
          } = this.state;
          if (type === 51) {
            this.state.pos -= 2;
            this.finishOp(47, 1);
            return 47;
          }
          return type;
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i = 0; i < exprList.length; i++) {
            const expr = exprList[i];
            if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
        shouldParseArrow(params) {
          if (this.match(14)) {
            return params.every((expr) => this.isAssignable(expr, true));
          }
          return super.shouldParseArrow(params);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(node) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            if (typeArguments)
              node.typeParameters = typeArguments;
          }
          return super.jsxParseOpeningElementAfterName(node);
        }
        getGetterSetterExpectedParamCount(method) {
          const baseCount = super.getGetterSetterExpectedParamCount(method);
          const params = this.getObjectOrClassMethodParams(method);
          const firstParam = params[0];
          const hasContextParam = firstParam && this.isThisParam(firstParam);
          return hasContextParam ? baseCount + 1 : baseCount;
        }
        parseCatchClauseParam() {
          const param = super.parseCatchClauseParam();
          const type = this.tsTryParseTypeAnnotation();
          if (type) {
            param.typeAnnotation = type;
            this.resetEndLocation(param);
          }
          return param;
        }
        tsInAmbientContext(cb) {
          const oldIsAmbientContext = this.state.isAmbientContext;
          this.state.isAmbientContext = true;
          try {
            return cb();
          } finally {
            this.state.isAmbientContext = oldIsAmbientContext;
          }
        }
        parseClass(node, isStatement, optionalId) {
          const oldInAbstractClass = this.state.inAbstractClass;
          this.state.inAbstractClass = !!node.abstract;
          try {
            return super.parseClass(node, isStatement, optionalId);
          } finally {
            this.state.inAbstractClass = oldInAbstractClass;
          }
        }
        tsParseAbstractDeclaration(node, decorators) {
          if (this.match(80)) {
            node.abstract = true;
            return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
          } else if (this.isContextual(127)) {
            if (!this.hasFollowingLineBreak()) {
              node.abstract = true;
              this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
                at: node
              });
              return this.tsParseInterfaceDeclaration(node);
            }
          } else {
            this.unexpected(null, 80);
          }
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
          const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          if (method.abstract) {
            const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
            if (hasBody) {
              const {
                key
              } = method;
              this.raise(TSErrors.AbstractMethodHasImplementation, {
                at: method,
                methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
              });
            }
          }
          return method;
        }
        tsParseTypeParameterName() {
          const typeName = this.parseIdentifier();
          return typeName.name;
        }
        shouldParseAsAmbientContext() {
          return !!this.getPluginOption("typescript", "dts");
        }
        parse() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.parse();
        }
        getExpression() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.getExpression();
        }
        parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
          if (!isString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
            return this.finishNode(node, "ExportSpecifier");
          }
          node.exportKind = "value";
          return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
          if (!importedIsString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
            return this.finishNode(specifier, "ImportSpecifier");
          }
          specifier.importKind = "value";
          return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);
        }
        parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
          const leftOfAsKey = isImport ? "imported" : "local";
          const rightOfAsKey = isImport ? "local" : "exported";
          let leftOfAs = node[leftOfAsKey];
          let rightOfAs;
          let hasTypeSpecifier = false;
          let canParseAsKeyword = true;
          const loc = leftOfAs.loc.start;
          if (this.isContextual(93)) {
            const firstAs = this.parseIdentifier();
            if (this.isContextual(93)) {
              const secondAs = this.parseIdentifier();
              if (tokenIsKeywordOrIdentifier(this.state.type)) {
                hasTypeSpecifier = true;
                leftOfAs = firstAs;
                rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                canParseAsKeyword = false;
              } else {
                rightOfAs = secondAs;
                canParseAsKeyword = false;
              }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
              canParseAsKeyword = false;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            } else {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            if (isImport) {
              leftOfAs = this.parseIdentifier(true);
              if (!this.isContextual(93)) {
                this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
              }
            } else {
              leftOfAs = this.parseModuleExportName();
            }
          }
          if (hasTypeSpecifier && isInTypeOnlyImportExport) {
            this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
              at: loc
            });
          }
          node[leftOfAsKey] = leftOfAs;
          node[rightOfAsKey] = rightOfAs;
          const kindKey = isImport ? "importKind" : "exportKind";
          node[kindKey] = hasTypeSpecifier ? "type" : "value";
          if (canParseAsKeyword && this.eatContextual(93)) {
            node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          }
          if (!node[rightOfAsKey]) {
            node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
          }
          if (isImport) {
            this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);
          }
        }
      };
      function isPossiblyLiteralEnum(expression) {
        if (expression.type !== "MemberExpression")
          return false;
        const {
          computed: computed2,
          property: property2
        } = expression;
        if (computed2 && property2.type !== "StringLiteral" && (property2.type !== "TemplateLiteral" || property2.expressions.length > 0)) {
          return false;
        }
        return isUncomputedMemberExpressionChain(expression.object);
      }
      function isValidAmbientConstInitializer(expression, estree2) {
        var _expression$extra;
        const {
          type
        } = expression;
        if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
          return false;
        }
        if (estree2) {
          if (type === "Literal") {
            const {
              value
            } = expression;
            if (typeof value === "string" || typeof value === "boolean") {
              return true;
            }
          }
        } else {
          if (type === "StringLiteral" || type === "BooleanLiteral") {
            return true;
          }
        }
        if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
          return true;
        }
        if (type === "TemplateLiteral" && expression.expressions.length === 0) {
          return true;
        }
        if (isPossiblyLiteralEnum(expression)) {
          return true;
        }
        return false;
      }
      function isNumber(expression, estree2) {
        if (estree2) {
          return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
        } else {
          return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
        }
      }
      function isNegativeNumber(expression, estree2) {
        if (expression.type === "UnaryExpression") {
          const {
            operator,
            argument
          } = expression;
          if (operator === "-" && isNumber(argument, estree2)) {
            return true;
          }
        }
        return false;
      }
      function isUncomputedMemberExpressionChain(expression) {
        if (expression.type === "Identifier")
          return true;
        if (expression.type !== "MemberExpression")
          return false;
        if (expression.computed)
          return false;
        return isUncomputedMemberExpressionChain(expression.object);
      }
      var PlaceholderErrors = ParseErrorEnum`placeholders`({
        ClassNameIsRequired: "A class name is required.",
        UnexpectedSpace: "Unexpected space in placeholder."
      });
      var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
        parsePlaceholder(expectedNode) {
          if (this.match(142)) {
            const node = this.startNode();
            this.next();
            this.assertNoSpace();
            node.name = super.parseIdentifier(true);
            this.assertNoSpace();
            this.expect(142);
            return this.finishPlaceholder(node, expectedNode);
          }
        }
        finishPlaceholder(node, expectedNode) {
          const isFinished = !!(node.expectedNode && node.type === "Placeholder");
          node.expectedNode = expectedNode;
          return isFinished ? node : this.finishNode(node, "Placeholder");
        }
        getTokenFromCode(code2) {
          if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            return this.finishOp(142, 2);
          }
          return super.getTokenFromCode(code2);
        }
        parseExprAtom(refExpressionErrors) {
          return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
        }
        parseIdentifier(liberal) {
          return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word !== void 0) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
        }
        parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
        }
        isValidLVal(type, isParenthesized, binding) {
          return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
        }
        toAssignable(node, isLHS) {
          if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
            node.expectedNode = "Pattern";
          } else {
            super.toAssignable(node, isLHS);
          }
        }
        chStartsBindingIdentifier(ch, pos) {
          if (super.chStartsBindingIdentifier(ch, pos)) {
            return true;
          }
          const nextToken = this.lookahead();
          if (nextToken.type === 142) {
            return true;
          }
          return false;
        }
        verifyBreakContinue(node, isBreak) {
          if (node.label && node.label.type === "Placeholder")
            return;
          super.verifyBreakContinue(node, isBreak);
        }
        parseExpressionStatement(node, expr) {
          if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
            return super.parseExpressionStatement(node, expr);
          }
          if (this.match(14)) {
            const stmt = node;
            stmt.label = this.finishPlaceholder(expr, "Identifier");
            this.next();
            stmt.body = super.parseStatementOrFunctionDeclaration(false);
            return this.finishNode(stmt, "LabeledStatement");
          }
          this.semicolon();
          node.name = expr.name;
          return this.finishPlaceholder(node, "Statement");
        }
        parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
          return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
        }
        parseFunctionId(requireId) {
          return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
        }
        parseClass(node, isStatement, optionalId) {
          const type = isStatement ? "ClassDeclaration" : "ClassExpression";
          this.next();
          const oldStrict = this.state.strict;
          const placeholder = this.parsePlaceholder("Identifier");
          if (placeholder) {
            if (this.match(81) || this.match(142) || this.match(5)) {
              node.id = placeholder;
            } else if (optionalId || !isStatement) {
              node.id = null;
              node.body = this.finishPlaceholder(placeholder, "ClassBody");
              return this.finishNode(node, type);
            } else {
              throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
                at: this.state.startLoc
              });
            }
          } else {
            this.parseClassId(node, isStatement, optionalId);
          }
          super.parseClassSuper(node);
          node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, type);
        }
        parseExport(node, decorators) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder)
            return super.parseExport(node, decorators);
          if (!this.isContextual(97) && !this.match(12)) {
            node.specifiers = [];
            node.source = null;
            node.declaration = this.finishPlaceholder(placeholder, "Declaration");
            return this.finishNode(node, "ExportNamedDeclaration");
          }
          this.expectPlugin("exportDefaultFrom");
          const specifier = this.startNode();
          specifier.exported = placeholder;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return super.parseExport(node, decorators);
        }
        isExportDefaultSpecifier() {
          if (this.match(65)) {
            const next = this.nextTokenStart();
            if (this.isUnparsedContextual(next, "from")) {
              if (this.input.startsWith(tokenLabelName(142), this.nextTokenStartSince(next + 4))) {
                return true;
              }
            }
          }
          return super.isExportDefaultSpecifier();
        }
        maybeParseExportDefaultSpecifier(node) {
          if (node.specifiers && node.specifiers.length > 0) {
            return true;
          }
          return super.maybeParseExportDefaultSpecifier(node);
        }
        checkExport(node) {
          const {
            specifiers
          } = node;
          if (specifiers != null && specifiers.length) {
            node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
          }
          super.checkExport(node);
          node.specifiers = specifiers;
        }
        parseImport(node) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder)
            return super.parseImport(node);
          node.specifiers = [];
          if (!this.isContextual(97) && !this.match(12)) {
            node.source = this.finishPlaceholder(placeholder, "StringLiteral");
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
          }
          const specifier = this.startNodeAtNode(placeholder);
          specifier.local = placeholder;
          node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
          if (this.eat(12)) {
            const hasStarImport = this.maybeParseStarImportSpecifier(node);
            if (!hasStarImport)
              this.parseNamedImportSpecifiers(node);
          }
          this.expectContextual(97);
          node.source = this.parseImportSource();
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
        }
        assertNoSpace() {
          if (this.state.start > this.state.lastTokEndLoc.index) {
            this.raise(PlaceholderErrors.UnexpectedSpace, {
              at: this.state.lastTokEndLoc
            });
          }
        }
      };
      var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
        parseV8Intrinsic() {
          if (this.match(54)) {
            const v8IntrinsicStartLoc = this.state.startLoc;
            const node = this.startNode();
            this.next();
            if (tokenIsIdentifier(this.state.type)) {
              const name41 = this.parseIdentifierName();
              const identifier4 = this.createIdentifier(node, name41);
              identifier4.type = "V8IntrinsicIdentifier";
              if (this.match(10)) {
                return identifier4;
              }
            }
            this.unexpected(v8IntrinsicStartLoc);
          }
        }
        parseExprAtom(refExpressionErrors) {
          return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
        }
      };
      function hasPlugin(plugins, expectedConfig) {
        const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
        const expectedKeys = Object.keys(expectedOptions);
        const expectedOptionsIsEmpty = expectedKeys.length === 0;
        return plugins.some((p) => {
          if (typeof p === "string") {
            return expectedOptionsIsEmpty && p === expectedName;
          } else {
            const [pluginName, pluginOptions] = p;
            if (pluginName !== expectedName) {
              return false;
            }
            for (const key of expectedKeys) {
              if (pluginOptions[key] !== expectedOptions[key]) {
                return false;
              }
            }
            return true;
          }
        });
      }
      function getPluginOption(plugins, name41, option) {
        const plugin = plugins.find((plugin2) => {
          if (Array.isArray(plugin2)) {
            return plugin2[0] === name41;
          } else {
            return plugin2 === name41;
          }
        });
        if (plugin && Array.isArray(plugin) && plugin.length > 1) {
          return plugin[1][option];
        }
        return null;
      }
      var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
      var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
      var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
      function validatePlugins(plugins) {
        if (hasPlugin(plugins, "decorators")) {
          if (hasPlugin(plugins, "decorators-legacy")) {
            throw new Error("Cannot use the decorators and decorators-legacy plugin together");
          }
          const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
          if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
            throw new Error("'decoratorsBeforeExport' must be a boolean.");
          }
          const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
          if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
            throw new Error("'allowCallParenthesized' must be a boolean.");
          }
        }
        if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
          throw new Error("Cannot combine flow and typescript plugins.");
        }
        if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
          throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
        }
        if (hasPlugin(plugins, "pipelineOperator")) {
          const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
          if (!PIPELINE_PROPOSALS.includes(proposal)) {
            const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
          }
          const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
            syntaxType: "hash"
          }]);
          if (proposal === "hack") {
            if (hasPlugin(plugins, "placeholders")) {
              throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
            }
            if (hasPlugin(plugins, "v8intrinsic")) {
              throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
            }
            const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
            if (!TOPIC_TOKENS.includes(topicToken)) {
              const tokenList = TOPIC_TOKENS.map((t4) => `"${t4}"`).join(", ");
              throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
            }
            if (topicToken === "#" && tupleSyntaxIsHash) {
              throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
          } else if (proposal === "smart" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        }
        if (hasPlugin(plugins, "moduleAttributes")) {
          {
            if (hasPlugin(plugins, "importAssertions")) {
              throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
            }
            const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
            if (moduleAttributesVersionPluginOption !== "may-2020") {
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
          }
        }
        if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
        }
        if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
          const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          error.missingPlugins = "doExpressions";
          throw error;
        }
      }
      var mixinPlugins = {
        estree,
        jsx,
        flow,
        typescript,
        v8intrinsic,
        placeholders
      };
      var mixinPluginNames = Object.keys(mixinPlugins);
      var defaultOptions = {
        sourceType: "script",
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true
      };
      function getOptions(opts) {
        const options = {};
        for (const key of Object.keys(defaultOptions)) {
          options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
        }
        return options;
      }
      var getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
      var unwrapParenthesizedExpression = (node) => {
        return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
      };
      var LValParser = class extends NodeUtils {
        toAssignable(node, isLHS = false) {
          var _node$extra, _node$extra3;
          let parenthesized = void 0;
          if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
            parenthesized = unwrapParenthesizedExpression(node);
            if (isLHS) {
              if (parenthesized.type === "Identifier") {
                this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, {
                  at: node
                });
              } else if (parenthesized.type !== "MemberExpression") {
                this.raise(Errors.InvalidParenthesizedAssignment, {
                  at: node
                });
              }
            } else {
              this.raise(Errors.InvalidParenthesizedAssignment, {
                at: node
              });
            }
          }
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
                var _node$extra2;
                const prop = node.properties[i];
                const isLast = i === last;
                this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                  this.raise(Errors.RestTrailingComma, {
                    at: node.extra.trailingCommaLoc
                  });
                }
              }
              break;
            case "ObjectProperty": {
              const {
                key,
                value
              } = node;
              if (this.isPrivateName(key)) {
                this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
              }
              this.toAssignable(value, isLHS);
              break;
            }
            case "SpreadElement": {
              throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
            }
            case "ArrayExpression":
              node.type = "ArrayPattern";
              this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(Errors.MissingEqInAssignment, {
                  at: node.left.loc.end
                });
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isLHS);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(parenthesized, isLHS);
              break;
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.type === "ObjectMethod") {
            this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
              at: prop.key
            });
          } else if (prop.type === "SpreadElement") {
            prop.type = "RestElement";
            const arg = prop.argument;
            this.checkToRestConversion(arg, false);
            this.toAssignable(arg, isLHS);
            if (!isLast) {
              this.raise(Errors.RestTrailingComma, {
                at: prop
              });
            }
          } else {
            this.toAssignable(prop, isLHS);
          }
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          const end = exprList.length - 1;
          for (let i = 0; i <= end; i++) {
            const elt = exprList[i];
            if (!elt)
              continue;
            if (elt.type === "SpreadElement") {
              elt.type = "RestElement";
              const arg = elt.argument;
              this.checkToRestConversion(arg, true);
              this.toAssignable(arg, isLHS);
            } else {
              this.toAssignable(elt, isLHS);
            }
            if (elt.type === "RestElement") {
              if (i < end) {
                this.raise(Errors.RestTrailingComma, {
                  at: elt
                });
              } else if (trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, {
                  at: trailingCommaLoc
                });
              }
            }
          }
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              return true;
            case "ObjectExpression": {
              const last = node.properties.length - 1;
              return node.properties.every((prop, i) => {
                return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
              });
            }
            case "ObjectProperty":
              return this.isAssignable(node.value);
            case "SpreadElement":
              return this.isAssignable(node.argument);
            case "ArrayExpression":
              return node.elements.every((element) => element === null || this.isAssignable(element));
            case "AssignmentExpression":
              return node.operator === "=";
            case "ParenthesizedExpression":
              return this.isAssignable(node.expression);
            case "MemberExpression":
            case "OptionalMemberExpression":
              return !isBinding;
            default:
              return false;
          }
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          return exprList;
        }
        toReferencedListDeep(exprList, isParenthesizedExpr) {
          this.toReferencedList(exprList, isParenthesizedExpr);
          for (const expr of exprList) {
            if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
              this.toReferencedListDeep(expr.elements);
            }
          }
        }
        parseSpread(refExpressionErrors) {
          const node = this.startNode();
          this.next();
          node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
          return this.finishNode(node, "SpreadElement");
        }
        parseRestBinding() {
          const node = this.startNode();
          this.next();
          node.argument = this.parseBindingAtom();
          return this.finishNode(node, "RestElement");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              const node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(3, 93, true);
              return this.finishNode(node, "ArrayPattern");
            }
            case 5:
              return this.parseObjectLike(8, true);
          }
          return this.parseIdentifier();
        }
        parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
            }
            if (allowEmpty && this.match(12)) {
              elts.push(null);
            } else if (this.eat(close)) {
              break;
            } else if (this.match(21)) {
              elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
              if (!this.checkCommaAfterRest(closeCharCode)) {
                this.expect(close);
                break;
              }
            } else {
              const decorators = [];
              if (this.match(26) && this.hasPlugin("decorators")) {
                this.raise(Errors.UnsupportedParameterDecorator, {
                  at: this.state.startLoc
                });
              }
              while (this.match(26)) {
                decorators.push(this.parseDecorator());
              }
              elts.push(this.parseAssignableListItem(allowModifiers, decorators));
            }
          }
          return elts;
        }
        parseBindingRestProperty(prop) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }
        parseBindingProperty() {
          const prop = this.startNode();
          const {
            type,
            startLoc
          } = this.state;
          if (type === 21) {
            return this.parseBindingRestProperty(prop);
          } else if (type === 136) {
            this.expectPlugin("destructuringPrivate", startLoc);
            this.classScope.usePrivateName(this.state.value, startLoc);
            prop.key = this.parsePrivateName();
          } else {
            this.parsePropertyName(prop);
          }
          prop.method = false;
          return this.parseObjPropValue(prop, startLoc, false, false, true, false);
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.loc.start, left);
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        parseAssignableListItemTypes(param) {
          return param;
        }
        parseMaybeDefault(startLoc, left) {
          var _startLoc, _left;
          (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
          left = (_left = left) != null ? _left : this.parseBindingAtom();
          if (!this.eat(29))
            return left;
          const node = this.startNodeAt(startLoc);
          node.left = left;
          node.right = this.parseMaybeAssignAllowIn();
          return this.finishNode(node, "AssignmentPattern");
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn({
            AssignmentPattern: "left",
            RestElement: "argument",
            ObjectProperty: "value",
            ParenthesizedExpression: "expression",
            ArrayPattern: "elements",
            ObjectPattern: "properties"
          }, type);
        }
        checkLVal(expression, {
          in: ancestor,
          binding = BIND_NONE,
          checkClashes = false,
          strictModeChanged = false,
          hasParenthesizedAncestor = false
        }) {
          var _expression$extra;
          const type = expression.type;
          if (this.isObjectMethod(expression))
            return;
          if (type === "MemberExpression") {
            if (binding !== BIND_NONE) {
              this.raise(Errors.InvalidPropertyBindingPattern, {
                at: expression
              });
            }
            return;
          }
          if (type === "Identifier") {
            this.checkIdentifier(expression, binding, strictModeChanged);
            const {
              name: name41
            } = expression;
            if (checkClashes) {
              if (checkClashes.has(name41)) {
                this.raise(Errors.ParamDupe, {
                  at: expression
                });
              } else {
                checkClashes.add(name41);
              }
            }
            return;
          }
          const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
          if (validity === true)
            return;
          if (validity === false) {
            const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
            this.raise(ParseErrorClass, {
              at: expression,
              ancestor
            });
            return;
          }
          const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
          const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" || type === "ParenthesizedExpression" ? {
            type
          } : ancestor;
          for (const child of [].concat(expression[key])) {
            if (child) {
              this.checkLVal(child, {
                in: nextAncestor,
                binding,
                checkClashes,
                strictModeChanged,
                hasParenthesizedAncestor: isParenthesizedExpression
              });
            }
          }
        }
        checkIdentifier(at, bindingType, strictModeChanged = false) {
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
            if (bindingType === BIND_NONE) {
              this.raise(Errors.StrictEvalArguments, {
                at,
                referenceName: at.name
              });
            } else {
              this.raise(Errors.StrictEvalArgumentsBinding, {
                at,
                bindingName: at.name
              });
            }
          }
          if (bindingType & BIND_FLAGS_NO_LET_IN_LEXICAL && at.name === "let") {
            this.raise(Errors.LetInLexicalBinding, {
              at
            });
          }
          if (!(bindingType & BIND_NONE)) {
            this.declareNameFromIdentifier(at, bindingType);
          }
        }
        declareNameFromIdentifier(identifier4, binding) {
          this.scope.declareName(identifier4.name, binding, identifier4.loc.start);
        }
        checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "ParenthesizedExpression":
              this.checkToRestConversion(node.expression, allowPattern);
              break;
            case "Identifier":
            case "MemberExpression":
              break;
            case "ArrayExpression":
            case "ObjectExpression":
              if (allowPattern)
                break;
            default:
              this.raise(Errors.InvalidRestAssignmentPattern, {
                at: node
              });
          }
        }
        checkCommaAfterRest(close) {
          if (!this.match(12)) {
            return false;
          }
          this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
            at: this.state.startLoc
          });
          return true;
        }
      };
      var ExpressionParser = class extends LValParser {
        checkProto(prop, isRecord, protoRef, refExpressionErrors) {
          if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
            return;
          }
          const key = prop.key;
          const name41 = key.type === "Identifier" ? key.name : key.value;
          if (name41 === "__proto__") {
            if (isRecord) {
              this.raise(Errors.RecordNoProto, {
                at: key
              });
              return;
            }
            if (protoRef.used) {
              if (refExpressionErrors) {
                if (refExpressionErrors.doubleProtoLoc === null) {
                  refExpressionErrors.doubleProtoLoc = key.loc.start;
                }
              } else {
                this.raise(Errors.DuplicateProto, {
                  at: key
                });
              }
            }
            protoRef.used = true;
          }
        }
        shouldExitDescending(expr, potentialArrowAt) {
          return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
        }
        getExpression() {
          this.enterInitialScopes();
          this.nextToken();
          const expr = this.parseExpression();
          if (!this.match(137)) {
            this.unexpected();
          }
          this.finalizeRemainingComments();
          expr.comments = this.state.comments;
          expr.errors = this.state.errors;
          if (this.options.tokens) {
            expr.tokens = this.tokens;
          }
          return expr;
        }
        parseExpression(disallowIn, refExpressionErrors) {
          if (disallowIn) {
            return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
          }
          return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        parseExpressionBase(refExpressionErrors) {
          const startLoc = this.state.startLoc;
          const expr = this.parseMaybeAssign(refExpressionErrors);
          if (this.match(12)) {
            const node = this.startNodeAt(startLoc);
            node.expressions = [expr];
            while (this.eat(12)) {
              node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
            }
            this.toReferencedList(node.expressions);
            return this.finishNode(node, "SequenceExpression");
          }
          return expr;
        }
        parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
          return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
          return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        setOptionalParametersError(refExpressionErrors, resultError) {
          var _resultError$loc;
          refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          const startLoc = this.state.startLoc;
          if (this.isContextual(106)) {
            if (this.prodParam.hasYield) {
              let left2 = this.parseYield();
              if (afterLeftParse) {
                left2 = afterLeftParse.call(this, left2, startLoc);
              }
              return left2;
            }
          }
          let ownExpressionErrors;
          if (refExpressionErrors) {
            ownExpressionErrors = false;
          } else {
            refExpressionErrors = new ExpressionErrors();
            ownExpressionErrors = true;
          }
          const {
            type
          } = this.state;
          if (type === 10 || tokenIsIdentifier(type)) {
            this.state.potentialArrowAt = this.state.start;
          }
          let left = this.parseMaybeConditional(refExpressionErrors);
          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startLoc);
          }
          if (tokenIsAssignment(this.state.type)) {
            const node = this.startNodeAt(startLoc);
            const operator = this.state.value;
            node.operator = operator;
            if (this.match(29)) {
              this.toAssignable(left, true);
              node.left = left;
              const startIndex = startLoc.index;
              if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
                refExpressionErrors.doubleProtoLoc = null;
              }
              if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
                refExpressionErrors.shorthandAssignLoc = null;
              }
              if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
                this.checkDestructuringPrivate(refExpressionErrors);
                refExpressionErrors.privateKeyLoc = null;
              }
            } else {
              node.left = left;
            }
            this.next();
            node.right = this.parseMaybeAssign();
            this.checkLVal(left, {
              in: this.finishNode(node, "AssignmentExpression")
            });
            return node;
          } else if (ownExpressionErrors) {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          return left;
        }
        parseMaybeConditional(refExpressionErrors) {
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprOps(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseConditional(expr, startLoc, refExpressionErrors);
        }
        parseConditional(expr, startLoc, refExpressionErrors) {
          if (this.eat(17)) {
            const node = this.startNodeAt(startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssignAllowIn();
            this.expect(14);
            node.alternate = this.parseMaybeAssign();
            return this.finishNode(node, "ConditionalExpression");
          }
          return expr;
        }
        parseMaybeUnaryOrPrivate(refExpressionErrors) {
          return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
        }
        parseExprOps(refExpressionErrors) {
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseExprOp(expr, startLoc, -1);
        }
        parseExprOp(left, leftStartLoc, minPrec) {
          if (this.isPrivateName(left)) {
            const value = this.getPrivateNameSV(left);
            if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
              this.raise(Errors.PrivateInExpectedIn, {
                at: left,
                identifierName: value
              });
            }
            this.classScope.usePrivateName(value, left.loc.start);
          }
          const op = this.state.type;
          if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
            let prec = tokenOperatorPrecedence(op);
            if (prec > minPrec) {
              if (op === 39) {
                this.expectPlugin("pipelineOperator");
                if (this.state.inFSharpPipelineDirectBody) {
                  return left;
                }
                this.checkPipelineAtInfixOperator(left, leftStartLoc);
              }
              const node = this.startNodeAt(leftStartLoc);
              node.left = left;
              node.operator = this.state.value;
              const logical = op === 41 || op === 42;
              const coalesce = op === 40;
              if (coalesce) {
                prec = tokenOperatorPrecedence(42);
              }
              this.next();
              if (op === 39 && this.hasPlugin(["pipelineOperator", {
                proposal: "minimal"
              }])) {
                if (this.state.type === 96 && this.prodParam.hasAwait) {
                  throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                    at: this.state.startLoc
                  });
                }
              }
              node.right = this.parseExprOpRightExpr(op, prec);
              const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
              const nextOp = this.state.type;
              if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
                throw this.raise(Errors.MixingCoalesceWithLogical, {
                  at: this.state.startLoc
                });
              }
              return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
            }
          }
          return left;
        }
        parseExprOpRightExpr(op, prec) {
          const startLoc = this.state.startLoc;
          switch (op) {
            case 39:
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => {
                    return this.parseHackPipeBody();
                  });
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(106)) {
                      throw this.raise(Errors.PipeBodyIsTighter, {
                        at: this.state.startLoc
                      });
                    }
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => {
                    return this.parseFSharpPipelineBody(prec);
                  });
              }
            default:
              return this.parseExprOpBaseRightExpr(op, prec);
          }
        }
        parseExprOpBaseRightExpr(op, prec) {
          const startLoc = this.state.startLoc;
          return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
        }
        parseHackPipeBody() {
          var _body$extra;
          const {
            startLoc
          } = this.state;
          const body = this.parseMaybeAssign();
          const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
          if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
            this.raise(Errors.PipeUnparenthesizedBody, {
              at: startLoc,
              type: body.type
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipeTopicUnused, {
              at: startLoc
            });
          }
          return body;
        }
        checkExponentialAfterUnary(node) {
          if (this.match(57)) {
            this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
              at: node.argument
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          const startLoc = this.state.startLoc;
          const isAwait = this.isContextual(96);
          if (isAwait && this.isAwaitAllowed()) {
            this.next();
            const expr2 = this.parseAwait(startLoc);
            if (!sawUnary)
              this.checkExponentialAfterUnary(expr2);
            return expr2;
          }
          const update = this.match(34);
          const node = this.startNode();
          if (tokenIsPrefix(this.state.type)) {
            node.operator = this.state.value;
            node.prefix = true;
            if (this.match(72)) {
              this.expectPlugin("throwExpressions");
            }
            const isDelete = this.match(89);
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refExpressionErrors, true);
            if (this.state.strict && isDelete) {
              const arg = node.argument;
              if (arg.type === "Identifier") {
                this.raise(Errors.StrictDelete, {
                  at: node
                });
              } else if (this.hasPropertyAsPrivateName(arg)) {
                this.raise(Errors.DeletePrivateField, {
                  at: node
                });
              }
            }
            if (!update) {
              if (!sawUnary) {
                this.checkExponentialAfterUnary(node);
              }
              return this.finishNode(node, "UnaryExpression");
            }
          }
          const expr = this.parseUpdate(node, update, refExpressionErrors);
          if (isAwait) {
            const {
              type
            } = this.state;
            const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
            if (startsExpr2 && !this.isAmbiguousAwait()) {
              this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
                at: startLoc
              });
              return this.parseAwait(startLoc);
            }
          }
          return expr;
        }
        parseUpdate(node, update, refExpressionErrors) {
          if (update) {
            const updateExpressionNode = node;
            this.checkLVal(updateExpressionNode.argument, {
              in: this.finishNode(updateExpressionNode, "UpdateExpression")
            });
            return node;
          }
          const startLoc = this.state.startLoc;
          let expr = this.parseExprSubscripts(refExpressionErrors);
          if (this.checkExpressionErrors(refExpressionErrors, false))
            return expr;
          while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
            const node2 = this.startNodeAt(startLoc);
            node2.operator = this.state.value;
            node2.prefix = false;
            node2.argument = expr;
            this.next();
            this.checkLVal(expr, {
              in: expr = this.finishNode(node2, "UpdateExpression")
            });
          }
          return expr;
        }
        parseExprSubscripts(refExpressionErrors) {
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprAtom(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseSubscripts(expr, startLoc);
        }
        parseSubscripts(base, startLoc, noCalls) {
          const state = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
            stop: false
          };
          do {
            base = this.parseSubscript(base, startLoc, noCalls, state);
            state.maybeAsyncArrow = false;
          } while (!state.stop);
          return base;
        }
        parseSubscript(base, startLoc, noCalls, state) {
          const {
            type
          } = this.state;
          if (!noCalls && type === 15) {
            return this.parseBind(base, startLoc, noCalls, state);
          } else if (tokenIsTemplate(type)) {
            return this.parseTaggedTemplateExpression(base, startLoc, state);
          }
          let optional = false;
          if (type === 18) {
            if (noCalls && this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base;
            }
            state.optionalChainMember = optional = true;
            this.next();
          }
          if (!noCalls && this.match(10)) {
            return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
          } else {
            const computed2 = this.eat(0);
            if (computed2 || optional || this.eat(16)) {
              return this.parseMember(base, startLoc, state, computed2, optional);
            } else {
              state.stop = true;
              return base;
            }
          }
        }
        parseMember(base, startLoc, state, computed2, optional) {
          const node = this.startNodeAt(startLoc);
          node.object = base;
          node.computed = computed2;
          if (computed2) {
            node.property = this.parseExpression();
            this.expect(3);
          } else if (this.match(136)) {
            if (base.type === "Super") {
              this.raise(Errors.SuperPrivateField, {
                at: startLoc
              });
            }
            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
            node.property = this.parsePrivateName();
          } else {
            node.property = this.parseIdentifier(true);
          }
          if (state.optionalChainMember) {
            node.optional = optional;
            return this.finishNode(node, "OptionalMemberExpression");
          } else {
            return this.finishNode(node, "MemberExpression");
          }
        }
        parseBind(base, startLoc, noCalls, state) {
          const node = this.startNodeAt(startLoc);
          node.object = base;
          this.next();
          node.callee = this.parseNoCallExpr();
          state.stop = true;
          return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
        }
        parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          let refExpressionErrors = null;
          this.state.maybeInArrowParameters = true;
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          const {
            maybeAsyncArrow,
            optionalChainMember
          } = state;
          if (maybeAsyncArrow) {
            this.expressionScope.enter(newAsyncArrowScope());
            refExpressionErrors = new ExpressionErrors();
          }
          if (optionalChainMember) {
            node.optional = optional;
          }
          if (optional) {
            node.arguments = this.parseCallExpressionArguments(11);
          } else {
            node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
          }
          let finishedNode = this.finishCallExpression(node, optionalChainMember);
          if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
            state.stop = true;
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
          } else {
            if (maybeAsyncArrow) {
              this.checkExpressionErrors(refExpressionErrors, true);
              this.expressionScope.exit();
            }
            this.toReferencedArguments(finishedNode);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return finishedNode;
        }
        toReferencedArguments(node, isParenthesizedExpr) {
          this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
        }
        parseTaggedTemplateExpression(base, startLoc, state) {
          const node = this.startNodeAt(startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate(true);
          if (state.optionalChainMember) {
            this.raise(Errors.OptionalChainingNoTemplate, {
              at: startLoc
            });
          }
          return this.finishNode(node, "TaggedTemplateExpression");
        }
        atPossibleAsyncArrow(base) {
          return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
        }
        finishCallExpression(node, optional) {
          if (node.callee.type === "Import") {
            if (node.arguments.length === 2) {
              {
                if (!this.hasPlugin("moduleAttributes")) {
                  this.expectPlugin("importAssertions");
                }
              }
            }
            if (node.arguments.length === 0 || node.arguments.length > 2) {
              this.raise(Errors.ImportCallArity, {
                at: node,
                maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
              });
            } else {
              for (const arg of node.arguments) {
                if (arg.type === "SpreadElement") {
                  this.raise(Errors.ImportCallSpreadArgument, {
                    at: arg
                  });
                }
              }
            }
          }
          return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
        }
        parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
          const elts = [];
          let first = true;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                  this.raise(Errors.ImportCallArgumentTrailingComma, {
                    at: this.state.lastTokStartLoc
                  });
                }
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
          }
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return elts;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(node, call) {
          var _call$extra;
          this.resetPreviousNodeTrailingComments(call);
          this.expect(19);
          this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
          if (call.innerComments) {
            setInnerComments(node, call.innerComments);
          }
          if (call.callee.trailingComments) {
            setInnerComments(node, call.callee.trailingComments);
          }
          return node;
        }
        parseNoCallExpr() {
          const startLoc = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
        }
        parseExprAtom(refExpressionErrors) {
          let node;
          let decorators = null;
          const {
            type
          } = this.state;
          switch (type) {
            case 79:
              return this.parseSuper();
            case 83:
              node = this.startNode();
              this.next();
              if (this.match(16)) {
                return this.parseImportMetaProperty(node);
              }
              if (!this.match(10)) {
                this.raise(Errors.UnsupportedImport, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.finishNode(node, "Import");
            case 78:
              node = this.startNode();
              this.next();
              return this.finishNode(node, "ThisExpression");
            case 90: {
              return this.parseDo(this.startNode(), false);
            }
            case 56:
            case 31: {
              this.readRegexp();
              return this.parseRegExpLiteral(this.state.value);
            }
            case 132:
              return this.parseNumericLiteral(this.state.value);
            case 133:
              return this.parseBigIntLiteral(this.state.value);
            case 134:
              return this.parseDecimalLiteral(this.state.value);
            case 131:
              return this.parseStringLiteral(this.state.value);
            case 84:
              return this.parseNullLiteral();
            case 85:
              return this.parseBooleanLiteral(true);
            case 86:
              return this.parseBooleanLiteral(false);
            case 10: {
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(canBeArrow);
            }
            case 2:
            case 1: {
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
            }
            case 0: {
              return this.parseArrayLike(3, true, false, refExpressionErrors);
            }
            case 6:
            case 7: {
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
            }
            case 5: {
              return this.parseObjectLike(8, false, false, refExpressionErrors);
            }
            case 68:
              return this.parseFunctionOrFunctionSent();
            case 26:
              decorators = this.parseDecorators();
            case 80:
              return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
            case 77:
              return this.parseNewOrNewTarget();
            case 25:
            case 24:
              return this.parseTemplate(false);
            case 15: {
              node = this.startNode();
              this.next();
              node.object = null;
              const callee = node.callee = this.parseNoCallExpr();
              if (callee.type === "MemberExpression") {
                return this.finishNode(node, "BindExpression");
              } else {
                throw this.raise(Errors.UnsupportedBind, {
                  at: callee
                });
              }
            }
            case 136: {
              this.raise(Errors.PrivateInExpectedIn, {
                at: this.state.startLoc,
                identifierName: this.state.value
              });
              return this.parsePrivateName();
            }
            case 33: {
              return this.parseTopicReferenceThenEqualsSign(54, "%");
            }
            case 32: {
              return this.parseTopicReferenceThenEqualsSign(44, "^");
            }
            case 37:
            case 38: {
              return this.parseTopicReference("hack");
            }
            case 44:
            case 54:
            case 27: {
              const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
              if (pipeProposal) {
                return this.parseTopicReference(pipeProposal);
              } else {
                throw this.unexpected();
              }
            }
            case 47: {
              const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
              if (isIdentifierStart2(lookaheadCh) || lookaheadCh === 62) {
                this.expectOnePlugin(["jsx", "flow", "typescript"]);
                break;
              } else {
                throw this.unexpected();
              }
            }
            default:
              if (tokenIsIdentifier(type)) {
                if (this.isContextual(125) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
                  return this.parseModuleExpression();
                }
                const canBeArrow = this.state.potentialArrowAt === this.state.start;
                const containsEsc = this.state.containsEsc;
                const id = this.parseIdentifier();
                if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                  const {
                    type: type2
                  } = this.state;
                  if (type2 === 68) {
                    this.resetPreviousNodeTrailingComments(id);
                    this.next();
                    return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                  } else if (tokenIsIdentifier(type2)) {
                    if (this.lookaheadCharCode() === 61) {
                      return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                    } else {
                      return id;
                    }
                  } else if (type2 === 90) {
                    this.resetPreviousNodeTrailingComments(id);
                    return this.parseDo(this.startNodeAtNode(id), true);
                  }
                }
                if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                  this.next();
                  return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
                }
                return id;
              } else {
                throw this.unexpected();
              }
          }
        }
        parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) {
            this.state.type = topicTokenType;
            this.state.value = topicTokenValue;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
            return this.parseTopicReference(pipeProposal);
          } else {
            throw this.unexpected();
          }
        }
        parseTopicReference(pipeProposal) {
          const node = this.startNode();
          const startLoc = this.state.startLoc;
          const tokenType2 = this.state.type;
          this.next();
          return this.finishTopicReference(node, startLoc, pipeProposal, tokenType2);
        }
        finishTopicReference(node, startLoc, pipeProposal, tokenType2) {
          if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType2)) {
            const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
                at: startLoc
              });
            }
            this.registerTopicReference();
            return this.finishNode(node, nodeType);
          } else {
            throw this.raise(Errors.PipeTopicUnconfiguredToken, {
              at: startLoc,
              token: tokenLabelName(tokenType2)
            });
          }
        }
        testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType2) {
          switch (pipeProposal) {
            case "hack": {
              return this.hasPlugin(["pipelineOperator", {
                topicToken: tokenLabelName(tokenType2)
              }]);
            }
            case "smart":
              return tokenType2 === 27;
            default:
              throw this.raise(Errors.PipeTopicRequiresHackPipes, {
                at: startLoc
              });
          }
        }
        parseAsyncArrowUnaryFunction(node) {
          this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
          const params = [this.parseIdentifier()];
          this.prodParam.exit();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.LineTerminatorBeforeArrow, {
              at: this.state.curPosition()
            });
          }
          this.expect(19);
          return this.parseArrowExpression(node, params, true);
        }
        parseDo(node, isAsync) {
          this.expectPlugin("doExpressions");
          if (isAsync) {
            this.expectPlugin("asyncDoExpressions");
          }
          node.async = isAsync;
          this.next();
          const oldLabels = this.state.labels;
          this.state.labels = [];
          if (isAsync) {
            this.prodParam.enter(PARAM_AWAIT);
            node.body = this.parseBlock();
            this.prodParam.exit();
          } else {
            node.body = this.parseBlock();
          }
          this.state.labels = oldLabels;
          return this.finishNode(node, "DoExpression");
        }
        parseSuper() {
          const node = this.startNode();
          this.next();
          if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.SuperNotAllowed, {
              at: node
            });
          } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.UnexpectedSuper, {
              at: node
            });
          }
          if (!this.match(10) && !this.match(0) && !this.match(16)) {
            this.raise(Errors.UnsupportedSuper, {
              at: node
            });
          }
          return this.finishNode(node, "Super");
        }
        parsePrivateName() {
          const node = this.startNode();
          const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
          const name41 = this.state.value;
          this.next();
          node.id = this.createIdentifier(id, name41);
          return this.finishNode(node, "PrivateName");
        }
        parseFunctionOrFunctionSent() {
          const node = this.startNode();
          this.next();
          if (this.prodParam.hasYield && this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
            this.next();
            if (this.match(102)) {
              this.expectPlugin("functionSent");
            } else if (!this.hasPlugin("functionSent")) {
              this.unexpected();
            }
            return this.parseMetaProperty(node, meta, "sent");
          }
          return this.parseFunction(node);
        }
        parseMetaProperty(node, meta, propertyName) {
          node.meta = meta;
          const containsEsc = this.state.containsEsc;
          node.property = this.parseIdentifier(true);
          if (node.property.name !== propertyName || containsEsc) {
            this.raise(Errors.UnsupportedMetaProperty, {
              at: node.property,
              target: meta.name,
              onlyValidPropertyName: propertyName
            });
          }
          return this.finishNode(node, "MetaProperty");
        }
        parseImportMetaProperty(node) {
          const id = this.createIdentifier(this.startNodeAtNode(node), "import");
          this.next();
          if (this.isContextual(100)) {
            if (!this.inModule) {
              this.raise(Errors.ImportMetaOutsideModule, {
                at: id
              });
            }
            this.sawUnambiguousESM = true;
          }
          return this.parseMetaProperty(node, id, "meta");
        }
        parseLiteralAtNode(value, type, node) {
          this.addExtra(node, "rawValue", value);
          this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
          node.value = value;
          this.next();
          return this.finishNode(node, type);
        }
        parseLiteral(value, type) {
          const node = this.startNode();
          return this.parseLiteralAtNode(value, type, node);
        }
        parseStringLiteral(value) {
          return this.parseLiteral(value, "StringLiteral");
        }
        parseNumericLiteral(value) {
          return this.parseLiteral(value, "NumericLiteral");
        }
        parseBigIntLiteral(value) {
          return this.parseLiteral(value, "BigIntLiteral");
        }
        parseDecimalLiteral(value) {
          return this.parseLiteral(value, "DecimalLiteral");
        }
        parseRegExpLiteral(value) {
          const node = this.parseLiteral(value.value, "RegExpLiteral");
          node.pattern = value.pattern;
          node.flags = value.flags;
          return node;
        }
        parseBooleanLiteral(value) {
          const node = this.startNode();
          node.value = value;
          this.next();
          return this.finishNode(node, "BooleanLiteral");
        }
        parseNullLiteral() {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          const startLoc = this.state.startLoc;
          let val;
          this.next();
          this.expressionScope.enter(newArrowHeadScope());
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.maybeInArrowParameters = true;
          this.state.inFSharpPipelineDirectBody = false;
          const innerStartLoc = this.state.startLoc;
          const exprList = [];
          const refExpressionErrors = new ExpressionErrors();
          let first = true;
          let spreadStartLoc;
          let optionalCommaStartLoc;
          while (!this.match(11)) {
            if (first) {
              first = false;
            } else {
              this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
              if (this.match(11)) {
                optionalCommaStartLoc = this.state.startLoc;
                break;
              }
            }
            if (this.match(21)) {
              const spreadNodeStartLoc = this.state.startLoc;
              spreadStartLoc = this.state.startLoc;
              exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
              if (!this.checkCommaAfterRest(41)) {
                break;
              }
            } else {
              exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
            }
          }
          const innerEndLoc = this.state.lastTokEndLoc;
          this.expect(11);
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let arrowNode = this.startNodeAt(startLoc);
          if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(arrowNode, exprList, false);
            return arrowNode;
          }
          this.expressionScope.exit();
          if (!exprList.length) {
            this.unexpected(this.state.lastTokStartLoc);
          }
          if (optionalCommaStartLoc)
            this.unexpected(optionalCommaStartLoc);
          if (spreadStartLoc)
            this.unexpected(spreadStartLoc);
          this.checkExpressionErrors(refExpressionErrors, true);
          this.toReferencedListDeep(exprList, true);
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartLoc);
            val.expressions = exprList;
            this.finishNode(val, "SequenceExpression");
            this.resetEndLocation(val, innerEndLoc);
          } else {
            val = exprList[0];
          }
          return this.wrapParenthesis(startLoc, val);
        }
        wrapParenthesis(startLoc, expression) {
          if (!this.options.createParenthesizedExpressions) {
            this.addExtra(expression, "parenthesized", true);
            this.addExtra(expression, "parenStart", startLoc.index);
            this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
            return expression;
          }
          const parenExpression = this.startNodeAt(startLoc);
          parenExpression.expression = expression;
          return this.finishNode(parenExpression, "ParenthesizedExpression");
        }
        shouldParseArrow(params) {
          return !this.canInsertSemicolon();
        }
        parseArrow(node) {
          if (this.eat(19)) {
            return node;
          }
        }
        parseParenItem(node, startLoc) {
          return node;
        }
        parseNewOrNewTarget() {
          const node = this.startNode();
          this.next();
          if (this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
            this.next();
            const metaProp = this.parseMetaProperty(node, meta, "target");
            if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
              this.raise(Errors.UnexpectedNewTarget, {
                at: metaProp
              });
            }
            return metaProp;
          }
          return this.parseNew(node);
        }
        parseNew(node) {
          this.parseNewCallee(node);
          if (this.eat(10)) {
            const args = this.parseExprList(11);
            this.toReferencedList(args);
            node.arguments = args;
          } else {
            node.arguments = [];
          }
          return this.finishNode(node, "NewExpression");
        }
        parseNewCallee(node) {
          var _node$callee$extra;
          node.callee = this.parseNoCallExpr();
          if (node.callee.type === "Import") {
            this.raise(Errors.ImportCallNotNewExpression, {
              at: node.callee
            });
          } else if (this.isOptionalChain(node.callee) && !((_node$callee$extra = node.callee.extra) != null && _node$callee$extra.parenthesized)) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.lastTokEndLoc
            });
          } else if (this.eat(18)) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.startLoc
            });
          }
        }
        parseTemplateElement(isTagged) {
          const {
            start,
            startLoc,
            end,
            value
          } = this.state;
          const elemStart = start + 1;
          const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
          if (value === null) {
            if (!isTagged) {
              this.raise(Errors.InvalidEscapeSequenceTemplate, {
                at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
              });
            }
          }
          const isTail = this.match(24);
          const endOffset = isTail ? -1 : -2;
          const elemEnd = end + endOffset;
          elem.value = {
            raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
            cooked: value === null ? null : value.slice(1, endOffset)
          };
          elem.tail = isTail;
          this.next();
          const finishedNode = this.finishNode(elem, "TemplateElement");
          this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
          return finishedNode;
        }
        parseTemplate(isTagged) {
          const node = this.startNode();
          node.expressions = [];
          let curElt = this.parseTemplateElement(isTagged);
          node.quasis = [curElt];
          while (!curElt.tail) {
            node.expressions.push(this.parseTemplateSubstitution());
            this.readTemplateContinuation();
            node.quasis.push(curElt = this.parseTemplateElement(isTagged));
          }
          return this.finishNode(node, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
          if (isRecord) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const propHash = /* @__PURE__ */ Object.create(null);
          let first = true;
          const node = this.startNode();
          node.properties = [];
          this.next();
          while (!this.match(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                this.addTrailingCommaExtraToNode(node);
                break;
              }
            }
            let prop;
            if (isPattern) {
              prop = this.parseBindingProperty();
            } else {
              prop = this.parsePropertyDefinition(refExpressionErrors);
              this.checkProto(prop, isRecord, propHash, refExpressionErrors);
            }
            if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
              this.raise(Errors.InvalidRecordProperty, {
                at: prop
              });
            }
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
            node.properties.push(prop);
          }
          this.next();
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let type = "ObjectExpression";
          if (isPattern) {
            type = "ObjectPattern";
          } else if (isRecord) {
            type = "RecordExpression";
          }
          return this.finishNode(node, type);
        }
        addTrailingCommaExtraToNode(node) {
          this.addExtra(node, "trailingComma", this.state.lastTokStart);
          this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
        }
        maybeAsyncOrAccessorProp(prop) {
          return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
        }
        parsePropertyDefinition(refExpressionErrors) {
          let decorators = [];
          if (this.match(26)) {
            if (this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedPropertyDecorator, {
                at: this.state.startLoc
              });
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
          }
          const prop = this.startNode();
          let isAsync = false;
          let isAccessor = false;
          let startLoc;
          if (this.match(21)) {
            if (decorators.length)
              this.unexpected();
            return this.parseSpread();
          }
          if (decorators.length) {
            prop.decorators = decorators;
            decorators = [];
          }
          prop.method = false;
          if (refExpressionErrors) {
            startLoc = this.state.startLoc;
          }
          let isGenerator = this.eat(55);
          this.parsePropertyNamePrefixOperator(prop);
          const containsEsc = this.state.containsEsc;
          const key = this.parsePropertyName(prop, refExpressionErrors);
          if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const keyName = key.name;
            if (keyName === "async" && !this.hasPrecedingLineBreak()) {
              isAsync = true;
              this.resetPreviousNodeTrailingComments(key);
              isGenerator = this.eat(55);
              this.parsePropertyName(prop);
            }
            if (keyName === "get" || keyName === "set") {
              isAccessor = true;
              this.resetPreviousNodeTrailingComments(key);
              prop.kind = keyName;
              if (this.match(55)) {
                isGenerator = true;
                this.raise(Errors.AccessorIsGenerator, {
                  at: this.state.curPosition(),
                  kind: keyName
                });
                this.next();
              }
              this.parsePropertyName(prop);
            }
          }
          return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
        }
        getGetterSetterExpectedParamCount(method) {
          return method.kind === "get" ? 0 : 1;
        }
        getObjectOrClassMethodParams(method) {
          return method.params;
        }
        checkGetterSetterParams(method) {
          var _params;
          const paramCount = this.getGetterSetterExpectedParamCount(method);
          const params = this.getObjectOrClassMethodParams(method);
          if (params.length !== paramCount) {
            this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: method
            });
          }
          if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
            this.raise(Errors.BadSetterRestParameter, {
              at: method
            });
          }
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          if (isAccessor) {
            const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
            this.checkGetterSetterParams(finishedProp);
            return finishedProp;
          }
          if (isAsync || isGenerator || this.match(10)) {
            if (isPattern)
              this.unexpected();
            prop.kind = "method";
            prop.method = true;
            return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
          }
        }
        parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
          prop.shorthand = false;
          if (this.eat(14)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
            return this.finishNode(prop, "ObjectProperty");
          }
          if (!prop.computed && prop.key.type === "Identifier") {
            this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
            } else if (this.match(29)) {
              const shorthandAssignLoc = this.state.startLoc;
              if (refExpressionErrors != null) {
                if (refExpressionErrors.shorthandAssignLoc === null) {
                  refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                }
              } else {
                this.raise(Errors.InvalidCoverInitializedName, {
                  at: shorthandAssignLoc
                });
              }
              prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
            } else {
              prop.value = cloneIdentifier(prop.key);
            }
            prop.shorthand = true;
            return this.finishNode(prop, "ObjectProperty");
          }
        }
        parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
          if (!node)
            this.unexpected();
          return node;
        }
        parsePropertyName(prop, refExpressionErrors) {
          if (this.eat(0)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssignAllowIn();
            this.expect(3);
          } else {
            const {
              type,
              value
            } = this.state;
            let key;
            if (tokenIsKeywordOrIdentifier(type)) {
              key = this.parseIdentifier(true);
            } else {
              switch (type) {
                case 132:
                  key = this.parseNumericLiteral(value);
                  break;
                case 131:
                  key = this.parseStringLiteral(value);
                  break;
                case 133:
                  key = this.parseBigIntLiteral(value);
                  break;
                case 134:
                  key = this.parseDecimalLiteral(value);
                  break;
                case 136: {
                  const privateKeyLoc = this.state.startLoc;
                  if (refExpressionErrors != null) {
                    if (refExpressionErrors.privateKeyLoc === null) {
                      refExpressionErrors.privateKeyLoc = privateKeyLoc;
                    }
                  } else {
                    this.raise(Errors.UnexpectedPrivateField, {
                      at: privateKeyLoc
                    });
                  }
                  key = this.parsePrivateName();
                  break;
                }
                default:
                  throw this.unexpected();
              }
            }
            prop.key = key;
            if (type !== 136) {
              prop.computed = false;
            }
          }
          return prop.key;
        }
        initFunction(node, isAsync) {
          node.id = null;
          node.generator = false;
          node.async = isAsync;
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
          this.initFunction(node, isAsync);
          node.generator = isGenerator;
          const allowModifiers = isConstructor;
          this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
          this.prodParam.enter(functionFlags(isAsync, node.generator));
          this.parseFunctionParams(node, allowModifiers);
          const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
          this.prodParam.exit();
          this.scope.exit();
          return finishedNode;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          if (isTuple) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const node = this.startNode();
          this.next();
          node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
        }
        parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          let flags = functionFlags(isAsync, false);
          if (!this.match(5) && this.prodParam.hasIn) {
            flags |= PARAM_IN;
          }
          this.prodParam.enter(flags);
          this.initFunction(node, isAsync);
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          if (params) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(node, params, trailingCommaLoc);
          }
          this.state.maybeInArrowParameters = false;
          this.parseFunctionBody(node, true);
          this.prodParam.exit();
          this.scope.exit();
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return this.finishNode(node, "ArrowFunctionExpression");
        }
        setArrowFunctionParameters(node, params, trailingCommaLoc) {
          this.toAssignableList(params, trailingCommaLoc, false);
          node.params = params;
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          this.parseFunctionBody(node, false, isMethod);
          return this.finishNode(node, type);
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
          const isExpression = allowExpression && !this.match(5);
          this.expressionScope.enter(newExpressionScope());
          if (isExpression) {
            node.body = this.parseMaybeAssign();
            this.checkParams(node, false, allowExpression, false);
          } else {
            const oldStrict = this.state.strict;
            const oldLabels = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
            node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
              const nonSimple = !this.isSimpleParamList(node.params);
              if (hasStrictModeDirective && nonSimple) {
                this.raise(Errors.IllegalLanguageModeDirective, {
                  at: (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node
                });
              }
              const strictModeChanged = !oldStrict && this.state.strict;
              this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
              if (this.state.strict && node.id) {
                this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);
              }
            });
            this.prodParam.exit();
            this.state.labels = oldLabels;
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(node) {
          return node.type === "Identifier";
        }
        isSimpleParamList(params) {
          for (let i = 0, len = params.length; i < len; i++) {
            if (!this.isSimpleParameter(params[i]))
              return false;
          }
          return true;
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
          const formalParameters = {
            type: "FormalParameters"
          };
          for (const param of node.params) {
            this.checkLVal(param, {
              in: formalParameters,
              binding: BIND_VAR,
              checkClashes,
              strictModeChanged
            });
          }
        }
        parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
          }
          return elts;
        }
        parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
          let elt;
          if (this.match(12)) {
            if (!allowEmpty) {
              this.raise(Errors.UnexpectedToken, {
                at: this.state.curPosition(),
                unexpected: ","
              });
            }
            elt = null;
          } else if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
          } else if (this.match(17)) {
            this.expectPlugin("partialApplication");
            if (!allowPlaceholder) {
              this.raise(Errors.UnexpectedArgumentPlaceholder, {
                at: this.state.startLoc
              });
            }
            const node = this.startNode();
            this.next();
            elt = this.finishNode(node, "ArgumentPlaceholder");
          } else {
            elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
          }
          return elt;
        }
        parseIdentifier(liberal) {
          const node = this.startNode();
          const name41 = this.parseIdentifierName(liberal);
          return this.createIdentifier(node, name41);
        }
        createIdentifier(node, name41) {
          node.name = name41;
          node.loc.identifierName = name41;
          return this.finishNode(node, "Identifier");
        }
        parseIdentifierName(liberal) {
          let name41;
          const {
            startLoc,
            type
          } = this.state;
          if (tokenIsKeywordOrIdentifier(type)) {
            name41 = this.state.value;
          } else {
            throw this.unexpected();
          }
          const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
          if (liberal) {
            if (tokenIsKeyword2) {
              this.replaceToken(130);
            }
          } else {
            this.checkReservedWord(name41, startLoc, tokenIsKeyword2, false);
          }
          this.next();
          return name41;
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word.length > 10) {
            return;
          }
          if (!canBeReservedWord(word)) {
            return;
          }
          if (word === "yield") {
            if (this.prodParam.hasYield) {
              this.raise(Errors.YieldBindingIdentifier, {
                at: startLoc
              });
              return;
            }
          } else if (word === "await") {
            if (this.prodParam.hasAwait) {
              this.raise(Errors.AwaitBindingIdentifier, {
                at: startLoc
              });
              return;
            }
            if (this.scope.inStaticBlock) {
              this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
                at: startLoc
              });
              return;
            }
            this.expressionScope.recordAsyncArrowParametersError({
              at: startLoc
            });
          } else if (word === "arguments") {
            if (this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(Errors.ArgumentsInClass, {
                at: startLoc
              });
              return;
            }
          }
          if (checkKeywords && isKeyword2(word)) {
            this.raise(Errors.UnexpectedKeyword, {
              at: startLoc,
              keyword: word
            });
            return;
          }
          const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
          if (reservedTest(word, this.inModule)) {
            this.raise(Errors.UnexpectedReservedWord, {
              at: startLoc,
              reservedWord: word
            });
          }
        }
        isAwaitAllowed() {
          if (this.prodParam.hasAwait)
            return true;
          if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
            return true;
          }
          return false;
        }
        parseAwait(startLoc) {
          const node = this.startNodeAt(startLoc);
          this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
            at: node
          });
          if (this.eat(55)) {
            this.raise(Errors.ObsoleteAwaitStar, {
              at: node
            });
          }
          if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
            if (this.isAmbiguousAwait()) {
              this.ambiguousScriptDifferentAst = true;
            } else {
              this.sawUnambiguousESM = true;
            }
          }
          if (!this.state.soloAwait) {
            node.argument = this.parseMaybeUnary(null, true);
          }
          return this.finishNode(node, "AwaitExpression");
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak())
            return true;
          const {
            type
          } = this.state;
          return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 101 && !this.state.containsEsc || type === 135 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
        }
        parseYield() {
          const node = this.startNode();
          this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
            at: node
          });
          this.next();
          let delegating = false;
          let argument = null;
          if (!this.hasPrecedingLineBreak()) {
            delegating = this.eat(55);
            switch (this.state.type) {
              case 13:
              case 137:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!delegating)
                  break;
              default:
                argument = this.parseMaybeAssign();
            }
          }
          node.delegate = delegating;
          node.argument = argument;
          return this.finishNode(node, "YieldExpression");
        }
        checkPipelineAtInfixOperator(left, leftStartLoc) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            if (left.type === "SequenceExpression") {
              this.raise(Errors.PipelineHeadSequenceExpression, {
                at: leftStartLoc
              });
            }
          }
        }
        parseSmartPipelineBodyInStyle(childExpr, startLoc) {
          if (this.isSimpleReference(childExpr)) {
            const bodyNode = this.startNodeAt(startLoc);
            bodyNode.callee = childExpr;
            return this.finishNode(bodyNode, "PipelineBareFunction");
          } else {
            const bodyNode = this.startNodeAt(startLoc);
            this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
            bodyNode.expression = childExpr;
            return this.finishNode(bodyNode, "PipelineTopicExpression");
          }
        }
        isSimpleReference(expression) {
          switch (expression.type) {
            case "MemberExpression":
              return !expression.computed && this.isSimpleReference(expression.object);
            case "Identifier":
              return true;
            default:
              return false;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(startLoc) {
          if (this.match(19)) {
            throw this.raise(Errors.PipelineBodyNoArrow, {
              at: this.state.startLoc
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipelineTopicUnused, {
              at: startLoc
            });
          }
        }
        withTopicBindingContext(callback) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        }
        withSmartMixTopicForbiddingContext(callback) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null
            };
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          } else {
            return callback();
          }
        }
        withSoloAwaitPermittingContext(callback) {
          const outerContextSoloAwaitState = this.state.soloAwait;
          this.state.soloAwait = true;
          try {
            return callback();
          } finally {
            this.state.soloAwait = outerContextSoloAwaitState;
          }
        }
        allowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToSet = PARAM_IN & ~flags;
          if (prodParamToSet) {
            this.prodParam.enter(flags | PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        disallowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToClear = PARAM_IN & flags;
          if (prodParamToClear) {
            this.prodParam.enter(flags & ~PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(prec) {
          const startLoc = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = true;
          const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return ret;
        }
        parseModuleExpression() {
          this.expectPlugin("moduleBlocks");
          const node = this.startNode();
          this.next();
          if (!this.match(5)) {
            this.unexpected(null, 5);
          }
          const program2 = this.startNodeAt(this.state.endLoc);
          this.next();
          const revertScopes = this.initializeScopes(true);
          this.enterInitialScopes();
          try {
            node.body = this.parseProgram(program2, 8, "module");
          } finally {
            revertScopes();
          }
          return this.finishNode(node, "ModuleExpression");
        }
        parsePropertyNamePrefixOperator(prop) {
        }
      };
      var loopLabel = {
        kind: "loop"
      };
      var switchLabel = {
        kind: "switch"
      };
      var ParseFunctionFlag = {
        Expression: 0,
        Declaration: 1,
        HangingDeclaration: 2,
        NullableId: 4,
        Async: 8
      };
      var ParseStatementFlag = {
        StatementOnly: 0,
        AllowImportExport: 1,
        AllowDeclaration: 2,
        AllowFunctionDeclaration: 4,
        AllowLabeledFunction: 8
      };
      var loneSurrogate = /[\uD800-\uDFFF]/u;
      var keywordRelationalOperator = /in(?:stanceof)?/y;
      function babel7CompatTokens(tokens, input) {
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          const {
            type
          } = token;
          if (typeof type === "number") {
            {
              if (type === 136) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const hashEndPos = start + 1;
                const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                tokens.splice(i, 1, new Token({
                  type: getExportedToken(27),
                  value: "#",
                  start,
                  end: hashEndPos,
                  startLoc: loc.start,
                  endLoc: hashEndLoc
                }), new Token({
                  type: getExportedToken(130),
                  value,
                  start: hashEndPos,
                  end,
                  startLoc: hashEndLoc,
                  endLoc: loc.end
                }));
                i++;
                continue;
              }
              if (tokenIsTemplate(type)) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const backquoteEnd = start + 1;
                const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
                let startToken;
                if (input.charCodeAt(start) === 96) {
                  startToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                } else {
                  startToken = new Token({
                    type: getExportedToken(8),
                    value: "}",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                }
                let templateValue, templateElementEnd, templateElementEndLoc, endToken;
                if (type === 24) {
                  templateElementEnd = end - 1;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                  templateValue = value === null ? null : value.slice(1, -1);
                  endToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                } else {
                  templateElementEnd = end - 2;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                  templateValue = value === null ? null : value.slice(1, -2);
                  endToken = new Token({
                    type: getExportedToken(23),
                    value: "${",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                }
                tokens.splice(i, 1, startToken, new Token({
                  type: getExportedToken(20),
                  value: templateValue,
                  start: backquoteEnd,
                  end: templateElementEnd,
                  startLoc: backquoteEndLoc,
                  endLoc: templateElementEndLoc
                }), endToken);
                i += 2;
                continue;
              }
            }
            token.type = getExportedToken(type);
          }
        }
        return tokens;
      }
      var StatementParser = class extends ExpressionParser {
        parseTopLevel(file, program2) {
          file.program = this.parseProgram(program2);
          file.comments = this.state.comments;
          if (this.options.tokens) {
            file.tokens = babel7CompatTokens(this.tokens, this.input);
          }
          return this.finishNode(file, "File");
        }
        parseProgram(program2, end = 137, sourceType = this.options.sourceType) {
          program2.sourceType = sourceType;
          program2.interpreter = this.parseInterpreterDirective();
          this.parseBlockBody(program2, true, true, end);
          if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
            for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, {
                at,
                localName
              });
            }
          }
          let finishedProgram;
          if (end === 137) {
            finishedProgram = this.finishNode(program2, "Program");
          } else {
            finishedProgram = this.finishNodeAt(program2, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
          }
          return finishedProgram;
        }
        stmtToDirective(stmt) {
          const directive = stmt;
          directive.type = "Directive";
          directive.value = directive.expression;
          delete directive.expression;
          const directiveLiteral = directive.value;
          const expressionValue = directiveLiteral.value;
          const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
          const val = directiveLiteral.value = raw.slice(1, -1);
          this.addExtra(directiveLiteral, "raw", raw);
          this.addExtra(directiveLiteral, "rawValue", val);
          this.addExtra(directiveLiteral, "expressionValue", expressionValue);
          directiveLiteral.type = "DirectiveLiteral";
          return directive;
        }
        parseInterpreterDirective() {
          if (!this.match(28)) {
            return null;
          }
          const node = this.startNode();
          node.value = this.state.value;
          this.next();
          return this.finishNode(node, "InterpreterDirective");
        }
        isLet() {
          if (!this.isContextual(99)) {
            return false;
          }
          return this.hasFollowingBindingAtom();
        }
        chStartsBindingIdentifier(ch, pos) {
          if (isIdentifierStart2(ch)) {
            keywordRelationalOperator.lastIndex = pos;
            if (keywordRelationalOperator.test(this.input)) {
              const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
              if (!isIdentifierChar(endCh) && endCh !== 92) {
                return false;
              }
            }
            return true;
          } else if (ch === 92) {
            return true;
          } else {
            return false;
          }
        }
        chStartsBindingPattern(ch) {
          return ch === 91 || ch === 123;
        }
        hasFollowingBindingAtom() {
          const next = this.nextTokenStart();
          const nextCh = this.codePointAtPos(next);
          return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
        }
        hasFollowingBindingIdentifier() {
          const next = this.nextTokenStart();
          const nextCh = this.codePointAtPos(next);
          return this.chStartsBindingIdentifier(nextCh, next);
        }
        startsUsingForOf() {
          const lookahead = this.lookahead();
          if (lookahead.type === 101 && !lookahead.containsEsc) {
            return false;
          } else {
            this.expectPlugin("explicitResourceManagement");
            return true;
          }
        }
        parseModuleItem() {
          return this.parseStatementLike(ParseStatementFlag.AllowImportExport | ParseStatementFlag.AllowDeclaration | ParseStatementFlag.AllowFunctionDeclaration | ParseStatementFlag.AllowLabeledFunction);
        }
        parseStatementListItem() {
          return this.parseStatementLike(ParseStatementFlag.AllowDeclaration | ParseStatementFlag.AllowFunctionDeclaration | ParseStatementFlag.AllowLabeledFunction);
        }
        parseStatementOrFunctionDeclaration(disallowLabeledFunction) {
          return this.parseStatementLike(ParseStatementFlag.AllowFunctionDeclaration | (disallowLabeledFunction ? 0 : ParseStatementFlag.AllowLabeledFunction));
        }
        parseStatement() {
          return this.parseStatementLike(ParseStatementFlag.StatementOnly);
        }
        parseStatementLike(flags) {
          let decorators = null;
          if (this.match(26)) {
            decorators = this.parseDecorators(true);
          }
          return this.parseStatementContent(flags, decorators);
        }
        parseStatementContent(flags, decorators) {
          const starttype = this.state.type;
          const node = this.startNode();
          const allowDeclaration = !!(flags & ParseStatementFlag.AllowDeclaration);
          const allowFunctionDeclaration = !!(flags & ParseStatementFlag.AllowFunctionDeclaration);
          const topLevel = flags & ParseStatementFlag.AllowImportExport;
          switch (starttype) {
            case 60:
              return this.parseBreakContinueStatement(node, true);
            case 63:
              return this.parseBreakContinueStatement(node, false);
            case 64:
              return this.parseDebuggerStatement(node);
            case 90:
              return this.parseDoWhileStatement(node);
            case 91:
              return this.parseForStatement(node);
            case 68:
              if (this.lookaheadCharCode() === 46)
                break;
              if (!allowDeclaration) {
                if (this.state.strict) {
                  this.raise(Errors.StrictFunction, {
                    at: this.state.startLoc
                  });
                } else if (!allowFunctionDeclaration) {
                  this.raise(Errors.SloppyFunction, {
                    at: this.state.startLoc
                  });
                }
              }
              return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
            case 80:
              if (!allowDeclaration)
                this.unexpected();
              return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
            case 69:
              return this.parseIfStatement(node);
            case 70:
              return this.parseReturnStatement(node);
            case 71:
              return this.parseSwitchStatement(node);
            case 72:
              return this.parseThrowStatement(node);
            case 73:
              return this.parseTryStatement(node);
            case 105:
              if (this.hasFollowingLineBreak() || this.state.containsEsc || !this.hasFollowingBindingIdentifier()) {
                break;
              }
              this.expectPlugin("explicitResourceManagement");
              if (!this.scope.inModule && this.scope.inTopLevel) {
                this.raise(Errors.UnexpectedUsingDeclaration, {
                  at: this.state.startLoc
                });
              } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, {
                  at: this.state.startLoc
                });
              }
              return this.parseVarStatement(node, "using");
            case 99: {
              if (this.state.containsEsc) {
                break;
              }
              const next = this.nextTokenStart();
              const nextCh = this.codePointAtPos(next);
              if (nextCh !== 91) {
                if (!allowDeclaration && this.hasFollowingLineBreak())
                  break;
                if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                  break;
                }
              }
            }
            case 75: {
              if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, {
                  at: this.state.startLoc
                });
              }
            }
            case 74: {
              const kind = this.state.value;
              return this.parseVarStatement(node, kind);
            }
            case 92:
              return this.parseWhileStatement(node);
            case 76:
              return this.parseWithStatement(node);
            case 5:
              return this.parseBlock();
            case 13:
              return this.parseEmptyStatement(node);
            case 83: {
              const nextTokenCharCode = this.lookaheadCharCode();
              if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }
            }
            case 82: {
              if (!this.options.allowImportExportEverywhere && !topLevel) {
                this.raise(Errors.UnexpectedImportExport, {
                  at: this.state.startLoc
                });
              }
              this.next();
              let result;
              if (starttype === 83) {
                result = this.parseImport(node);
                if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                  this.sawUnambiguousESM = true;
                }
              } else {
                result = this.parseExport(node, decorators);
                if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                  this.sawUnambiguousESM = true;
                }
              }
              this.assertModuleNodeAllowed(result);
              return result;
            }
            default: {
              if (this.isAsyncFunction()) {
                if (!allowDeclaration) {
                  this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                    at: this.state.startLoc
                  });
                }
                this.next();
                return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
              }
            }
          }
          const maybeName = this.state.value;
          const expr = this.parseExpression();
          if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
            return this.parseLabeledStatement(node, maybeName, expr, flags);
          } else {
            return this.parseExpressionStatement(node, expr, decorators);
          }
        }
        assertModuleNodeAllowed(node) {
          if (!this.options.allowImportExportEverywhere && !this.inModule) {
            this.raise(Errors.ImportOutsideModule, {
              at: node
            });
          }
        }
        decoratorsEnabledBeforeExport() {
          if (this.hasPlugin("decorators-legacy"))
            return true;
          return this.hasPlugin("decorators") && !!this.getPluginOption("decorators", "decoratorsBeforeExport");
        }
        maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
          if (maybeDecorators) {
            classNode.decorators = maybeDecorators;
            this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
            if (exportNode)
              this.resetStartLocationFromNode(exportNode, classNode);
          }
          return classNode;
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(allowExport) {
          const decorators = [];
          do {
            decorators.push(this.parseDecorator());
          } while (this.match(26));
          if (this.match(82)) {
            if (!allowExport) {
              this.unexpected();
            }
            if (!this.decoratorsEnabledBeforeExport()) {
              this.raise(Errors.DecoratorExportClass, {
                at: this.state.startLoc
              });
            }
          } else if (!this.canHaveLeadingDecorator()) {
            throw this.raise(Errors.UnexpectedLeadingDecorator, {
              at: this.state.startLoc
            });
          }
          return decorators;
        }
        parseDecorator() {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          const node = this.startNode();
          this.next();
          if (this.hasPlugin("decorators")) {
            const startLoc = this.state.startLoc;
            let expr;
            if (this.match(10)) {
              const startLoc2 = this.state.startLoc;
              this.next();
              expr = this.parseExpression();
              this.expect(11);
              expr = this.wrapParenthesis(startLoc2, expr);
              const paramsStartLoc = this.state.startLoc;
              node.expression = this.parseMaybeDecoratorArguments(expr);
              if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
                this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
                  at: paramsStartLoc
                });
              }
            } else {
              expr = this.parseIdentifier(false);
              while (this.eat(16)) {
                const node2 = this.startNodeAt(startLoc);
                node2.object = expr;
                if (this.match(136)) {
                  this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                  node2.property = this.parsePrivateName();
                } else {
                  node2.property = this.parseIdentifier(true);
                }
                node2.computed = false;
                expr = this.finishNode(node2, "MemberExpression");
              }
              node.expression = this.parseMaybeDecoratorArguments(expr);
            }
          } else {
            node.expression = this.parseExprSubscripts();
          }
          return this.finishNode(node, "Decorator");
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.eat(10)) {
            const node = this.startNodeAtNode(expr);
            node.callee = expr;
            node.arguments = this.parseCallExpressionArguments(11, false);
            this.toReferencedList(node.arguments);
            return this.finishNode(node, "CallExpression");
          }
          return expr;
        }
        parseBreakContinueStatement(node, isBreak) {
          this.next();
          if (this.isLineTerminator()) {
            node.label = null;
          } else {
            node.label = this.parseIdentifier();
            this.semicolon();
          }
          this.verifyBreakContinue(node, isBreak);
          return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        }
        verifyBreakContinue(node, isBreak) {
          let i;
          for (i = 0; i < this.state.labels.length; ++i) {
            const lab = this.state.labels[i];
            if (node.label == null || lab.name === node.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop"))
                break;
              if (node.label && isBreak)
                break;
            }
          }
          if (i === this.state.labels.length) {
            const type = isBreak ? "BreakStatement" : "ContinueStatement";
            this.raise(Errors.IllegalBreakContinue, {
              at: node,
              type
            });
          }
        }
        parseDebuggerStatement(node) {
          this.next();
          this.semicolon();
          return this.finishNode(node, "DebuggerStatement");
        }
        parseHeaderExpression() {
          this.expect(10);
          const val = this.parseExpression();
          this.expect(11);
          return val;
        }
        parseDoWhileStatement(node) {
          this.next();
          this.state.labels.push(loopLabel);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
          this.state.labels.pop();
          this.expect(92);
          node.test = this.parseHeaderExpression();
          this.eat(13);
          return this.finishNode(node, "DoWhileStatement");
        }
        parseForStatement(node) {
          this.next();
          this.state.labels.push(loopLabel);
          let awaitAt = null;
          if (this.isAwaitAllowed() && this.eatContextual(96)) {
            awaitAt = this.state.lastTokStartLoc;
          }
          this.scope.enter(SCOPE_OTHER);
          this.expect(10);
          if (this.match(13)) {
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, null);
          }
          const startsWithLet = this.isContextual(99);
          const startsWithUsing = this.isContextual(105) && !this.hasFollowingLineBreak();
          const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || startsWithUsing && this.hasFollowingBindingIdentifier() && this.startsUsingForOf();
          if (this.match(74) || this.match(75) || isLetOrUsing) {
            const initNode = this.startNode();
            const kind = this.state.value;
            this.next();
            this.parseVar(initNode, true, kind);
            const init2 = this.finishNode(initNode, "VariableDeclaration");
            const isForIn = this.match(58);
            if (isForIn && startsWithUsing) {
              this.raise(Errors.ForInUsing, {
                at: init2
              });
            }
            if ((isForIn || this.isContextual(101)) && init2.declarations.length === 1) {
              return this.parseForIn(node, init2, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init2);
          }
          const startsWithAsync = this.isContextual(95);
          const refExpressionErrors = new ExpressionErrors();
          const init = this.parseExpression(true, refExpressionErrors);
          const isForOf = this.isContextual(101);
          if (isForOf) {
            if (startsWithLet) {
              this.raise(Errors.ForOfLet, {
                at: init
              });
            }
            if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
              this.raise(Errors.ForOfAsync, {
                at: init
              });
            }
          }
          if (isForOf || this.match(58)) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.toAssignable(init, true);
            const type = isForOf ? "ForOfStatement" : "ForInStatement";
            this.checkLVal(init, {
              in: {
                type
              }
            });
            return this.parseForIn(node, init, awaitAt);
          } else {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init);
        }
        parseFunctionStatement(node, isAsync, isHangingDeclaration) {
          this.next();
          return this.parseFunction(node, ParseFunctionFlag.Declaration | (isHangingDeclaration ? ParseFunctionFlag.HangingDeclaration : 0) | (isAsync ? ParseFunctionFlag.Async : 0));
        }
        parseIfStatement(node) {
          this.next();
          node.test = this.parseHeaderExpression();
          node.consequent = this.parseStatementOrFunctionDeclaration(true);
          node.alternate = this.eat(66) ? this.parseStatementOrFunctionDeclaration(true) : null;
          return this.finishNode(node, "IfStatement");
        }
        parseReturnStatement(node) {
          if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
            this.raise(Errors.IllegalReturn, {
              at: this.state.startLoc
            });
          }
          this.next();
          if (this.isLineTerminator()) {
            node.argument = null;
          } else {
            node.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(node, "ReturnStatement");
        }
        parseSwitchStatement(node) {
          this.next();
          node.discriminant = this.parseHeaderExpression();
          const cases = node.cases = [];
          this.expect(5);
          this.state.labels.push(switchLabel);
          this.scope.enter(SCOPE_OTHER);
          let cur;
          for (let sawDefault; !this.match(8); ) {
            if (this.match(61) || this.match(65)) {
              const isCase = this.match(61);
              if (cur)
                this.finishNode(cur, "SwitchCase");
              cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                if (sawDefault) {
                  this.raise(Errors.MultipleDefaultsInSwitch, {
                    at: this.state.lastTokStartLoc
                  });
                }
                sawDefault = true;
                cur.test = null;
              }
              this.expect(14);
            } else {
              if (cur) {
                cur.consequent.push(this.parseStatementListItem());
              } else {
                this.unexpected();
              }
            }
          }
          this.scope.exit();
          if (cur)
            this.finishNode(cur, "SwitchCase");
          this.next();
          this.state.labels.pop();
          return this.finishNode(node, "SwitchStatement");
        }
        parseThrowStatement(node) {
          this.next();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.NewlineAfterThrow, {
              at: this.state.lastTokEndLoc
            });
          }
          node.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node, "ThrowStatement");
        }
        parseCatchClauseParam() {
          const param = this.parseBindingAtom();
          const simple = param.type === "Identifier";
          this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(param, {
            in: {
              type: "CatchClause"
            },
            binding: BIND_CATCH_PARAM
          });
          return param;
        }
        parseTryStatement(node) {
          this.next();
          node.block = this.parseBlock();
          node.handler = null;
          if (this.match(62)) {
            const clause = this.startNode();
            this.next();
            if (this.match(10)) {
              this.expect(10);
              clause.param = this.parseCatchClauseParam();
              this.expect(11);
            } else {
              clause.param = null;
              this.scope.enter(SCOPE_OTHER);
            }
            clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
            this.scope.exit();
            node.handler = this.finishNode(clause, "CatchClause");
          }
          node.finalizer = this.eat(67) ? this.parseBlock() : null;
          if (!node.handler && !node.finalizer) {
            this.raise(Errors.NoCatchOrFinally, {
              at: node
            });
          }
          return this.finishNode(node, "TryStatement");
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
          this.next();
          this.parseVar(node, false, kind, allowMissingInitializer);
          this.semicolon();
          return this.finishNode(node, "VariableDeclaration");
        }
        parseWhileStatement(node) {
          this.next();
          node.test = this.parseHeaderExpression();
          this.state.labels.push(loopLabel);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
          this.state.labels.pop();
          return this.finishNode(node, "WhileStatement");
        }
        parseWithStatement(node) {
          if (this.state.strict) {
            this.raise(Errors.StrictWith, {
              at: this.state.startLoc
            });
          }
          this.next();
          node.object = this.parseHeaderExpression();
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
          return this.finishNode(node, "WithStatement");
        }
        parseEmptyStatement(node) {
          this.next();
          return this.finishNode(node, "EmptyStatement");
        }
        parseLabeledStatement(node, maybeName, expr, flags) {
          for (const label of this.state.labels) {
            if (label.name === maybeName) {
              this.raise(Errors.LabelRedeclaration, {
                at: expr,
                labelName: maybeName
              });
            }
          }
          const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
          for (let i = this.state.labels.length - 1; i >= 0; i--) {
            const label = this.state.labels[i];
            if (label.statementStart === node.start) {
              label.statementStart = this.state.start;
              label.kind = kind;
            } else {
              break;
            }
          }
          this.state.labels.push({
            name: maybeName,
            kind,
            statementStart: this.state.start
          });
          node.body = flags & ParseStatementFlag.AllowLabeledFunction ? this.parseStatementOrFunctionDeclaration(false) : this.parseStatement();
          this.state.labels.pop();
          node.label = expr;
          return this.finishNode(node, "LabeledStatement");
        }
        parseExpressionStatement(node, expr, decorators) {
          node.expression = expr;
          this.semicolon();
          return this.finishNode(node, "ExpressionStatement");
        }
        parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
          const node = this.startNode();
          if (allowDirectives) {
            this.state.strictErrors.clear();
          }
          this.expect(5);
          if (createNewLexicalScope) {
            this.scope.enter(SCOPE_OTHER);
          }
          this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
          if (createNewLexicalScope) {
            this.scope.exit();
          }
          return this.finishNode(node, "BlockStatement");
        }
        isValidDirective(stmt) {
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          const body = node.body = [];
          const directives = node.directives = [];
          this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
        }
        parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
          const oldStrict = this.state.strict;
          let hasStrictModeDirective = false;
          let parsedNonDirective = false;
          while (!this.match(end)) {
            const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
            if (directives && !parsedNonDirective) {
              if (this.isValidDirective(stmt)) {
                const directive = this.stmtToDirective(stmt);
                directives.push(directive);
                if (!hasStrictModeDirective && directive.value.value === "use strict") {
                  hasStrictModeDirective = true;
                  this.setStrict(true);
                }
                continue;
              }
              parsedNonDirective = true;
              this.state.strictErrors.clear();
            }
            body.push(stmt);
          }
          if (afterBlockParse) {
            afterBlockParse.call(this, hasStrictModeDirective);
          }
          if (!oldStrict) {
            this.setStrict(false);
          }
          this.next();
        }
        parseFor(node, init) {
          node.init = init;
          this.semicolon(false);
          node.test = this.match(13) ? null : this.parseExpression();
          this.semicolon(false);
          node.update = this.match(11) ? null : this.parseExpression();
          this.expect(11);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node, "ForStatement");
        }
        parseForIn(node, init, awaitAt) {
          const isForIn = this.match(58);
          this.next();
          if (isForIn) {
            if (awaitAt !== null)
              this.unexpected(awaitAt);
          } else {
            node.await = awaitAt !== null;
          }
          if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
            this.raise(Errors.ForInOfLoopInitializer, {
              at: init,
              type: isForIn ? "ForInStatement" : "ForOfStatement"
            });
          }
          if (init.type === "AssignmentPattern") {
            this.raise(Errors.InvalidLhs, {
              at: init,
              ancestor: {
                type: "ForStatement"
              }
            });
          }
          node.left = init;
          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
          this.expect(11);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
        }
        parseVar(node, isFor, kind, allowMissingInitializer = false) {
          const declarations = node.declarations = [];
          node.kind = kind;
          for (; ; ) {
            const decl = this.startNode();
            this.parseVarId(decl, kind);
            decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
            if (decl.init === null && !allowMissingInitializer) {
              if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "destructuring"
                });
              } else if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "const"
                });
              }
            }
            declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(12))
              break;
          }
          return node;
        }
        parseVarId(decl, kind) {
          if (kind === "using" && !this.inModule && this.match(96)) {
            this.raise(Errors.AwaitInUsingBinding, {
              at: this.state.startLoc
            });
          }
          const id = this.parseBindingAtom();
          this.checkLVal(id, {
            in: {
              type: "VariableDeclarator"
            },
            binding: kind === "var" ? BIND_VAR : BIND_LEXICAL
          });
          decl.id = id;
        }
        parseAsyncFunctionExpression(node) {
          return this.parseFunction(node, ParseFunctionFlag.Async);
        }
        parseFunction(node, flags = ParseFunctionFlag.Expression) {
          const hangingDeclaration = flags & ParseFunctionFlag.HangingDeclaration;
          const isDeclaration = !!(flags & ParseFunctionFlag.Declaration);
          const requireId = isDeclaration && !(flags & ParseFunctionFlag.NullableId);
          const isAsync = !!(flags & ParseFunctionFlag.Async);
          this.initFunction(node, isAsync);
          if (this.match(55)) {
            if (hangingDeclaration) {
              this.raise(Errors.GeneratorInSingleStatementContext, {
                at: this.state.startLoc
              });
            }
            this.next();
            node.generator = true;
          }
          if (isDeclaration) {
            node.id = this.parseFunctionId(requireId);
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = false;
          this.scope.enter(SCOPE_FUNCTION);
          this.prodParam.enter(functionFlags(isAsync, node.generator));
          if (!isDeclaration) {
            node.id = this.parseFunctionId();
          }
          this.parseFunctionParams(node, false);
          this.withSmartMixTopicForbiddingContext(() => {
            this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
          });
          this.prodParam.exit();
          this.scope.exit();
          if (isDeclaration && !hangingDeclaration) {
            this.registerFunctionStatementId(node);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return node;
        }
        parseFunctionId(requireId) {
          return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(node, allowModifiers) {
          this.expect(10);
          this.expressionScope.enter(newParameterDeclarationScope());
          node.params = this.parseBindingList(11, 41, false, allowModifiers);
          this.expressionScope.exit();
        }
        registerFunctionStatementId(node) {
          if (!node.id)
            return;
          this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);
        }
        parseClass(node, isStatement, optionalId) {
          this.next();
          const oldStrict = this.state.strict;
          this.state.strict = true;
          this.parseClassId(node, isStatement, optionalId);
          this.parseClassSuper(node);
          node.body = this.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(method) {
          return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
        }
        parseClassBody(hadSuperClass, oldStrict) {
          this.classScope.enter();
          const state = {
            hadConstructor: false,
            hadSuperClass
          };
          let decorators = [];
          const classBody = this.startNode();
          classBody.body = [];
          this.expect(5);
          this.withSmartMixTopicForbiddingContext(() => {
            while (!this.match(8)) {
              if (this.eat(13)) {
                if (decorators.length > 0) {
                  throw this.raise(Errors.DecoratorSemicolon, {
                    at: this.state.lastTokEndLoc
                  });
                }
                continue;
              }
              if (this.match(26)) {
                decorators.push(this.parseDecorator());
                continue;
              }
              const member = this.startNode();
              if (decorators.length) {
                member.decorators = decorators;
                this.resetStartLocationFromNode(member, decorators[0]);
                decorators = [];
              }
              this.parseClassMember(classBody, member, state);
              if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                this.raise(Errors.DecoratorConstructor, {
                  at: member
                });
              }
            }
          });
          this.state.strict = oldStrict;
          this.next();
          if (decorators.length) {
            throw this.raise(Errors.TrailingDecorator, {
              at: this.state.startLoc
            });
          }
          this.classScope.exit();
          return this.finishNode(classBody, "ClassBody");
        }
        parseClassMemberFromModifier(classBody, member) {
          const key = this.parseIdentifier(true);
          if (this.isClassMethod()) {
            const method = member;
            method.kind = "method";
            method.computed = false;
            method.key = key;
            method.static = false;
            this.pushClassMethod(classBody, method, false, false, false, false);
            return true;
          } else if (this.isClassProperty()) {
            const prop = member;
            prop.computed = false;
            prop.key = key;
            prop.static = false;
            classBody.body.push(this.parseClassProperty(prop));
            return true;
          }
          this.resetPreviousNodeTrailingComments(key);
          return false;
        }
        parseClassMember(classBody, member, state) {
          const isStatic = this.isContextual(104);
          if (isStatic) {
            if (this.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            if (this.eat(5)) {
              this.parseClassStaticBlock(classBody, member);
              return;
            }
          }
          this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const publicMethod = member;
          const privateMethod = member;
          const publicProp = member;
          const privateProp = member;
          const accessorProp = member;
          const method = publicMethod;
          const publicMember = publicMethod;
          member.static = isStatic;
          this.parsePropertyNamePrefixOperator(member);
          if (this.eat(55)) {
            method.kind = "method";
            const isPrivateName = this.match(136);
            this.parseClassElementName(method);
            if (isPrivateName) {
              this.pushClassPrivateMethod(classBody, privateMethod, true, false);
              return;
            }
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsGenerator, {
                at: publicMethod.key
              });
            }
            this.pushClassMethod(classBody, publicMethod, true, false, false, false);
            return;
          }
          const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
          const isPrivate = this.match(136);
          const key = this.parseClassElementName(member);
          const maybeQuestionTokenStartLoc = this.state.startLoc;
          this.parsePostMemberNameModifiers(publicMember);
          if (this.isClassMethod()) {
            method.kind = "method";
            if (isPrivate) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
              return;
            }
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = false;
            if (isConstructor) {
              publicMethod.kind = "constructor";
              if (state.hadConstructor && !this.hasPlugin("typescript")) {
                this.raise(Errors.DuplicateConstructor, {
                  at: key
                });
              }
              if (isConstructor && this.hasPlugin("typescript") && member.override) {
                this.raise(Errors.OverrideOnConstructor, {
                  at: key
                });
              }
              state.hadConstructor = true;
              allowsDirectSuper = state.hadSuperClass;
            }
            this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
          } else if (this.isClassProperty()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(55);
            if (publicMember.optional) {
              this.unexpected(maybeQuestionTokenStartLoc);
            }
            method.kind = "method";
            const isPrivate2 = this.match(136);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(publicMember);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAsync, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
            }
          } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(key);
            method.kind = key.name;
            const isPrivate2 = this.match(136);
            this.parseClassElementName(publicMethod);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAccessor, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, false, false, false, false);
            }
            this.checkGetterSetterParams(publicMethod);
          } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
            this.expectPlugin("decoratorAutoAccessors");
            this.resetPreviousNodeTrailingComments(key);
            const isPrivate2 = this.match(136);
            this.parseClassElementName(publicProp);
            this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
          } else if (this.isLineTerminator()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else {
            this.unexpected();
          }
        }
        parseClassElementName(member) {
          const {
            type,
            value
          } = this.state;
          if ((type === 130 || type === 131) && member.static && value === "prototype") {
            this.raise(Errors.StaticPrototype, {
              at: this.state.startLoc
            });
          }
          if (type === 136) {
            if (value === "constructor") {
              this.raise(Errors.ConstructorClassPrivateField, {
                at: this.state.startLoc
              });
            }
            const key = this.parsePrivateName();
            member.key = key;
            return key;
          }
          return this.parsePropertyName(member);
        }
        parseClassStaticBlock(classBody, member) {
          var _member$decorators;
          this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(PARAM);
          const body = member.body = [];
          this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
          this.prodParam.exit();
          this.scope.exit();
          this.state.labels = oldLabels;
          classBody.body.push(this.finishNode(member, "StaticBlock"));
          if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
            this.raise(Errors.DecoratorStaticBlock, {
              at: member
            });
          }
        }
        pushClassProperty(classBody, prop) {
          if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
            this.raise(Errors.ConstructorClassField, {
              at: prop.key
            });
          }
          classBody.body.push(this.parseClassProperty(prop));
        }
        pushClassPrivateProperty(classBody, prop) {
          const node = this.parseClassPrivateProperty(prop);
          classBody.body.push(node);
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
        }
        pushClassAccessorProperty(classBody, prop, isPrivate) {
          if (!isPrivate && !prop.computed) {
            const key = prop.key;
            if (key.name === "constructor" || key.value === "constructor") {
              this.raise(Errors.ConstructorClassField, {
                at: key
              });
            }
          }
          const node = this.parseClassAccessorProperty(prop);
          classBody.body.push(node);
          if (isPrivate) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
          }
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
          classBody.body.push(node);
          const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
          this.declareClassPrivateMethodInScope(node, kind);
        }
        declareClassPrivateMethodInScope(node, kind) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
        }
        parsePostMemberNameModifiers(methodOrProp) {
        }
        parseClassPrivateProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassPrivateProperty");
        }
        parseClassProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassProperty");
        }
        parseClassAccessorProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassAccessorProperty");
        }
        parseInitializer(node) {
          this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
          this.expressionScope.enter(newExpressionScope());
          this.prodParam.enter(PARAM);
          node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
          this.expressionScope.exit();
          this.prodParam.exit();
          this.scope.exit();
        }
        parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            if (isStatement) {
              this.declareNameFromIdentifier(node.id, bindingType);
            }
          } else {
            if (optionalId || !isStatement) {
              node.id = null;
            } else {
              throw this.raise(Errors.MissingClassName, {
                at: this.state.startLoc
              });
            }
          }
        }
        parseClassSuper(node) {
          node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(node, decorators) {
          const hasDefault = this.maybeParseExportDefaultSpecifier(node);
          const parseAfterDefault = !hasDefault || this.eat(12);
          const hasStar = parseAfterDefault && this.eatExportStar(node);
          const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
          const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
          const isFromRequired = hasDefault || hasStar;
          if (hasStar && !hasNamespace) {
            if (hasDefault)
              this.unexpected();
            if (decorators) {
              throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
              });
            }
            this.parseExportFrom(node, true);
            return this.finishNode(node, "ExportAllDeclaration");
          }
          const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
          if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
            throw this.unexpected(null, 5);
          }
          if (hasNamespace && parseAfterNamespace) {
            throw this.unexpected(null, 97);
          }
          let hasDeclaration;
          if (isFromRequired || hasSpecifiers) {
            hasDeclaration = false;
            if (decorators) {
              throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
              });
            }
            this.parseExportFrom(node, isFromRequired);
          } else {
            hasDeclaration = this.maybeParseExportDeclaration(node);
          }
          if (isFromRequired || hasSpecifiers || hasDeclaration) {
            var _node2$declaration;
            const node2 = node;
            this.checkExport(node2, true, false, !!node2.source);
            if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
              this.maybeTakeDecorators(decorators, node2.declaration, node2);
            } else if (decorators) {
              throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
              });
            }
            return this.finishNode(node2, "ExportNamedDeclaration");
          }
          if (this.eat(65)) {
            const node2 = node;
            const decl = this.parseExportDefaultExpression();
            node2.declaration = decl;
            if (decl.type === "ClassDeclaration") {
              this.maybeTakeDecorators(decorators, decl, node2);
            } else if (decorators) {
              throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
              });
            }
            this.checkExport(node2, true, true);
            return this.finishNode(node2, "ExportDefaultDeclaration");
          }
          throw this.unexpected(null, 5);
        }
        eatExportStar(node) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(node) {
          if (this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            specifier.exported = this.parseIdentifier(true);
            node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
          if (this.isContextual(93)) {
            if (!node.specifiers)
              node.specifiers = [];
            const specifier = this.startNodeAt(this.state.lastTokStartLoc);
            this.next();
            specifier.exported = this.parseModuleExportName();
            node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
            return true;
          }
          return false;
        }
        maybeParseExportNamedSpecifiers(node) {
          if (this.match(5)) {
            if (!node.specifiers)
              node.specifiers = [];
            const isTypeExport = node.exportKind === "type";
            node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
            node.source = null;
            node.declaration = null;
            if (this.hasPlugin("importAssertions")) {
              node.assertions = [];
            }
            return true;
          }
          return false;
        }
        maybeParseExportDeclaration(node) {
          if (this.shouldParseExportDeclaration()) {
            node.specifiers = [];
            node.source = null;
            if (this.hasPlugin("importAssertions")) {
              node.assertions = [];
            }
            node.declaration = this.parseExportDeclaration(node);
            return true;
          }
          return false;
        }
        isAsyncFunction() {
          if (!this.isContextual(95))
            return false;
          const next = this.nextTokenStart();
          return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
        }
        parseExportDefaultExpression() {
          const expr = this.startNode();
          if (this.match(68)) {
            this.next();
            return this.parseFunction(expr, ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId);
          } else if (this.isAsyncFunction()) {
            this.next();
            this.next();
            return this.parseFunction(expr, ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId | ParseFunctionFlag.Async);
          }
          if (this.match(80)) {
            return this.parseClass(expr, true, true);
          }
          if (this.match(26)) {
            if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.raise(Errors.DecoratorBeforeExport, {
                at: this.state.startLoc
              });
            }
            return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
          }
          if (this.match(75) || this.match(74) || this.isLet()) {
            throw this.raise(Errors.UnsupportedDefaultExport, {
              at: this.state.startLoc
            });
          }
          const res = this.parseMaybeAssignAllowIn();
          this.semicolon();
          return res;
        }
        parseExportDeclaration(node) {
          if (this.match(80)) {
            const node2 = this.parseClass(this.startNode(), true, false);
            return node2;
          }
          return this.parseStatementListItem();
        }
        isExportDefaultSpecifier() {
          const {
            type
          } = this.state;
          if (tokenIsIdentifier(type)) {
            if (type === 95 && !this.state.containsEsc || type === 99) {
              return false;
            }
            if ((type === 128 || type === 127) && !this.state.containsEsc) {
              const {
                type: nextType
              } = this.lookahead();
              if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {
                this.expectOnePlugin(["flow", "typescript"]);
                return false;
              }
            }
          } else if (!this.match(65)) {
            return false;
          }
          const next = this.nextTokenStart();
          const hasFrom = this.isUnparsedContextual(next, "from");
          if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
            return true;
          }
          if (this.match(65) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
            return nextAfterFrom === 34 || nextAfterFrom === 39;
          }
          return false;
        }
        parseExportFrom(node, expect) {
          if (this.eatContextual(97)) {
            node.source = this.parseImportSource();
            this.checkExport(node);
            const assertions = this.maybeParseImportAssertions();
            if (assertions) {
              node.assertions = assertions;
              this.checkJSONModuleImport(node);
            }
          } else if (expect) {
            this.unexpected();
          }
          this.semicolon();
        }
        shouldParseExportDeclaration() {
          const {
            type
          } = this.state;
          if (type === 26) {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            if (this.hasPlugin("decorators")) {
              if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                throw this.raise(Errors.DecoratorBeforeExport, {
                  at: this.state.startLoc
                });
              }
              return true;
            }
          }
          return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
        }
        checkExport(node, checkNames, isDefault, isFrom) {
          if (checkNames) {
            if (isDefault) {
              this.checkDuplicateExports(node, "default");
              if (this.hasPlugin("exportDefaultFrom")) {
                var _declaration$extra;
                const declaration = node.declaration;
                if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                  this.raise(Errors.ExportDefaultFromAsIdentifier, {
                    at: declaration
                  });
                }
              }
            } else if (node.specifiers && node.specifiers.length) {
              for (const specifier of node.specifiers) {
                const {
                  exported
                } = specifier;
                const exportName = exported.type === "Identifier" ? exported.name : exported.value;
                this.checkDuplicateExports(specifier, exportName);
                if (!isFrom && specifier.local) {
                  const {
                    local
                  } = specifier;
                  if (local.type !== "Identifier") {
                    this.raise(Errors.ExportBindingIsString, {
                      at: specifier,
                      localName: local.value,
                      exportName
                    });
                  } else {
                    this.checkReservedWord(local.name, local.loc.start, true, false);
                    this.scope.checkLocalExport(local);
                  }
                }
              }
            } else if (node.declaration) {
              if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
                const id = node.declaration.id;
                if (!id)
                  throw new Error("Assertion failure");
                this.checkDuplicateExports(node, id.name);
              } else if (node.declaration.type === "VariableDeclaration") {
                for (const declaration of node.declaration.declarations) {
                  this.checkDeclaration(declaration.id);
                }
              }
            }
          }
        }
        checkDeclaration(node) {
          if (node.type === "Identifier") {
            this.checkDuplicateExports(node, node.name);
          } else if (node.type === "ObjectPattern") {
            for (const prop of node.properties) {
              this.checkDeclaration(prop);
            }
          } else if (node.type === "ArrayPattern") {
            for (const elem of node.elements) {
              if (elem) {
                this.checkDeclaration(elem);
              }
            }
          } else if (node.type === "ObjectProperty") {
            this.checkDeclaration(node.value);
          } else if (node.type === "RestElement") {
            this.checkDeclaration(node.argument);
          } else if (node.type === "AssignmentPattern") {
            this.checkDeclaration(node.left);
          }
        }
        checkDuplicateExports(node, exportName) {
          if (this.exportedIdentifiers.has(exportName)) {
            if (exportName === "default") {
              this.raise(Errors.DuplicateDefaultExport, {
                at: node
              });
            } else {
              this.raise(Errors.DuplicateExport, {
                at: node,
                exportName
              });
            }
          }
          this.exportedIdentifiers.add(exportName);
        }
        parseExportSpecifiers(isInTypeExport) {
          const nodes = [];
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.eat(8))
                break;
            }
            const isMaybeTypeOnly = this.isContextual(128);
            const isString = this.match(131);
            const node = this.startNode();
            node.local = this.parseModuleExportName();
            nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
          }
          return nodes;
        }
        parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) {
            node.exported = this.parseModuleExportName();
          } else if (isString) {
            node.exported = cloneStringLiteral(node.local);
          } else if (!node.exported) {
            node.exported = cloneIdentifier(node.local);
          }
          return this.finishNode(node, "ExportSpecifier");
        }
        parseModuleExportName() {
          if (this.match(131)) {
            const result = this.parseStringLiteral(this.state.value);
            const surrogate = result.value.match(loneSurrogate);
            if (surrogate) {
              this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
                at: result,
                surrogateCharCode: surrogate[0].charCodeAt(0)
              });
            }
            return result;
          }
          return this.parseIdentifier(true);
        }
        isJSONModuleImport(node) {
          if (node.assertions != null) {
            return node.assertions.some(({
              key,
              value
            }) => {
              return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
            });
          }
          return false;
        }
        checkImportReflection(node) {
          if (node.module) {
            var _node$assertions;
            if (node.specifiers.length !== 1 || node.specifiers[0].type !== "ImportDefaultSpecifier") {
              this.raise(Errors.ImportReflectionNotBinding, {
                at: node.specifiers[0].loc.start
              });
            }
            if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
              this.raise(Errors.ImportReflectionHasAssertion, {
                at: node.specifiers[0].loc.start
              });
            }
          }
        }
        checkJSONModuleImport(node) {
          if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
            const {
              specifiers
            } = node;
            if (specifiers != null) {
              const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
                let imported;
                if (specifier.type === "ExportSpecifier") {
                  imported = specifier.local;
                } else if (specifier.type === "ImportSpecifier") {
                  imported = specifier.imported;
                }
                if (imported !== void 0) {
                  return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
                }
              });
              if (nonDefaultNamedSpecifier !== void 0) {
                this.raise(Errors.ImportJSONBindingNotDefault, {
                  at: nonDefaultNamedSpecifier.loc.start
                });
              }
            }
          }
        }
        parseMaybeImportReflection(node) {
          let isImportReflection = false;
          if (this.isContextual(125)) {
            const lookahead = this.lookahead();
            const nextType = lookahead.type;
            if (tokenIsIdentifier(nextType)) {
              if (nextType !== 97) {
                isImportReflection = true;
              } else {
                const nextNextTokenFirstChar = this.input.charCodeAt(this.nextTokenStartSince(lookahead.end));
                if (nextNextTokenFirstChar === 102) {
                  isImportReflection = true;
                }
              }
            } else if (nextType !== 12) {
              isImportReflection = true;
            }
          }
          if (isImportReflection) {
            this.expectPlugin("importReflection");
            this.next();
            node.module = true;
          } else if (this.hasPlugin("importReflection")) {
            node.module = false;
          }
        }
        parseImport(node) {
          node.specifiers = [];
          if (!this.match(131)) {
            this.parseMaybeImportReflection(node);
            const hasDefault = this.maybeParseDefaultImportSpecifier(node);
            const parseNext = !hasDefault || this.eat(12);
            const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
            if (parseNext && !hasStar)
              this.parseNamedImportSpecifiers(node);
            this.expectContextual(97);
          }
          node.source = this.parseImportSource();
          const assertions = this.maybeParseImportAssertions();
          if (assertions) {
            node.assertions = assertions;
          } else {
            const attributes = this.maybeParseModuleAttributes();
            if (attributes) {
              node.attributes = attributes;
            }
          }
          this.checkImportReflection(node);
          this.checkJSONModuleImport(node);
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          if (!this.match(131))
            this.unexpected();
          return this.parseExprAtom();
        }
        shouldParseDefaultImport(node) {
          return tokenIsIdentifier(this.state.type);
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        finishImportSpecifier(specifier, type, bindingType = BIND_LEXICAL) {
          this.checkLVal(specifier.local, {
            in: {
              type
            },
            binding: bindingType
          });
          return this.finishNode(specifier, type);
        }
        parseAssertEntries() {
          const attrs = [];
          const attrNames = /* @__PURE__ */ new Set();
          do {
            if (this.match(8)) {
              break;
            }
            const node = this.startNode();
            const keyName = this.state.value;
            if (attrNames.has(keyName)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: this.state.startLoc,
                key: keyName
              });
            }
            attrNames.add(keyName);
            if (this.match(131)) {
              node.key = this.parseStringLiteral(keyName);
            } else {
              node.key = this.parseIdentifier(true);
            }
            this.expect(14);
            if (!this.match(131)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, "ImportAttribute"));
          } while (this.eat(12));
          return attrs;
        }
        maybeParseModuleAttributes() {
          if (this.match(76) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("moduleAttributes");
            this.next();
          } else {
            if (this.hasPlugin("moduleAttributes"))
              return [];
            return null;
          }
          const attrs = [];
          const attributes = /* @__PURE__ */ new Set();
          do {
            const node = this.startNode();
            node.key = this.parseIdentifier(true);
            if (node.key.name !== "type") {
              this.raise(Errors.ModuleAttributeDifferentFromType, {
                at: node.key
              });
            }
            if (attributes.has(node.key.name)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: node.key,
                key: node.key.name
              });
            }
            attributes.add(node.key.name);
            this.expect(14);
            if (!this.match(131)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node.value = this.parseStringLiteral(this.state.value);
            this.finishNode(node, "ImportAttribute");
            attrs.push(node);
          } while (this.eat(12));
          return attrs;
        }
        maybeParseImportAssertions() {
          if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("importAssertions");
            this.next();
          } else {
            if (this.hasPlugin("importAssertions"))
              return [];
            return null;
          }
          this.eat(5);
          const attrs = this.parseAssertEntries();
          this.eat(8);
          return attrs;
        }
        maybeParseDefaultImportSpecifier(node) {
          if (this.shouldParseDefaultImport(node)) {
            this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
            return true;
          }
          return false;
        }
        maybeParseStarImportSpecifier(node) {
          if (this.match(55)) {
            const specifier = this.startNode();
            this.next();
            this.expectContextual(93);
            this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
            return true;
          }
          return false;
        }
        parseNamedImportSpecifiers(node) {
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              if (this.eat(14)) {
                throw this.raise(Errors.DestructureNamedImport, {
                  at: this.state.startLoc
                });
              }
              this.expect(12);
              if (this.eat(8))
                break;
            }
            const specifier = this.startNode();
            const importedIsString = this.match(131);
            const isMaybeTypeOnly = this.isContextual(128);
            specifier.imported = this.parseModuleExportName();
            const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
            node.specifiers.push(importSpecifier);
          }
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            const {
              imported
            } = specifier;
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, {
                at: specifier,
                importName: imported.value
              });
            }
            this.checkReservedWord(imported.name, specifier.loc.start, true, true);
            if (!specifier.local) {
              specifier.local = cloneIdentifier(imported);
            }
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
        }
        isThisParam(param) {
          return param.type === "Identifier" && param.name === "this";
        }
      };
      var Parser = class extends StatementParser {
        constructor(options, input) {
          options = getOptions(options);
          super(options, input);
          this.options = options;
          this.initializeScopes();
          this.plugins = pluginsMap(this.options.plugins);
          this.filename = options.sourceFilename;
        }
        getScopeHandler() {
          return ScopeHandler;
        }
        parse() {
          this.enterInitialScopes();
          const file = this.startNode();
          const program2 = this.startNode();
          this.nextToken();
          file.errors = null;
          this.parseTopLevel(file, program2);
          file.errors = this.state.errors;
          return file;
        }
      };
      function pluginsMap(plugins) {
        const pluginMap = /* @__PURE__ */ new Map();
        for (const plugin of plugins) {
          const [name41, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
          if (!pluginMap.has(name41))
            pluginMap.set(name41, options || {});
        }
        return pluginMap;
      }
      function parse44(input, options) {
        var _options;
        if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
          options = Object.assign({}, options);
          try {
            options.sourceType = "module";
            const parser = getParser(options, input);
            const ast = parser.parse();
            if (parser.sawUnambiguousESM) {
              return ast;
            }
            if (parser.ambiguousScriptDifferentAst) {
              try {
                options.sourceType = "script";
                return getParser(options, input).parse();
              } catch (_unused) {
              }
            } else {
              ast.program.sourceType = "script";
            }
            return ast;
          } catch (moduleError) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused2) {
            }
            throw moduleError;
          }
        } else {
          return getParser(options, input).parse();
        }
      }
      function parseExpression(input, options) {
        const parser = getParser(options, input);
        if (parser.options.strictMode) {
          parser.state.strict = true;
        }
        return parser.getExpression();
      }
      function generateExportedTokenTypes(internalTokenTypes) {
        const tokenTypes2 = {};
        for (const typeName of Object.keys(internalTokenTypes)) {
          tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
        }
        return tokenTypes2;
      }
      var tokTypes = generateExportedTokenTypes(tt);
      function getParser(options, input) {
        let cls = Parser;
        if (options != null && options.plugins) {
          validatePlugins(options.plugins);
          cls = getParserClass(options.plugins);
        }
        return new cls(options, input);
      }
      var parserClassCache = {};
      function getParserClass(pluginsFromOptions) {
        const pluginList = mixinPluginNames.filter((name41) => hasPlugin(pluginsFromOptions, name41));
        const key = pluginList.join("/");
        let cls = parserClassCache[key];
        if (!cls) {
          cls = Parser;
          for (const plugin of pluginList) {
            cls = mixinPlugins[plugin](cls);
          }
          parserClassCache[key] = cls;
        }
        return cls;
      }
      exports.parse = parse44;
      exports.parseExpression = parseExpression;
      exports.tokTypes = tokTypes;
    }
  });

  // node_modules/@babel/types/lib/utils/shallowEqual.js
  var require_shallowEqual = __commonJS({
    "node_modules/@babel/types/lib/utils/shallowEqual.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = shallowEqual;
      function shallowEqual(actual, expected) {
        const keys = Object.keys(expected);
        for (const key of keys) {
          if (actual[key] !== expected[key]) {
            return false;
          }
        }
        return true;
      }
    }
  });

  // node_modules/@babel/types/lib/validators/generated/index.js
  var require_generated = __commonJS({
    "node_modules/@babel/types/lib/validators/generated/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isAccessor = isAccessor;
      exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
      exports.isArgumentPlaceholder = isArgumentPlaceholder;
      exports.isArrayExpression = isArrayExpression2;
      exports.isArrayPattern = isArrayPattern;
      exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
      exports.isArrowFunctionExpression = isArrowFunctionExpression2;
      exports.isAssignmentExpression = isAssignmentExpression2;
      exports.isAssignmentPattern = isAssignmentPattern;
      exports.isAwaitExpression = isAwaitExpression;
      exports.isBigIntLiteral = isBigIntLiteral;
      exports.isBinary = isBinary;
      exports.isBinaryExpression = isBinaryExpression;
      exports.isBindExpression = isBindExpression;
      exports.isBlock = isBlock2;
      exports.isBlockParent = isBlockParent;
      exports.isBlockStatement = isBlockStatement;
      exports.isBooleanLiteral = isBooleanLiteral;
      exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
      exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
      exports.isBreakStatement = isBreakStatement;
      exports.isCallExpression = isCallExpression;
      exports.isCatchClause = isCatchClause;
      exports.isClass = isClass;
      exports.isClassAccessorProperty = isClassAccessorProperty;
      exports.isClassBody = isClassBody;
      exports.isClassDeclaration = isClassDeclaration;
      exports.isClassExpression = isClassExpression;
      exports.isClassImplements = isClassImplements;
      exports.isClassMethod = isClassMethod;
      exports.isClassPrivateMethod = isClassPrivateMethod;
      exports.isClassPrivateProperty = isClassPrivateProperty;
      exports.isClassProperty = isClassProperty;
      exports.isCompletionStatement = isCompletionStatement;
      exports.isConditional = isConditional;
      exports.isConditionalExpression = isConditionalExpression;
      exports.isContinueStatement = isContinueStatement;
      exports.isDebuggerStatement = isDebuggerStatement;
      exports.isDecimalLiteral = isDecimalLiteral;
      exports.isDeclaration = isDeclaration;
      exports.isDeclareClass = isDeclareClass;
      exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
      exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
      exports.isDeclareFunction = isDeclareFunction;
      exports.isDeclareInterface = isDeclareInterface;
      exports.isDeclareModule = isDeclareModule;
      exports.isDeclareModuleExports = isDeclareModuleExports;
      exports.isDeclareOpaqueType = isDeclareOpaqueType;
      exports.isDeclareTypeAlias = isDeclareTypeAlias;
      exports.isDeclareVariable = isDeclareVariable;
      exports.isDeclaredPredicate = isDeclaredPredicate;
      exports.isDecorator = isDecorator;
      exports.isDirective = isDirective;
      exports.isDirectiveLiteral = isDirectiveLiteral;
      exports.isDoExpression = isDoExpression;
      exports.isDoWhileStatement = isDoWhileStatement;
      exports.isEmptyStatement = isEmptyStatement;
      exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
      exports.isEnumBody = isEnumBody;
      exports.isEnumBooleanBody = isEnumBooleanBody;
      exports.isEnumBooleanMember = isEnumBooleanMember;
      exports.isEnumDeclaration = isEnumDeclaration;
      exports.isEnumDefaultedMember = isEnumDefaultedMember;
      exports.isEnumMember = isEnumMember;
      exports.isEnumNumberBody = isEnumNumberBody;
      exports.isEnumNumberMember = isEnumNumberMember;
      exports.isEnumStringBody = isEnumStringBody;
      exports.isEnumStringMember = isEnumStringMember;
      exports.isEnumSymbolBody = isEnumSymbolBody;
      exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
      exports.isExportAllDeclaration = isExportAllDeclaration;
      exports.isExportDeclaration = isExportDeclaration;
      exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
      exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
      exports.isExportNamedDeclaration = isExportNamedDeclaration;
      exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
      exports.isExportSpecifier = isExportSpecifier;
      exports.isExpression = isExpression;
      exports.isExpressionStatement = isExpressionStatement2;
      exports.isExpressionWrapper = isExpressionWrapper;
      exports.isFile = isFile;
      exports.isFlow = isFlow;
      exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
      exports.isFlowDeclaration = isFlowDeclaration;
      exports.isFlowPredicate = isFlowPredicate;
      exports.isFlowType = isFlowType;
      exports.isFor = isFor;
      exports.isForInStatement = isForInStatement;
      exports.isForOfStatement = isForOfStatement;
      exports.isForStatement = isForStatement;
      exports.isForXStatement = isForXStatement;
      exports.isFunction = isFunction;
      exports.isFunctionDeclaration = isFunctionDeclaration;
      exports.isFunctionExpression = isFunctionExpression;
      exports.isFunctionParent = isFunctionParent;
      exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
      exports.isFunctionTypeParam = isFunctionTypeParam;
      exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
      exports.isIdentifier = isIdentifier2;
      exports.isIfStatement = isIfStatement;
      exports.isImmutable = isImmutable;
      exports.isImport = isImport;
      exports.isImportAttribute = isImportAttribute;
      exports.isImportDeclaration = isImportDeclaration;
      exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
      exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
      exports.isImportSpecifier = isImportSpecifier;
      exports.isIndexedAccessType = isIndexedAccessType;
      exports.isInferredPredicate = isInferredPredicate;
      exports.isInterfaceDeclaration = isInterfaceDeclaration;
      exports.isInterfaceExtends = isInterfaceExtends;
      exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
      exports.isInterpreterDirective = isInterpreterDirective;
      exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
      exports.isJSX = isJSX;
      exports.isJSXAttribute = isJSXAttribute2;
      exports.isJSXClosingElement = isJSXClosingElement;
      exports.isJSXClosingFragment = isJSXClosingFragment;
      exports.isJSXElement = isJSXElement3;
      exports.isJSXEmptyExpression = isJSXEmptyExpression;
      exports.isJSXExpressionContainer = isJSXExpressionContainer2;
      exports.isJSXFragment = isJSXFragment;
      exports.isJSXIdentifier = isJSXIdentifier;
      exports.isJSXMemberExpression = isJSXMemberExpression;
      exports.isJSXNamespacedName = isJSXNamespacedName;
      exports.isJSXOpeningElement = isJSXOpeningElement;
      exports.isJSXOpeningFragment = isJSXOpeningFragment;
      exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
      exports.isJSXSpreadChild = isJSXSpreadChild;
      exports.isJSXText = isJSXText;
      exports.isLVal = isLVal;
      exports.isLabeledStatement = isLabeledStatement;
      exports.isLiteral = isLiteral;
      exports.isLogicalExpression = isLogicalExpression;
      exports.isLoop = isLoop;
      exports.isMemberExpression = isMemberExpression2;
      exports.isMetaProperty = isMetaProperty;
      exports.isMethod = isMethod;
      exports.isMiscellaneous = isMiscellaneous;
      exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
      exports.isModuleDeclaration = isModuleDeclaration;
      exports.isModuleExpression = isModuleExpression;
      exports.isModuleSpecifier = isModuleSpecifier;
      exports.isNewExpression = isNewExpression;
      exports.isNoop = isNoop;
      exports.isNullLiteral = isNullLiteral;
      exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
      exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
      exports.isNumberLiteral = isNumberLiteral;
      exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
      exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
      exports.isNumericLiteral = isNumericLiteral;
      exports.isObjectExpression = isObjectExpression;
      exports.isObjectMember = isObjectMember;
      exports.isObjectMethod = isObjectMethod;
      exports.isObjectPattern = isObjectPattern;
      exports.isObjectProperty = isObjectProperty;
      exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
      exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
      exports.isObjectTypeIndexer = isObjectTypeIndexer;
      exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
      exports.isObjectTypeProperty = isObjectTypeProperty;
      exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
      exports.isOpaqueType = isOpaqueType;
      exports.isOptionalCallExpression = isOptionalCallExpression;
      exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
      exports.isOptionalMemberExpression = isOptionalMemberExpression;
      exports.isParenthesizedExpression = isParenthesizedExpression;
      exports.isPattern = isPattern;
      exports.isPatternLike = isPatternLike;
      exports.isPipelineBareFunction = isPipelineBareFunction;
      exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
      exports.isPipelineTopicExpression = isPipelineTopicExpression;
      exports.isPlaceholder = isPlaceholder;
      exports.isPrivate = isPrivate;
      exports.isPrivateName = isPrivateName;
      exports.isProgram = isProgram2;
      exports.isProperty = isProperty2;
      exports.isPureish = isPureish;
      exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
      exports.isRecordExpression = isRecordExpression;
      exports.isRegExpLiteral = isRegExpLiteral;
      exports.isRegexLiteral = isRegexLiteral;
      exports.isRestElement = isRestElement;
      exports.isRestProperty = isRestProperty;
      exports.isReturnStatement = isReturnStatement;
      exports.isScopable = isScopable;
      exports.isSequenceExpression = isSequenceExpression2;
      exports.isSpreadElement = isSpreadElement;
      exports.isSpreadProperty = isSpreadProperty;
      exports.isStandardized = isStandardized;
      exports.isStatement = isStatement;
      exports.isStaticBlock = isStaticBlock;
      exports.isStringLiteral = isStringLiteral;
      exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
      exports.isStringTypeAnnotation = isStringTypeAnnotation;
      exports.isSuper = isSuper;
      exports.isSwitchCase = isSwitchCase;
      exports.isSwitchStatement = isSwitchStatement;
      exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
      exports.isTSAnyKeyword = isTSAnyKeyword;
      exports.isTSArrayType = isTSArrayType;
      exports.isTSAsExpression = isTSAsExpression;
      exports.isTSBaseType = isTSBaseType;
      exports.isTSBigIntKeyword = isTSBigIntKeyword;
      exports.isTSBooleanKeyword = isTSBooleanKeyword;
      exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
      exports.isTSConditionalType = isTSConditionalType;
      exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
      exports.isTSConstructorType = isTSConstructorType;
      exports.isTSDeclareFunction = isTSDeclareFunction;
      exports.isTSDeclareMethod = isTSDeclareMethod;
      exports.isTSEntityName = isTSEntityName;
      exports.isTSEnumDeclaration = isTSEnumDeclaration;
      exports.isTSEnumMember = isTSEnumMember;
      exports.isTSExportAssignment = isTSExportAssignment;
      exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
      exports.isTSExternalModuleReference = isTSExternalModuleReference;
      exports.isTSFunctionType = isTSFunctionType;
      exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
      exports.isTSImportType = isTSImportType;
      exports.isTSIndexSignature = isTSIndexSignature;
      exports.isTSIndexedAccessType = isTSIndexedAccessType;
      exports.isTSInferType = isTSInferType;
      exports.isTSInstantiationExpression = isTSInstantiationExpression;
      exports.isTSInterfaceBody = isTSInterfaceBody;
      exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
      exports.isTSIntersectionType = isTSIntersectionType;
      exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
      exports.isTSLiteralType = isTSLiteralType;
      exports.isTSMappedType = isTSMappedType;
      exports.isTSMethodSignature = isTSMethodSignature;
      exports.isTSModuleBlock = isTSModuleBlock;
      exports.isTSModuleDeclaration = isTSModuleDeclaration;
      exports.isTSNamedTupleMember = isTSNamedTupleMember;
      exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
      exports.isTSNeverKeyword = isTSNeverKeyword;
      exports.isTSNonNullExpression = isTSNonNullExpression;
      exports.isTSNullKeyword = isTSNullKeyword;
      exports.isTSNumberKeyword = isTSNumberKeyword;
      exports.isTSObjectKeyword = isTSObjectKeyword;
      exports.isTSOptionalType = isTSOptionalType;
      exports.isTSParameterProperty = isTSParameterProperty;
      exports.isTSParenthesizedType = isTSParenthesizedType;
      exports.isTSPropertySignature = isTSPropertySignature;
      exports.isTSQualifiedName = isTSQualifiedName;
      exports.isTSRestType = isTSRestType;
      exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
      exports.isTSStringKeyword = isTSStringKeyword;
      exports.isTSSymbolKeyword = isTSSymbolKeyword;
      exports.isTSThisType = isTSThisType;
      exports.isTSTupleType = isTSTupleType;
      exports.isTSType = isTSType;
      exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
      exports.isTSTypeAnnotation = isTSTypeAnnotation;
      exports.isTSTypeAssertion = isTSTypeAssertion;
      exports.isTSTypeElement = isTSTypeElement;
      exports.isTSTypeLiteral = isTSTypeLiteral;
      exports.isTSTypeOperator = isTSTypeOperator;
      exports.isTSTypeParameter = isTSTypeParameter;
      exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
      exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
      exports.isTSTypePredicate = isTSTypePredicate;
      exports.isTSTypeQuery = isTSTypeQuery;
      exports.isTSTypeReference = isTSTypeReference;
      exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
      exports.isTSUnionType = isTSUnionType;
      exports.isTSUnknownKeyword = isTSUnknownKeyword;
      exports.isTSVoidKeyword = isTSVoidKeyword;
      exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
      exports.isTemplateElement = isTemplateElement;
      exports.isTemplateLiteral = isTemplateLiteral;
      exports.isTerminatorless = isTerminatorless;
      exports.isThisExpression = isThisExpression;
      exports.isThisTypeAnnotation = isThisTypeAnnotation;
      exports.isThrowStatement = isThrowStatement;
      exports.isTopicReference = isTopicReference;
      exports.isTryStatement = isTryStatement;
      exports.isTupleExpression = isTupleExpression;
      exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
      exports.isTypeAlias = isTypeAlias;
      exports.isTypeAnnotation = isTypeAnnotation;
      exports.isTypeCastExpression = isTypeCastExpression;
      exports.isTypeParameter = isTypeParameter;
      exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
      exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
      exports.isTypeScript = isTypeScript;
      exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
      exports.isUnaryExpression = isUnaryExpression;
      exports.isUnaryLike = isUnaryLike;
      exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
      exports.isUpdateExpression = isUpdateExpression;
      exports.isUserWhitespacable = isUserWhitespacable;
      exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
      exports.isVariableDeclaration = isVariableDeclaration;
      exports.isVariableDeclarator = isVariableDeclarator;
      exports.isVariance = isVariance;
      exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
      exports.isWhile = isWhile;
      exports.isWhileStatement = isWhileStatement;
      exports.isWithStatement = isWithStatement;
      exports.isYieldExpression = isYieldExpression;
      var _shallowEqual = require_shallowEqual();
      function isArrayExpression2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ArrayExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isAssignmentExpression2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "AssignmentExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBinaryExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BinaryExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isInterpreterDirective(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "InterpreterDirective") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDirective(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Directive") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDirectiveLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DirectiveLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBlockStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BlockStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBreakStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BreakStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isCallExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "CallExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isCatchClause(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "CatchClause") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isConditionalExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ConditionalExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isContinueStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ContinueStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDebuggerStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DebuggerStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDoWhileStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DoWhileStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEmptyStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EmptyStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExpressionStatement2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExpressionStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFile(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "File") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isForInStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ForInStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isForStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ForStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunctionDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "FunctionDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunctionExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "FunctionExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isIdentifier2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Identifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isIfStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "IfStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isLabeledStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "LabeledStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStringLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "StringLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNumericLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NumericLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNullLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NullLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBooleanLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BooleanLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isRegExpLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "RegExpLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isLogicalExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "LogicalExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isMemberExpression2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "MemberExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNewExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NewExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isProgram2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Program") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectMethod(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectMethod") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isRestElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "RestElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isReturnStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ReturnStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSequenceExpression2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SequenceExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isParenthesizedExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ParenthesizedExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSwitchCase(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SwitchCase") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSwitchStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SwitchStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isThisExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ThisExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isThrowStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ThrowStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTryStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TryStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isUnaryExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "UnaryExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isUpdateExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "UpdateExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isVariableDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "VariableDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isVariableDeclarator(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "VariableDeclarator") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isWhileStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "WhileStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isWithStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "WithStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isAssignmentPattern(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "AssignmentPattern") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isArrayPattern(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ArrayPattern") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isArrowFunctionExpression2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ArrowFunctionExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportAllDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportAllDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportDefaultDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportDefaultDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportNamedDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportNamedDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isForOfStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ForOfStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImportDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ImportDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImportDefaultSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ImportDefaultSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImportNamespaceSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ImportNamespaceSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImportSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ImportSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isMetaProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "MetaProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassMethod(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassMethod") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectPattern(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectPattern") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSpreadElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SpreadElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSuper(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Super") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTaggedTemplateExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TaggedTemplateExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTemplateElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TemplateElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTemplateLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TemplateLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isYieldExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "YieldExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isAwaitExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "AwaitExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImport(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Import") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBigIntLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BigIntLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportNamespaceSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportNamespaceSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isOptionalMemberExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "OptionalMemberExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isOptionalCallExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "OptionalCallExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassAccessorProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassAccessorProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassPrivateProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassPrivateProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassPrivateMethod(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassPrivateMethod") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPrivateName(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "PrivateName") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStaticBlock(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "StaticBlock") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isAnyTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "AnyTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isArrayTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ArrayTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBooleanTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BooleanTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBooleanLiteralTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BooleanLiteralTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNullLiteralTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NullLiteralTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassImplements(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassImplements") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareClass(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareClass") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareFunction(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareFunction") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareInterface(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareInterface") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareModule(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareModule") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareModuleExports(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareModuleExports") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareTypeAlias(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareTypeAlias") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareOpaqueType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareOpaqueType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareVariable(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareVariable") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareExportDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareExportDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareExportAllDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareExportAllDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclaredPredicate(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclaredPredicate") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExistsTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExistsTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunctionTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "FunctionTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunctionTypeParam(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "FunctionTypeParam") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isGenericTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "GenericTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isInferredPredicate(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "InferredPredicate") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isInterfaceExtends(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "InterfaceExtends") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isInterfaceDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "InterfaceDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isInterfaceTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "InterfaceTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isIntersectionTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "IntersectionTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isMixedTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "MixedTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEmptyTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EmptyTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNullableTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NullableTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNumberLiteralTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NumberLiteralTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNumberTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NumberTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeInternalSlot(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeInternalSlot") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeCallProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeCallProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeIndexer(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeIndexer") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeSpreadProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeSpreadProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isOpaqueType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "OpaqueType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isQualifiedTypeIdentifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "QualifiedTypeIdentifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStringLiteralTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "StringLiteralTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStringTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "StringTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSymbolTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SymbolTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isThisTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ThisTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTupleTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TupleTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeofTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeofTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeAlias(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeAlias") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeCastExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeCastExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeParameter(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeParameter") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeParameterDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeParameterDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeParameterInstantiation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeParameterInstantiation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isUnionTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "UnionTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isVariance(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Variance") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isVoidTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "VoidTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumBooleanBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumBooleanBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumNumberBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumNumberBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumStringBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumStringBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumSymbolBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumSymbolBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumBooleanMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumBooleanMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumNumberMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumNumberMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumStringMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumStringMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumDefaultedMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumDefaultedMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isIndexedAccessType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "IndexedAccessType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isOptionalIndexedAccessType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "OptionalIndexedAccessType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXAttribute2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXAttribute") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXClosingElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXClosingElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXElement3(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXEmptyExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXEmptyExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXExpressionContainer2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXExpressionContainer") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXSpreadChild(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXSpreadChild") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXIdentifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXIdentifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXMemberExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXMemberExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXNamespacedName(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXNamespacedName") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXOpeningElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXOpeningElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXSpreadAttribute(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXSpreadAttribute") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXText(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXText") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXFragment(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXFragment") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXOpeningFragment(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXOpeningFragment") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXClosingFragment(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXClosingFragment") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNoop(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Noop") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPlaceholder(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Placeholder") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isV8IntrinsicIdentifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "V8IntrinsicIdentifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isArgumentPlaceholder(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ArgumentPlaceholder") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBindExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BindExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImportAttribute(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ImportAttribute") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDecorator(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Decorator") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDoExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DoExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportDefaultSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportDefaultSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isRecordExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "RecordExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTupleExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TupleExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDecimalLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DecimalLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isModuleExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ModuleExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTopicReference(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TopicReference") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPipelineTopicExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "PipelineTopicExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPipelineBareFunction(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "PipelineBareFunction") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPipelinePrimaryTopicReference(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "PipelinePrimaryTopicReference") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSParameterProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSParameterProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSDeclareFunction(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSDeclareFunction") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSDeclareMethod(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSDeclareMethod") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSQualifiedName(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSQualifiedName") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSCallSignatureDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSCallSignatureDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSConstructSignatureDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSConstructSignatureDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSPropertySignature(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSPropertySignature") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSMethodSignature(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSMethodSignature") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSIndexSignature(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSIndexSignature") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSAnyKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSAnyKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSBooleanKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSBooleanKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSBigIntKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSBigIntKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSIntrinsicKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSIntrinsicKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNeverKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNeverKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNullKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNullKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNumberKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNumberKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSObjectKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSObjectKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSStringKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSStringKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSSymbolKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSSymbolKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSUndefinedKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSUndefinedKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSUnknownKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSUnknownKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSVoidKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSVoidKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSThisType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSThisType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSFunctionType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSFunctionType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSConstructorType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSConstructorType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeReference(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeReference") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypePredicate(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypePredicate") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeQuery(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeQuery") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSArrayType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSArrayType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTupleType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTupleType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSOptionalType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSOptionalType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSRestType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSRestType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNamedTupleMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNamedTupleMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSUnionType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSUnionType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSIntersectionType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSIntersectionType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSConditionalType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSConditionalType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSInferType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSInferType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSParenthesizedType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSParenthesizedType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeOperator(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeOperator") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSIndexedAccessType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSIndexedAccessType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSMappedType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSMappedType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSLiteralType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSLiteralType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSExpressionWithTypeArguments(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSExpressionWithTypeArguments") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSInterfaceDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSInterfaceDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSInterfaceBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSInterfaceBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeAliasDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeAliasDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSInstantiationExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSInstantiationExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSAsExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSAsExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSSatisfiesExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSSatisfiesExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeAssertion(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeAssertion") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSEnumDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSEnumDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSEnumMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSEnumMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSModuleDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSModuleDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSModuleBlock(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSModuleBlock") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSImportType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSImportType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSImportEqualsDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSImportEqualsDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSExternalModuleReference(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSExternalModuleReference") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNonNullExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNonNullExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSExportAssignment(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSExportAssignment") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNamespaceExportDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNamespaceExportDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeParameterInstantiation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeParameterInstantiation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeParameterDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeParameterDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeParameter(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeParameter") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStandardized(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "InterpreterDirective" === nodeType || "Directive" === nodeType || "DirectiveLiteral" === nodeType || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "CallExpression" === nodeType || "CatchClause" === nodeType || "ConditionalExpression" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "File" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "Program" === nodeType || "ObjectExpression" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "RestElement" === nodeType || "ReturnStatement" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "SwitchCase" === nodeType || "SwitchStatement" === nodeType || "ThisExpression" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "VariableDeclaration" === nodeType || "VariableDeclarator" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassBody" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ExportSpecifier" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "MetaProperty" === nodeType || "ClassMethod" === nodeType || "ObjectPattern" === nodeType || "SpreadElement" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateElement" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "ExportNamespaceSpecifier" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "ClassProperty" === nodeType || "ClassAccessorProperty" === nodeType || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType || "StaticBlock" === nodeType || nodeType === "Placeholder" && ("Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode || "BlockStatement" === node.expectedNode || "ClassBody" === node.expectedNode)) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TopicReference" === nodeType || "PipelineTopicExpression" === nodeType || "PipelineBareFunction" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "TSInstantiationExpression" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBinary(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isScopable(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBlockParent(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBlock2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTerminatorless(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isCompletionStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isConditional(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isLoop(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isWhile(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExpressionWrapper(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFor(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isForXStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunction(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunctionParent(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPureish(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPatternLike(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isLVal(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSEntityName(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImmutable(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isUserWhitespacable(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isMethod(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isProperty2(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassAccessorProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isUnaryLike(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPattern(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClass(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isModuleDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isModuleSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isAccessor(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ClassAccessorProperty" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPrivate(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFlow(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "EnumDeclaration" === nodeType || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFlowType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFlowBaseAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFlowDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFlowPredicate(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSX(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isMiscellaneous(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("Noop" === nodeType || "Placeholder" === nodeType || "V8IntrinsicIdentifier" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeScript(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("TSParameterProperty" === nodeType || "TSDeclareFunction" === nodeType || "TSDeclareMethod" === nodeType || "TSQualifiedName" === nodeType || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSNamedTupleMember" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSInterfaceBody" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSInstantiationExpression" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSEnumDeclaration" === nodeType || "TSEnumMember" === nodeType || "TSModuleDeclaration" === nodeType || "TSModuleBlock" === nodeType || "TSImportType" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExternalModuleReference" === nodeType || "TSNonNullExpression" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "TSTypeAnnotation" === nodeType || "TSTypeParameterInstantiation" === nodeType || "TSTypeParameterDeclaration" === nodeType || "TSTypeParameter" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSBaseType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNumberLiteral(node, opts) {
        console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NumberLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isRegexLiteral(node, opts) {
        console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "RegexLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isRestProperty(node, opts) {
        console.trace("The node type RestProperty has been renamed to RestElement");
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "RestProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSpreadProperty(node, opts) {
        console.trace("The node type SpreadProperty has been renamed to SpreadElement");
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SpreadProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
    }
  });

  // node_modules/@babel/types/lib/validators/matchesPattern.js
  var require_matchesPattern = __commonJS({
    "node_modules/@babel/types/lib/validators/matchesPattern.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = matchesPattern;
      var _generated = require_generated();
      function matchesPattern(member, match, allowPartial) {
        if (!(0, _generated.isMemberExpression)(member))
          return false;
        const parts = Array.isArray(match) ? match : match.split(".");
        const nodes = [];
        let node;
        for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
          nodes.push(node.property);
        }
        nodes.push(node);
        if (nodes.length < parts.length)
          return false;
        if (!allowPartial && nodes.length > parts.length)
          return false;
        for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
          const node2 = nodes[j];
          let value;
          if ((0, _generated.isIdentifier)(node2)) {
            value = node2.name;
          } else if ((0, _generated.isStringLiteral)(node2)) {
            value = node2.value;
          } else if ((0, _generated.isThisExpression)(node2)) {
            value = "this";
          } else {
            return false;
          }
          if (parts[i] !== value)
            return false;
        }
        return true;
      }
    }
  });

  // node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
  var require_buildMatchMemberExpression = __commonJS({
    "node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = buildMatchMemberExpression;
      var _matchesPattern = require_matchesPattern();
      function buildMatchMemberExpression(match, allowPartial) {
        const parts = match.split(".");
        return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
      }
    }
  });

  // node_modules/@babel/types/lib/validators/react/isReactComponent.js
  var require_isReactComponent = __commonJS({
    "node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _buildMatchMemberExpression = require_buildMatchMemberExpression();
      var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
      var _default = isReactComponent;
      exports.default = _default;
    }
  });

  // node_modules/@babel/types/lib/validators/react/isCompatTag.js
  var require_isCompatTag = __commonJS({
    "node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isCompatTag;
      function isCompatTag(tagName) {
        return !!tagName && /^[a-z]/.test(tagName);
      }
    }
  });

  // node_modules/to-fast-properties/index.js
  var require_to_fast_properties = __commonJS({
    "node_modules/to-fast-properties/index.js"(exports, module) {
      "use strict";
      var fastProto = null;
      function FastObject(o) {
        if (fastProto !== null && typeof fastProto.property) {
          const result = fastProto;
          fastProto = FastObject.prototype = null;
          return result;
        }
        fastProto = FastObject.prototype = o == null ? /* @__PURE__ */ Object.create(null) : o;
        return new FastObject();
      }
      FastObject();
      module.exports = function toFastproperties(o) {
        return FastObject(o);
      };
    }
  });

  // node_modules/@babel/types/lib/validators/isType.js
  var require_isType = __commonJS({
    "node_modules/@babel/types/lib/validators/isType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isType2;
      var _definitions = require_definitions();
      function isType2(nodeType, targetType) {
        if (nodeType === targetType)
          return true;
        if (_definitions.ALIAS_KEYS[targetType])
          return false;
        const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
        if (aliases) {
          if (aliases[0] === nodeType)
            return true;
          for (const alias of aliases) {
            if (nodeType === alias)
              return true;
          }
        }
        return false;
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isPlaceholderType.js
  var require_isPlaceholderType = __commonJS({
    "node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isPlaceholderType;
      var _definitions = require_definitions();
      function isPlaceholderType(placeholderType, targetType) {
        if (placeholderType === targetType)
          return true;
        const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
        if (aliases) {
          for (const alias of aliases) {
            if (targetType === alias)
              return true;
          }
        }
        return false;
      }
    }
  });

  // node_modules/@babel/types/lib/validators/is.js
  var require_is = __commonJS({
    "node_modules/@babel/types/lib/validators/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = is2;
      var _shallowEqual = require_shallowEqual();
      var _isType = require_isType();
      var _isPlaceholderType = require_isPlaceholderType();
      var _definitions = require_definitions();
      function is2(type, node, opts) {
        if (!node)
          return false;
        const matches = (0, _isType.default)(node.type, type);
        if (!matches) {
          if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) {
            return (0, _isPlaceholderType.default)(node.expectedNode, type);
          }
          return false;
        }
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
    }
  });

  // node_modules/@babel/helper-validator-identifier/lib/identifier.js
  var require_identifier = __commonJS({
    "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isIdentifierChar = isIdentifierChar;
      exports.isIdentifierName = isIdentifierName;
      exports.isIdentifierStart = isIdentifierStart2;
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code2, set) {
        let pos = 65536;
        for (let i = 0, length = set.length; i < length; i += 2) {
          pos += set[i];
          if (pos > code2)
            return false;
          pos += set[i + 1];
          if (pos >= code2)
            return true;
        }
        return false;
      }
      function isIdentifierStart2(code2) {
        if (code2 < 65)
          return code2 === 36;
        if (code2 <= 90)
          return true;
        if (code2 < 97)
          return code2 === 95;
        if (code2 <= 122)
          return true;
        if (code2 <= 65535) {
          return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
        }
        return isInAstralSet(code2, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code2) {
        if (code2 < 48)
          return code2 === 36;
        if (code2 < 58)
          return true;
        if (code2 < 65)
          return false;
        if (code2 <= 90)
          return true;
        if (code2 < 97)
          return code2 === 95;
        if (code2 <= 122)
          return true;
        if (code2 <= 65535) {
          return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
        }
        return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
      }
      function isIdentifierName(name41) {
        let isFirst = true;
        for (let i = 0; i < name41.length; i++) {
          let cp = name41.charCodeAt(i);
          if ((cp & 64512) === 55296 && i + 1 < name41.length) {
            const trail = name41.charCodeAt(++i);
            if ((trail & 64512) === 56320) {
              cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
          }
          if (isFirst) {
            isFirst = false;
            if (!isIdentifierStart2(cp)) {
              return false;
            }
          } else if (!isIdentifierChar(cp)) {
            return false;
          }
        }
        return !isFirst;
      }
    }
  });

  // node_modules/@babel/helper-validator-identifier/lib/keyword.js
  var require_keyword = __commonJS({
    "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isKeyword = isKeyword2;
      exports.isReservedWord = isReservedWord;
      exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
      exports.isStrictBindReservedWord = isStrictBindReservedWord;
      exports.isStrictReservedWord = isStrictReservedWord;
      var reservedWords = {
        keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
        strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
        strictBind: ["eval", "arguments"]
      };
      var keywords2 = new Set(reservedWords.keyword);
      var reservedWordsStrictSet = new Set(reservedWords.strict);
      var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
      function isReservedWord(word, inModule) {
        return inModule && word === "await" || word === "enum";
      }
      function isStrictReservedWord(word, inModule) {
        return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
      }
      function isStrictBindOnlyReservedWord(word) {
        return reservedWordsStrictBindSet.has(word);
      }
      function isStrictBindReservedWord(word, inModule) {
        return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
      }
      function isKeyword2(word) {
        return keywords2.has(word);
      }
    }
  });

  // node_modules/@babel/helper-validator-identifier/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "isIdentifierChar", {
        enumerable: true,
        get: function() {
          return _identifier.isIdentifierChar;
        }
      });
      Object.defineProperty(exports, "isIdentifierName", {
        enumerable: true,
        get: function() {
          return _identifier.isIdentifierName;
        }
      });
      Object.defineProperty(exports, "isIdentifierStart", {
        enumerable: true,
        get: function() {
          return _identifier.isIdentifierStart;
        }
      });
      Object.defineProperty(exports, "isKeyword", {
        enumerable: true,
        get: function() {
          return _keyword.isKeyword;
        }
      });
      Object.defineProperty(exports, "isReservedWord", {
        enumerable: true,
        get: function() {
          return _keyword.isReservedWord;
        }
      });
      Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
        enumerable: true,
        get: function() {
          return _keyword.isStrictBindOnlyReservedWord;
        }
      });
      Object.defineProperty(exports, "isStrictBindReservedWord", {
        enumerable: true,
        get: function() {
          return _keyword.isStrictBindReservedWord;
        }
      });
      Object.defineProperty(exports, "isStrictReservedWord", {
        enumerable: true,
        get: function() {
          return _keyword.isStrictReservedWord;
        }
      });
      var _identifier = require_identifier();
      var _keyword = require_keyword();
    }
  });

  // node_modules/@babel/types/lib/validators/isValidIdentifier.js
  var require_isValidIdentifier = __commonJS({
    "node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isValidIdentifier;
      var _helperValidatorIdentifier = require_lib2();
      function isValidIdentifier(name41, reserved = true) {
        if (typeof name41 !== "string")
          return false;
        if (reserved) {
          if ((0, _helperValidatorIdentifier.isKeyword)(name41) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name41, true)) {
            return false;
          }
        }
        return (0, _helperValidatorIdentifier.isIdentifierName)(name41);
      }
    }
  });

  // node_modules/@babel/helper-string-parser/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/@babel/helper-string-parser/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.readCodePoint = readCodePoint;
      exports.readInt = readInt;
      exports.readStringContents = readStringContents;
      var _isDigit = function isDigit2(code2) {
        return code2 >= 48 && code2 <= 57;
      };
      var forbiddenNumericSeparatorSiblings = {
        decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
      };
      var isAllowedNumericSeparatorSibling = {
        bin: (ch) => ch === 48 || ch === 49,
        oct: (ch) => ch >= 48 && ch <= 55,
        dec: (ch) => ch >= 48 && ch <= 57,
        hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
      };
      function readStringContents(type, input, pos, lineStart, curLine, errors) {
        const initialPos = pos;
        const initialLineStart = lineStart;
        const initialCurLine = curLine;
        let out = "";
        let firstInvalidLoc = null;
        let chunkStart = pos;
        const {
          length
        } = input;
        for (; ; ) {
          if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
          }
          const ch = input.charCodeAt(pos);
          if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
          }
          if (ch === 92) {
            out += input.slice(chunkStart, pos);
            const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
            if (res.ch === null && !firstInvalidLoc) {
              firstInvalidLoc = {
                pos,
                lineStart,
                curLine
              };
            } else {
              out += res.ch;
            }
            ({
              pos,
              lineStart,
              curLine
            } = res);
            chunkStart = pos;
          } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
          } else if (ch === 10 || ch === 13) {
            if (type === "template") {
              out += input.slice(chunkStart, pos) + "\n";
              ++pos;
              if (ch === 13 && input.charCodeAt(pos) === 10) {
                ++pos;
              }
              ++curLine;
              chunkStart = lineStart = pos;
            } else {
              errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
          } else {
            ++pos;
          }
        }
        return {
          pos,
          str: out,
          firstInvalidLoc,
          lineStart,
          curLine,
          containsInvalid: !!firstInvalidLoc
        };
      }
      function isStringEnd(type, ch, input, pos) {
        if (type === "template") {
          return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
        }
        return ch === (type === "double" ? 34 : 39);
      }
      function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
        const throwOnInvalid = !inTemplate;
        pos++;
        const res = (ch2) => ({
          pos,
          ch: ch2,
          lineStart,
          curLine
        });
        const ch = input.charCodeAt(pos++);
        switch (ch) {
          case 110:
            return res("\n");
          case 114:
            return res("\r");
          case 120: {
            let code2;
            ({
              code: code2,
              pos
            } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
            return res(code2 === null ? null : String.fromCharCode(code2));
          }
          case 117: {
            let code2;
            ({
              code: code2,
              pos
            } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
            return res(code2 === null ? null : String.fromCodePoint(code2));
          }
          case 116:
            return res("	");
          case 98:
            return res("\b");
          case 118:
            return res("\v");
          case 102:
            return res("\f");
          case 13:
            if (input.charCodeAt(pos) === 10) {
              ++pos;
            }
          case 10:
            lineStart = pos;
            ++curLine;
          case 8232:
          case 8233:
            return res("");
          case 56:
          case 57:
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(pos - 1, lineStart, curLine);
            }
          default:
            if (ch >= 48 && ch <= 55) {
              const startPos = pos - 1;
              const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
              let octalStr = match[0];
              let octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              pos += octalStr.length - 1;
              const next = input.charCodeAt(pos);
              if (octalStr !== "0" || next === 56 || next === 57) {
                if (inTemplate) {
                  return res(null);
                } else {
                  errors.strictNumericEscape(startPos, lineStart, curLine);
                }
              }
              return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
        }
      }
      function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
        const initialPos = pos;
        let n;
        ({
          n,
          pos
        } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
        if (n === null) {
          if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
          } else {
            pos = initialPos - 1;
          }
        }
        return {
          code: n,
          pos
        };
      }
      function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
        const start = pos;
        const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
        let invalid = false;
        let total = 0;
        for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          const code2 = input.charCodeAt(pos);
          let val;
          if (code2 === 95 && allowNumSeparator !== "bail") {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
              if (bailOnError)
                return {
                  n: null,
                  pos
                };
              errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
              if (bailOnError)
                return {
                  n: null,
                  pos
                };
              errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
          }
          if (code2 >= 97) {
            val = code2 - 97 + 10;
          } else if (code2 >= 65) {
            val = code2 - 65 + 10;
          } else if (_isDigit(code2)) {
            val = code2 - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            if (val <= 9 && bailOnError) {
              return {
                n: null,
                pos
              };
            } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
              val = 0;
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }
          ++pos;
          total = total * radix + val;
        }
        if (pos === start || len != null && pos - start !== len || invalid) {
          return {
            n: null,
            pos
          };
        }
        return {
          n: total,
          pos
        };
      }
      function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
        const ch = input.charCodeAt(pos);
        let code2;
        if (ch === 123) {
          ++pos;
          ({
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
          ++pos;
          if (code2 !== null && code2 > 1114111) {
            if (throwOnInvalid) {
              errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
              return {
                code: null,
                pos
              };
            }
          }
        } else {
          ({
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
        }
        return {
          code: code2,
          pos
        };
      }
    }
  });

  // node_modules/@babel/types/lib/constants/index.js
  var require_constants = __commonJS({
    "node_modules/@babel/types/lib/constants/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
      var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
      exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
      var FLATTENABLE_KEYS = ["body", "expressions"];
      exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
      var FOR_INIT_KEYS = ["left", "init"];
      exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
      var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
      exports.COMMENT_KEYS = COMMENT_KEYS;
      var LOGICAL_OPERATORS = ["||", "&&", "??"];
      exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
      var UPDATE_OPERATORS = ["++", "--"];
      exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
      var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
      exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
      var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
      exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
      var COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
      exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
      var BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
      exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
      var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
      exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
      var BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
      exports.BINARY_OPERATORS = BINARY_OPERATORS;
      var ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
      exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
      var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
      exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
      var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
      exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
      var STRING_UNARY_OPERATORS = ["typeof"];
      exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
      var UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
      exports.UNARY_OPERATORS = UNARY_OPERATORS;
      var INHERIT_KEYS = {
        optional: ["typeAnnotation", "typeParameters", "returnType"],
        force: ["start", "loc", "end"]
      };
      exports.INHERIT_KEYS = INHERIT_KEYS;
      var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
      exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
      var NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
      exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
    }
  });

  // node_modules/@babel/types/lib/definitions/utils.js
  var require_utils = __commonJS({
    "node_modules/@babel/types/lib/definitions/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
      exports.arrayOf = arrayOf;
      exports.arrayOfType = arrayOfType;
      exports.assertEach = assertEach;
      exports.assertNodeOrValueType = assertNodeOrValueType;
      exports.assertNodeType = assertNodeType;
      exports.assertOneOf = assertOneOf;
      exports.assertOptionalChainStart = assertOptionalChainStart;
      exports.assertShape = assertShape;
      exports.assertValueType = assertValueType;
      exports.chain = chain;
      exports.default = defineType;
      exports.defineAliasedType = defineAliasedType;
      exports.typeIs = typeIs;
      exports.validate = validate;
      exports.validateArrayOfType = validateArrayOfType;
      exports.validateOptional = validateOptional;
      exports.validateOptionalType = validateOptionalType;
      exports.validateType = validateType;
      var _is = require_is();
      var _validate = require_validate();
      var VISITOR_KEYS = {};
      exports.VISITOR_KEYS = VISITOR_KEYS;
      var ALIAS_KEYS = {};
      exports.ALIAS_KEYS = ALIAS_KEYS;
      var FLIPPED_ALIAS_KEYS = {};
      exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
      var NODE_FIELDS = {};
      exports.NODE_FIELDS = NODE_FIELDS;
      var BUILDER_KEYS = {};
      exports.BUILDER_KEYS = BUILDER_KEYS;
      var DEPRECATED_KEYS = {};
      exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
      var NODE_PARENT_VALIDATIONS = {};
      exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
      function getType(val) {
        if (Array.isArray(val)) {
          return "array";
        } else if (val === null) {
          return "null";
        } else {
          return typeof val;
        }
      }
      function validate(validate2) {
        return {
          validate: validate2
        };
      }
      function typeIs(typeName) {
        return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
      }
      function validateType(typeName) {
        return validate(typeIs(typeName));
      }
      function validateOptional(validate2) {
        return {
          validate: validate2,
          optional: true
        };
      }
      function validateOptionalType(typeName) {
        return {
          validate: typeIs(typeName),
          optional: true
        };
      }
      function arrayOf(elementType) {
        return chain(assertValueType("array"), assertEach(elementType));
      }
      function arrayOfType(typeName) {
        return arrayOf(typeIs(typeName));
      }
      function validateArrayOfType(typeName) {
        return validate(arrayOfType(typeName));
      }
      function assertEach(callback) {
        function validator(node, key, val) {
          if (!Array.isArray(val))
            return;
          for (let i = 0; i < val.length; i++) {
            const subkey = `${key}[${i}]`;
            const v = val[i];
            callback(node, subkey, v);
            if (process.env.BABEL_TYPES_8_BREAKING)
              (0, _validate.validateChild)(node, subkey, v);
          }
        }
        validator.each = callback;
        return validator;
      }
      function assertOneOf(...values) {
        function validate2(node, key, val) {
          if (values.indexOf(val) < 0) {
            throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
          }
        }
        validate2.oneOf = values;
        return validate2;
      }
      function assertNodeType(...types) {
        function validate2(node, key, val) {
          for (const type of types) {
            if ((0, _is.default)(type, val)) {
              (0, _validate.validateChild)(node, key, val);
              return;
            }
          }
          throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
        }
        validate2.oneOfNodeTypes = types;
        return validate2;
      }
      function assertNodeOrValueType(...types) {
        function validate2(node, key, val) {
          for (const type of types) {
            if (getType(val) === type || (0, _is.default)(type, val)) {
              (0, _validate.validateChild)(node, key, val);
              return;
            }
          }
          throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
        }
        validate2.oneOfNodeOrValueTypes = types;
        return validate2;
      }
      function assertValueType(type) {
        function validate2(node, key, val) {
          const valid = getType(val) === type;
          if (!valid) {
            throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
          }
        }
        validate2.type = type;
        return validate2;
      }
      function assertShape(shape2) {
        function validate2(node, key, val) {
          const errors = [];
          for (const property2 of Object.keys(shape2)) {
            try {
              (0, _validate.validateField)(node, property2, val[property2], shape2[property2]);
            } catch (error) {
              if (error instanceof TypeError) {
                errors.push(error.message);
                continue;
              }
              throw error;
            }
          }
          if (errors.length) {
            throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join("\n")}`);
          }
        }
        validate2.shapeOf = shape2;
        return validate2;
      }
      function assertOptionalChainStart() {
        function validate2(node) {
          var _current;
          let current = node;
          while (node) {
            const {
              type
            } = current;
            if (type === "OptionalCallExpression") {
              if (current.optional)
                return;
              current = current.callee;
              continue;
            }
            if (type === "OptionalMemberExpression") {
              if (current.optional)
                return;
              current = current.object;
              continue;
            }
            break;
          }
          throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
        }
        return validate2;
      }
      function chain(...fns) {
        function validate2(...args) {
          for (const fn of fns) {
            fn(...args);
          }
        }
        validate2.chainOf = fns;
        if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
          throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
        }
        return validate2;
      }
      var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
      var validFieldKeys = ["default", "optional", "validate"];
      var store = {};
      function defineAliasedType(...aliases) {
        return (type, opts = {}) => {
          let defined = opts.aliases;
          if (!defined) {
            var _store$opts$inherits$, _defined;
            if (opts.inherits)
              defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
            (_defined = defined) != null ? _defined : defined = [];
            opts.aliases = defined;
          }
          const additional = aliases.filter((a) => !defined.includes(a));
          defined.unshift(...additional);
          return defineType(type, opts);
        };
      }
      function defineType(type, opts = {}) {
        const inherits = opts.inherits && store[opts.inherits] || {};
        let fields = opts.fields;
        if (!fields) {
          fields = {};
          if (inherits.fields) {
            const keys = Object.getOwnPropertyNames(inherits.fields);
            for (const key of keys) {
              const field = inherits.fields[key];
              const def = field.default;
              if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
                throw new Error("field defaults can only be primitives or empty arrays currently");
              }
              fields[key] = {
                default: Array.isArray(def) ? [] : def,
                optional: field.optional,
                validate: field.validate
              };
            }
          }
        }
        const visitor = opts.visitor || inherits.visitor || [];
        const aliases = opts.aliases || inherits.aliases || [];
        const builder = opts.builder || inherits.builder || opts.visitor || [];
        for (const k of Object.keys(opts)) {
          if (validTypeOpts.indexOf(k) === -1) {
            throw new Error(`Unknown type option "${k}" on ${type}`);
          }
        }
        if (opts.deprecatedAlias) {
          DEPRECATED_KEYS[opts.deprecatedAlias] = type;
        }
        for (const key of visitor.concat(builder)) {
          fields[key] = fields[key] || {};
        }
        for (const key of Object.keys(fields)) {
          const field = fields[key];
          if (field.default !== void 0 && builder.indexOf(key) === -1) {
            field.optional = true;
          }
          if (field.default === void 0) {
            field.default = null;
          } else if (!field.validate && field.default != null) {
            field.validate = assertValueType(getType(field.default));
          }
          for (const k of Object.keys(field)) {
            if (validFieldKeys.indexOf(k) === -1) {
              throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
            }
          }
        }
        VISITOR_KEYS[type] = opts.visitor = visitor;
        BUILDER_KEYS[type] = opts.builder = builder;
        NODE_FIELDS[type] = opts.fields = fields;
        ALIAS_KEYS[type] = opts.aliases = aliases;
        aliases.forEach((alias) => {
          FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
          FLIPPED_ALIAS_KEYS[alias].push(type);
        });
        if (opts.validate) {
          NODE_PARENT_VALIDATIONS[type] = opts.validate;
        }
        store[type] = opts;
      }
    }
  });

  // node_modules/@babel/types/lib/definitions/core.js
  var require_core = __commonJS({
    "node_modules/@babel/types/lib/definitions/core.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
      var _is = require_is();
      var _isValidIdentifier = require_isValidIdentifier();
      var _helperValidatorIdentifier = require_lib2();
      var _helperStringParser = require_lib3();
      var _constants = require_constants();
      var _utils = require_utils();
      var defineType = (0, _utils.defineAliasedType)("Standardized");
      defineType("ArrayExpression", {
        fields: {
          elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
            default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
          }
        },
        visitor: ["elements"],
        aliases: ["Expression"]
      });
      defineType("AssignmentExpression", {
        fields: {
          operator: {
            validate: function() {
              if (!process.env.BABEL_TYPES_8_BREAKING) {
                return (0, _utils.assertValueType)("string");
              }
              const identifier4 = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);
              const pattern = (0, _utils.assertOneOf)("=");
              return function(node, key, val) {
                const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier4;
                validator(node, key, val);
              };
            }()
          },
          left: {
            validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        builder: ["operator", "left", "right"],
        visitor: ["left", "right"],
        aliases: ["Expression"]
      });
      defineType("BinaryExpression", {
        builder: ["operator", "left", "right"],
        fields: {
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
          },
          left: {
            validate: function() {
              const expression = (0, _utils.assertNodeType)("Expression");
              const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
              const validator = Object.assign(
                function(node, key, val) {
                  const validator2 = node.operator === "in" ? inOp : expression;
                  validator2(node, key, val);
                },
                {
                  oneOfNodeTypes: ["Expression", "PrivateName"]
                }
              );
              return validator;
            }()
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        visitor: ["left", "right"],
        aliases: ["Binary", "Expression"]
      });
      defineType("InterpreterDirective", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
      defineType("Directive", {
        visitor: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertNodeType)("DirectiveLiteral")
          }
        }
      });
      defineType("DirectiveLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
      defineType("BlockStatement", {
        builder: ["body", "directives"],
        visitor: ["directives", "body"],
        fields: {
          directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
          },
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
          }
        },
        aliases: ["Scopable", "BlockParent", "Block", "Statement"]
      });
      defineType("BreakStatement", {
        visitor: ["label"],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          }
        },
        aliases: ["Statement", "Terminatorless", "CompletionStatement"]
      });
      defineType("CallExpression", {
        visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
        builder: ["callee", "arguments"],
        aliases: ["Expression"],
        fields: Object.assign({
          callee: {
            validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
          },
          arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
          }
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
          }
        } : {}, {
          typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
          }
        })
      });
      defineType("CatchClause", {
        visitor: ["param", "body"],
        fields: {
          param: {
            validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        },
        aliases: ["Scopable", "BlockParent"]
      });
      defineType("ConditionalExpression", {
        visitor: ["test", "consequent", "alternate"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          consequent: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          alternate: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: ["Expression", "Conditional"]
      });
      defineType("ContinueStatement", {
        visitor: ["label"],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          }
        },
        aliases: ["Statement", "Terminatorless", "CompletionStatement"]
      });
      defineType("DebuggerStatement", {
        aliases: ["Statement"]
      });
      defineType("DoWhileStatement", {
        visitor: ["test", "body"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        },
        aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
      });
      defineType("EmptyStatement", {
        aliases: ["Statement"]
      });
      defineType("ExpressionStatement", {
        visitor: ["expression"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: ["Statement", "ExpressionWrapper"]
      });
      defineType("File", {
        builder: ["program", "comments", "tokens"],
        visitor: ["program"],
        fields: {
          program: {
            validate: (0, _utils.assertNodeType)("Program")
          },
          comments: {
            validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
            }, {
              each: {
                oneOfNodeTypes: ["CommentBlock", "CommentLine"]
              }
            }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
            optional: true
          },
          tokens: {
            validate: (0, _utils.assertEach)(Object.assign(() => {
            }, {
              type: "any"
            })),
            optional: true
          }
        }
      });
      defineType("ForInStatement", {
        visitor: ["left", "right", "body"],
        aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
        fields: {
          left: {
            validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("ForStatement", {
        visitor: ["init", "test", "update", "body"],
        aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
        fields: {
          init: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
            optional: true
          },
          test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          update: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      var functionCommon = () => ({
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
        },
        generator: {
          default: false
        },
        async: {
          default: false
        }
      });
      exports.functionCommon = functionCommon;
      var functionTypeAnnotationCommon = () => ({
        returnType: {
          validate: (0, _utils.assertNodeType)(
            "TypeAnnotation",
            "TSTypeAnnotation",
            "Noop"
          ),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)(
            "TypeParameterDeclaration",
            "TSTypeParameterDeclaration",
            "Noop"
          ),
          optional: true
        }
      });
      exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
      var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      });
      exports.functionDeclarationCommon = functionDeclarationCommon;
      defineType("FunctionDeclaration", {
        builder: ["id", "params", "body", "generator", "async"],
        visitor: ["id", "params", "body", "returnType", "typeParameters"],
        fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          },
          predicate: {
            validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
            optional: true
          }
        }),
        aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return () => {
            };
          const identifier4 = (0, _utils.assertNodeType)("Identifier");
          return function(parent, key, node) {
            if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
              identifier4(node, "id", node.id);
            }
          };
        }()
      });
      defineType("FunctionExpression", {
        inherits: "FunctionDeclaration",
        aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
        fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          },
          predicate: {
            validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
            optional: true
          }
        })
      });
      var patternLikeCommon = () => ({
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)(
            "TypeAnnotation",
            "TSTypeAnnotation",
            "Noop"
          ),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      });
      exports.patternLikeCommon = patternLikeCommon;
      defineType("Identifier", {
        builder: ["name"],
        visitor: ["typeAnnotation", "decorators"],
        aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
        fields: Object.assign({}, patternLikeCommon(), {
          name: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING)
                return;
              if (!(0, _isValidIdentifier.default)(val, false)) {
                throw new TypeError(`"${val}" is not a valid identifier name`);
              }
            }, {
              type: "string"
            }))
          },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        }),
        validate(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const match = /\.(\w+)$/.exec(key);
          if (!match)
            return;
          const [, parentKey] = match;
          const nonComp = {
            computed: false
          };
          if (parentKey === "property") {
            if ((0, _is.default)("MemberExpression", parent, nonComp))
              return;
            if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
              return;
          } else if (parentKey === "key") {
            if ((0, _is.default)("Property", parent, nonComp))
              return;
            if ((0, _is.default)("Method", parent, nonComp))
              return;
          } else if (parentKey === "exported") {
            if ((0, _is.default)("ExportSpecifier", parent))
              return;
          } else if (parentKey === "imported") {
            if ((0, _is.default)("ImportSpecifier", parent, {
              imported: node
            }))
              return;
          } else if (parentKey === "meta") {
            if ((0, _is.default)("MetaProperty", parent, {
              meta: node
            }))
              return;
          }
          if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
            throw new TypeError(`"${node.name}" is not a valid identifier`);
          }
        }
      });
      defineType("IfStatement", {
        visitor: ["test", "consequent", "alternate"],
        aliases: ["Statement", "Conditional"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          consequent: {
            validate: (0, _utils.assertNodeType)("Statement")
          },
          alternate: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("LabeledStatement", {
        visitor: ["label", "body"],
        aliases: ["Statement"],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("StringLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("NumericLiteral", {
        builder: ["value"],
        deprecatedAlias: "NumberLiteral",
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("number")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("NullLiteral", {
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("BooleanLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("boolean")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("RegExpLiteral", {
        builder: ["pattern", "flags"],
        deprecatedAlias: "RegexLiteral",
        aliases: ["Expression", "Pureish", "Literal"],
        fields: {
          pattern: {
            validate: (0, _utils.assertValueType)("string")
          },
          flags: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING)
                return;
              const invalid = /[^gimsuy]/.exec(val);
              if (invalid) {
                throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
              }
            }, {
              type: "string"
            })),
            default: ""
          }
        }
      });
      defineType("LogicalExpression", {
        builder: ["operator", "left", "right"],
        visitor: ["left", "right"],
        aliases: ["Binary", "Expression"],
        fields: {
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
          },
          left: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("MemberExpression", {
        builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
        visitor: ["object", "property"],
        aliases: ["Expression", "LVal"],
        fields: Object.assign({
          object: {
            validate: (0, _utils.assertNodeType)("Expression", "Super")
          },
          property: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
              const computed2 = (0, _utils.assertNodeType)("Expression");
              const validator = function(node, key, val) {
                const validator2 = node.computed ? computed2 : normal;
                validator2(node, key, val);
              };
              validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
              return validator;
            }()
          },
          computed: {
            default: false
          }
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
          }
        } : {})
      });
      defineType("NewExpression", {
        inherits: "CallExpression"
      });
      defineType("Program", {
        visitor: ["directives", "body"],
        builder: ["body", "directives", "sourceType", "interpreter"],
        fields: {
          sourceFile: {
            validate: (0, _utils.assertValueType)("string")
          },
          sourceType: {
            validate: (0, _utils.assertOneOf)("script", "module"),
            default: "script"
          },
          interpreter: {
            validate: (0, _utils.assertNodeType)("InterpreterDirective"),
            default: null,
            optional: true
          },
          directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
          },
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
          }
        },
        aliases: ["Scopable", "BlockParent", "Block"]
      });
      defineType("ObjectExpression", {
        visitor: ["properties"],
        aliases: ["Expression"],
        fields: {
          properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
          }
        }
      });
      defineType("ObjectMethod", {
        builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
        fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
          kind: Object.assign({
            validate: (0, _utils.assertOneOf)("method", "get", "set")
          }, !process.env.BABEL_TYPES_8_BREAKING ? {
            default: "method"
          } : {}),
          computed: {
            default: false
          },
          key: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
              const computed2 = (0, _utils.assertNodeType)("Expression");
              const validator = function(node, key, val) {
                const validator2 = node.computed ? computed2 : normal;
                validator2(node, key, val);
              };
              validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
              return validator;
            }()
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        }),
        visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
        aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
      });
      defineType("ObjectProperty", {
        builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
        fields: {
          computed: {
            default: false
          },
          key: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
              const computed2 = (0, _utils.assertNodeType)("Expression");
              const validator = Object.assign(function(node, key, val) {
                const validator2 = node.computed ? computed2 : normal;
                validator2(node, key, val);
              }, {
                oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
              });
              return validator;
            }()
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
          },
          shorthand: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING)
                return;
              if (val && node.computed) {
                throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
              }
            }, {
              type: "boolean"
            }), function(node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING)
                return;
              if (val && !(0, _is.default)("Identifier", node.key)) {
                throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
              }
            }),
            default: false
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          }
        },
        visitor: ["key", "value", "decorators"],
        aliases: ["UserWhitespacable", "Property", "ObjectMember"],
        validate: function() {
          const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
          const expression = (0, _utils.assertNodeType)("Expression");
          return function(parent, key, node) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
            validator(node, "value", node.value);
          };
        }()
      });
      defineType("RestElement", {
        visitor: ["argument", "typeAnnotation"],
        builder: ["argument"],
        aliases: ["LVal", "PatternLike"],
        deprecatedAlias: "RestProperty",
        fields: Object.assign({}, patternLikeCommon(), {
          argument: {
            validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
          },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        }),
        validate(parent, key) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const match = /(\w+)\[(\d+)\]/.exec(key);
          if (!match)
            throw new Error("Internal Babel error: malformed key.");
          const [, listKey, index] = match;
          if (parent[listKey].length > +index + 1) {
            throw new TypeError(`RestElement must be last element of ${listKey}`);
          }
        }
      });
      defineType("ReturnStatement", {
        visitor: ["argument"],
        aliases: ["Statement", "Terminatorless", "CompletionStatement"],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          }
        }
      });
      defineType("SequenceExpression", {
        visitor: ["expressions"],
        fields: {
          expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
          }
        },
        aliases: ["Expression"]
      });
      defineType("ParenthesizedExpression", {
        visitor: ["expression"],
        aliases: ["Expression", "ExpressionWrapper"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("SwitchCase", {
        visitor: ["test", "consequent"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          consequent: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
          }
        }
      });
      defineType("SwitchStatement", {
        visitor: ["discriminant", "cases"],
        aliases: ["Statement", "BlockParent", "Scopable"],
        fields: {
          discriminant: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          cases: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
          }
        }
      });
      defineType("ThisExpression", {
        aliases: ["Expression"]
      });
      defineType("ThrowStatement", {
        visitor: ["argument"],
        aliases: ["Statement", "Terminatorless", "CompletionStatement"],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("TryStatement", {
        visitor: ["block", "handler", "finalizer"],
        aliases: ["Statement"],
        fields: {
          block: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
              if (!process.env.BABEL_TYPES_8_BREAKING)
                return;
              if (!node.handler && !node.finalizer) {
                throw new TypeError("TryStatement expects either a handler or finalizer, or both");
              }
            }, {
              oneOfNodeTypes: ["BlockStatement"]
            }))
          },
          handler: {
            optional: true,
            validate: (0, _utils.assertNodeType)("CatchClause")
          },
          finalizer: {
            optional: true,
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        }
      });
      defineType("UnaryExpression", {
        builder: ["operator", "argument", "prefix"],
        fields: {
          prefix: {
            default: true
          },
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
          }
        },
        visitor: ["argument"],
        aliases: ["UnaryLike", "Expression"]
      });
      defineType("UpdateExpression", {
        builder: ["operator", "argument", "prefix"],
        fields: {
          prefix: {
            default: false
          },
          argument: {
            validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
          },
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
          }
        },
        visitor: ["argument"],
        aliases: ["Expression"]
      });
      defineType("VariableDeclaration", {
        builder: ["kind", "declarations"],
        visitor: ["declarations"],
        aliases: ["Statement", "Declaration"],
        fields: {
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          kind: {
            validate: (0, _utils.assertOneOf)(
              "var",
              "let",
              "const",
              "using"
            )
          },
          declarations: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
          }
        },
        validate(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!(0, _is.default)("ForXStatement", parent, {
            left: node
          }))
            return;
          if (node.declarations.length !== 1) {
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
          }
        }
      });
      defineType("VariableDeclarator", {
        visitor: ["id", "init"],
        fields: {
          id: {
            validate: function() {
              if (!process.env.BABEL_TYPES_8_BREAKING) {
                return (0, _utils.assertNodeType)("LVal");
              }
              const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
              const without = (0, _utils.assertNodeType)("Identifier");
              return function(node, key, val) {
                const validator = node.init ? normal : without;
                validator(node, key, val);
              };
            }()
          },
          definite: {
            optional: true,
            validate: (0, _utils.assertValueType)("boolean")
          },
          init: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("WhileStatement", {
        visitor: ["test", "body"],
        aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("WithStatement", {
        visitor: ["object", "body"],
        aliases: ["Statement"],
        fields: {
          object: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("AssignmentPattern", {
        visitor: ["left", "right", "decorators"],
        builder: ["left", "right"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, patternLikeCommon(), {
          left: {
            validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          }
        })
      });
      defineType("ArrayPattern", {
        visitor: ["elements", "typeAnnotation"],
        builder: ["elements"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, patternLikeCommon(), {
          elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        })
      });
      defineType("ArrowFunctionExpression", {
        builder: ["params", "body", "async"],
        visitor: ["params", "body", "returnType", "typeParameters"],
        aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
        fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
          expression: {
            validate: (0, _utils.assertValueType)("boolean")
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
          },
          predicate: {
            validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
            optional: true
          }
        })
      });
      defineType("ClassBody", {
        visitor: ["body"],
        fields: {
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
          }
        }
      });
      defineType("ClassExpression", {
        builder: ["id", "superClass", "body", "decorators"],
        visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
        aliases: ["Scopable", "Class", "Expression"],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)(
              "TypeParameterDeclaration",
              "TSTypeParameterDeclaration",
              "Noop"
            ),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
          },
          superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          },
          superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
          },
          implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
          }
        }
      });
      defineType("ClassDeclaration", {
        inherits: "ClassExpression",
        aliases: ["Scopable", "Class", "Statement", "Declaration"],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)(
              "TypeParameterDeclaration",
              "TSTypeParameterDeclaration",
              "Noop"
            ),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
          },
          superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          },
          superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
          },
          implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          abstract: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        },
        validate: function() {
          const identifier4 = (0, _utils.assertNodeType)("Identifier");
          return function(parent, key, node) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
              identifier4(node, "id", node.id);
            }
          };
        }()
      });
      defineType("ExportAllDeclaration", {
        visitor: ["source"],
        aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
        fields: {
          source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
          },
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
          assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
          }
        }
      });
      defineType("ExportDefaultDeclaration", {
        visitor: ["declaration"],
        aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
        fields: {
          declaration: {
            validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
          },
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
        }
      });
      defineType("ExportNamedDeclaration", {
        visitor: ["declaration", "specifiers", "source"],
        aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
        fields: {
          declaration: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING)
                return;
              if (val && node.specifiers.length) {
                throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
              }
            }, {
              oneOfNodeTypes: ["Declaration"]
            }), function(node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING)
                return;
              if (val && node.source) {
                throw new TypeError("Cannot export a declaration from a source");
              }
            })
          },
          assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
          },
          specifiers: {
            default: [],
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
              const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
              const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
              if (!process.env.BABEL_TYPES_8_BREAKING)
                return sourced;
              return function(node, key, val) {
                const validator = node.source ? sourced : sourceless;
                validator(node, key, val);
              };
            }()))
          },
          source: {
            validate: (0, _utils.assertNodeType)("StringLiteral"),
            optional: true
          },
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
        }
      });
      defineType("ExportSpecifier", {
        visitor: ["local", "exported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          exported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          exportKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
          }
        }
      });
      defineType("ForOfStatement", {
        visitor: ["left", "right", "body"],
        builder: ["left", "right", "body", "await"],
        aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
        fields: {
          left: {
            validate: function() {
              if (!process.env.BABEL_TYPES_8_BREAKING) {
                return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
              }
              const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
              const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
              return function(node, key, val) {
                if ((0, _is.default)("VariableDeclaration", val)) {
                  declaration(node, key, val);
                } else {
                  lval(node, key, val);
                }
              };
            }()
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          },
          await: {
            default: false
          }
        }
      });
      defineType("ImportDeclaration", {
        visitor: ["specifiers", "source"],
        aliases: ["Statement", "Declaration", "ModuleDeclaration"],
        fields: {
          assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
          },
          module: {
            optional: true,
            validate: (0, _utils.assertValueType)("boolean")
          },
          specifiers: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
          },
          source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
          },
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
          }
        }
      });
      defineType("ImportDefaultSpecifier", {
        visitor: ["local"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      defineType("ImportNamespaceSpecifier", {
        visitor: ["local"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      defineType("ImportSpecifier", {
        visitor: ["local", "imported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          imported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
          }
        }
      });
      defineType("MetaProperty", {
        visitor: ["meta", "property"],
        aliases: ["Expression"],
        fields: {
          meta: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING)
                return;
              let property2;
              switch (val.name) {
                case "function":
                  property2 = "sent";
                  break;
                case "new":
                  property2 = "target";
                  break;
                case "import":
                  property2 = "meta";
                  break;
              }
              if (!(0, _is.default)("Identifier", node.property, {
                name: property2
              })) {
                throw new TypeError("Unrecognised MetaProperty");
              }
            }, {
              oneOfNodeTypes: ["Identifier"]
            }))
          },
          property: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      var classMethodOrPropertyCommon = () => ({
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: true
        },
        static: {
          default: false
        },
        override: {
          default: false
        },
        computed: {
          default: false
        },
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        key: {
          validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
            const computed2 = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
              const validator = node.computed ? computed2 : normal;
              validator(node, key, val);
            };
          }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
        }
      });
      exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
      var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
        },
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
          default: "method"
        },
        access: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      });
      exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
      defineType("ClassMethod", {
        aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
        builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
        visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
        fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        })
      });
      defineType("ObjectPattern", {
        visitor: ["properties", "typeAnnotation", "decorators"],
        builder: ["properties"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, patternLikeCommon(), {
          properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
          }
        })
      });
      defineType("SpreadElement", {
        visitor: ["argument"],
        aliases: ["UnaryLike"],
        deprecatedAlias: "SpreadProperty",
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("Super", {
        aliases: ["Expression"]
      });
      defineType("TaggedTemplateExpression", {
        visitor: ["tag", "quasi", "typeParameters"],
        builder: ["tag", "quasi"],
        aliases: ["Expression"],
        fields: {
          tag: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          quasi: {
            validate: (0, _utils.assertNodeType)("TemplateLiteral")
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
          }
        }
      });
      defineType("TemplateElement", {
        builder: ["value", "tail"],
        fields: {
          value: {
            validate: (0, _utils.chain)((0, _utils.assertShape)({
              raw: {
                validate: (0, _utils.assertValueType)("string")
              },
              cooked: {
                validate: (0, _utils.assertValueType)("string"),
                optional: true
              }
            }), function templateElementCookedValidator(node) {
              const raw = node.value.raw;
              let unterminatedCalled = false;
              const error = () => {
                throw new Error("Internal @babel/types error.");
              };
              const {
                str,
                firstInvalidLoc
              } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
                unterminated() {
                  unterminatedCalled = true;
                },
                strictNumericEscape: error,
                invalidEscapeSequence: error,
                numericSeparatorInEscapeSequence: error,
                unexpectedNumericSeparator: error,
                invalidDigit: error,
                invalidCodePoint: error
              });
              if (!unterminatedCalled)
                throw new Error("Invalid raw");
              node.value.cooked = firstInvalidLoc ? null : str;
            })
          },
          tail: {
            default: false
          }
        }
      });
      defineType("TemplateLiteral", {
        visitor: ["quasis", "expressions"],
        aliases: ["Expression", "Literal"],
        fields: {
          quasis: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
          },
          expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)(
              "Expression",
              "TSType"
            )), function(node, key, val) {
              if (node.quasis.length !== val.length + 1) {
                throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
              }
            })
          }
        }
      });
      defineType("YieldExpression", {
        builder: ["argument", "delegate"],
        visitor: ["argument"],
        aliases: ["Expression", "Terminatorless"],
        fields: {
          delegate: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING)
                return;
              if (val && !node.argument) {
                throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
              }
            }, {
              type: "boolean"
            })),
            default: false
          },
          argument: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("AwaitExpression", {
        builder: ["argument"],
        visitor: ["argument"],
        aliases: ["Expression", "Terminatorless"],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("Import", {
        aliases: ["Expression"]
      });
      defineType("BigIntLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("ExportNamespaceSpecifier", {
        visitor: ["exported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      defineType("OptionalMemberExpression", {
        builder: ["object", "property", "computed", "optional"],
        visitor: ["object", "property"],
        aliases: ["Expression"],
        fields: {
          object: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          property: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier");
              const computed2 = (0, _utils.assertNodeType)("Expression");
              const validator = Object.assign(
                function(node, key, val) {
                  const validator2 = node.computed ? computed2 : normal;
                  validator2(node, key, val);
                },
                {
                  oneOfNodeTypes: ["Expression", "Identifier"]
                }
              );
              return validator;
            }()
          },
          computed: {
            default: false
          },
          optional: {
            validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
          }
        }
      });
      defineType("OptionalCallExpression", {
        visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
        builder: ["callee", "arguments", "optional"],
        aliases: ["Expression"],
        fields: {
          callee: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
          },
          optional: {
            validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
          },
          typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
          }
        }
      });
      defineType("ClassProperty", {
        visitor: ["key", "value", "typeAnnotation", "decorators"],
        builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
        aliases: ["Property"],
        fields: Object.assign({}, classMethodOrPropertyCommon(), {
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)(
              "TypeAnnotation",
              "TSTypeAnnotation",
              "Noop"
            ),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
          }
        })
      });
      defineType("ClassAccessorProperty", {
        visitor: ["key", "value", "typeAnnotation", "decorators"],
        builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
        aliases: ["Property", "Accessor"],
        fields: Object.assign({}, classMethodOrPropertyCommon(), {
          key: {
            validate: (0, _utils.chain)(function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
              const computed2 = (0, _utils.assertNodeType)("Expression");
              return function(node, key, val) {
                const validator = node.computed ? computed2 : normal;
                validator(node, key, val);
              };
            }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)(
              "TypeAnnotation",
              "TSTypeAnnotation",
              "Noop"
            ),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
          }
        })
      });
      defineType("ClassPrivateProperty", {
        visitor: ["key", "value", "decorators", "typeAnnotation"],
        builder: ["key", "value", "decorators", "static"],
        aliases: ["Property", "Private"],
        fields: {
          key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)(
              "TypeAnnotation",
              "TSTypeAnnotation",
              "Noop"
            ),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          static: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
          }
        }
      });
      defineType("ClassPrivateMethod", {
        builder: ["kind", "key", "params", "body", "static"],
        visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
        aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
        fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
          kind: {
            validate: (0, _utils.assertOneOf)("get", "set", "method"),
            default: "method"
          },
          key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        })
      });
      defineType("PrivateName", {
        visitor: ["id"],
        aliases: ["Private"],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      defineType("StaticBlock", {
        visitor: ["body"],
        fields: {
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
          }
        },
        aliases: ["Scopable", "BlockParent", "FunctionParent"]
      });
    }
  });

  // node_modules/@babel/types/lib/definitions/flow.js
  var require_flow = __commonJS({
    "node_modules/@babel/types/lib/definitions/flow.js"() {
      "use strict";
      var _utils = require_utils();
      var defineType = (0, _utils.defineAliasedType)("Flow");
      var defineInterfaceishType = (name41) => {
        defineType(name41, {
          builder: ["id", "typeParameters", "extends", "body"],
          visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
          aliases: ["FlowDeclaration", "Statement", "Declaration"],
          fields: {
            id: (0, _utils.validateType)("Identifier"),
            typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
            extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
            body: (0, _utils.validateType)("ObjectTypeAnnotation")
          }
        });
      };
      defineType("AnyTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ArrayTypeAnnotation", {
        visitor: ["elementType"],
        aliases: ["FlowType"],
        fields: {
          elementType: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("BooleanTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("BooleanLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("NullLiteralTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ClassImplements", {
        visitor: ["id", "typeParameters"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
        }
      });
      defineInterfaceishType("DeclareClass");
      defineType("DeclareFunction", {
        visitor: ["id"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
        }
      });
      defineInterfaceishType("DeclareInterface");
      defineType("DeclareModule", {
        builder: ["id", "body", "kind"],
        visitor: ["id", "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
          body: (0, _utils.validateType)("BlockStatement"),
          kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
        }
      });
      defineType("DeclareModuleExports", {
        visitor: ["typeAnnotation"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
        }
      });
      defineType("DeclareTypeAlias", {
        visitor: ["id", "typeParameters", "right"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          right: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("DeclareOpaqueType", {
        visitor: ["id", "typeParameters", "supertype"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          supertype: (0, _utils.validateOptionalType)("FlowType"),
          impltype: (0, _utils.validateOptionalType)("FlowType")
        }
      });
      defineType("DeclareVariable", {
        visitor: ["id"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier")
        }
      });
      defineType("DeclareExportDeclaration", {
        visitor: ["declaration", "specifiers", "source"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          declaration: (0, _utils.validateOptionalType)("Flow"),
          specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
          source: (0, _utils.validateOptionalType)("StringLiteral"),
          default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("DeclareExportAllDeclaration", {
        visitor: ["source"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          source: (0, _utils.validateType)("StringLiteral"),
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
        }
      });
      defineType("DeclaredPredicate", {
        visitor: ["value"],
        aliases: ["FlowPredicate"],
        fields: {
          value: (0, _utils.validateType)("Flow")
        }
      });
      defineType("ExistsTypeAnnotation", {
        aliases: ["FlowType"]
      });
      defineType("FunctionTypeAnnotation", {
        visitor: ["typeParameters", "params", "rest", "returnType"],
        aliases: ["FlowType"],
        fields: {
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
          rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
          this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
          returnType: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("FunctionTypeParam", {
        visitor: ["name", "typeAnnotation"],
        fields: {
          name: (0, _utils.validateOptionalType)("Identifier"),
          typeAnnotation: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("GenericTypeAnnotation", {
        visitor: ["id", "typeParameters"],
        aliases: ["FlowType"],
        fields: {
          id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
        }
      });
      defineType("InferredPredicate", {
        aliases: ["FlowPredicate"]
      });
      defineType("InterfaceExtends", {
        visitor: ["id", "typeParameters"],
        fields: {
          id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
        }
      });
      defineInterfaceishType("InterfaceDeclaration");
      defineType("InterfaceTypeAnnotation", {
        visitor: ["extends", "body"],
        aliases: ["FlowType"],
        fields: {
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        }
      });
      defineType("IntersectionTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("MixedTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("EmptyTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("NullableTypeAnnotation", {
        visitor: ["typeAnnotation"],
        aliases: ["FlowType"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("NumberLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
        }
      });
      defineType("NumberTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ObjectTypeAnnotation", {
        visitor: ["properties", "indexers", "callProperties", "internalSlots"],
        aliases: ["FlowType"],
        builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
        fields: {
          properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
          indexers: {
            validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
            optional: true,
            default: []
          },
          callProperties: {
            validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
            optional: true,
            default: []
          },
          internalSlots: {
            validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
            optional: true,
            default: []
          },
          exact: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
          },
          inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeInternalSlot", {
        visitor: ["id", "value", "optional", "static", "method"],
        aliases: ["UserWhitespacable"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          value: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeCallProperty", {
        visitor: ["value"],
        aliases: ["UserWhitespacable"],
        fields: {
          value: (0, _utils.validateType)("FlowType"),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeIndexer", {
        visitor: ["id", "key", "value", "variance"],
        aliases: ["UserWhitespacable"],
        fields: {
          id: (0, _utils.validateOptionalType)("Identifier"),
          key: (0, _utils.validateType)("FlowType"),
          value: (0, _utils.validateType)("FlowType"),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          variance: (0, _utils.validateOptionalType)("Variance")
        }
      });
      defineType("ObjectTypeProperty", {
        visitor: ["key", "value", "variance"],
        aliases: ["UserWhitespacable"],
        fields: {
          key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
          value: (0, _utils.validateType)("FlowType"),
          kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          variance: (0, _utils.validateOptionalType)("Variance"),
          method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeSpreadProperty", {
        visitor: ["argument"],
        aliases: ["UserWhitespacable"],
        fields: {
          argument: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("OpaqueType", {
        visitor: ["id", "typeParameters", "supertype", "impltype"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          supertype: (0, _utils.validateOptionalType)("FlowType"),
          impltype: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("QualifiedTypeIdentifier", {
        visitor: ["id", "qualification"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
        }
      });
      defineType("StringLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
        }
      });
      defineType("StringTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("SymbolTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ThisTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("TupleTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("TypeofTypeAnnotation", {
        visitor: ["argument"],
        aliases: ["FlowType"],
        fields: {
          argument: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("TypeAlias", {
        visitor: ["id", "typeParameters", "right"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          right: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("TypeAnnotation", {
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("TypeCastExpression", {
        visitor: ["expression", "typeAnnotation"],
        aliases: ["ExpressionWrapper", "Expression"],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
        }
      });
      defineType("TypeParameter", {
        visitor: ["bound", "default", "variance"],
        fields: {
          name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
          bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
          default: (0, _utils.validateOptionalType)("FlowType"),
          variance: (0, _utils.validateOptionalType)("Variance")
        }
      });
      defineType("TypeParameterDeclaration", {
        visitor: ["params"],
        fields: {
          params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
        }
      });
      defineType("TypeParameterInstantiation", {
        visitor: ["params"],
        fields: {
          params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("UnionTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("Variance", {
        builder: ["kind"],
        fields: {
          kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
        }
      });
      defineType("VoidTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("EnumDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "body"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
        }
      });
      defineType("EnumBooleanBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("EnumNumberBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("EnumStringBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("EnumSymbolBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("EnumBooleanMember", {
        aliases: ["EnumMember"],
        visitor: ["id"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("BooleanLiteral")
        }
      });
      defineType("EnumNumberMember", {
        aliases: ["EnumMember"],
        visitor: ["id", "init"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("NumericLiteral")
        }
      });
      defineType("EnumStringMember", {
        aliases: ["EnumMember"],
        visitor: ["id", "init"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("StringLiteral")
        }
      });
      defineType("EnumDefaultedMember", {
        aliases: ["EnumMember"],
        visitor: ["id"],
        fields: {
          id: (0, _utils.validateType)("Identifier")
        }
      });
      defineType("IndexedAccessType", {
        visitor: ["objectType", "indexType"],
        aliases: ["FlowType"],
        fields: {
          objectType: (0, _utils.validateType)("FlowType"),
          indexType: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("OptionalIndexedAccessType", {
        visitor: ["objectType", "indexType"],
        aliases: ["FlowType"],
        fields: {
          objectType: (0, _utils.validateType)("FlowType"),
          indexType: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
    }
  });

  // node_modules/@babel/types/lib/definitions/jsx.js
  var require_jsx = __commonJS({
    "node_modules/@babel/types/lib/definitions/jsx.js"() {
      "use strict";
      var _utils = require_utils();
      var defineType = (0, _utils.defineAliasedType)("JSX");
      defineType("JSXAttribute", {
        visitor: ["name", "value"],
        aliases: ["Immutable"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
          },
          value: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
          }
        }
      });
      defineType("JSXClosingElement", {
        visitor: ["name"],
        aliases: ["Immutable"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
          }
        }
      });
      defineType("JSXElement", {
        builder: ["openingElement", "closingElement", "children", "selfClosing"],
        visitor: ["openingElement", "children", "closingElement"],
        aliases: ["Immutable", "Expression"],
        fields: Object.assign({
          openingElement: {
            validate: (0, _utils.assertNodeType)("JSXOpeningElement")
          },
          closingElement: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXClosingElement")
          },
          children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
          }
        }, {
          selfClosing: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        })
      });
      defineType("JSXEmptyExpression", {});
      defineType("JSXExpressionContainer", {
        visitor: ["expression"],
        aliases: ["Immutable"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
          }
        }
      });
      defineType("JSXSpreadChild", {
        visitor: ["expression"],
        aliases: ["Immutable"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("JSXIdentifier", {
        builder: ["name"],
        fields: {
          name: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
      defineType("JSXMemberExpression", {
        visitor: ["object", "property"],
        fields: {
          object: {
            validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
          },
          property: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
          }
        }
      });
      defineType("JSXNamespacedName", {
        visitor: ["namespace", "name"],
        fields: {
          namespace: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
          },
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
          }
        }
      });
      defineType("JSXOpeningElement", {
        builder: ["name", "attributes", "selfClosing"],
        visitor: ["name", "attributes"],
        aliases: ["Immutable"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
          },
          selfClosing: {
            default: false
          },
          attributes: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
          }
        }
      });
      defineType("JSXSpreadAttribute", {
        visitor: ["argument"],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("JSXText", {
        aliases: ["Immutable"],
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
      defineType("JSXFragment", {
        builder: ["openingFragment", "closingFragment", "children"],
        visitor: ["openingFragment", "children", "closingFragment"],
        aliases: ["Immutable", "Expression"],
        fields: {
          openingFragment: {
            validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
          },
          closingFragment: {
            validate: (0, _utils.assertNodeType)("JSXClosingFragment")
          },
          children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
          }
        }
      });
      defineType("JSXOpeningFragment", {
        aliases: ["Immutable"]
      });
      defineType("JSXClosingFragment", {
        aliases: ["Immutable"]
      });
    }
  });

  // node_modules/@babel/types/lib/definitions/placeholders.js
  var require_placeholders = __commonJS({
    "node_modules/@babel/types/lib/definitions/placeholders.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
      var _utils = require_utils();
      var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
      exports.PLACEHOLDERS = PLACEHOLDERS;
      var PLACEHOLDERS_ALIAS = {
        Declaration: ["Statement"],
        Pattern: ["PatternLike", "LVal"]
      };
      exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
      for (const type of PLACEHOLDERS) {
        const alias = _utils.ALIAS_KEYS[type];
        if (alias != null && alias.length)
          PLACEHOLDERS_ALIAS[type] = alias;
      }
      var PLACEHOLDERS_FLIPPED_ALIAS = {};
      exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
      Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
        PLACEHOLDERS_ALIAS[type].forEach((alias) => {
          if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
            PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
          }
          PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
        });
      });
    }
  });

  // node_modules/@babel/types/lib/definitions/misc.js
  var require_misc = __commonJS({
    "node_modules/@babel/types/lib/definitions/misc.js"() {
      "use strict";
      var _utils = require_utils();
      var _placeholders = require_placeholders();
      var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
      {
        defineType("Noop", {
          visitor: []
        });
      }
      defineType("Placeholder", {
        visitor: [],
        builder: ["expectedNode", "name"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          expectedNode: {
            validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
          }
        }
      });
      defineType("V8IntrinsicIdentifier", {
        builder: ["name"],
        fields: {
          name: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
    }
  });

  // node_modules/@babel/types/lib/definitions/experimental.js
  var require_experimental = __commonJS({
    "node_modules/@babel/types/lib/definitions/experimental.js"() {
      "use strict";
      var _utils = require_utils();
      (0, _utils.default)("ArgumentPlaceholder", {});
      (0, _utils.default)("BindExpression", {
        visitor: ["object", "callee"],
        aliases: ["Expression"],
        fields: !process.env.BABEL_TYPES_8_BREAKING ? {
          object: {
            validate: Object.assign(() => {
            }, {
              oneOfNodeTypes: ["Expression"]
            })
          },
          callee: {
            validate: Object.assign(() => {
            }, {
              oneOfNodeTypes: ["Expression"]
            })
          }
        } : {
          object: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          callee: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      (0, _utils.default)("ImportAttribute", {
        visitor: ["key", "value"],
        fields: {
          key: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          value: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
          }
        }
      });
      (0, _utils.default)("Decorator", {
        visitor: ["expression"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      (0, _utils.default)("DoExpression", {
        visitor: ["body"],
        builder: ["body", "async"],
        aliases: ["Expression"],
        fields: {
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          },
          async: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
          }
        }
      });
      (0, _utils.default)("ExportDefaultSpecifier", {
        visitor: ["exported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      (0, _utils.default)("RecordExpression", {
        visitor: ["properties"],
        aliases: ["Expression"],
        fields: {
          properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
          }
        }
      });
      (0, _utils.default)("TupleExpression", {
        fields: {
          elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
            default: []
          }
        },
        visitor: ["elements"],
        aliases: ["Expression"]
      });
      (0, _utils.default)("DecimalLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      (0, _utils.default)("ModuleExpression", {
        visitor: ["body"],
        fields: {
          body: {
            validate: (0, _utils.assertNodeType)("Program")
          }
        },
        aliases: ["Expression"]
      });
      (0, _utils.default)("TopicReference", {
        aliases: ["Expression"]
      });
      (0, _utils.default)("PipelineTopicExpression", {
        builder: ["expression"],
        visitor: ["expression"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: ["Expression"]
      });
      (0, _utils.default)("PipelineBareFunction", {
        builder: ["callee"],
        visitor: ["callee"],
        fields: {
          callee: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: ["Expression"]
      });
      (0, _utils.default)("PipelinePrimaryTopicReference", {
        aliases: ["Expression"]
      });
    }
  });

  // node_modules/@babel/types/lib/definitions/typescript.js
  var require_typescript = __commonJS({
    "node_modules/@babel/types/lib/definitions/typescript.js"() {
      "use strict";
      var _utils = require_utils();
      var _core = require_core();
      var _is = require_is();
      var defineType = (0, _utils.defineAliasedType)("TypeScript");
      var bool = (0, _utils.assertValueType)("boolean");
      var tSFunctionTypeAnnotationCommon = () => ({
        returnType: {
          validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
          optional: true
        }
      });
      defineType("TSParameterProperty", {
        aliases: ["LVal"],
        visitor: ["parameter"],
        fields: {
          accessibility: {
            validate: (0, _utils.assertOneOf)("public", "private", "protected"),
            optional: true
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          parameter: {
            validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
          },
          override: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          }
        }
      });
      defineType("TSDeclareFunction", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "params", "returnType"],
        fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
      });
      defineType("TSDeclareMethod", {
        visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
        fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
      });
      defineType("TSQualifiedName", {
        aliases: ["TSEntityName"],
        visitor: ["left", "right"],
        fields: {
          left: (0, _utils.validateType)("TSEntityName"),
          right: (0, _utils.validateType)("Identifier")
        }
      });
      var signatureDeclarationCommon = () => ({
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        ["parameters"]: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
        ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      });
      var callConstructSignatureDeclaration = {
        aliases: ["TSTypeElement"],
        visitor: ["typeParameters", "parameters", "typeAnnotation"],
        fields: signatureDeclarationCommon()
      };
      defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
      defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
      var namedTypeElementCommon = () => ({
        key: (0, _utils.validateType)("Expression"),
        computed: {
          default: false
        },
        optional: (0, _utils.validateOptional)(bool)
      });
      defineType("TSPropertySignature", {
        aliases: ["TSTypeElement"],
        visitor: ["key", "typeAnnotation", "initializer"],
        fields: Object.assign({}, namedTypeElementCommon(), {
          readonly: (0, _utils.validateOptional)(bool),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
          initializer: (0, _utils.validateOptionalType)("Expression"),
          kind: {
            validate: (0, _utils.assertOneOf)("get", "set")
          }
        })
      });
      defineType("TSMethodSignature", {
        aliases: ["TSTypeElement"],
        visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
        fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
          kind: {
            validate: (0, _utils.assertOneOf)("method", "get", "set")
          }
        })
      });
      defineType("TSIndexSignature", {
        aliases: ["TSTypeElement"],
        visitor: ["parameters", "typeAnnotation"],
        fields: {
          readonly: (0, _utils.validateOptional)(bool),
          static: (0, _utils.validateOptional)(bool),
          parameters: (0, _utils.validateArrayOfType)("Identifier"),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
        }
      });
      var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
      for (const type of tsKeywordTypes) {
        defineType(type, {
          aliases: ["TSType", "TSBaseType"],
          visitor: [],
          fields: {}
        });
      }
      defineType("TSThisType", {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
      var fnOrCtrBase = {
        aliases: ["TSType"],
        visitor: ["typeParameters", "parameters", "typeAnnotation"]
      };
      defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
        fields: signatureDeclarationCommon()
      }));
      defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
        fields: Object.assign({}, signatureDeclarationCommon(), {
          abstract: (0, _utils.validateOptional)(bool)
        })
      }));
      defineType("TSTypeReference", {
        aliases: ["TSType"],
        visitor: ["typeName", "typeParameters"],
        fields: {
          typeName: (0, _utils.validateType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
      defineType("TSTypePredicate", {
        aliases: ["TSType"],
        visitor: ["parameterName", "typeAnnotation"],
        builder: ["parameterName", "typeAnnotation", "asserts"],
        fields: {
          parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
          asserts: (0, _utils.validateOptional)(bool)
        }
      });
      defineType("TSTypeQuery", {
        aliases: ["TSType"],
        visitor: ["exprName", "typeParameters"],
        fields: {
          exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
      defineType("TSTypeLiteral", {
        aliases: ["TSType"],
        visitor: ["members"],
        fields: {
          members: (0, _utils.validateArrayOfType)("TSTypeElement")
        }
      });
      defineType("TSArrayType", {
        aliases: ["TSType"],
        visitor: ["elementType"],
        fields: {
          elementType: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSTupleType", {
        aliases: ["TSType"],
        visitor: ["elementTypes"],
        fields: {
          elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
        }
      });
      defineType("TSOptionalType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSRestType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSNamedTupleMember", {
        visitor: ["label", "elementType"],
        builder: ["label", "elementType", "optional"],
        fields: {
          label: (0, _utils.validateType)("Identifier"),
          optional: {
            validate: bool,
            default: false
          },
          elementType: (0, _utils.validateType)("TSType")
        }
      });
      var unionOrIntersection = {
        aliases: ["TSType"],
        visitor: ["types"],
        fields: {
          types: (0, _utils.validateArrayOfType)("TSType")
        }
      };
      defineType("TSUnionType", unionOrIntersection);
      defineType("TSIntersectionType", unionOrIntersection);
      defineType("TSConditionalType", {
        aliases: ["TSType"],
        visitor: ["checkType", "extendsType", "trueType", "falseType"],
        fields: {
          checkType: (0, _utils.validateType)("TSType"),
          extendsType: (0, _utils.validateType)("TSType"),
          trueType: (0, _utils.validateType)("TSType"),
          falseType: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSInferType", {
        aliases: ["TSType"],
        visitor: ["typeParameter"],
        fields: {
          typeParameter: (0, _utils.validateType)("TSTypeParameter")
        }
      });
      defineType("TSParenthesizedType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSTypeOperator", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {
          operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSIndexedAccessType", {
        aliases: ["TSType"],
        visitor: ["objectType", "indexType"],
        fields: {
          objectType: (0, _utils.validateType)("TSType"),
          indexType: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSMappedType", {
        aliases: ["TSType"],
        visitor: ["typeParameter", "typeAnnotation", "nameType"],
        fields: {
          readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
          typeParameter: (0, _utils.validateType)("TSTypeParameter"),
          optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
          typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
          nameType: (0, _utils.validateOptionalType)("TSType")
        }
      });
      defineType("TSLiteralType", {
        aliases: ["TSType", "TSBaseType"],
        visitor: ["literal"],
        fields: {
          literal: {
            validate: function() {
              const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
              const unaryOperator = (0, _utils.assertOneOf)("-");
              const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
              function validator(parent, key, node) {
                if ((0, _is.default)("UnaryExpression", node)) {
                  unaryOperator(node, "operator", node.operator);
                  unaryExpression(node, "argument", node.argument);
                } else {
                  literal(parent, key, node);
                }
              }
              validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
              return validator;
            }()
          }
        }
      });
      defineType("TSExpressionWithTypeArguments", {
        aliases: ["TSType"],
        visitor: ["expression", "typeParameters"],
        fields: {
          expression: (0, _utils.validateType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
      defineType("TSInterfaceDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "extends", "body"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
          body: (0, _utils.validateType)("TSInterfaceBody")
        }
      });
      defineType("TSInterfaceBody", {
        visitor: ["body"],
        fields: {
          body: (0, _utils.validateArrayOfType)("TSTypeElement")
        }
      });
      defineType("TSTypeAliasDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "typeAnnotation"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSInstantiationExpression", {
        aliases: ["Expression"],
        visitor: ["expression", "typeParameters"],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
      var TSTypeExpression = {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["expression", "typeAnnotation"],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      };
      defineType("TSAsExpression", TSTypeExpression);
      defineType("TSSatisfiesExpression", TSTypeExpression);
      defineType("TSTypeAssertion", {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["typeAnnotation", "expression"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType"),
          expression: (0, _utils.validateType)("Expression")
        }
      });
      defineType("TSEnumDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "members"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          const: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          members: (0, _utils.validateArrayOfType)("TSEnumMember"),
          initializer: (0, _utils.validateOptionalType)("Expression")
        }
      });
      defineType("TSEnumMember", {
        visitor: ["id", "initializer"],
        fields: {
          id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
          initializer: (0, _utils.validateOptionalType)("Expression")
        }
      });
      defineType("TSModuleDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "body"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          global: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
          body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
        }
      });
      defineType("TSModuleBlock", {
        aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
        visitor: ["body"],
        fields: {
          body: (0, _utils.validateArrayOfType)("Statement")
        }
      });
      defineType("TSImportType", {
        aliases: ["TSType"],
        visitor: ["argument", "qualifier", "typeParameters"],
        fields: {
          argument: (0, _utils.validateType)("StringLiteral"),
          qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
      defineType("TSImportEqualsDeclaration", {
        aliases: ["Statement"],
        visitor: ["id", "moduleReference"],
        fields: {
          isExport: (0, _utils.validate)(bool),
          id: (0, _utils.validateType)("Identifier"),
          moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]),
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
          }
        }
      });
      defineType("TSExternalModuleReference", {
        visitor: ["expression"],
        fields: {
          expression: (0, _utils.validateType)("StringLiteral")
        }
      });
      defineType("TSNonNullExpression", {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["expression"],
        fields: {
          expression: (0, _utils.validateType)("Expression")
        }
      });
      defineType("TSExportAssignment", {
        aliases: ["Statement"],
        visitor: ["expression"],
        fields: {
          expression: (0, _utils.validateType)("Expression")
        }
      });
      defineType("TSNamespaceExportDeclaration", {
        aliases: ["Statement"],
        visitor: ["id"],
        fields: {
          id: (0, _utils.validateType)("Identifier")
        }
      });
      defineType("TSTypeAnnotation", {
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TSType")
          }
        }
      });
      defineType("TSTypeParameterInstantiation", {
        visitor: ["params"],
        fields: {
          params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
          }
        }
      });
      defineType("TSTypeParameterDeclaration", {
        visitor: ["params"],
        fields: {
          params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
          }
        }
      });
      defineType("TSTypeParameter", {
        builder: ["constraint", "default", "name"],
        visitor: ["constraint", "default"],
        fields: {
          name: {
            validate: (0, _utils.assertValueType)("string")
          },
          in: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          out: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          constraint: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
          },
          default: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
          }
        }
      });
    }
  });

  // node_modules/@babel/types/lib/definitions/index.js
  var require_definitions = __commonJS({
    "node_modules/@babel/types/lib/definitions/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "ALIAS_KEYS", {
        enumerable: true,
        get: function() {
          return _utils.ALIAS_KEYS;
        }
      });
      Object.defineProperty(exports, "BUILDER_KEYS", {
        enumerable: true,
        get: function() {
          return _utils.BUILDER_KEYS;
        }
      });
      Object.defineProperty(exports, "DEPRECATED_KEYS", {
        enumerable: true,
        get: function() {
          return _utils.DEPRECATED_KEYS;
        }
      });
      Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
        enumerable: true,
        get: function() {
          return _utils.FLIPPED_ALIAS_KEYS;
        }
      });
      Object.defineProperty(exports, "NODE_FIELDS", {
        enumerable: true,
        get: function() {
          return _utils.NODE_FIELDS;
        }
      });
      Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
        enumerable: true,
        get: function() {
          return _utils.NODE_PARENT_VALIDATIONS;
        }
      });
      Object.defineProperty(exports, "PLACEHOLDERS", {
        enumerable: true,
        get: function() {
          return _placeholders.PLACEHOLDERS;
        }
      });
      Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
        enumerable: true,
        get: function() {
          return _placeholders.PLACEHOLDERS_ALIAS;
        }
      });
      Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
        enumerable: true,
        get: function() {
          return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
        }
      });
      exports.TYPES = void 0;
      Object.defineProperty(exports, "VISITOR_KEYS", {
        enumerable: true,
        get: function() {
          return _utils.VISITOR_KEYS;
        }
      });
      var _toFastProperties = require_to_fast_properties();
      require_core();
      require_flow();
      require_jsx();
      require_misc();
      require_experimental();
      require_typescript();
      var _utils = require_utils();
      var _placeholders = require_placeholders();
      _toFastProperties(_utils.VISITOR_KEYS);
      _toFastProperties(_utils.ALIAS_KEYS);
      _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
      _toFastProperties(_utils.NODE_FIELDS);
      _toFastProperties(_utils.BUILDER_KEYS);
      _toFastProperties(_utils.DEPRECATED_KEYS);
      _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
      _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
      var TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
      exports.TYPES = TYPES;
    }
  });

  // node_modules/@babel/types/lib/validators/validate.js
  var require_validate = __commonJS({
    "node_modules/@babel/types/lib/validators/validate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = validate;
      exports.validateChild = validateChild;
      exports.validateField = validateField;
      var _definitions = require_definitions();
      function validate(node, key, val) {
        if (!node)
          return;
        const fields = _definitions.NODE_FIELDS[node.type];
        if (!fields)
          return;
        const field = fields[key];
        validateField(node, key, val, field);
        validateChild(node, key, val);
      }
      function validateField(node, key, val, field) {
        if (!(field != null && field.validate))
          return;
        if (field.optional && val == null)
          return;
        field.validate(node, key, val);
      }
      function validateChild(node, key, val) {
        if (val == null)
          return;
        const validate2 = _definitions.NODE_PARENT_VALIDATIONS[val.type];
        if (!validate2)
          return;
        validate2(node, key, val);
      }
    }
  });

  // node_modules/@babel/types/lib/builders/validateNode.js
  var require_validateNode = __commonJS({
    "node_modules/@babel/types/lib/builders/validateNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = validateNode;
      var _validate = require_validate();
      var _ = require_lib4();
      function validateNode(node) {
        const keys = _.BUILDER_KEYS[node.type];
        for (const key of keys) {
          (0, _validate.default)(node, key, node[key]);
        }
        return node;
      }
    }
  });

  // node_modules/@babel/types/lib/builders/generated/index.js
  var require_generated2 = __commonJS({
    "node_modules/@babel/types/lib/builders/generated/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.anyTypeAnnotation = anyTypeAnnotation;
      exports.argumentPlaceholder = argumentPlaceholder;
      exports.arrayExpression = arrayExpression2;
      exports.arrayPattern = arrayPattern;
      exports.arrayTypeAnnotation = arrayTypeAnnotation;
      exports.arrowFunctionExpression = arrowFunctionExpression4;
      exports.assignmentExpression = assignmentExpression;
      exports.assignmentPattern = assignmentPattern;
      exports.awaitExpression = awaitExpression;
      exports.bigIntLiteral = bigIntLiteral;
      exports.binaryExpression = binaryExpression;
      exports.bindExpression = bindExpression;
      exports.blockStatement = blockStatement2;
      exports.booleanLiteral = booleanLiteral;
      exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
      exports.booleanTypeAnnotation = booleanTypeAnnotation;
      exports.breakStatement = breakStatement;
      exports.callExpression = callExpression4;
      exports.catchClause = catchClause;
      exports.classAccessorProperty = classAccessorProperty;
      exports.classBody = classBody;
      exports.classDeclaration = classDeclaration;
      exports.classExpression = classExpression;
      exports.classImplements = classImplements;
      exports.classMethod = classMethod;
      exports.classPrivateMethod = classPrivateMethod;
      exports.classPrivateProperty = classPrivateProperty;
      exports.classProperty = classProperty;
      exports.conditionalExpression = conditionalExpression2;
      exports.continueStatement = continueStatement;
      exports.debuggerStatement = debuggerStatement;
      exports.decimalLiteral = decimalLiteral;
      exports.declareClass = declareClass;
      exports.declareExportAllDeclaration = declareExportAllDeclaration;
      exports.declareExportDeclaration = declareExportDeclaration;
      exports.declareFunction = declareFunction;
      exports.declareInterface = declareInterface;
      exports.declareModule = declareModule;
      exports.declareModuleExports = declareModuleExports;
      exports.declareOpaqueType = declareOpaqueType;
      exports.declareTypeAlias = declareTypeAlias;
      exports.declareVariable = declareVariable;
      exports.declaredPredicate = declaredPredicate;
      exports.decorator = decorator;
      exports.directive = directive;
      exports.directiveLiteral = directiveLiteral;
      exports.doExpression = doExpression;
      exports.doWhileStatement = doWhileStatement;
      exports.emptyStatement = emptyStatement;
      exports.emptyTypeAnnotation = emptyTypeAnnotation;
      exports.enumBooleanBody = enumBooleanBody;
      exports.enumBooleanMember = enumBooleanMember;
      exports.enumDeclaration = enumDeclaration;
      exports.enumDefaultedMember = enumDefaultedMember;
      exports.enumNumberBody = enumNumberBody;
      exports.enumNumberMember = enumNumberMember;
      exports.enumStringBody = enumStringBody;
      exports.enumStringMember = enumStringMember;
      exports.enumSymbolBody = enumSymbolBody;
      exports.existsTypeAnnotation = existsTypeAnnotation;
      exports.exportAllDeclaration = exportAllDeclaration;
      exports.exportDefaultDeclaration = exportDefaultDeclaration2;
      exports.exportDefaultSpecifier = exportDefaultSpecifier;
      exports.exportNamedDeclaration = exportNamedDeclaration;
      exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
      exports.exportSpecifier = exportSpecifier;
      exports.expressionStatement = expressionStatement2;
      exports.file = file;
      exports.forInStatement = forInStatement;
      exports.forOfStatement = forOfStatement;
      exports.forStatement = forStatement;
      exports.functionDeclaration = functionDeclaration;
      exports.functionExpression = functionExpression;
      exports.functionTypeAnnotation = functionTypeAnnotation;
      exports.functionTypeParam = functionTypeParam;
      exports.genericTypeAnnotation = genericTypeAnnotation;
      exports.identifier = identifier4;
      exports.ifStatement = ifStatement;
      exports.import = _import;
      exports.importAttribute = importAttribute;
      exports.importDeclaration = importDeclaration;
      exports.importDefaultSpecifier = importDefaultSpecifier;
      exports.importNamespaceSpecifier = importNamespaceSpecifier;
      exports.importSpecifier = importSpecifier;
      exports.indexedAccessType = indexedAccessType;
      exports.inferredPredicate = inferredPredicate;
      exports.interfaceDeclaration = interfaceDeclaration;
      exports.interfaceExtends = interfaceExtends;
      exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
      exports.interpreterDirective = interpreterDirective;
      exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
      exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
      exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
      exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
      exports.jSXElement = exports.jsxElement = jsxElement;
      exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
      exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
      exports.jSXFragment = exports.jsxFragment = jsxFragment;
      exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
      exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
      exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
      exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
      exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
      exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
      exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
      exports.jSXText = exports.jsxText = jsxText;
      exports.labeledStatement = labeledStatement;
      exports.logicalExpression = logicalExpression;
      exports.memberExpression = memberExpression2;
      exports.metaProperty = metaProperty;
      exports.mixedTypeAnnotation = mixedTypeAnnotation;
      exports.moduleExpression = moduleExpression;
      exports.newExpression = newExpression;
      exports.noop = noop4;
      exports.nullLiteral = nullLiteral;
      exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
      exports.nullableTypeAnnotation = nullableTypeAnnotation;
      exports.numberLiteral = NumberLiteral;
      exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
      exports.numberTypeAnnotation = numberTypeAnnotation;
      exports.numericLiteral = numericLiteral;
      exports.objectExpression = objectExpression2;
      exports.objectMethod = objectMethod;
      exports.objectPattern = objectPattern2;
      exports.objectProperty = objectProperty3;
      exports.objectTypeAnnotation = objectTypeAnnotation;
      exports.objectTypeCallProperty = objectTypeCallProperty;
      exports.objectTypeIndexer = objectTypeIndexer;
      exports.objectTypeInternalSlot = objectTypeInternalSlot;
      exports.objectTypeProperty = objectTypeProperty;
      exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
      exports.opaqueType = opaqueType;
      exports.optionalCallExpression = optionalCallExpression;
      exports.optionalIndexedAccessType = optionalIndexedAccessType;
      exports.optionalMemberExpression = optionalMemberExpression;
      exports.parenthesizedExpression = parenthesizedExpression;
      exports.pipelineBareFunction = pipelineBareFunction;
      exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
      exports.pipelineTopicExpression = pipelineTopicExpression;
      exports.placeholder = placeholder;
      exports.privateName = privateName;
      exports.program = program2;
      exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
      exports.recordExpression = recordExpression;
      exports.regExpLiteral = regExpLiteral;
      exports.regexLiteral = RegexLiteral;
      exports.restElement = restElement;
      exports.restProperty = RestProperty;
      exports.returnStatement = returnStatement2;
      exports.sequenceExpression = sequenceExpression;
      exports.spreadElement = spreadElement;
      exports.spreadProperty = SpreadProperty;
      exports.staticBlock = staticBlock;
      exports.stringLiteral = stringLiteral2;
      exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
      exports.stringTypeAnnotation = stringTypeAnnotation;
      exports.super = _super;
      exports.switchCase = switchCase;
      exports.switchStatement = switchStatement;
      exports.symbolTypeAnnotation = symbolTypeAnnotation;
      exports.taggedTemplateExpression = taggedTemplateExpression;
      exports.templateElement = templateElement;
      exports.templateLiteral = templateLiteral;
      exports.thisExpression = thisExpression;
      exports.thisTypeAnnotation = thisTypeAnnotation;
      exports.throwStatement = throwStatement;
      exports.topicReference = topicReference;
      exports.tryStatement = tryStatement;
      exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
      exports.tSArrayType = exports.tsArrayType = tsArrayType;
      exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
      exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
      exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
      exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
      exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
      exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
      exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
      exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
      exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
      exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
      exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
      exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
      exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
      exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
      exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
      exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
      exports.tSImportType = exports.tsImportType = tsImportType;
      exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
      exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
      exports.tSInferType = exports.tsInferType = tsInferType;
      exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
      exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
      exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
      exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
      exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
      exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
      exports.tSMappedType = exports.tsMappedType = tsMappedType;
      exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
      exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
      exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
      exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
      exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
      exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
      exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
      exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
      exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
      exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
      exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
      exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
      exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
      exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
      exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
      exports.tSRestType = exports.tsRestType = tsRestType;
      exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
      exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
      exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
      exports.tSThisType = exports.tsThisType = tsThisType;
      exports.tSTupleType = exports.tsTupleType = tsTupleType;
      exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
      exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
      exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
      exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
      exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
      exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
      exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
      exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
      exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
      exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
      exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
      exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
      exports.tSUnionType = exports.tsUnionType = tsUnionType;
      exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
      exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
      exports.tupleExpression = tupleExpression;
      exports.tupleTypeAnnotation = tupleTypeAnnotation;
      exports.typeAlias = typeAlias;
      exports.typeAnnotation = typeAnnotation;
      exports.typeCastExpression = typeCastExpression;
      exports.typeParameter = typeParameter;
      exports.typeParameterDeclaration = typeParameterDeclaration;
      exports.typeParameterInstantiation = typeParameterInstantiation;
      exports.typeofTypeAnnotation = typeofTypeAnnotation;
      exports.unaryExpression = unaryExpression;
      exports.unionTypeAnnotation = unionTypeAnnotation;
      exports.updateExpression = updateExpression;
      exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
      exports.variableDeclaration = variableDeclaration2;
      exports.variableDeclarator = variableDeclarator2;
      exports.variance = variance;
      exports.voidTypeAnnotation = voidTypeAnnotation;
      exports.whileStatement = whileStatement;
      exports.withStatement = withStatement;
      exports.yieldExpression = yieldExpression;
      var _validateNode = require_validateNode();
      function arrayExpression2(elements = []) {
        return (0, _validateNode.default)({
          type: "ArrayExpression",
          elements
        });
      }
      function assignmentExpression(operator, left, right) {
        return (0, _validateNode.default)({
          type: "AssignmentExpression",
          operator,
          left,
          right
        });
      }
      function binaryExpression(operator, left, right) {
        return (0, _validateNode.default)({
          type: "BinaryExpression",
          operator,
          left,
          right
        });
      }
      function interpreterDirective(value) {
        return (0, _validateNode.default)({
          type: "InterpreterDirective",
          value
        });
      }
      function directive(value) {
        return (0, _validateNode.default)({
          type: "Directive",
          value
        });
      }
      function directiveLiteral(value) {
        return (0, _validateNode.default)({
          type: "DirectiveLiteral",
          value
        });
      }
      function blockStatement2(body, directives = []) {
        return (0, _validateNode.default)({
          type: "BlockStatement",
          body,
          directives
        });
      }
      function breakStatement(label = null) {
        return (0, _validateNode.default)({
          type: "BreakStatement",
          label
        });
      }
      function callExpression4(callee, _arguments) {
        return (0, _validateNode.default)({
          type: "CallExpression",
          callee,
          arguments: _arguments
        });
      }
      function catchClause(param = null, body) {
        return (0, _validateNode.default)({
          type: "CatchClause",
          param,
          body
        });
      }
      function conditionalExpression2(test, consequent, alternate) {
        return (0, _validateNode.default)({
          type: "ConditionalExpression",
          test,
          consequent,
          alternate
        });
      }
      function continueStatement(label = null) {
        return (0, _validateNode.default)({
          type: "ContinueStatement",
          label
        });
      }
      function debuggerStatement() {
        return {
          type: "DebuggerStatement"
        };
      }
      function doWhileStatement(test, body) {
        return (0, _validateNode.default)({
          type: "DoWhileStatement",
          test,
          body
        });
      }
      function emptyStatement() {
        return {
          type: "EmptyStatement"
        };
      }
      function expressionStatement2(expression) {
        return (0, _validateNode.default)({
          type: "ExpressionStatement",
          expression
        });
      }
      function file(program3, comments = null, tokens = null) {
        return (0, _validateNode.default)({
          type: "File",
          program: program3,
          comments,
          tokens
        });
      }
      function forInStatement(left, right, body) {
        return (0, _validateNode.default)({
          type: "ForInStatement",
          left,
          right,
          body
        });
      }
      function forStatement(init = null, test = null, update = null, body) {
        return (0, _validateNode.default)({
          type: "ForStatement",
          init,
          test,
          update,
          body
        });
      }
      function functionDeclaration(id = null, params, body, generator = false, async = false) {
        return (0, _validateNode.default)({
          type: "FunctionDeclaration",
          id,
          params,
          body,
          generator,
          async
        });
      }
      function functionExpression(id = null, params, body, generator = false, async = false) {
        return (0, _validateNode.default)({
          type: "FunctionExpression",
          id,
          params,
          body,
          generator,
          async
        });
      }
      function identifier4(name41) {
        return (0, _validateNode.default)({
          type: "Identifier",
          name: name41
        });
      }
      function ifStatement(test, consequent, alternate = null) {
        return (0, _validateNode.default)({
          type: "IfStatement",
          test,
          consequent,
          alternate
        });
      }
      function labeledStatement(label, body) {
        return (0, _validateNode.default)({
          type: "LabeledStatement",
          label,
          body
        });
      }
      function stringLiteral2(value) {
        return (0, _validateNode.default)({
          type: "StringLiteral",
          value
        });
      }
      function numericLiteral(value) {
        return (0, _validateNode.default)({
          type: "NumericLiteral",
          value
        });
      }
      function nullLiteral() {
        return {
          type: "NullLiteral"
        };
      }
      function booleanLiteral(value) {
        return (0, _validateNode.default)({
          type: "BooleanLiteral",
          value
        });
      }
      function regExpLiteral(pattern, flags = "") {
        return (0, _validateNode.default)({
          type: "RegExpLiteral",
          pattern,
          flags
        });
      }
      function logicalExpression(operator, left, right) {
        return (0, _validateNode.default)({
          type: "LogicalExpression",
          operator,
          left,
          right
        });
      }
      function memberExpression2(object, property2, computed2 = false, optional = null) {
        return (0, _validateNode.default)({
          type: "MemberExpression",
          object,
          property: property2,
          computed: computed2,
          optional
        });
      }
      function newExpression(callee, _arguments) {
        return (0, _validateNode.default)({
          type: "NewExpression",
          callee,
          arguments: _arguments
        });
      }
      function program2(body, directives = [], sourceType = "script", interpreter = null) {
        return (0, _validateNode.default)({
          type: "Program",
          body,
          directives,
          sourceType,
          interpreter,
          sourceFile: null
        });
      }
      function objectExpression2(properties2) {
        return (0, _validateNode.default)({
          type: "ObjectExpression",
          properties: properties2
        });
      }
      function objectMethod(kind = "method", key, params, body, computed2 = false, generator = false, async = false) {
        return (0, _validateNode.default)({
          type: "ObjectMethod",
          kind,
          key,
          params,
          body,
          computed: computed2,
          generator,
          async
        });
      }
      function objectProperty3(key, value, computed2 = false, shorthand = false, decorators = null) {
        return (0, _validateNode.default)({
          type: "ObjectProperty",
          key,
          value,
          computed: computed2,
          shorthand,
          decorators
        });
      }
      function restElement(argument) {
        return (0, _validateNode.default)({
          type: "RestElement",
          argument
        });
      }
      function returnStatement2(argument = null) {
        return (0, _validateNode.default)({
          type: "ReturnStatement",
          argument
        });
      }
      function sequenceExpression(expressions) {
        return (0, _validateNode.default)({
          type: "SequenceExpression",
          expressions
        });
      }
      function parenthesizedExpression(expression) {
        return (0, _validateNode.default)({
          type: "ParenthesizedExpression",
          expression
        });
      }
      function switchCase(test = null, consequent) {
        return (0, _validateNode.default)({
          type: "SwitchCase",
          test,
          consequent
        });
      }
      function switchStatement(discriminant, cases) {
        return (0, _validateNode.default)({
          type: "SwitchStatement",
          discriminant,
          cases
        });
      }
      function thisExpression() {
        return {
          type: "ThisExpression"
        };
      }
      function throwStatement(argument) {
        return (0, _validateNode.default)({
          type: "ThrowStatement",
          argument
        });
      }
      function tryStatement(block, handler = null, finalizer = null) {
        return (0, _validateNode.default)({
          type: "TryStatement",
          block,
          handler,
          finalizer
        });
      }
      function unaryExpression(operator, argument, prefix = true) {
        return (0, _validateNode.default)({
          type: "UnaryExpression",
          operator,
          argument,
          prefix
        });
      }
      function updateExpression(operator, argument, prefix = false) {
        return (0, _validateNode.default)({
          type: "UpdateExpression",
          operator,
          argument,
          prefix
        });
      }
      function variableDeclaration2(kind, declarations) {
        return (0, _validateNode.default)({
          type: "VariableDeclaration",
          kind,
          declarations
        });
      }
      function variableDeclarator2(id, init = null) {
        return (0, _validateNode.default)({
          type: "VariableDeclarator",
          id,
          init
        });
      }
      function whileStatement(test, body) {
        return (0, _validateNode.default)({
          type: "WhileStatement",
          test,
          body
        });
      }
      function withStatement(object, body) {
        return (0, _validateNode.default)({
          type: "WithStatement",
          object,
          body
        });
      }
      function assignmentPattern(left, right) {
        return (0, _validateNode.default)({
          type: "AssignmentPattern",
          left,
          right
        });
      }
      function arrayPattern(elements) {
        return (0, _validateNode.default)({
          type: "ArrayPattern",
          elements
        });
      }
      function arrowFunctionExpression4(params, body, async = false) {
        return (0, _validateNode.default)({
          type: "ArrowFunctionExpression",
          params,
          body,
          async,
          expression: null
        });
      }
      function classBody(body) {
        return (0, _validateNode.default)({
          type: "ClassBody",
          body
        });
      }
      function classExpression(id = null, superClass = null, body, decorators = null) {
        return (0, _validateNode.default)({
          type: "ClassExpression",
          id,
          superClass,
          body,
          decorators
        });
      }
      function classDeclaration(id, superClass = null, body, decorators = null) {
        return (0, _validateNode.default)({
          type: "ClassDeclaration",
          id,
          superClass,
          body,
          decorators
        });
      }
      function exportAllDeclaration(source) {
        return (0, _validateNode.default)({
          type: "ExportAllDeclaration",
          source
        });
      }
      function exportDefaultDeclaration2(declaration) {
        return (0, _validateNode.default)({
          type: "ExportDefaultDeclaration",
          declaration
        });
      }
      function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
        return (0, _validateNode.default)({
          type: "ExportNamedDeclaration",
          declaration,
          specifiers,
          source
        });
      }
      function exportSpecifier(local, exported) {
        return (0, _validateNode.default)({
          type: "ExportSpecifier",
          local,
          exported
        });
      }
      function forOfStatement(left, right, body, _await = false) {
        return (0, _validateNode.default)({
          type: "ForOfStatement",
          left,
          right,
          body,
          await: _await
        });
      }
      function importDeclaration(specifiers, source) {
        return (0, _validateNode.default)({
          type: "ImportDeclaration",
          specifiers,
          source
        });
      }
      function importDefaultSpecifier(local) {
        return (0, _validateNode.default)({
          type: "ImportDefaultSpecifier",
          local
        });
      }
      function importNamespaceSpecifier(local) {
        return (0, _validateNode.default)({
          type: "ImportNamespaceSpecifier",
          local
        });
      }
      function importSpecifier(local, imported) {
        return (0, _validateNode.default)({
          type: "ImportSpecifier",
          local,
          imported
        });
      }
      function metaProperty(meta, property2) {
        return (0, _validateNode.default)({
          type: "MetaProperty",
          meta,
          property: property2
        });
      }
      function classMethod(kind = "method", key, params, body, computed2 = false, _static = false, generator = false, async = false) {
        return (0, _validateNode.default)({
          type: "ClassMethod",
          kind,
          key,
          params,
          body,
          computed: computed2,
          static: _static,
          generator,
          async
        });
      }
      function objectPattern2(properties2) {
        return (0, _validateNode.default)({
          type: "ObjectPattern",
          properties: properties2
        });
      }
      function spreadElement(argument) {
        return (0, _validateNode.default)({
          type: "SpreadElement",
          argument
        });
      }
      function _super() {
        return {
          type: "Super"
        };
      }
      function taggedTemplateExpression(tag, quasi) {
        return (0, _validateNode.default)({
          type: "TaggedTemplateExpression",
          tag,
          quasi
        });
      }
      function templateElement(value, tail = false) {
        return (0, _validateNode.default)({
          type: "TemplateElement",
          value,
          tail
        });
      }
      function templateLiteral(quasis, expressions) {
        return (0, _validateNode.default)({
          type: "TemplateLiteral",
          quasis,
          expressions
        });
      }
      function yieldExpression(argument = null, delegate = false) {
        return (0, _validateNode.default)({
          type: "YieldExpression",
          argument,
          delegate
        });
      }
      function awaitExpression(argument) {
        return (0, _validateNode.default)({
          type: "AwaitExpression",
          argument
        });
      }
      function _import() {
        return {
          type: "Import"
        };
      }
      function bigIntLiteral(value) {
        return (0, _validateNode.default)({
          type: "BigIntLiteral",
          value
        });
      }
      function exportNamespaceSpecifier(exported) {
        return (0, _validateNode.default)({
          type: "ExportNamespaceSpecifier",
          exported
        });
      }
      function optionalMemberExpression(object, property2, computed2 = false, optional) {
        return (0, _validateNode.default)({
          type: "OptionalMemberExpression",
          object,
          property: property2,
          computed: computed2,
          optional
        });
      }
      function optionalCallExpression(callee, _arguments, optional) {
        return (0, _validateNode.default)({
          type: "OptionalCallExpression",
          callee,
          arguments: _arguments,
          optional
        });
      }
      function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed2 = false, _static = false) {
        return (0, _validateNode.default)({
          type: "ClassProperty",
          key,
          value,
          typeAnnotation: typeAnnotation2,
          decorators,
          computed: computed2,
          static: _static
        });
      }
      function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed2 = false, _static = false) {
        return (0, _validateNode.default)({
          type: "ClassAccessorProperty",
          key,
          value,
          typeAnnotation: typeAnnotation2,
          decorators,
          computed: computed2,
          static: _static
        });
      }
      function classPrivateProperty(key, value = null, decorators = null, _static = false) {
        return (0, _validateNode.default)({
          type: "ClassPrivateProperty",
          key,
          value,
          decorators,
          static: _static
        });
      }
      function classPrivateMethod(kind = "method", key, params, body, _static = false) {
        return (0, _validateNode.default)({
          type: "ClassPrivateMethod",
          kind,
          key,
          params,
          body,
          static: _static
        });
      }
      function privateName(id) {
        return (0, _validateNode.default)({
          type: "PrivateName",
          id
        });
      }
      function staticBlock(body) {
        return (0, _validateNode.default)({
          type: "StaticBlock",
          body
        });
      }
      function anyTypeAnnotation() {
        return {
          type: "AnyTypeAnnotation"
        };
      }
      function arrayTypeAnnotation(elementType) {
        return (0, _validateNode.default)({
          type: "ArrayTypeAnnotation",
          elementType
        });
      }
      function booleanTypeAnnotation() {
        return {
          type: "BooleanTypeAnnotation"
        };
      }
      function booleanLiteralTypeAnnotation(value) {
        return (0, _validateNode.default)({
          type: "BooleanLiteralTypeAnnotation",
          value
        });
      }
      function nullLiteralTypeAnnotation() {
        return {
          type: "NullLiteralTypeAnnotation"
        };
      }
      function classImplements(id, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "ClassImplements",
          id,
          typeParameters
        });
      }
      function declareClass(id, typeParameters = null, _extends = null, body) {
        return (0, _validateNode.default)({
          type: "DeclareClass",
          id,
          typeParameters,
          extends: _extends,
          body
        });
      }
      function declareFunction(id) {
        return (0, _validateNode.default)({
          type: "DeclareFunction",
          id
        });
      }
      function declareInterface(id, typeParameters = null, _extends = null, body) {
        return (0, _validateNode.default)({
          type: "DeclareInterface",
          id,
          typeParameters,
          extends: _extends,
          body
        });
      }
      function declareModule(id, body, kind = null) {
        return (0, _validateNode.default)({
          type: "DeclareModule",
          id,
          body,
          kind
        });
      }
      function declareModuleExports(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "DeclareModuleExports",
          typeAnnotation: typeAnnotation2
        });
      }
      function declareTypeAlias(id, typeParameters = null, right) {
        return (0, _validateNode.default)({
          type: "DeclareTypeAlias",
          id,
          typeParameters,
          right
        });
      }
      function declareOpaqueType(id, typeParameters = null, supertype = null) {
        return (0, _validateNode.default)({
          type: "DeclareOpaqueType",
          id,
          typeParameters,
          supertype
        });
      }
      function declareVariable(id) {
        return (0, _validateNode.default)({
          type: "DeclareVariable",
          id
        });
      }
      function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
        return (0, _validateNode.default)({
          type: "DeclareExportDeclaration",
          declaration,
          specifiers,
          source
        });
      }
      function declareExportAllDeclaration(source) {
        return (0, _validateNode.default)({
          type: "DeclareExportAllDeclaration",
          source
        });
      }
      function declaredPredicate(value) {
        return (0, _validateNode.default)({
          type: "DeclaredPredicate",
          value
        });
      }
      function existsTypeAnnotation() {
        return {
          type: "ExistsTypeAnnotation"
        };
      }
      function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
        return (0, _validateNode.default)({
          type: "FunctionTypeAnnotation",
          typeParameters,
          params,
          rest,
          returnType
        });
      }
      function functionTypeParam(name41 = null, typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "FunctionTypeParam",
          name: name41,
          typeAnnotation: typeAnnotation2
        });
      }
      function genericTypeAnnotation(id, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "GenericTypeAnnotation",
          id,
          typeParameters
        });
      }
      function inferredPredicate() {
        return {
          type: "InferredPredicate"
        };
      }
      function interfaceExtends(id, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "InterfaceExtends",
          id,
          typeParameters
        });
      }
      function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
        return (0, _validateNode.default)({
          type: "InterfaceDeclaration",
          id,
          typeParameters,
          extends: _extends,
          body
        });
      }
      function interfaceTypeAnnotation(_extends = null, body) {
        return (0, _validateNode.default)({
          type: "InterfaceTypeAnnotation",
          extends: _extends,
          body
        });
      }
      function intersectionTypeAnnotation(types) {
        return (0, _validateNode.default)({
          type: "IntersectionTypeAnnotation",
          types
        });
      }
      function mixedTypeAnnotation() {
        return {
          type: "MixedTypeAnnotation"
        };
      }
      function emptyTypeAnnotation() {
        return {
          type: "EmptyTypeAnnotation"
        };
      }
      function nullableTypeAnnotation(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "NullableTypeAnnotation",
          typeAnnotation: typeAnnotation2
        });
      }
      function numberLiteralTypeAnnotation(value) {
        return (0, _validateNode.default)({
          type: "NumberLiteralTypeAnnotation",
          value
        });
      }
      function numberTypeAnnotation() {
        return {
          type: "NumberTypeAnnotation"
        };
      }
      function objectTypeAnnotation(properties2, indexers = [], callProperties = [], internalSlots = [], exact = false) {
        return (0, _validateNode.default)({
          type: "ObjectTypeAnnotation",
          properties: properties2,
          indexers,
          callProperties,
          internalSlots,
          exact
        });
      }
      function objectTypeInternalSlot(id, value, optional, _static, method) {
        return (0, _validateNode.default)({
          type: "ObjectTypeInternalSlot",
          id,
          value,
          optional,
          static: _static,
          method
        });
      }
      function objectTypeCallProperty(value) {
        return (0, _validateNode.default)({
          type: "ObjectTypeCallProperty",
          value,
          static: null
        });
      }
      function objectTypeIndexer(id = null, key, value, variance2 = null) {
        return (0, _validateNode.default)({
          type: "ObjectTypeIndexer",
          id,
          key,
          value,
          variance: variance2,
          static: null
        });
      }
      function objectTypeProperty(key, value, variance2 = null) {
        return (0, _validateNode.default)({
          type: "ObjectTypeProperty",
          key,
          value,
          variance: variance2,
          kind: null,
          method: null,
          optional: null,
          proto: null,
          static: null
        });
      }
      function objectTypeSpreadProperty(argument) {
        return (0, _validateNode.default)({
          type: "ObjectTypeSpreadProperty",
          argument
        });
      }
      function opaqueType(id, typeParameters = null, supertype = null, impltype) {
        return (0, _validateNode.default)({
          type: "OpaqueType",
          id,
          typeParameters,
          supertype,
          impltype
        });
      }
      function qualifiedTypeIdentifier(id, qualification) {
        return (0, _validateNode.default)({
          type: "QualifiedTypeIdentifier",
          id,
          qualification
        });
      }
      function stringLiteralTypeAnnotation(value) {
        return (0, _validateNode.default)({
          type: "StringLiteralTypeAnnotation",
          value
        });
      }
      function stringTypeAnnotation() {
        return {
          type: "StringTypeAnnotation"
        };
      }
      function symbolTypeAnnotation() {
        return {
          type: "SymbolTypeAnnotation"
        };
      }
      function thisTypeAnnotation() {
        return {
          type: "ThisTypeAnnotation"
        };
      }
      function tupleTypeAnnotation(types) {
        return (0, _validateNode.default)({
          type: "TupleTypeAnnotation",
          types
        });
      }
      function typeofTypeAnnotation(argument) {
        return (0, _validateNode.default)({
          type: "TypeofTypeAnnotation",
          argument
        });
      }
      function typeAlias(id, typeParameters = null, right) {
        return (0, _validateNode.default)({
          type: "TypeAlias",
          id,
          typeParameters,
          right
        });
      }
      function typeAnnotation(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TypeAnnotation",
          typeAnnotation: typeAnnotation2
        });
      }
      function typeCastExpression(expression, typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TypeCastExpression",
          expression,
          typeAnnotation: typeAnnotation2
        });
      }
      function typeParameter(bound = null, _default = null, variance2 = null) {
        return (0, _validateNode.default)({
          type: "TypeParameter",
          bound,
          default: _default,
          variance: variance2,
          name: null
        });
      }
      function typeParameterDeclaration(params) {
        return (0, _validateNode.default)({
          type: "TypeParameterDeclaration",
          params
        });
      }
      function typeParameterInstantiation(params) {
        return (0, _validateNode.default)({
          type: "TypeParameterInstantiation",
          params
        });
      }
      function unionTypeAnnotation(types) {
        return (0, _validateNode.default)({
          type: "UnionTypeAnnotation",
          types
        });
      }
      function variance(kind) {
        return (0, _validateNode.default)({
          type: "Variance",
          kind
        });
      }
      function voidTypeAnnotation() {
        return {
          type: "VoidTypeAnnotation"
        };
      }
      function enumDeclaration(id, body) {
        return (0, _validateNode.default)({
          type: "EnumDeclaration",
          id,
          body
        });
      }
      function enumBooleanBody(members) {
        return (0, _validateNode.default)({
          type: "EnumBooleanBody",
          members,
          explicitType: null,
          hasUnknownMembers: null
        });
      }
      function enumNumberBody(members) {
        return (0, _validateNode.default)({
          type: "EnumNumberBody",
          members,
          explicitType: null,
          hasUnknownMembers: null
        });
      }
      function enumStringBody(members) {
        return (0, _validateNode.default)({
          type: "EnumStringBody",
          members,
          explicitType: null,
          hasUnknownMembers: null
        });
      }
      function enumSymbolBody(members) {
        return (0, _validateNode.default)({
          type: "EnumSymbolBody",
          members,
          hasUnknownMembers: null
        });
      }
      function enumBooleanMember(id) {
        return (0, _validateNode.default)({
          type: "EnumBooleanMember",
          id,
          init: null
        });
      }
      function enumNumberMember(id, init) {
        return (0, _validateNode.default)({
          type: "EnumNumberMember",
          id,
          init
        });
      }
      function enumStringMember(id, init) {
        return (0, _validateNode.default)({
          type: "EnumStringMember",
          id,
          init
        });
      }
      function enumDefaultedMember(id) {
        return (0, _validateNode.default)({
          type: "EnumDefaultedMember",
          id
        });
      }
      function indexedAccessType(objectType, indexType) {
        return (0, _validateNode.default)({
          type: "IndexedAccessType",
          objectType,
          indexType
        });
      }
      function optionalIndexedAccessType(objectType, indexType) {
        return (0, _validateNode.default)({
          type: "OptionalIndexedAccessType",
          objectType,
          indexType,
          optional: null
        });
      }
      function jsxAttribute(name41, value = null) {
        return (0, _validateNode.default)({
          type: "JSXAttribute",
          name: name41,
          value
        });
      }
      function jsxClosingElement(name41) {
        return (0, _validateNode.default)({
          type: "JSXClosingElement",
          name: name41
        });
      }
      function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
        return (0, _validateNode.default)({
          type: "JSXElement",
          openingElement,
          closingElement,
          children,
          selfClosing
        });
      }
      function jsxEmptyExpression() {
        return {
          type: "JSXEmptyExpression"
        };
      }
      function jsxExpressionContainer(expression) {
        return (0, _validateNode.default)({
          type: "JSXExpressionContainer",
          expression
        });
      }
      function jsxSpreadChild(expression) {
        return (0, _validateNode.default)({
          type: "JSXSpreadChild",
          expression
        });
      }
      function jsxIdentifier(name41) {
        return (0, _validateNode.default)({
          type: "JSXIdentifier",
          name: name41
        });
      }
      function jsxMemberExpression(object, property2) {
        return (0, _validateNode.default)({
          type: "JSXMemberExpression",
          object,
          property: property2
        });
      }
      function jsxNamespacedName(namespace, name41) {
        return (0, _validateNode.default)({
          type: "JSXNamespacedName",
          namespace,
          name: name41
        });
      }
      function jsxOpeningElement(name41, attributes, selfClosing = false) {
        return (0, _validateNode.default)({
          type: "JSXOpeningElement",
          name: name41,
          attributes,
          selfClosing
        });
      }
      function jsxSpreadAttribute(argument) {
        return (0, _validateNode.default)({
          type: "JSXSpreadAttribute",
          argument
        });
      }
      function jsxText(value) {
        return (0, _validateNode.default)({
          type: "JSXText",
          value
        });
      }
      function jsxFragment(openingFragment, closingFragment, children) {
        return (0, _validateNode.default)({
          type: "JSXFragment",
          openingFragment,
          closingFragment,
          children
        });
      }
      function jsxOpeningFragment() {
        return {
          type: "JSXOpeningFragment"
        };
      }
      function jsxClosingFragment() {
        return {
          type: "JSXClosingFragment"
        };
      }
      function noop4() {
        return {
          type: "Noop"
        };
      }
      function placeholder(expectedNode, name41) {
        return (0, _validateNode.default)({
          type: "Placeholder",
          expectedNode,
          name: name41
        });
      }
      function v8IntrinsicIdentifier(name41) {
        return (0, _validateNode.default)({
          type: "V8IntrinsicIdentifier",
          name: name41
        });
      }
      function argumentPlaceholder() {
        return {
          type: "ArgumentPlaceholder"
        };
      }
      function bindExpression(object, callee) {
        return (0, _validateNode.default)({
          type: "BindExpression",
          object,
          callee
        });
      }
      function importAttribute(key, value) {
        return (0, _validateNode.default)({
          type: "ImportAttribute",
          key,
          value
        });
      }
      function decorator(expression) {
        return (0, _validateNode.default)({
          type: "Decorator",
          expression
        });
      }
      function doExpression(body, async = false) {
        return (0, _validateNode.default)({
          type: "DoExpression",
          body,
          async
        });
      }
      function exportDefaultSpecifier(exported) {
        return (0, _validateNode.default)({
          type: "ExportDefaultSpecifier",
          exported
        });
      }
      function recordExpression(properties2) {
        return (0, _validateNode.default)({
          type: "RecordExpression",
          properties: properties2
        });
      }
      function tupleExpression(elements = []) {
        return (0, _validateNode.default)({
          type: "TupleExpression",
          elements
        });
      }
      function decimalLiteral(value) {
        return (0, _validateNode.default)({
          type: "DecimalLiteral",
          value
        });
      }
      function moduleExpression(body) {
        return (0, _validateNode.default)({
          type: "ModuleExpression",
          body
        });
      }
      function topicReference() {
        return {
          type: "TopicReference"
        };
      }
      function pipelineTopicExpression(expression) {
        return (0, _validateNode.default)({
          type: "PipelineTopicExpression",
          expression
        });
      }
      function pipelineBareFunction(callee) {
        return (0, _validateNode.default)({
          type: "PipelineBareFunction",
          callee
        });
      }
      function pipelinePrimaryTopicReference() {
        return {
          type: "PipelinePrimaryTopicReference"
        };
      }
      function tsParameterProperty(parameter) {
        return (0, _validateNode.default)({
          type: "TSParameterProperty",
          parameter
        });
      }
      function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
        return (0, _validateNode.default)({
          type: "TSDeclareFunction",
          id,
          typeParameters,
          params,
          returnType
        });
      }
      function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
        return (0, _validateNode.default)({
          type: "TSDeclareMethod",
          decorators,
          key,
          typeParameters,
          params,
          returnType
        });
      }
      function tsQualifiedName(left, right) {
        return (0, _validateNode.default)({
          type: "TSQualifiedName",
          left,
          right
        });
      }
      function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSCallSignatureDeclaration",
          typeParameters,
          parameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSConstructSignatureDeclaration",
          typeParameters,
          parameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsPropertySignature(key, typeAnnotation2 = null, initializer = null) {
        return (0, _validateNode.default)({
          type: "TSPropertySignature",
          key,
          typeAnnotation: typeAnnotation2,
          initializer,
          kind: null
        });
      }
      function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSMethodSignature",
          key,
          typeParameters,
          parameters,
          typeAnnotation: typeAnnotation2,
          kind: null
        });
      }
      function tsIndexSignature(parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSIndexSignature",
          parameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsAnyKeyword() {
        return {
          type: "TSAnyKeyword"
        };
      }
      function tsBooleanKeyword() {
        return {
          type: "TSBooleanKeyword"
        };
      }
      function tsBigIntKeyword() {
        return {
          type: "TSBigIntKeyword"
        };
      }
      function tsIntrinsicKeyword() {
        return {
          type: "TSIntrinsicKeyword"
        };
      }
      function tsNeverKeyword() {
        return {
          type: "TSNeverKeyword"
        };
      }
      function tsNullKeyword() {
        return {
          type: "TSNullKeyword"
        };
      }
      function tsNumberKeyword() {
        return {
          type: "TSNumberKeyword"
        };
      }
      function tsObjectKeyword() {
        return {
          type: "TSObjectKeyword"
        };
      }
      function tsStringKeyword() {
        return {
          type: "TSStringKeyword"
        };
      }
      function tsSymbolKeyword() {
        return {
          type: "TSSymbolKeyword"
        };
      }
      function tsUndefinedKeyword() {
        return {
          type: "TSUndefinedKeyword"
        };
      }
      function tsUnknownKeyword() {
        return {
          type: "TSUnknownKeyword"
        };
      }
      function tsVoidKeyword() {
        return {
          type: "TSVoidKeyword"
        };
      }
      function tsThisType() {
        return {
          type: "TSThisType"
        };
      }
      function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSFunctionType",
          typeParameters,
          parameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSConstructorType",
          typeParameters,
          parameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsTypeReference(typeName, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "TSTypeReference",
          typeName,
          typeParameters
        });
      }
      function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
        return (0, _validateNode.default)({
          type: "TSTypePredicate",
          parameterName,
          typeAnnotation: typeAnnotation2,
          asserts
        });
      }
      function tsTypeQuery(exprName, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "TSTypeQuery",
          exprName,
          typeParameters
        });
      }
      function tsTypeLiteral(members) {
        return (0, _validateNode.default)({
          type: "TSTypeLiteral",
          members
        });
      }
      function tsArrayType(elementType) {
        return (0, _validateNode.default)({
          type: "TSArrayType",
          elementType
        });
      }
      function tsTupleType(elementTypes) {
        return (0, _validateNode.default)({
          type: "TSTupleType",
          elementTypes
        });
      }
      function tsOptionalType(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSOptionalType",
          typeAnnotation: typeAnnotation2
        });
      }
      function tsRestType(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSRestType",
          typeAnnotation: typeAnnotation2
        });
      }
      function tsNamedTupleMember(label, elementType, optional = false) {
        return (0, _validateNode.default)({
          type: "TSNamedTupleMember",
          label,
          elementType,
          optional
        });
      }
      function tsUnionType(types) {
        return (0, _validateNode.default)({
          type: "TSUnionType",
          types
        });
      }
      function tsIntersectionType(types) {
        return (0, _validateNode.default)({
          type: "TSIntersectionType",
          types
        });
      }
      function tsConditionalType(checkType, extendsType, trueType, falseType) {
        return (0, _validateNode.default)({
          type: "TSConditionalType",
          checkType,
          extendsType,
          trueType,
          falseType
        });
      }
      function tsInferType(typeParameter2) {
        return (0, _validateNode.default)({
          type: "TSInferType",
          typeParameter: typeParameter2
        });
      }
      function tsParenthesizedType(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSParenthesizedType",
          typeAnnotation: typeAnnotation2
        });
      }
      function tsTypeOperator(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSTypeOperator",
          typeAnnotation: typeAnnotation2,
          operator: null
        });
      }
      function tsIndexedAccessType(objectType, indexType) {
        return (0, _validateNode.default)({
          type: "TSIndexedAccessType",
          objectType,
          indexType
        });
      }
      function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
        return (0, _validateNode.default)({
          type: "TSMappedType",
          typeParameter: typeParameter2,
          typeAnnotation: typeAnnotation2,
          nameType
        });
      }
      function tsLiteralType(literal) {
        return (0, _validateNode.default)({
          type: "TSLiteralType",
          literal
        });
      }
      function tsExpressionWithTypeArguments(expression, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "TSExpressionWithTypeArguments",
          expression,
          typeParameters
        });
      }
      function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
        return (0, _validateNode.default)({
          type: "TSInterfaceDeclaration",
          id,
          typeParameters,
          extends: _extends,
          body
        });
      }
      function tsInterfaceBody(body) {
        return (0, _validateNode.default)({
          type: "TSInterfaceBody",
          body
        });
      }
      function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSTypeAliasDeclaration",
          id,
          typeParameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsInstantiationExpression(expression, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "TSInstantiationExpression",
          expression,
          typeParameters
        });
      }
      function tsAsExpression(expression, typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSAsExpression",
          expression,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsSatisfiesExpression(expression, typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSSatisfiesExpression",
          expression,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsTypeAssertion(typeAnnotation2, expression) {
        return (0, _validateNode.default)({
          type: "TSTypeAssertion",
          typeAnnotation: typeAnnotation2,
          expression
        });
      }
      function tsEnumDeclaration(id, members) {
        return (0, _validateNode.default)({
          type: "TSEnumDeclaration",
          id,
          members
        });
      }
      function tsEnumMember(id, initializer = null) {
        return (0, _validateNode.default)({
          type: "TSEnumMember",
          id,
          initializer
        });
      }
      function tsModuleDeclaration(id, body) {
        return (0, _validateNode.default)({
          type: "TSModuleDeclaration",
          id,
          body
        });
      }
      function tsModuleBlock(body) {
        return (0, _validateNode.default)({
          type: "TSModuleBlock",
          body
        });
      }
      function tsImportType(argument, qualifier = null, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "TSImportType",
          argument,
          qualifier,
          typeParameters
        });
      }
      function tsImportEqualsDeclaration(id, moduleReference) {
        return (0, _validateNode.default)({
          type: "TSImportEqualsDeclaration",
          id,
          moduleReference,
          isExport: null
        });
      }
      function tsExternalModuleReference(expression) {
        return (0, _validateNode.default)({
          type: "TSExternalModuleReference",
          expression
        });
      }
      function tsNonNullExpression(expression) {
        return (0, _validateNode.default)({
          type: "TSNonNullExpression",
          expression
        });
      }
      function tsExportAssignment(expression) {
        return (0, _validateNode.default)({
          type: "TSExportAssignment",
          expression
        });
      }
      function tsNamespaceExportDeclaration(id) {
        return (0, _validateNode.default)({
          type: "TSNamespaceExportDeclaration",
          id
        });
      }
      function tsTypeAnnotation(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSTypeAnnotation",
          typeAnnotation: typeAnnotation2
        });
      }
      function tsTypeParameterInstantiation(params) {
        return (0, _validateNode.default)({
          type: "TSTypeParameterInstantiation",
          params
        });
      }
      function tsTypeParameterDeclaration(params) {
        return (0, _validateNode.default)({
          type: "TSTypeParameterDeclaration",
          params
        });
      }
      function tsTypeParameter(constraint = null, _default = null, name41) {
        return (0, _validateNode.default)({
          type: "TSTypeParameter",
          constraint,
          default: _default,
          name: name41
        });
      }
      function NumberLiteral(value) {
        console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
        return numericLiteral(value);
      }
      function RegexLiteral(pattern, flags = "") {
        console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
        return regExpLiteral(pattern, flags);
      }
      function RestProperty(argument) {
        console.trace("The node type RestProperty has been renamed to RestElement");
        return restElement(argument);
      }
      function SpreadProperty(argument) {
        console.trace("The node type SpreadProperty has been renamed to SpreadElement");
        return spreadElement(argument);
      }
    }
  });

  // node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
  var require_cleanJSXElementLiteralChild = __commonJS({
    "node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cleanJSXElementLiteralChild;
      var _generated = require_generated2();
      var _ = require_lib4();
      function cleanJSXElementLiteralChild(child, args) {
        const lines = child.value.split(/\r\n|\n|\r/);
        let lastNonEmptyLine = 0;
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].match(/[^ \t]/)) {
            lastNonEmptyLine = i;
          }
        }
        let str = "";
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const isFirstLine = i === 0;
          const isLastLine = i === lines.length - 1;
          const isLastNonEmptyLine = i === lastNonEmptyLine;
          let trimmedLine = line.replace(/\t/g, " ");
          if (!isFirstLine) {
            trimmedLine = trimmedLine.replace(/^[ ]+/, "");
          }
          if (!isLastLine) {
            trimmedLine = trimmedLine.replace(/[ ]+$/, "");
          }
          if (trimmedLine) {
            if (!isLastNonEmptyLine) {
              trimmedLine += " ";
            }
            str += trimmedLine;
          }
        }
        if (str)
          args.push((0, _.inherits)((0, _generated.stringLiteral)(str), child));
      }
    }
  });

  // node_modules/@babel/types/lib/builders/react/buildChildren.js
  var require_buildChildren = __commonJS({
    "node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = buildChildren;
      var _generated = require_generated();
      var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
      function buildChildren(node) {
        const elements = [];
        for (let i = 0; i < node.children.length; i++) {
          let child = node.children[i];
          if ((0, _generated.isJSXText)(child)) {
            (0, _cleanJSXElementLiteralChild.default)(child, elements);
            continue;
          }
          if ((0, _generated.isJSXExpressionContainer)(child))
            child = child.expression;
          if ((0, _generated.isJSXEmptyExpression)(child))
            continue;
          elements.push(child);
        }
        return elements;
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isNode.js
  var require_isNode = __commonJS({
    "node_modules/@babel/types/lib/validators/isNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isNode;
      var _definitions = require_definitions();
      function isNode(node) {
        return !!(node && _definitions.VISITOR_KEYS[node.type]);
      }
    }
  });

  // node_modules/@babel/types/lib/asserts/assertNode.js
  var require_assertNode = __commonJS({
    "node_modules/@babel/types/lib/asserts/assertNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = assertNode;
      var _isNode = require_isNode();
      function assertNode(node) {
        if (!(0, _isNode.default)(node)) {
          var _node$type;
          const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
          throw new TypeError(`Not a valid node of type "${type}"`);
        }
      }
    }
  });

  // node_modules/@babel/types/lib/asserts/generated/index.js
  var require_generated3 = __commonJS({
    "node_modules/@babel/types/lib/asserts/generated/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertAccessor = assertAccessor;
      exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
      exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
      exports.assertArrayExpression = assertArrayExpression;
      exports.assertArrayPattern = assertArrayPattern;
      exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
      exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
      exports.assertAssignmentExpression = assertAssignmentExpression;
      exports.assertAssignmentPattern = assertAssignmentPattern;
      exports.assertAwaitExpression = assertAwaitExpression;
      exports.assertBigIntLiteral = assertBigIntLiteral;
      exports.assertBinary = assertBinary;
      exports.assertBinaryExpression = assertBinaryExpression;
      exports.assertBindExpression = assertBindExpression;
      exports.assertBlock = assertBlock;
      exports.assertBlockParent = assertBlockParent;
      exports.assertBlockStatement = assertBlockStatement;
      exports.assertBooleanLiteral = assertBooleanLiteral;
      exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
      exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
      exports.assertBreakStatement = assertBreakStatement;
      exports.assertCallExpression = assertCallExpression;
      exports.assertCatchClause = assertCatchClause;
      exports.assertClass = assertClass;
      exports.assertClassAccessorProperty = assertClassAccessorProperty;
      exports.assertClassBody = assertClassBody;
      exports.assertClassDeclaration = assertClassDeclaration;
      exports.assertClassExpression = assertClassExpression;
      exports.assertClassImplements = assertClassImplements;
      exports.assertClassMethod = assertClassMethod;
      exports.assertClassPrivateMethod = assertClassPrivateMethod;
      exports.assertClassPrivateProperty = assertClassPrivateProperty;
      exports.assertClassProperty = assertClassProperty;
      exports.assertCompletionStatement = assertCompletionStatement;
      exports.assertConditional = assertConditional;
      exports.assertConditionalExpression = assertConditionalExpression;
      exports.assertContinueStatement = assertContinueStatement;
      exports.assertDebuggerStatement = assertDebuggerStatement;
      exports.assertDecimalLiteral = assertDecimalLiteral;
      exports.assertDeclaration = assertDeclaration;
      exports.assertDeclareClass = assertDeclareClass;
      exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
      exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
      exports.assertDeclareFunction = assertDeclareFunction;
      exports.assertDeclareInterface = assertDeclareInterface;
      exports.assertDeclareModule = assertDeclareModule;
      exports.assertDeclareModuleExports = assertDeclareModuleExports;
      exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
      exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
      exports.assertDeclareVariable = assertDeclareVariable;
      exports.assertDeclaredPredicate = assertDeclaredPredicate;
      exports.assertDecorator = assertDecorator;
      exports.assertDirective = assertDirective;
      exports.assertDirectiveLiteral = assertDirectiveLiteral;
      exports.assertDoExpression = assertDoExpression;
      exports.assertDoWhileStatement = assertDoWhileStatement;
      exports.assertEmptyStatement = assertEmptyStatement;
      exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
      exports.assertEnumBody = assertEnumBody;
      exports.assertEnumBooleanBody = assertEnumBooleanBody;
      exports.assertEnumBooleanMember = assertEnumBooleanMember;
      exports.assertEnumDeclaration = assertEnumDeclaration;
      exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
      exports.assertEnumMember = assertEnumMember;
      exports.assertEnumNumberBody = assertEnumNumberBody;
      exports.assertEnumNumberMember = assertEnumNumberMember;
      exports.assertEnumStringBody = assertEnumStringBody;
      exports.assertEnumStringMember = assertEnumStringMember;
      exports.assertEnumSymbolBody = assertEnumSymbolBody;
      exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
      exports.assertExportAllDeclaration = assertExportAllDeclaration;
      exports.assertExportDeclaration = assertExportDeclaration;
      exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
      exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
      exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
      exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
      exports.assertExportSpecifier = assertExportSpecifier;
      exports.assertExpression = assertExpression;
      exports.assertExpressionStatement = assertExpressionStatement;
      exports.assertExpressionWrapper = assertExpressionWrapper;
      exports.assertFile = assertFile;
      exports.assertFlow = assertFlow;
      exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
      exports.assertFlowDeclaration = assertFlowDeclaration;
      exports.assertFlowPredicate = assertFlowPredicate;
      exports.assertFlowType = assertFlowType;
      exports.assertFor = assertFor;
      exports.assertForInStatement = assertForInStatement;
      exports.assertForOfStatement = assertForOfStatement;
      exports.assertForStatement = assertForStatement;
      exports.assertForXStatement = assertForXStatement;
      exports.assertFunction = assertFunction;
      exports.assertFunctionDeclaration = assertFunctionDeclaration;
      exports.assertFunctionExpression = assertFunctionExpression;
      exports.assertFunctionParent = assertFunctionParent;
      exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
      exports.assertFunctionTypeParam = assertFunctionTypeParam;
      exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
      exports.assertIdentifier = assertIdentifier;
      exports.assertIfStatement = assertIfStatement;
      exports.assertImmutable = assertImmutable;
      exports.assertImport = assertImport;
      exports.assertImportAttribute = assertImportAttribute;
      exports.assertImportDeclaration = assertImportDeclaration;
      exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
      exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
      exports.assertImportSpecifier = assertImportSpecifier;
      exports.assertIndexedAccessType = assertIndexedAccessType;
      exports.assertInferredPredicate = assertInferredPredicate;
      exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
      exports.assertInterfaceExtends = assertInterfaceExtends;
      exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
      exports.assertInterpreterDirective = assertInterpreterDirective;
      exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
      exports.assertJSX = assertJSX;
      exports.assertJSXAttribute = assertJSXAttribute;
      exports.assertJSXClosingElement = assertJSXClosingElement;
      exports.assertJSXClosingFragment = assertJSXClosingFragment;
      exports.assertJSXElement = assertJSXElement;
      exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
      exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
      exports.assertJSXFragment = assertJSXFragment;
      exports.assertJSXIdentifier = assertJSXIdentifier;
      exports.assertJSXMemberExpression = assertJSXMemberExpression;
      exports.assertJSXNamespacedName = assertJSXNamespacedName;
      exports.assertJSXOpeningElement = assertJSXOpeningElement;
      exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
      exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
      exports.assertJSXSpreadChild = assertJSXSpreadChild;
      exports.assertJSXText = assertJSXText;
      exports.assertLVal = assertLVal;
      exports.assertLabeledStatement = assertLabeledStatement;
      exports.assertLiteral = assertLiteral;
      exports.assertLogicalExpression = assertLogicalExpression;
      exports.assertLoop = assertLoop;
      exports.assertMemberExpression = assertMemberExpression;
      exports.assertMetaProperty = assertMetaProperty;
      exports.assertMethod = assertMethod;
      exports.assertMiscellaneous = assertMiscellaneous;
      exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
      exports.assertModuleDeclaration = assertModuleDeclaration;
      exports.assertModuleExpression = assertModuleExpression;
      exports.assertModuleSpecifier = assertModuleSpecifier;
      exports.assertNewExpression = assertNewExpression;
      exports.assertNoop = assertNoop;
      exports.assertNullLiteral = assertNullLiteral;
      exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
      exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
      exports.assertNumberLiteral = assertNumberLiteral;
      exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
      exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
      exports.assertNumericLiteral = assertNumericLiteral;
      exports.assertObjectExpression = assertObjectExpression;
      exports.assertObjectMember = assertObjectMember;
      exports.assertObjectMethod = assertObjectMethod;
      exports.assertObjectPattern = assertObjectPattern;
      exports.assertObjectProperty = assertObjectProperty;
      exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
      exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
      exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
      exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
      exports.assertObjectTypeProperty = assertObjectTypeProperty;
      exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
      exports.assertOpaqueType = assertOpaqueType;
      exports.assertOptionalCallExpression = assertOptionalCallExpression;
      exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
      exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
      exports.assertParenthesizedExpression = assertParenthesizedExpression;
      exports.assertPattern = assertPattern;
      exports.assertPatternLike = assertPatternLike;
      exports.assertPipelineBareFunction = assertPipelineBareFunction;
      exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
      exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
      exports.assertPlaceholder = assertPlaceholder;
      exports.assertPrivate = assertPrivate;
      exports.assertPrivateName = assertPrivateName;
      exports.assertProgram = assertProgram;
      exports.assertProperty = assertProperty;
      exports.assertPureish = assertPureish;
      exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
      exports.assertRecordExpression = assertRecordExpression;
      exports.assertRegExpLiteral = assertRegExpLiteral;
      exports.assertRegexLiteral = assertRegexLiteral;
      exports.assertRestElement = assertRestElement;
      exports.assertRestProperty = assertRestProperty;
      exports.assertReturnStatement = assertReturnStatement;
      exports.assertScopable = assertScopable;
      exports.assertSequenceExpression = assertSequenceExpression;
      exports.assertSpreadElement = assertSpreadElement;
      exports.assertSpreadProperty = assertSpreadProperty;
      exports.assertStandardized = assertStandardized;
      exports.assertStatement = assertStatement;
      exports.assertStaticBlock = assertStaticBlock;
      exports.assertStringLiteral = assertStringLiteral;
      exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
      exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
      exports.assertSuper = assertSuper;
      exports.assertSwitchCase = assertSwitchCase;
      exports.assertSwitchStatement = assertSwitchStatement;
      exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
      exports.assertTSAnyKeyword = assertTSAnyKeyword;
      exports.assertTSArrayType = assertTSArrayType;
      exports.assertTSAsExpression = assertTSAsExpression;
      exports.assertTSBaseType = assertTSBaseType;
      exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
      exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
      exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
      exports.assertTSConditionalType = assertTSConditionalType;
      exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
      exports.assertTSConstructorType = assertTSConstructorType;
      exports.assertTSDeclareFunction = assertTSDeclareFunction;
      exports.assertTSDeclareMethod = assertTSDeclareMethod;
      exports.assertTSEntityName = assertTSEntityName;
      exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
      exports.assertTSEnumMember = assertTSEnumMember;
      exports.assertTSExportAssignment = assertTSExportAssignment;
      exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
      exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
      exports.assertTSFunctionType = assertTSFunctionType;
      exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
      exports.assertTSImportType = assertTSImportType;
      exports.assertTSIndexSignature = assertTSIndexSignature;
      exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
      exports.assertTSInferType = assertTSInferType;
      exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
      exports.assertTSInterfaceBody = assertTSInterfaceBody;
      exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
      exports.assertTSIntersectionType = assertTSIntersectionType;
      exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
      exports.assertTSLiteralType = assertTSLiteralType;
      exports.assertTSMappedType = assertTSMappedType;
      exports.assertTSMethodSignature = assertTSMethodSignature;
      exports.assertTSModuleBlock = assertTSModuleBlock;
      exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
      exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
      exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
      exports.assertTSNeverKeyword = assertTSNeverKeyword;
      exports.assertTSNonNullExpression = assertTSNonNullExpression;
      exports.assertTSNullKeyword = assertTSNullKeyword;
      exports.assertTSNumberKeyword = assertTSNumberKeyword;
      exports.assertTSObjectKeyword = assertTSObjectKeyword;
      exports.assertTSOptionalType = assertTSOptionalType;
      exports.assertTSParameterProperty = assertTSParameterProperty;
      exports.assertTSParenthesizedType = assertTSParenthesizedType;
      exports.assertTSPropertySignature = assertTSPropertySignature;
      exports.assertTSQualifiedName = assertTSQualifiedName;
      exports.assertTSRestType = assertTSRestType;
      exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
      exports.assertTSStringKeyword = assertTSStringKeyword;
      exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
      exports.assertTSThisType = assertTSThisType;
      exports.assertTSTupleType = assertTSTupleType;
      exports.assertTSType = assertTSType;
      exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
      exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
      exports.assertTSTypeAssertion = assertTSTypeAssertion;
      exports.assertTSTypeElement = assertTSTypeElement;
      exports.assertTSTypeLiteral = assertTSTypeLiteral;
      exports.assertTSTypeOperator = assertTSTypeOperator;
      exports.assertTSTypeParameter = assertTSTypeParameter;
      exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
      exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
      exports.assertTSTypePredicate = assertTSTypePredicate;
      exports.assertTSTypeQuery = assertTSTypeQuery;
      exports.assertTSTypeReference = assertTSTypeReference;
      exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
      exports.assertTSUnionType = assertTSUnionType;
      exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
      exports.assertTSVoidKeyword = assertTSVoidKeyword;
      exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
      exports.assertTemplateElement = assertTemplateElement;
      exports.assertTemplateLiteral = assertTemplateLiteral;
      exports.assertTerminatorless = assertTerminatorless;
      exports.assertThisExpression = assertThisExpression;
      exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
      exports.assertThrowStatement = assertThrowStatement;
      exports.assertTopicReference = assertTopicReference;
      exports.assertTryStatement = assertTryStatement;
      exports.assertTupleExpression = assertTupleExpression;
      exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
      exports.assertTypeAlias = assertTypeAlias;
      exports.assertTypeAnnotation = assertTypeAnnotation;
      exports.assertTypeCastExpression = assertTypeCastExpression;
      exports.assertTypeParameter = assertTypeParameter;
      exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
      exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
      exports.assertTypeScript = assertTypeScript;
      exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
      exports.assertUnaryExpression = assertUnaryExpression;
      exports.assertUnaryLike = assertUnaryLike;
      exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
      exports.assertUpdateExpression = assertUpdateExpression;
      exports.assertUserWhitespacable = assertUserWhitespacable;
      exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
      exports.assertVariableDeclaration = assertVariableDeclaration;
      exports.assertVariableDeclarator = assertVariableDeclarator;
      exports.assertVariance = assertVariance;
      exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
      exports.assertWhile = assertWhile;
      exports.assertWhileStatement = assertWhileStatement;
      exports.assertWithStatement = assertWithStatement;
      exports.assertYieldExpression = assertYieldExpression;
      var _is = require_is();
      function assert(type, node, opts) {
        if (!(0, _is.default)(type, node, opts)) {
          throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
        }
      }
      function assertArrayExpression(node, opts) {
        assert("ArrayExpression", node, opts);
      }
      function assertAssignmentExpression(node, opts) {
        assert("AssignmentExpression", node, opts);
      }
      function assertBinaryExpression(node, opts) {
        assert("BinaryExpression", node, opts);
      }
      function assertInterpreterDirective(node, opts) {
        assert("InterpreterDirective", node, opts);
      }
      function assertDirective(node, opts) {
        assert("Directive", node, opts);
      }
      function assertDirectiveLiteral(node, opts) {
        assert("DirectiveLiteral", node, opts);
      }
      function assertBlockStatement(node, opts) {
        assert("BlockStatement", node, opts);
      }
      function assertBreakStatement(node, opts) {
        assert("BreakStatement", node, opts);
      }
      function assertCallExpression(node, opts) {
        assert("CallExpression", node, opts);
      }
      function assertCatchClause(node, opts) {
        assert("CatchClause", node, opts);
      }
      function assertConditionalExpression(node, opts) {
        assert("ConditionalExpression", node, opts);
      }
      function assertContinueStatement(node, opts) {
        assert("ContinueStatement", node, opts);
      }
      function assertDebuggerStatement(node, opts) {
        assert("DebuggerStatement", node, opts);
      }
      function assertDoWhileStatement(node, opts) {
        assert("DoWhileStatement", node, opts);
      }
      function assertEmptyStatement(node, opts) {
        assert("EmptyStatement", node, opts);
      }
      function assertExpressionStatement(node, opts) {
        assert("ExpressionStatement", node, opts);
      }
      function assertFile(node, opts) {
        assert("File", node, opts);
      }
      function assertForInStatement(node, opts) {
        assert("ForInStatement", node, opts);
      }
      function assertForStatement(node, opts) {
        assert("ForStatement", node, opts);
      }
      function assertFunctionDeclaration(node, opts) {
        assert("FunctionDeclaration", node, opts);
      }
      function assertFunctionExpression(node, opts) {
        assert("FunctionExpression", node, opts);
      }
      function assertIdentifier(node, opts) {
        assert("Identifier", node, opts);
      }
      function assertIfStatement(node, opts) {
        assert("IfStatement", node, opts);
      }
      function assertLabeledStatement(node, opts) {
        assert("LabeledStatement", node, opts);
      }
      function assertStringLiteral(node, opts) {
        assert("StringLiteral", node, opts);
      }
      function assertNumericLiteral(node, opts) {
        assert("NumericLiteral", node, opts);
      }
      function assertNullLiteral(node, opts) {
        assert("NullLiteral", node, opts);
      }
      function assertBooleanLiteral(node, opts) {
        assert("BooleanLiteral", node, opts);
      }
      function assertRegExpLiteral(node, opts) {
        assert("RegExpLiteral", node, opts);
      }
      function assertLogicalExpression(node, opts) {
        assert("LogicalExpression", node, opts);
      }
      function assertMemberExpression(node, opts) {
        assert("MemberExpression", node, opts);
      }
      function assertNewExpression(node, opts) {
        assert("NewExpression", node, opts);
      }
      function assertProgram(node, opts) {
        assert("Program", node, opts);
      }
      function assertObjectExpression(node, opts) {
        assert("ObjectExpression", node, opts);
      }
      function assertObjectMethod(node, opts) {
        assert("ObjectMethod", node, opts);
      }
      function assertObjectProperty(node, opts) {
        assert("ObjectProperty", node, opts);
      }
      function assertRestElement(node, opts) {
        assert("RestElement", node, opts);
      }
      function assertReturnStatement(node, opts) {
        assert("ReturnStatement", node, opts);
      }
      function assertSequenceExpression(node, opts) {
        assert("SequenceExpression", node, opts);
      }
      function assertParenthesizedExpression(node, opts) {
        assert("ParenthesizedExpression", node, opts);
      }
      function assertSwitchCase(node, opts) {
        assert("SwitchCase", node, opts);
      }
      function assertSwitchStatement(node, opts) {
        assert("SwitchStatement", node, opts);
      }
      function assertThisExpression(node, opts) {
        assert("ThisExpression", node, opts);
      }
      function assertThrowStatement(node, opts) {
        assert("ThrowStatement", node, opts);
      }
      function assertTryStatement(node, opts) {
        assert("TryStatement", node, opts);
      }
      function assertUnaryExpression(node, opts) {
        assert("UnaryExpression", node, opts);
      }
      function assertUpdateExpression(node, opts) {
        assert("UpdateExpression", node, opts);
      }
      function assertVariableDeclaration(node, opts) {
        assert("VariableDeclaration", node, opts);
      }
      function assertVariableDeclarator(node, opts) {
        assert("VariableDeclarator", node, opts);
      }
      function assertWhileStatement(node, opts) {
        assert("WhileStatement", node, opts);
      }
      function assertWithStatement(node, opts) {
        assert("WithStatement", node, opts);
      }
      function assertAssignmentPattern(node, opts) {
        assert("AssignmentPattern", node, opts);
      }
      function assertArrayPattern(node, opts) {
        assert("ArrayPattern", node, opts);
      }
      function assertArrowFunctionExpression(node, opts) {
        assert("ArrowFunctionExpression", node, opts);
      }
      function assertClassBody(node, opts) {
        assert("ClassBody", node, opts);
      }
      function assertClassExpression(node, opts) {
        assert("ClassExpression", node, opts);
      }
      function assertClassDeclaration(node, opts) {
        assert("ClassDeclaration", node, opts);
      }
      function assertExportAllDeclaration(node, opts) {
        assert("ExportAllDeclaration", node, opts);
      }
      function assertExportDefaultDeclaration(node, opts) {
        assert("ExportDefaultDeclaration", node, opts);
      }
      function assertExportNamedDeclaration(node, opts) {
        assert("ExportNamedDeclaration", node, opts);
      }
      function assertExportSpecifier(node, opts) {
        assert("ExportSpecifier", node, opts);
      }
      function assertForOfStatement(node, opts) {
        assert("ForOfStatement", node, opts);
      }
      function assertImportDeclaration(node, opts) {
        assert("ImportDeclaration", node, opts);
      }
      function assertImportDefaultSpecifier(node, opts) {
        assert("ImportDefaultSpecifier", node, opts);
      }
      function assertImportNamespaceSpecifier(node, opts) {
        assert("ImportNamespaceSpecifier", node, opts);
      }
      function assertImportSpecifier(node, opts) {
        assert("ImportSpecifier", node, opts);
      }
      function assertMetaProperty(node, opts) {
        assert("MetaProperty", node, opts);
      }
      function assertClassMethod(node, opts) {
        assert("ClassMethod", node, opts);
      }
      function assertObjectPattern(node, opts) {
        assert("ObjectPattern", node, opts);
      }
      function assertSpreadElement(node, opts) {
        assert("SpreadElement", node, opts);
      }
      function assertSuper(node, opts) {
        assert("Super", node, opts);
      }
      function assertTaggedTemplateExpression(node, opts) {
        assert("TaggedTemplateExpression", node, opts);
      }
      function assertTemplateElement(node, opts) {
        assert("TemplateElement", node, opts);
      }
      function assertTemplateLiteral(node, opts) {
        assert("TemplateLiteral", node, opts);
      }
      function assertYieldExpression(node, opts) {
        assert("YieldExpression", node, opts);
      }
      function assertAwaitExpression(node, opts) {
        assert("AwaitExpression", node, opts);
      }
      function assertImport(node, opts) {
        assert("Import", node, opts);
      }
      function assertBigIntLiteral(node, opts) {
        assert("BigIntLiteral", node, opts);
      }
      function assertExportNamespaceSpecifier(node, opts) {
        assert("ExportNamespaceSpecifier", node, opts);
      }
      function assertOptionalMemberExpression(node, opts) {
        assert("OptionalMemberExpression", node, opts);
      }
      function assertOptionalCallExpression(node, opts) {
        assert("OptionalCallExpression", node, opts);
      }
      function assertClassProperty(node, opts) {
        assert("ClassProperty", node, opts);
      }
      function assertClassAccessorProperty(node, opts) {
        assert("ClassAccessorProperty", node, opts);
      }
      function assertClassPrivateProperty(node, opts) {
        assert("ClassPrivateProperty", node, opts);
      }
      function assertClassPrivateMethod(node, opts) {
        assert("ClassPrivateMethod", node, opts);
      }
      function assertPrivateName(node, opts) {
        assert("PrivateName", node, opts);
      }
      function assertStaticBlock(node, opts) {
        assert("StaticBlock", node, opts);
      }
      function assertAnyTypeAnnotation(node, opts) {
        assert("AnyTypeAnnotation", node, opts);
      }
      function assertArrayTypeAnnotation(node, opts) {
        assert("ArrayTypeAnnotation", node, opts);
      }
      function assertBooleanTypeAnnotation(node, opts) {
        assert("BooleanTypeAnnotation", node, opts);
      }
      function assertBooleanLiteralTypeAnnotation(node, opts) {
        assert("BooleanLiteralTypeAnnotation", node, opts);
      }
      function assertNullLiteralTypeAnnotation(node, opts) {
        assert("NullLiteralTypeAnnotation", node, opts);
      }
      function assertClassImplements(node, opts) {
        assert("ClassImplements", node, opts);
      }
      function assertDeclareClass(node, opts) {
        assert("DeclareClass", node, opts);
      }
      function assertDeclareFunction(node, opts) {
        assert("DeclareFunction", node, opts);
      }
      function assertDeclareInterface(node, opts) {
        assert("DeclareInterface", node, opts);
      }
      function assertDeclareModule(node, opts) {
        assert("DeclareModule", node, opts);
      }
      function assertDeclareModuleExports(node, opts) {
        assert("DeclareModuleExports", node, opts);
      }
      function assertDeclareTypeAlias(node, opts) {
        assert("DeclareTypeAlias", node, opts);
      }
      function assertDeclareOpaqueType(node, opts) {
        assert("DeclareOpaqueType", node, opts);
      }
      function assertDeclareVariable(node, opts) {
        assert("DeclareVariable", node, opts);
      }
      function assertDeclareExportDeclaration(node, opts) {
        assert("DeclareExportDeclaration", node, opts);
      }
      function assertDeclareExportAllDeclaration(node, opts) {
        assert("DeclareExportAllDeclaration", node, opts);
      }
      function assertDeclaredPredicate(node, opts) {
        assert("DeclaredPredicate", node, opts);
      }
      function assertExistsTypeAnnotation(node, opts) {
        assert("ExistsTypeAnnotation", node, opts);
      }
      function assertFunctionTypeAnnotation(node, opts) {
        assert("FunctionTypeAnnotation", node, opts);
      }
      function assertFunctionTypeParam(node, opts) {
        assert("FunctionTypeParam", node, opts);
      }
      function assertGenericTypeAnnotation(node, opts) {
        assert("GenericTypeAnnotation", node, opts);
      }
      function assertInferredPredicate(node, opts) {
        assert("InferredPredicate", node, opts);
      }
      function assertInterfaceExtends(node, opts) {
        assert("InterfaceExtends", node, opts);
      }
      function assertInterfaceDeclaration(node, opts) {
        assert("InterfaceDeclaration", node, opts);
      }
      function assertInterfaceTypeAnnotation(node, opts) {
        assert("InterfaceTypeAnnotation", node, opts);
      }
      function assertIntersectionTypeAnnotation(node, opts) {
        assert("IntersectionTypeAnnotation", node, opts);
      }
      function assertMixedTypeAnnotation(node, opts) {
        assert("MixedTypeAnnotation", node, opts);
      }
      function assertEmptyTypeAnnotation(node, opts) {
        assert("EmptyTypeAnnotation", node, opts);
      }
      function assertNullableTypeAnnotation(node, opts) {
        assert("NullableTypeAnnotation", node, opts);
      }
      function assertNumberLiteralTypeAnnotation(node, opts) {
        assert("NumberLiteralTypeAnnotation", node, opts);
      }
      function assertNumberTypeAnnotation(node, opts) {
        assert("NumberTypeAnnotation", node, opts);
      }
      function assertObjectTypeAnnotation(node, opts) {
        assert("ObjectTypeAnnotation", node, opts);
      }
      function assertObjectTypeInternalSlot(node, opts) {
        assert("ObjectTypeInternalSlot", node, opts);
      }
      function assertObjectTypeCallProperty(node, opts) {
        assert("ObjectTypeCallProperty", node, opts);
      }
      function assertObjectTypeIndexer(node, opts) {
        assert("ObjectTypeIndexer", node, opts);
      }
      function assertObjectTypeProperty(node, opts) {
        assert("ObjectTypeProperty", node, opts);
      }
      function assertObjectTypeSpreadProperty(node, opts) {
        assert("ObjectTypeSpreadProperty", node, opts);
      }
      function assertOpaqueType(node, opts) {
        assert("OpaqueType", node, opts);
      }
      function assertQualifiedTypeIdentifier(node, opts) {
        assert("QualifiedTypeIdentifier", node, opts);
      }
      function assertStringLiteralTypeAnnotation(node, opts) {
        assert("StringLiteralTypeAnnotation", node, opts);
      }
      function assertStringTypeAnnotation(node, opts) {
        assert("StringTypeAnnotation", node, opts);
      }
      function assertSymbolTypeAnnotation(node, opts) {
        assert("SymbolTypeAnnotation", node, opts);
      }
      function assertThisTypeAnnotation(node, opts) {
        assert("ThisTypeAnnotation", node, opts);
      }
      function assertTupleTypeAnnotation(node, opts) {
        assert("TupleTypeAnnotation", node, opts);
      }
      function assertTypeofTypeAnnotation(node, opts) {
        assert("TypeofTypeAnnotation", node, opts);
      }
      function assertTypeAlias(node, opts) {
        assert("TypeAlias", node, opts);
      }
      function assertTypeAnnotation(node, opts) {
        assert("TypeAnnotation", node, opts);
      }
      function assertTypeCastExpression(node, opts) {
        assert("TypeCastExpression", node, opts);
      }
      function assertTypeParameter(node, opts) {
        assert("TypeParameter", node, opts);
      }
      function assertTypeParameterDeclaration(node, opts) {
        assert("TypeParameterDeclaration", node, opts);
      }
      function assertTypeParameterInstantiation(node, opts) {
        assert("TypeParameterInstantiation", node, opts);
      }
      function assertUnionTypeAnnotation(node, opts) {
        assert("UnionTypeAnnotation", node, opts);
      }
      function assertVariance(node, opts) {
        assert("Variance", node, opts);
      }
      function assertVoidTypeAnnotation(node, opts) {
        assert("VoidTypeAnnotation", node, opts);
      }
      function assertEnumDeclaration(node, opts) {
        assert("EnumDeclaration", node, opts);
      }
      function assertEnumBooleanBody(node, opts) {
        assert("EnumBooleanBody", node, opts);
      }
      function assertEnumNumberBody(node, opts) {
        assert("EnumNumberBody", node, opts);
      }
      function assertEnumStringBody(node, opts) {
        assert("EnumStringBody", node, opts);
      }
      function assertEnumSymbolBody(node, opts) {
        assert("EnumSymbolBody", node, opts);
      }
      function assertEnumBooleanMember(node, opts) {
        assert("EnumBooleanMember", node, opts);
      }
      function assertEnumNumberMember(node, opts) {
        assert("EnumNumberMember", node, opts);
      }
      function assertEnumStringMember(node, opts) {
        assert("EnumStringMember", node, opts);
      }
      function assertEnumDefaultedMember(node, opts) {
        assert("EnumDefaultedMember", node, opts);
      }
      function assertIndexedAccessType(node, opts) {
        assert("IndexedAccessType", node, opts);
      }
      function assertOptionalIndexedAccessType(node, opts) {
        assert("OptionalIndexedAccessType", node, opts);
      }
      function assertJSXAttribute(node, opts) {
        assert("JSXAttribute", node, opts);
      }
      function assertJSXClosingElement(node, opts) {
        assert("JSXClosingElement", node, opts);
      }
      function assertJSXElement(node, opts) {
        assert("JSXElement", node, opts);
      }
      function assertJSXEmptyExpression(node, opts) {
        assert("JSXEmptyExpression", node, opts);
      }
      function assertJSXExpressionContainer(node, opts) {
        assert("JSXExpressionContainer", node, opts);
      }
      function assertJSXSpreadChild(node, opts) {
        assert("JSXSpreadChild", node, opts);
      }
      function assertJSXIdentifier(node, opts) {
        assert("JSXIdentifier", node, opts);
      }
      function assertJSXMemberExpression(node, opts) {
        assert("JSXMemberExpression", node, opts);
      }
      function assertJSXNamespacedName(node, opts) {
        assert("JSXNamespacedName", node, opts);
      }
      function assertJSXOpeningElement(node, opts) {
        assert("JSXOpeningElement", node, opts);
      }
      function assertJSXSpreadAttribute(node, opts) {
        assert("JSXSpreadAttribute", node, opts);
      }
      function assertJSXText(node, opts) {
        assert("JSXText", node, opts);
      }
      function assertJSXFragment(node, opts) {
        assert("JSXFragment", node, opts);
      }
      function assertJSXOpeningFragment(node, opts) {
        assert("JSXOpeningFragment", node, opts);
      }
      function assertJSXClosingFragment(node, opts) {
        assert("JSXClosingFragment", node, opts);
      }
      function assertNoop(node, opts) {
        assert("Noop", node, opts);
      }
      function assertPlaceholder(node, opts) {
        assert("Placeholder", node, opts);
      }
      function assertV8IntrinsicIdentifier(node, opts) {
        assert("V8IntrinsicIdentifier", node, opts);
      }
      function assertArgumentPlaceholder(node, opts) {
        assert("ArgumentPlaceholder", node, opts);
      }
      function assertBindExpression(node, opts) {
        assert("BindExpression", node, opts);
      }
      function assertImportAttribute(node, opts) {
        assert("ImportAttribute", node, opts);
      }
      function assertDecorator(node, opts) {
        assert("Decorator", node, opts);
      }
      function assertDoExpression(node, opts) {
        assert("DoExpression", node, opts);
      }
      function assertExportDefaultSpecifier(node, opts) {
        assert("ExportDefaultSpecifier", node, opts);
      }
      function assertRecordExpression(node, opts) {
        assert("RecordExpression", node, opts);
      }
      function assertTupleExpression(node, opts) {
        assert("TupleExpression", node, opts);
      }
      function assertDecimalLiteral(node, opts) {
        assert("DecimalLiteral", node, opts);
      }
      function assertModuleExpression(node, opts) {
        assert("ModuleExpression", node, opts);
      }
      function assertTopicReference(node, opts) {
        assert("TopicReference", node, opts);
      }
      function assertPipelineTopicExpression(node, opts) {
        assert("PipelineTopicExpression", node, opts);
      }
      function assertPipelineBareFunction(node, opts) {
        assert("PipelineBareFunction", node, opts);
      }
      function assertPipelinePrimaryTopicReference(node, opts) {
        assert("PipelinePrimaryTopicReference", node, opts);
      }
      function assertTSParameterProperty(node, opts) {
        assert("TSParameterProperty", node, opts);
      }
      function assertTSDeclareFunction(node, opts) {
        assert("TSDeclareFunction", node, opts);
      }
      function assertTSDeclareMethod(node, opts) {
        assert("TSDeclareMethod", node, opts);
      }
      function assertTSQualifiedName(node, opts) {
        assert("TSQualifiedName", node, opts);
      }
      function assertTSCallSignatureDeclaration(node, opts) {
        assert("TSCallSignatureDeclaration", node, opts);
      }
      function assertTSConstructSignatureDeclaration(node, opts) {
        assert("TSConstructSignatureDeclaration", node, opts);
      }
      function assertTSPropertySignature(node, opts) {
        assert("TSPropertySignature", node, opts);
      }
      function assertTSMethodSignature(node, opts) {
        assert("TSMethodSignature", node, opts);
      }
      function assertTSIndexSignature(node, opts) {
        assert("TSIndexSignature", node, opts);
      }
      function assertTSAnyKeyword(node, opts) {
        assert("TSAnyKeyword", node, opts);
      }
      function assertTSBooleanKeyword(node, opts) {
        assert("TSBooleanKeyword", node, opts);
      }
      function assertTSBigIntKeyword(node, opts) {
        assert("TSBigIntKeyword", node, opts);
      }
      function assertTSIntrinsicKeyword(node, opts) {
        assert("TSIntrinsicKeyword", node, opts);
      }
      function assertTSNeverKeyword(node, opts) {
        assert("TSNeverKeyword", node, opts);
      }
      function assertTSNullKeyword(node, opts) {
        assert("TSNullKeyword", node, opts);
      }
      function assertTSNumberKeyword(node, opts) {
        assert("TSNumberKeyword", node, opts);
      }
      function assertTSObjectKeyword(node, opts) {
        assert("TSObjectKeyword", node, opts);
      }
      function assertTSStringKeyword(node, opts) {
        assert("TSStringKeyword", node, opts);
      }
      function assertTSSymbolKeyword(node, opts) {
        assert("TSSymbolKeyword", node, opts);
      }
      function assertTSUndefinedKeyword(node, opts) {
        assert("TSUndefinedKeyword", node, opts);
      }
      function assertTSUnknownKeyword(node, opts) {
        assert("TSUnknownKeyword", node, opts);
      }
      function assertTSVoidKeyword(node, opts) {
        assert("TSVoidKeyword", node, opts);
      }
      function assertTSThisType(node, opts) {
        assert("TSThisType", node, opts);
      }
      function assertTSFunctionType(node, opts) {
        assert("TSFunctionType", node, opts);
      }
      function assertTSConstructorType(node, opts) {
        assert("TSConstructorType", node, opts);
      }
      function assertTSTypeReference(node, opts) {
        assert("TSTypeReference", node, opts);
      }
      function assertTSTypePredicate(node, opts) {
        assert("TSTypePredicate", node, opts);
      }
      function assertTSTypeQuery(node, opts) {
        assert("TSTypeQuery", node, opts);
      }
      function assertTSTypeLiteral(node, opts) {
        assert("TSTypeLiteral", node, opts);
      }
      function assertTSArrayType(node, opts) {
        assert("TSArrayType", node, opts);
      }
      function assertTSTupleType(node, opts) {
        assert("TSTupleType", node, opts);
      }
      function assertTSOptionalType(node, opts) {
        assert("TSOptionalType", node, opts);
      }
      function assertTSRestType(node, opts) {
        assert("TSRestType", node, opts);
      }
      function assertTSNamedTupleMember(node, opts) {
        assert("TSNamedTupleMember", node, opts);
      }
      function assertTSUnionType(node, opts) {
        assert("TSUnionType", node, opts);
      }
      function assertTSIntersectionType(node, opts) {
        assert("TSIntersectionType", node, opts);
      }
      function assertTSConditionalType(node, opts) {
        assert("TSConditionalType", node, opts);
      }
      function assertTSInferType(node, opts) {
        assert("TSInferType", node, opts);
      }
      function assertTSParenthesizedType(node, opts) {
        assert("TSParenthesizedType", node, opts);
      }
      function assertTSTypeOperator(node, opts) {
        assert("TSTypeOperator", node, opts);
      }
      function assertTSIndexedAccessType(node, opts) {
        assert("TSIndexedAccessType", node, opts);
      }
      function assertTSMappedType(node, opts) {
        assert("TSMappedType", node, opts);
      }
      function assertTSLiteralType(node, opts) {
        assert("TSLiteralType", node, opts);
      }
      function assertTSExpressionWithTypeArguments(node, opts) {
        assert("TSExpressionWithTypeArguments", node, opts);
      }
      function assertTSInterfaceDeclaration(node, opts) {
        assert("TSInterfaceDeclaration", node, opts);
      }
      function assertTSInterfaceBody(node, opts) {
        assert("TSInterfaceBody", node, opts);
      }
      function assertTSTypeAliasDeclaration(node, opts) {
        assert("TSTypeAliasDeclaration", node, opts);
      }
      function assertTSInstantiationExpression(node, opts) {
        assert("TSInstantiationExpression", node, opts);
      }
      function assertTSAsExpression(node, opts) {
        assert("TSAsExpression", node, opts);
      }
      function assertTSSatisfiesExpression(node, opts) {
        assert("TSSatisfiesExpression", node, opts);
      }
      function assertTSTypeAssertion(node, opts) {
        assert("TSTypeAssertion", node, opts);
      }
      function assertTSEnumDeclaration(node, opts) {
        assert("TSEnumDeclaration", node, opts);
      }
      function assertTSEnumMember(node, opts) {
        assert("TSEnumMember", node, opts);
      }
      function assertTSModuleDeclaration(node, opts) {
        assert("TSModuleDeclaration", node, opts);
      }
      function assertTSModuleBlock(node, opts) {
        assert("TSModuleBlock", node, opts);
      }
      function assertTSImportType(node, opts) {
        assert("TSImportType", node, opts);
      }
      function assertTSImportEqualsDeclaration(node, opts) {
        assert("TSImportEqualsDeclaration", node, opts);
      }
      function assertTSExternalModuleReference(node, opts) {
        assert("TSExternalModuleReference", node, opts);
      }
      function assertTSNonNullExpression(node, opts) {
        assert("TSNonNullExpression", node, opts);
      }
      function assertTSExportAssignment(node, opts) {
        assert("TSExportAssignment", node, opts);
      }
      function assertTSNamespaceExportDeclaration(node, opts) {
        assert("TSNamespaceExportDeclaration", node, opts);
      }
      function assertTSTypeAnnotation(node, opts) {
        assert("TSTypeAnnotation", node, opts);
      }
      function assertTSTypeParameterInstantiation(node, opts) {
        assert("TSTypeParameterInstantiation", node, opts);
      }
      function assertTSTypeParameterDeclaration(node, opts) {
        assert("TSTypeParameterDeclaration", node, opts);
      }
      function assertTSTypeParameter(node, opts) {
        assert("TSTypeParameter", node, opts);
      }
      function assertStandardized(node, opts) {
        assert("Standardized", node, opts);
      }
      function assertExpression(node, opts) {
        assert("Expression", node, opts);
      }
      function assertBinary(node, opts) {
        assert("Binary", node, opts);
      }
      function assertScopable(node, opts) {
        assert("Scopable", node, opts);
      }
      function assertBlockParent(node, opts) {
        assert("BlockParent", node, opts);
      }
      function assertBlock(node, opts) {
        assert("Block", node, opts);
      }
      function assertStatement(node, opts) {
        assert("Statement", node, opts);
      }
      function assertTerminatorless(node, opts) {
        assert("Terminatorless", node, opts);
      }
      function assertCompletionStatement(node, opts) {
        assert("CompletionStatement", node, opts);
      }
      function assertConditional(node, opts) {
        assert("Conditional", node, opts);
      }
      function assertLoop(node, opts) {
        assert("Loop", node, opts);
      }
      function assertWhile(node, opts) {
        assert("While", node, opts);
      }
      function assertExpressionWrapper(node, opts) {
        assert("ExpressionWrapper", node, opts);
      }
      function assertFor(node, opts) {
        assert("For", node, opts);
      }
      function assertForXStatement(node, opts) {
        assert("ForXStatement", node, opts);
      }
      function assertFunction(node, opts) {
        assert("Function", node, opts);
      }
      function assertFunctionParent(node, opts) {
        assert("FunctionParent", node, opts);
      }
      function assertPureish(node, opts) {
        assert("Pureish", node, opts);
      }
      function assertDeclaration(node, opts) {
        assert("Declaration", node, opts);
      }
      function assertPatternLike(node, opts) {
        assert("PatternLike", node, opts);
      }
      function assertLVal(node, opts) {
        assert("LVal", node, opts);
      }
      function assertTSEntityName(node, opts) {
        assert("TSEntityName", node, opts);
      }
      function assertLiteral(node, opts) {
        assert("Literal", node, opts);
      }
      function assertImmutable(node, opts) {
        assert("Immutable", node, opts);
      }
      function assertUserWhitespacable(node, opts) {
        assert("UserWhitespacable", node, opts);
      }
      function assertMethod(node, opts) {
        assert("Method", node, opts);
      }
      function assertObjectMember(node, opts) {
        assert("ObjectMember", node, opts);
      }
      function assertProperty(node, opts) {
        assert("Property", node, opts);
      }
      function assertUnaryLike(node, opts) {
        assert("UnaryLike", node, opts);
      }
      function assertPattern(node, opts) {
        assert("Pattern", node, opts);
      }
      function assertClass(node, opts) {
        assert("Class", node, opts);
      }
      function assertModuleDeclaration(node, opts) {
        assert("ModuleDeclaration", node, opts);
      }
      function assertExportDeclaration(node, opts) {
        assert("ExportDeclaration", node, opts);
      }
      function assertModuleSpecifier(node, opts) {
        assert("ModuleSpecifier", node, opts);
      }
      function assertAccessor(node, opts) {
        assert("Accessor", node, opts);
      }
      function assertPrivate(node, opts) {
        assert("Private", node, opts);
      }
      function assertFlow(node, opts) {
        assert("Flow", node, opts);
      }
      function assertFlowType(node, opts) {
        assert("FlowType", node, opts);
      }
      function assertFlowBaseAnnotation(node, opts) {
        assert("FlowBaseAnnotation", node, opts);
      }
      function assertFlowDeclaration(node, opts) {
        assert("FlowDeclaration", node, opts);
      }
      function assertFlowPredicate(node, opts) {
        assert("FlowPredicate", node, opts);
      }
      function assertEnumBody(node, opts) {
        assert("EnumBody", node, opts);
      }
      function assertEnumMember(node, opts) {
        assert("EnumMember", node, opts);
      }
      function assertJSX(node, opts) {
        assert("JSX", node, opts);
      }
      function assertMiscellaneous(node, opts) {
        assert("Miscellaneous", node, opts);
      }
      function assertTypeScript(node, opts) {
        assert("TypeScript", node, opts);
      }
      function assertTSTypeElement(node, opts) {
        assert("TSTypeElement", node, opts);
      }
      function assertTSType(node, opts) {
        assert("TSType", node, opts);
      }
      function assertTSBaseType(node, opts) {
        assert("TSBaseType", node, opts);
      }
      function assertNumberLiteral(node, opts) {
        console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
        assert("NumberLiteral", node, opts);
      }
      function assertRegexLiteral(node, opts) {
        console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
        assert("RegexLiteral", node, opts);
      }
      function assertRestProperty(node, opts) {
        console.trace("The node type RestProperty has been renamed to RestElement");
        assert("RestProperty", node, opts);
      }
      function assertSpreadProperty(node, opts) {
        console.trace("The node type SpreadProperty has been renamed to SpreadElement");
        assert("SpreadProperty", node, opts);
      }
    }
  });

  // node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
  var require_createTypeAnnotationBasedOnTypeof = __commonJS({
    "node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _generated = require_generated2();
      var _default = createTypeAnnotationBasedOnTypeof;
      exports.default = _default;
      function createTypeAnnotationBasedOnTypeof(type) {
        switch (type) {
          case "string":
            return (0, _generated.stringTypeAnnotation)();
          case "number":
            return (0, _generated.numberTypeAnnotation)();
          case "undefined":
            return (0, _generated.voidTypeAnnotation)();
          case "boolean":
            return (0, _generated.booleanTypeAnnotation)();
          case "function":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
          case "object":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
          case "symbol":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
          case "bigint":
            return (0, _generated.anyTypeAnnotation)();
        }
        throw new Error("Invalid typeof value: " + type);
      }
    }
  });

  // node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
  var require_removeTypeDuplicates = __commonJS({
    "node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = removeTypeDuplicates;
      var _generated = require_generated();
      function getQualifiedName(node) {
        return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
      }
      function removeTypeDuplicates(nodes) {
        const generics = /* @__PURE__ */ new Map();
        const bases = /* @__PURE__ */ new Map();
        const typeGroups = /* @__PURE__ */ new Set();
        const types = [];
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (!node)
            continue;
          if (types.indexOf(node) >= 0) {
            continue;
          }
          if ((0, _generated.isAnyTypeAnnotation)(node)) {
            return [node];
          }
          if ((0, _generated.isFlowBaseAnnotation)(node)) {
            bases.set(node.type, node);
            continue;
          }
          if ((0, _generated.isUnionTypeAnnotation)(node)) {
            if (!typeGroups.has(node.types)) {
              nodes = nodes.concat(node.types);
              typeGroups.add(node.types);
            }
            continue;
          }
          if ((0, _generated.isGenericTypeAnnotation)(node)) {
            const name41 = getQualifiedName(node.id);
            if (generics.has(name41)) {
              let existing = generics.get(name41);
              if (existing.typeParameters) {
                if (node.typeParameters) {
                  existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
                }
              } else {
                existing = node.typeParameters;
              }
            } else {
              generics.set(name41, node);
            }
            continue;
          }
          types.push(node);
        }
        for (const [, baseType] of bases) {
          types.push(baseType);
        }
        for (const [, genericName] of generics) {
          types.push(genericName);
        }
        return types;
      }
    }
  });

  // node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
  var require_createFlowUnionType = __commonJS({
    "node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = createFlowUnionType;
      var _generated = require_generated2();
      var _removeTypeDuplicates = require_removeTypeDuplicates();
      function createFlowUnionType(types) {
        const flattened = (0, _removeTypeDuplicates.default)(types);
        if (flattened.length === 1) {
          return flattened[0];
        } else {
          return (0, _generated.unionTypeAnnotation)(flattened);
        }
      }
    }
  });

  // node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
  var require_removeTypeDuplicates2 = __commonJS({
    "node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = removeTypeDuplicates;
      var _generated = require_generated();
      function getQualifiedName(node) {
        return (0, _generated.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;
      }
      function removeTypeDuplicates(nodes) {
        const generics = /* @__PURE__ */ new Map();
        const bases = /* @__PURE__ */ new Map();
        const typeGroups = /* @__PURE__ */ new Set();
        const types = [];
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (!node)
            continue;
          if (types.indexOf(node) >= 0) {
            continue;
          }
          if ((0, _generated.isTSAnyKeyword)(node)) {
            return [node];
          }
          if ((0, _generated.isTSBaseType)(node)) {
            bases.set(node.type, node);
            continue;
          }
          if ((0, _generated.isTSUnionType)(node)) {
            if (!typeGroups.has(node.types)) {
              nodes.push(...node.types);
              typeGroups.add(node.types);
            }
            continue;
          }
          if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {
            const name41 = getQualifiedName(node.typeName);
            if (generics.has(name41)) {
              let existing = generics.get(name41);
              if (existing.typeParameters) {
                if (node.typeParameters) {
                  existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
                }
              } else {
                existing = node.typeParameters;
              }
            } else {
              generics.set(name41, node);
            }
            continue;
          }
          types.push(node);
        }
        for (const [, baseType] of bases) {
          types.push(baseType);
        }
        for (const [, genericName] of generics) {
          types.push(genericName);
        }
        return types;
      }
    }
  });

  // node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
  var require_createTSUnionType = __commonJS({
    "node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = createTSUnionType;
      var _generated = require_generated2();
      var _removeTypeDuplicates = require_removeTypeDuplicates2();
      var _index = require_generated();
      function createTSUnionType(typeAnnotations) {
        const types = typeAnnotations.map((type) => {
          return (0, _index.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
        });
        const flattened = (0, _removeTypeDuplicates.default)(types);
        if (flattened.length === 1) {
          return flattened[0];
        } else {
          return (0, _generated.tsUnionType)(flattened);
        }
      }
    }
  });

  // node_modules/@babel/types/lib/builders/generated/uppercase.js
  var require_uppercase = __commonJS({
    "node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "AnyTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.anyTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ArgumentPlaceholder", {
        enumerable: true,
        get: function() {
          return _index.argumentPlaceholder;
        }
      });
      Object.defineProperty(exports, "ArrayExpression", {
        enumerable: true,
        get: function() {
          return _index.arrayExpression;
        }
      });
      Object.defineProperty(exports, "ArrayPattern", {
        enumerable: true,
        get: function() {
          return _index.arrayPattern;
        }
      });
      Object.defineProperty(exports, "ArrayTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.arrayTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ArrowFunctionExpression", {
        enumerable: true,
        get: function() {
          return _index.arrowFunctionExpression;
        }
      });
      Object.defineProperty(exports, "AssignmentExpression", {
        enumerable: true,
        get: function() {
          return _index.assignmentExpression;
        }
      });
      Object.defineProperty(exports, "AssignmentPattern", {
        enumerable: true,
        get: function() {
          return _index.assignmentPattern;
        }
      });
      Object.defineProperty(exports, "AwaitExpression", {
        enumerable: true,
        get: function() {
          return _index.awaitExpression;
        }
      });
      Object.defineProperty(exports, "BigIntLiteral", {
        enumerable: true,
        get: function() {
          return _index.bigIntLiteral;
        }
      });
      Object.defineProperty(exports, "BinaryExpression", {
        enumerable: true,
        get: function() {
          return _index.binaryExpression;
        }
      });
      Object.defineProperty(exports, "BindExpression", {
        enumerable: true,
        get: function() {
          return _index.bindExpression;
        }
      });
      Object.defineProperty(exports, "BlockStatement", {
        enumerable: true,
        get: function() {
          return _index.blockStatement;
        }
      });
      Object.defineProperty(exports, "BooleanLiteral", {
        enumerable: true,
        get: function() {
          return _index.booleanLiteral;
        }
      });
      Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.booleanLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "BooleanTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.booleanTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "BreakStatement", {
        enumerable: true,
        get: function() {
          return _index.breakStatement;
        }
      });
      Object.defineProperty(exports, "CallExpression", {
        enumerable: true,
        get: function() {
          return _index.callExpression;
        }
      });
      Object.defineProperty(exports, "CatchClause", {
        enumerable: true,
        get: function() {
          return _index.catchClause;
        }
      });
      Object.defineProperty(exports, "ClassAccessorProperty", {
        enumerable: true,
        get: function() {
          return _index.classAccessorProperty;
        }
      });
      Object.defineProperty(exports, "ClassBody", {
        enumerable: true,
        get: function() {
          return _index.classBody;
        }
      });
      Object.defineProperty(exports, "ClassDeclaration", {
        enumerable: true,
        get: function() {
          return _index.classDeclaration;
        }
      });
      Object.defineProperty(exports, "ClassExpression", {
        enumerable: true,
        get: function() {
          return _index.classExpression;
        }
      });
      Object.defineProperty(exports, "ClassImplements", {
        enumerable: true,
        get: function() {
          return _index.classImplements;
        }
      });
      Object.defineProperty(exports, "ClassMethod", {
        enumerable: true,
        get: function() {
          return _index.classMethod;
        }
      });
      Object.defineProperty(exports, "ClassPrivateMethod", {
        enumerable: true,
        get: function() {
          return _index.classPrivateMethod;
        }
      });
      Object.defineProperty(exports, "ClassPrivateProperty", {
        enumerable: true,
        get: function() {
          return _index.classPrivateProperty;
        }
      });
      Object.defineProperty(exports, "ClassProperty", {
        enumerable: true,
        get: function() {
          return _index.classProperty;
        }
      });
      Object.defineProperty(exports, "ConditionalExpression", {
        enumerable: true,
        get: function() {
          return _index.conditionalExpression;
        }
      });
      Object.defineProperty(exports, "ContinueStatement", {
        enumerable: true,
        get: function() {
          return _index.continueStatement;
        }
      });
      Object.defineProperty(exports, "DebuggerStatement", {
        enumerable: true,
        get: function() {
          return _index.debuggerStatement;
        }
      });
      Object.defineProperty(exports, "DecimalLiteral", {
        enumerable: true,
        get: function() {
          return _index.decimalLiteral;
        }
      });
      Object.defineProperty(exports, "DeclareClass", {
        enumerable: true,
        get: function() {
          return _index.declareClass;
        }
      });
      Object.defineProperty(exports, "DeclareExportAllDeclaration", {
        enumerable: true,
        get: function() {
          return _index.declareExportAllDeclaration;
        }
      });
      Object.defineProperty(exports, "DeclareExportDeclaration", {
        enumerable: true,
        get: function() {
          return _index.declareExportDeclaration;
        }
      });
      Object.defineProperty(exports, "DeclareFunction", {
        enumerable: true,
        get: function() {
          return _index.declareFunction;
        }
      });
      Object.defineProperty(exports, "DeclareInterface", {
        enumerable: true,
        get: function() {
          return _index.declareInterface;
        }
      });
      Object.defineProperty(exports, "DeclareModule", {
        enumerable: true,
        get: function() {
          return _index.declareModule;
        }
      });
      Object.defineProperty(exports, "DeclareModuleExports", {
        enumerable: true,
        get: function() {
          return _index.declareModuleExports;
        }
      });
      Object.defineProperty(exports, "DeclareOpaqueType", {
        enumerable: true,
        get: function() {
          return _index.declareOpaqueType;
        }
      });
      Object.defineProperty(exports, "DeclareTypeAlias", {
        enumerable: true,
        get: function() {
          return _index.declareTypeAlias;
        }
      });
      Object.defineProperty(exports, "DeclareVariable", {
        enumerable: true,
        get: function() {
          return _index.declareVariable;
        }
      });
      Object.defineProperty(exports, "DeclaredPredicate", {
        enumerable: true,
        get: function() {
          return _index.declaredPredicate;
        }
      });
      Object.defineProperty(exports, "Decorator", {
        enumerable: true,
        get: function() {
          return _index.decorator;
        }
      });
      Object.defineProperty(exports, "Directive", {
        enumerable: true,
        get: function() {
          return _index.directive;
        }
      });
      Object.defineProperty(exports, "DirectiveLiteral", {
        enumerable: true,
        get: function() {
          return _index.directiveLiteral;
        }
      });
      Object.defineProperty(exports, "DoExpression", {
        enumerable: true,
        get: function() {
          return _index.doExpression;
        }
      });
      Object.defineProperty(exports, "DoWhileStatement", {
        enumerable: true,
        get: function() {
          return _index.doWhileStatement;
        }
      });
      Object.defineProperty(exports, "EmptyStatement", {
        enumerable: true,
        get: function() {
          return _index.emptyStatement;
        }
      });
      Object.defineProperty(exports, "EmptyTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.emptyTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "EnumBooleanBody", {
        enumerable: true,
        get: function() {
          return _index.enumBooleanBody;
        }
      });
      Object.defineProperty(exports, "EnumBooleanMember", {
        enumerable: true,
        get: function() {
          return _index.enumBooleanMember;
        }
      });
      Object.defineProperty(exports, "EnumDeclaration", {
        enumerable: true,
        get: function() {
          return _index.enumDeclaration;
        }
      });
      Object.defineProperty(exports, "EnumDefaultedMember", {
        enumerable: true,
        get: function() {
          return _index.enumDefaultedMember;
        }
      });
      Object.defineProperty(exports, "EnumNumberBody", {
        enumerable: true,
        get: function() {
          return _index.enumNumberBody;
        }
      });
      Object.defineProperty(exports, "EnumNumberMember", {
        enumerable: true,
        get: function() {
          return _index.enumNumberMember;
        }
      });
      Object.defineProperty(exports, "EnumStringBody", {
        enumerable: true,
        get: function() {
          return _index.enumStringBody;
        }
      });
      Object.defineProperty(exports, "EnumStringMember", {
        enumerable: true,
        get: function() {
          return _index.enumStringMember;
        }
      });
      Object.defineProperty(exports, "EnumSymbolBody", {
        enumerable: true,
        get: function() {
          return _index.enumSymbolBody;
        }
      });
      Object.defineProperty(exports, "ExistsTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.existsTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ExportAllDeclaration", {
        enumerable: true,
        get: function() {
          return _index.exportAllDeclaration;
        }
      });
      Object.defineProperty(exports, "ExportDefaultDeclaration", {
        enumerable: true,
        get: function() {
          return _index.exportDefaultDeclaration;
        }
      });
      Object.defineProperty(exports, "ExportDefaultSpecifier", {
        enumerable: true,
        get: function() {
          return _index.exportDefaultSpecifier;
        }
      });
      Object.defineProperty(exports, "ExportNamedDeclaration", {
        enumerable: true,
        get: function() {
          return _index.exportNamedDeclaration;
        }
      });
      Object.defineProperty(exports, "ExportNamespaceSpecifier", {
        enumerable: true,
        get: function() {
          return _index.exportNamespaceSpecifier;
        }
      });
      Object.defineProperty(exports, "ExportSpecifier", {
        enumerable: true,
        get: function() {
          return _index.exportSpecifier;
        }
      });
      Object.defineProperty(exports, "ExpressionStatement", {
        enumerable: true,
        get: function() {
          return _index.expressionStatement;
        }
      });
      Object.defineProperty(exports, "File", {
        enumerable: true,
        get: function() {
          return _index.file;
        }
      });
      Object.defineProperty(exports, "ForInStatement", {
        enumerable: true,
        get: function() {
          return _index.forInStatement;
        }
      });
      Object.defineProperty(exports, "ForOfStatement", {
        enumerable: true,
        get: function() {
          return _index.forOfStatement;
        }
      });
      Object.defineProperty(exports, "ForStatement", {
        enumerable: true,
        get: function() {
          return _index.forStatement;
        }
      });
      Object.defineProperty(exports, "FunctionDeclaration", {
        enumerable: true,
        get: function() {
          return _index.functionDeclaration;
        }
      });
      Object.defineProperty(exports, "FunctionExpression", {
        enumerable: true,
        get: function() {
          return _index.functionExpression;
        }
      });
      Object.defineProperty(exports, "FunctionTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.functionTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "FunctionTypeParam", {
        enumerable: true,
        get: function() {
          return _index.functionTypeParam;
        }
      });
      Object.defineProperty(exports, "GenericTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.genericTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "Identifier", {
        enumerable: true,
        get: function() {
          return _index.identifier;
        }
      });
      Object.defineProperty(exports, "IfStatement", {
        enumerable: true,
        get: function() {
          return _index.ifStatement;
        }
      });
      Object.defineProperty(exports, "Import", {
        enumerable: true,
        get: function() {
          return _index.import;
        }
      });
      Object.defineProperty(exports, "ImportAttribute", {
        enumerable: true,
        get: function() {
          return _index.importAttribute;
        }
      });
      Object.defineProperty(exports, "ImportDeclaration", {
        enumerable: true,
        get: function() {
          return _index.importDeclaration;
        }
      });
      Object.defineProperty(exports, "ImportDefaultSpecifier", {
        enumerable: true,
        get: function() {
          return _index.importDefaultSpecifier;
        }
      });
      Object.defineProperty(exports, "ImportNamespaceSpecifier", {
        enumerable: true,
        get: function() {
          return _index.importNamespaceSpecifier;
        }
      });
      Object.defineProperty(exports, "ImportSpecifier", {
        enumerable: true,
        get: function() {
          return _index.importSpecifier;
        }
      });
      Object.defineProperty(exports, "IndexedAccessType", {
        enumerable: true,
        get: function() {
          return _index.indexedAccessType;
        }
      });
      Object.defineProperty(exports, "InferredPredicate", {
        enumerable: true,
        get: function() {
          return _index.inferredPredicate;
        }
      });
      Object.defineProperty(exports, "InterfaceDeclaration", {
        enumerable: true,
        get: function() {
          return _index.interfaceDeclaration;
        }
      });
      Object.defineProperty(exports, "InterfaceExtends", {
        enumerable: true,
        get: function() {
          return _index.interfaceExtends;
        }
      });
      Object.defineProperty(exports, "InterfaceTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.interfaceTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "InterpreterDirective", {
        enumerable: true,
        get: function() {
          return _index.interpreterDirective;
        }
      });
      Object.defineProperty(exports, "IntersectionTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.intersectionTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "JSXAttribute", {
        enumerable: true,
        get: function() {
          return _index.jsxAttribute;
        }
      });
      Object.defineProperty(exports, "JSXClosingElement", {
        enumerable: true,
        get: function() {
          return _index.jsxClosingElement;
        }
      });
      Object.defineProperty(exports, "JSXClosingFragment", {
        enumerable: true,
        get: function() {
          return _index.jsxClosingFragment;
        }
      });
      Object.defineProperty(exports, "JSXElement", {
        enumerable: true,
        get: function() {
          return _index.jsxElement;
        }
      });
      Object.defineProperty(exports, "JSXEmptyExpression", {
        enumerable: true,
        get: function() {
          return _index.jsxEmptyExpression;
        }
      });
      Object.defineProperty(exports, "JSXExpressionContainer", {
        enumerable: true,
        get: function() {
          return _index.jsxExpressionContainer;
        }
      });
      Object.defineProperty(exports, "JSXFragment", {
        enumerable: true,
        get: function() {
          return _index.jsxFragment;
        }
      });
      Object.defineProperty(exports, "JSXIdentifier", {
        enumerable: true,
        get: function() {
          return _index.jsxIdentifier;
        }
      });
      Object.defineProperty(exports, "JSXMemberExpression", {
        enumerable: true,
        get: function() {
          return _index.jsxMemberExpression;
        }
      });
      Object.defineProperty(exports, "JSXNamespacedName", {
        enumerable: true,
        get: function() {
          return _index.jsxNamespacedName;
        }
      });
      Object.defineProperty(exports, "JSXOpeningElement", {
        enumerable: true,
        get: function() {
          return _index.jsxOpeningElement;
        }
      });
      Object.defineProperty(exports, "JSXOpeningFragment", {
        enumerable: true,
        get: function() {
          return _index.jsxOpeningFragment;
        }
      });
      Object.defineProperty(exports, "JSXSpreadAttribute", {
        enumerable: true,
        get: function() {
          return _index.jsxSpreadAttribute;
        }
      });
      Object.defineProperty(exports, "JSXSpreadChild", {
        enumerable: true,
        get: function() {
          return _index.jsxSpreadChild;
        }
      });
      Object.defineProperty(exports, "JSXText", {
        enumerable: true,
        get: function() {
          return _index.jsxText;
        }
      });
      Object.defineProperty(exports, "LabeledStatement", {
        enumerable: true,
        get: function() {
          return _index.labeledStatement;
        }
      });
      Object.defineProperty(exports, "LogicalExpression", {
        enumerable: true,
        get: function() {
          return _index.logicalExpression;
        }
      });
      Object.defineProperty(exports, "MemberExpression", {
        enumerable: true,
        get: function() {
          return _index.memberExpression;
        }
      });
      Object.defineProperty(exports, "MetaProperty", {
        enumerable: true,
        get: function() {
          return _index.metaProperty;
        }
      });
      Object.defineProperty(exports, "MixedTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.mixedTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ModuleExpression", {
        enumerable: true,
        get: function() {
          return _index.moduleExpression;
        }
      });
      Object.defineProperty(exports, "NewExpression", {
        enumerable: true,
        get: function() {
          return _index.newExpression;
        }
      });
      Object.defineProperty(exports, "Noop", {
        enumerable: true,
        get: function() {
          return _index.noop;
        }
      });
      Object.defineProperty(exports, "NullLiteral", {
        enumerable: true,
        get: function() {
          return _index.nullLiteral;
        }
      });
      Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.nullLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NullableTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.nullableTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NumberLiteral", {
        enumerable: true,
        get: function() {
          return _index.numberLiteral;
        }
      });
      Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.numberLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NumberTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.numberTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NumericLiteral", {
        enumerable: true,
        get: function() {
          return _index.numericLiteral;
        }
      });
      Object.defineProperty(exports, "ObjectExpression", {
        enumerable: true,
        get: function() {
          return _index.objectExpression;
        }
      });
      Object.defineProperty(exports, "ObjectMethod", {
        enumerable: true,
        get: function() {
          return _index.objectMethod;
        }
      });
      Object.defineProperty(exports, "ObjectPattern", {
        enumerable: true,
        get: function() {
          return _index.objectPattern;
        }
      });
      Object.defineProperty(exports, "ObjectProperty", {
        enumerable: true,
        get: function() {
          return _index.objectProperty;
        }
      });
      Object.defineProperty(exports, "ObjectTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.objectTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ObjectTypeCallProperty", {
        enumerable: true,
        get: function() {
          return _index.objectTypeCallProperty;
        }
      });
      Object.defineProperty(exports, "ObjectTypeIndexer", {
        enumerable: true,
        get: function() {
          return _index.objectTypeIndexer;
        }
      });
      Object.defineProperty(exports, "ObjectTypeInternalSlot", {
        enumerable: true,
        get: function() {
          return _index.objectTypeInternalSlot;
        }
      });
      Object.defineProperty(exports, "ObjectTypeProperty", {
        enumerable: true,
        get: function() {
          return _index.objectTypeProperty;
        }
      });
      Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
        enumerable: true,
        get: function() {
          return _index.objectTypeSpreadProperty;
        }
      });
      Object.defineProperty(exports, "OpaqueType", {
        enumerable: true,
        get: function() {
          return _index.opaqueType;
        }
      });
      Object.defineProperty(exports, "OptionalCallExpression", {
        enumerable: true,
        get: function() {
          return _index.optionalCallExpression;
        }
      });
      Object.defineProperty(exports, "OptionalIndexedAccessType", {
        enumerable: true,
        get: function() {
          return _index.optionalIndexedAccessType;
        }
      });
      Object.defineProperty(exports, "OptionalMemberExpression", {
        enumerable: true,
        get: function() {
          return _index.optionalMemberExpression;
        }
      });
      Object.defineProperty(exports, "ParenthesizedExpression", {
        enumerable: true,
        get: function() {
          return _index.parenthesizedExpression;
        }
      });
      Object.defineProperty(exports, "PipelineBareFunction", {
        enumerable: true,
        get: function() {
          return _index.pipelineBareFunction;
        }
      });
      Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
        enumerable: true,
        get: function() {
          return _index.pipelinePrimaryTopicReference;
        }
      });
      Object.defineProperty(exports, "PipelineTopicExpression", {
        enumerable: true,
        get: function() {
          return _index.pipelineTopicExpression;
        }
      });
      Object.defineProperty(exports, "Placeholder", {
        enumerable: true,
        get: function() {
          return _index.placeholder;
        }
      });
      Object.defineProperty(exports, "PrivateName", {
        enumerable: true,
        get: function() {
          return _index.privateName;
        }
      });
      Object.defineProperty(exports, "Program", {
        enumerable: true,
        get: function() {
          return _index.program;
        }
      });
      Object.defineProperty(exports, "QualifiedTypeIdentifier", {
        enumerable: true,
        get: function() {
          return _index.qualifiedTypeIdentifier;
        }
      });
      Object.defineProperty(exports, "RecordExpression", {
        enumerable: true,
        get: function() {
          return _index.recordExpression;
        }
      });
      Object.defineProperty(exports, "RegExpLiteral", {
        enumerable: true,
        get: function() {
          return _index.regExpLiteral;
        }
      });
      Object.defineProperty(exports, "RegexLiteral", {
        enumerable: true,
        get: function() {
          return _index.regexLiteral;
        }
      });
      Object.defineProperty(exports, "RestElement", {
        enumerable: true,
        get: function() {
          return _index.restElement;
        }
      });
      Object.defineProperty(exports, "RestProperty", {
        enumerable: true,
        get: function() {
          return _index.restProperty;
        }
      });
      Object.defineProperty(exports, "ReturnStatement", {
        enumerable: true,
        get: function() {
          return _index.returnStatement;
        }
      });
      Object.defineProperty(exports, "SequenceExpression", {
        enumerable: true,
        get: function() {
          return _index.sequenceExpression;
        }
      });
      Object.defineProperty(exports, "SpreadElement", {
        enumerable: true,
        get: function() {
          return _index.spreadElement;
        }
      });
      Object.defineProperty(exports, "SpreadProperty", {
        enumerable: true,
        get: function() {
          return _index.spreadProperty;
        }
      });
      Object.defineProperty(exports, "StaticBlock", {
        enumerable: true,
        get: function() {
          return _index.staticBlock;
        }
      });
      Object.defineProperty(exports, "StringLiteral", {
        enumerable: true,
        get: function() {
          return _index.stringLiteral;
        }
      });
      Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.stringLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "StringTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.stringTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "Super", {
        enumerable: true,
        get: function() {
          return _index.super;
        }
      });
      Object.defineProperty(exports, "SwitchCase", {
        enumerable: true,
        get: function() {
          return _index.switchCase;
        }
      });
      Object.defineProperty(exports, "SwitchStatement", {
        enumerable: true,
        get: function() {
          return _index.switchStatement;
        }
      });
      Object.defineProperty(exports, "SymbolTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.symbolTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "TSAnyKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsAnyKeyword;
        }
      });
      Object.defineProperty(exports, "TSArrayType", {
        enumerable: true,
        get: function() {
          return _index.tsArrayType;
        }
      });
      Object.defineProperty(exports, "TSAsExpression", {
        enumerable: true,
        get: function() {
          return _index.tsAsExpression;
        }
      });
      Object.defineProperty(exports, "TSBigIntKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsBigIntKeyword;
        }
      });
      Object.defineProperty(exports, "TSBooleanKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsBooleanKeyword;
        }
      });
      Object.defineProperty(exports, "TSCallSignatureDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsCallSignatureDeclaration;
        }
      });
      Object.defineProperty(exports, "TSConditionalType", {
        enumerable: true,
        get: function() {
          return _index.tsConditionalType;
        }
      });
      Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsConstructSignatureDeclaration;
        }
      });
      Object.defineProperty(exports, "TSConstructorType", {
        enumerable: true,
        get: function() {
          return _index.tsConstructorType;
        }
      });
      Object.defineProperty(exports, "TSDeclareFunction", {
        enumerable: true,
        get: function() {
          return _index.tsDeclareFunction;
        }
      });
      Object.defineProperty(exports, "TSDeclareMethod", {
        enumerable: true,
        get: function() {
          return _index.tsDeclareMethod;
        }
      });
      Object.defineProperty(exports, "TSEnumDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsEnumDeclaration;
        }
      });
      Object.defineProperty(exports, "TSEnumMember", {
        enumerable: true,
        get: function() {
          return _index.tsEnumMember;
        }
      });
      Object.defineProperty(exports, "TSExportAssignment", {
        enumerable: true,
        get: function() {
          return _index.tsExportAssignment;
        }
      });
      Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
        enumerable: true,
        get: function() {
          return _index.tsExpressionWithTypeArguments;
        }
      });
      Object.defineProperty(exports, "TSExternalModuleReference", {
        enumerable: true,
        get: function() {
          return _index.tsExternalModuleReference;
        }
      });
      Object.defineProperty(exports, "TSFunctionType", {
        enumerable: true,
        get: function() {
          return _index.tsFunctionType;
        }
      });
      Object.defineProperty(exports, "TSImportEqualsDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsImportEqualsDeclaration;
        }
      });
      Object.defineProperty(exports, "TSImportType", {
        enumerable: true,
        get: function() {
          return _index.tsImportType;
        }
      });
      Object.defineProperty(exports, "TSIndexSignature", {
        enumerable: true,
        get: function() {
          return _index.tsIndexSignature;
        }
      });
      Object.defineProperty(exports, "TSIndexedAccessType", {
        enumerable: true,
        get: function() {
          return _index.tsIndexedAccessType;
        }
      });
      Object.defineProperty(exports, "TSInferType", {
        enumerable: true,
        get: function() {
          return _index.tsInferType;
        }
      });
      Object.defineProperty(exports, "TSInstantiationExpression", {
        enumerable: true,
        get: function() {
          return _index.tsInstantiationExpression;
        }
      });
      Object.defineProperty(exports, "TSInterfaceBody", {
        enumerable: true,
        get: function() {
          return _index.tsInterfaceBody;
        }
      });
      Object.defineProperty(exports, "TSInterfaceDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsInterfaceDeclaration;
        }
      });
      Object.defineProperty(exports, "TSIntersectionType", {
        enumerable: true,
        get: function() {
          return _index.tsIntersectionType;
        }
      });
      Object.defineProperty(exports, "TSIntrinsicKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsIntrinsicKeyword;
        }
      });
      Object.defineProperty(exports, "TSLiteralType", {
        enumerable: true,
        get: function() {
          return _index.tsLiteralType;
        }
      });
      Object.defineProperty(exports, "TSMappedType", {
        enumerable: true,
        get: function() {
          return _index.tsMappedType;
        }
      });
      Object.defineProperty(exports, "TSMethodSignature", {
        enumerable: true,
        get: function() {
          return _index.tsMethodSignature;
        }
      });
      Object.defineProperty(exports, "TSModuleBlock", {
        enumerable: true,
        get: function() {
          return _index.tsModuleBlock;
        }
      });
      Object.defineProperty(exports, "TSModuleDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsModuleDeclaration;
        }
      });
      Object.defineProperty(exports, "TSNamedTupleMember", {
        enumerable: true,
        get: function() {
          return _index.tsNamedTupleMember;
        }
      });
      Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsNamespaceExportDeclaration;
        }
      });
      Object.defineProperty(exports, "TSNeverKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsNeverKeyword;
        }
      });
      Object.defineProperty(exports, "TSNonNullExpression", {
        enumerable: true,
        get: function() {
          return _index.tsNonNullExpression;
        }
      });
      Object.defineProperty(exports, "TSNullKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsNullKeyword;
        }
      });
      Object.defineProperty(exports, "TSNumberKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsNumberKeyword;
        }
      });
      Object.defineProperty(exports, "TSObjectKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsObjectKeyword;
        }
      });
      Object.defineProperty(exports, "TSOptionalType", {
        enumerable: true,
        get: function() {
          return _index.tsOptionalType;
        }
      });
      Object.defineProperty(exports, "TSParameterProperty", {
        enumerable: true,
        get: function() {
          return _index.tsParameterProperty;
        }
      });
      Object.defineProperty(exports, "TSParenthesizedType", {
        enumerable: true,
        get: function() {
          return _index.tsParenthesizedType;
        }
      });
      Object.defineProperty(exports, "TSPropertySignature", {
        enumerable: true,
        get: function() {
          return _index.tsPropertySignature;
        }
      });
      Object.defineProperty(exports, "TSQualifiedName", {
        enumerable: true,
        get: function() {
          return _index.tsQualifiedName;
        }
      });
      Object.defineProperty(exports, "TSRestType", {
        enumerable: true,
        get: function() {
          return _index.tsRestType;
        }
      });
      Object.defineProperty(exports, "TSSatisfiesExpression", {
        enumerable: true,
        get: function() {
          return _index.tsSatisfiesExpression;
        }
      });
      Object.defineProperty(exports, "TSStringKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsStringKeyword;
        }
      });
      Object.defineProperty(exports, "TSSymbolKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsSymbolKeyword;
        }
      });
      Object.defineProperty(exports, "TSThisType", {
        enumerable: true,
        get: function() {
          return _index.tsThisType;
        }
      });
      Object.defineProperty(exports, "TSTupleType", {
        enumerable: true,
        get: function() {
          return _index.tsTupleType;
        }
      });
      Object.defineProperty(exports, "TSTypeAliasDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsTypeAliasDeclaration;
        }
      });
      Object.defineProperty(exports, "TSTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.tsTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "TSTypeAssertion", {
        enumerable: true,
        get: function() {
          return _index.tsTypeAssertion;
        }
      });
      Object.defineProperty(exports, "TSTypeLiteral", {
        enumerable: true,
        get: function() {
          return _index.tsTypeLiteral;
        }
      });
      Object.defineProperty(exports, "TSTypeOperator", {
        enumerable: true,
        get: function() {
          return _index.tsTypeOperator;
        }
      });
      Object.defineProperty(exports, "TSTypeParameter", {
        enumerable: true,
        get: function() {
          return _index.tsTypeParameter;
        }
      });
      Object.defineProperty(exports, "TSTypeParameterDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsTypeParameterDeclaration;
        }
      });
      Object.defineProperty(exports, "TSTypeParameterInstantiation", {
        enumerable: true,
        get: function() {
          return _index.tsTypeParameterInstantiation;
        }
      });
      Object.defineProperty(exports, "TSTypePredicate", {
        enumerable: true,
        get: function() {
          return _index.tsTypePredicate;
        }
      });
      Object.defineProperty(exports, "TSTypeQuery", {
        enumerable: true,
        get: function() {
          return _index.tsTypeQuery;
        }
      });
      Object.defineProperty(exports, "TSTypeReference", {
        enumerable: true,
        get: function() {
          return _index.tsTypeReference;
        }
      });
      Object.defineProperty(exports, "TSUndefinedKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsUndefinedKeyword;
        }
      });
      Object.defineProperty(exports, "TSUnionType", {
        enumerable: true,
        get: function() {
          return _index.tsUnionType;
        }
      });
      Object.defineProperty(exports, "TSUnknownKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsUnknownKeyword;
        }
      });
      Object.defineProperty(exports, "TSVoidKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsVoidKeyword;
        }
      });
      Object.defineProperty(exports, "TaggedTemplateExpression", {
        enumerable: true,
        get: function() {
          return _index.taggedTemplateExpression;
        }
      });
      Object.defineProperty(exports, "TemplateElement", {
        enumerable: true,
        get: function() {
          return _index.templateElement;
        }
      });
      Object.defineProperty(exports, "TemplateLiteral", {
        enumerable: true,
        get: function() {
          return _index.templateLiteral;
        }
      });
      Object.defineProperty(exports, "ThisExpression", {
        enumerable: true,
        get: function() {
          return _index.thisExpression;
        }
      });
      Object.defineProperty(exports, "ThisTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.thisTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ThrowStatement", {
        enumerable: true,
        get: function() {
          return _index.throwStatement;
        }
      });
      Object.defineProperty(exports, "TopicReference", {
        enumerable: true,
        get: function() {
          return _index.topicReference;
        }
      });
      Object.defineProperty(exports, "TryStatement", {
        enumerable: true,
        get: function() {
          return _index.tryStatement;
        }
      });
      Object.defineProperty(exports, "TupleExpression", {
        enumerable: true,
        get: function() {
          return _index.tupleExpression;
        }
      });
      Object.defineProperty(exports, "TupleTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.tupleTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "TypeAlias", {
        enumerable: true,
        get: function() {
          return _index.typeAlias;
        }
      });
      Object.defineProperty(exports, "TypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.typeAnnotation;
        }
      });
      Object.defineProperty(exports, "TypeCastExpression", {
        enumerable: true,
        get: function() {
          return _index.typeCastExpression;
        }
      });
      Object.defineProperty(exports, "TypeParameter", {
        enumerable: true,
        get: function() {
          return _index.typeParameter;
        }
      });
      Object.defineProperty(exports, "TypeParameterDeclaration", {
        enumerable: true,
        get: function() {
          return _index.typeParameterDeclaration;
        }
      });
      Object.defineProperty(exports, "TypeParameterInstantiation", {
        enumerable: true,
        get: function() {
          return _index.typeParameterInstantiation;
        }
      });
      Object.defineProperty(exports, "TypeofTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.typeofTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "UnaryExpression", {
        enumerable: true,
        get: function() {
          return _index.unaryExpression;
        }
      });
      Object.defineProperty(exports, "UnionTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.unionTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "UpdateExpression", {
        enumerable: true,
        get: function() {
          return _index.updateExpression;
        }
      });
      Object.defineProperty(exports, "V8IntrinsicIdentifier", {
        enumerable: true,
        get: function() {
          return _index.v8IntrinsicIdentifier;
        }
      });
      Object.defineProperty(exports, "VariableDeclaration", {
        enumerable: true,
        get: function() {
          return _index.variableDeclaration;
        }
      });
      Object.defineProperty(exports, "VariableDeclarator", {
        enumerable: true,
        get: function() {
          return _index.variableDeclarator;
        }
      });
      Object.defineProperty(exports, "Variance", {
        enumerable: true,
        get: function() {
          return _index.variance;
        }
      });
      Object.defineProperty(exports, "VoidTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.voidTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "WhileStatement", {
        enumerable: true,
        get: function() {
          return _index.whileStatement;
        }
      });
      Object.defineProperty(exports, "WithStatement", {
        enumerable: true,
        get: function() {
          return _index.withStatement;
        }
      });
      Object.defineProperty(exports, "YieldExpression", {
        enumerable: true,
        get: function() {
          return _index.yieldExpression;
        }
      });
      var _index = require_generated2();
    }
  });

  // node_modules/@babel/types/lib/clone/cloneNode.js
  var require_cloneNode = __commonJS({
    "node_modules/@babel/types/lib/clone/cloneNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cloneNode;
      var _definitions = require_definitions();
      var _generated = require_generated();
      var has = Function.call.bind(Object.prototype.hasOwnProperty);
      function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
        if (obj && typeof obj.type === "string") {
          return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
        }
        return obj;
      }
      function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
        if (Array.isArray(obj)) {
          return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
        }
        return cloneIfNode(obj, deep, withoutLoc, commentsCache);
      }
      function cloneNode(node, deep = true, withoutLoc = false) {
        return cloneNodeInternal(node, deep, withoutLoc, /* @__PURE__ */ new Map());
      }
      function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
        if (!node)
          return node;
        const {
          type
        } = node;
        const newNode = {
          type: node.type
        };
        if ((0, _generated.isIdentifier)(node)) {
          newNode.name = node.name;
          if (has(node, "optional") && typeof node.optional === "boolean") {
            newNode.optional = node.optional;
          }
          if (has(node, "typeAnnotation")) {
            newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
          }
        } else if (!has(_definitions.NODE_FIELDS, type)) {
          throw new Error(`Unknown node type: "${type}"`);
        } else {
          for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
            if (has(node, field)) {
              if (deep) {
                newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(
                  node[field],
                  true,
                  withoutLoc,
                  commentsCache
                );
              } else {
                newNode[field] = node[field];
              }
            }
          }
        }
        if (has(node, "loc")) {
          if (withoutLoc) {
            newNode.loc = null;
          } else {
            newNode.loc = node.loc;
          }
        }
        if (has(node, "leadingComments")) {
          newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
        }
        if (has(node, "innerComments")) {
          newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
        }
        if (has(node, "trailingComments")) {
          newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
        }
        if (has(node, "extra")) {
          newNode.extra = Object.assign({}, node.extra);
        }
        return newNode;
      }
      function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
        if (!comments || !deep) {
          return comments;
        }
        return comments.map((comment) => {
          const cache = commentsCache.get(comment);
          if (cache)
            return cache;
          const {
            type,
            value,
            loc
          } = comment;
          const ret = {
            type,
            value,
            loc
          };
          if (withoutLoc) {
            ret.loc = null;
          }
          commentsCache.set(comment, ret);
          return ret;
        });
      }
    }
  });

  // node_modules/@babel/types/lib/clone/clone.js
  var require_clone = __commonJS({
    "node_modules/@babel/types/lib/clone/clone.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = clone2;
      var _cloneNode = require_cloneNode();
      function clone2(node) {
        return (0, _cloneNode.default)(node, false);
      }
    }
  });

  // node_modules/@babel/types/lib/clone/cloneDeep.js
  var require_cloneDeep = __commonJS({
    "node_modules/@babel/types/lib/clone/cloneDeep.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cloneDeep;
      var _cloneNode = require_cloneNode();
      function cloneDeep(node) {
        return (0, _cloneNode.default)(node);
      }
    }
  });

  // node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
  var require_cloneDeepWithoutLoc = __commonJS({
    "node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cloneDeepWithoutLoc;
      var _cloneNode = require_cloneNode();
      function cloneDeepWithoutLoc(node) {
        return (0, _cloneNode.default)(node, true, true);
      }
    }
  });

  // node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
  var require_cloneWithoutLoc = __commonJS({
    "node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cloneWithoutLoc;
      var _cloneNode = require_cloneNode();
      function cloneWithoutLoc(node) {
        return (0, _cloneNode.default)(node, false, true);
      }
    }
  });

  // node_modules/@babel/types/lib/comments/addComments.js
  var require_addComments = __commonJS({
    "node_modules/@babel/types/lib/comments/addComments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = addComments;
      function addComments(node, type, comments) {
        if (!comments || !node)
          return node;
        const key = `${type}Comments`;
        if (node[key]) {
          if (type === "leading") {
            node[key] = comments.concat(node[key]);
          } else {
            node[key].push(...comments);
          }
        } else {
          node[key] = comments;
        }
        return node;
      }
    }
  });

  // node_modules/@babel/types/lib/comments/addComment.js
  var require_addComment = __commonJS({
    "node_modules/@babel/types/lib/comments/addComment.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = addComment;
      var _addComments = require_addComments();
      function addComment(node, type, content, line) {
        return (0, _addComments.default)(node, type, [{
          type: line ? "CommentLine" : "CommentBlock",
          value: content
        }]);
      }
    }
  });

  // node_modules/@babel/types/lib/utils/inherit.js
  var require_inherit = __commonJS({
    "node_modules/@babel/types/lib/utils/inherit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inherit;
      function inherit(key, child, parent) {
        if (child && parent) {
          child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
        }
      }
    }
  });

  // node_modules/@babel/types/lib/comments/inheritInnerComments.js
  var require_inheritInnerComments = __commonJS({
    "node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inheritInnerComments;
      var _inherit = require_inherit();
      function inheritInnerComments(child, parent) {
        (0, _inherit.default)("innerComments", child, parent);
      }
    }
  });

  // node_modules/@babel/types/lib/comments/inheritLeadingComments.js
  var require_inheritLeadingComments = __commonJS({
    "node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inheritLeadingComments;
      var _inherit = require_inherit();
      function inheritLeadingComments(child, parent) {
        (0, _inherit.default)("leadingComments", child, parent);
      }
    }
  });

  // node_modules/@babel/types/lib/comments/inheritTrailingComments.js
  var require_inheritTrailingComments = __commonJS({
    "node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inheritTrailingComments;
      var _inherit = require_inherit();
      function inheritTrailingComments(child, parent) {
        (0, _inherit.default)("trailingComments", child, parent);
      }
    }
  });

  // node_modules/@babel/types/lib/comments/inheritsComments.js
  var require_inheritsComments = __commonJS({
    "node_modules/@babel/types/lib/comments/inheritsComments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inheritsComments;
      var _inheritTrailingComments = require_inheritTrailingComments();
      var _inheritLeadingComments = require_inheritLeadingComments();
      var _inheritInnerComments = require_inheritInnerComments();
      function inheritsComments(child, parent) {
        (0, _inheritTrailingComments.default)(child, parent);
        (0, _inheritLeadingComments.default)(child, parent);
        (0, _inheritInnerComments.default)(child, parent);
        return child;
      }
    }
  });

  // node_modules/@babel/types/lib/comments/removeComments.js
  var require_removeComments = __commonJS({
    "node_modules/@babel/types/lib/comments/removeComments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = removeComments;
      var _constants = require_constants();
      function removeComments(node) {
        _constants.COMMENT_KEYS.forEach((key) => {
          node[key] = null;
        });
        return node;
      }
    }
  });

  // node_modules/@babel/types/lib/constants/generated/index.js
  var require_generated4 = __commonJS({
    "node_modules/@babel/types/lib/constants/generated/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
      var _definitions = require_definitions();
      var STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Standardized"];
      exports.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
      var EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
      exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
      var BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
      exports.BINARY_TYPES = BINARY_TYPES;
      var SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
      exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
      var BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
      exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
      var BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
      exports.BLOCK_TYPES = BLOCK_TYPES;
      var STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
      exports.STATEMENT_TYPES = STATEMENT_TYPES;
      var TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
      exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
      var COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
      exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
      var CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
      exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
      var LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
      exports.LOOP_TYPES = LOOP_TYPES;
      var WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
      exports.WHILE_TYPES = WHILE_TYPES;
      var EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
      exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
      var FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
      exports.FOR_TYPES = FOR_TYPES;
      var FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
      exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
      var FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
      exports.FUNCTION_TYPES = FUNCTION_TYPES;
      var FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
      exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
      var PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
      exports.PUREISH_TYPES = PUREISH_TYPES;
      var DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
      exports.DECLARATION_TYPES = DECLARATION_TYPES;
      var PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
      exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
      var LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
      exports.LVAL_TYPES = LVAL_TYPES;
      var TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
      exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
      var LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
      exports.LITERAL_TYPES = LITERAL_TYPES;
      var IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
      exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
      var USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
      exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
      var METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
      exports.METHOD_TYPES = METHOD_TYPES;
      var OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
      exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
      var PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
      exports.PROPERTY_TYPES = PROPERTY_TYPES;
      var UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
      exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
      var PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
      exports.PATTERN_TYPES = PATTERN_TYPES;
      var CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
      exports.CLASS_TYPES = CLASS_TYPES;
      var MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
      exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
      var EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
      exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
      var MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
      exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
      var ACCESSOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Accessor"];
      exports.ACCESSOR_TYPES = ACCESSOR_TYPES;
      var PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
      exports.PRIVATE_TYPES = PRIVATE_TYPES;
      var FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
      exports.FLOW_TYPES = FLOW_TYPES;
      var FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
      exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
      var FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
      exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
      var FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
      exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
      var FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
      exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
      var ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
      exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
      var ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
      exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
      var JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
      exports.JSX_TYPES = JSX_TYPES;
      var MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Miscellaneous"];
      exports.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
      var TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TypeScript"];
      exports.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
      var TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
      exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
      var TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
      exports.TSTYPE_TYPES = TSTYPE_TYPES;
      var TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
      exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
    }
  });

  // node_modules/@babel/types/lib/converters/toBlock.js
  var require_toBlock = __commonJS({
    "node_modules/@babel/types/lib/converters/toBlock.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toBlock;
      var _generated = require_generated();
      var _generated2 = require_generated2();
      function toBlock(node, parent) {
        if ((0, _generated.isBlockStatement)(node)) {
          return node;
        }
        let blockNodes = [];
        if ((0, _generated.isEmptyStatement)(node)) {
          blockNodes = [];
        } else {
          if (!(0, _generated.isStatement)(node)) {
            if ((0, _generated.isFunction)(parent)) {
              node = (0, _generated2.returnStatement)(node);
            } else {
              node = (0, _generated2.expressionStatement)(node);
            }
          }
          blockNodes = [node];
        }
        return (0, _generated2.blockStatement)(blockNodes);
      }
    }
  });

  // node_modules/@babel/types/lib/converters/ensureBlock.js
  var require_ensureBlock = __commonJS({
    "node_modules/@babel/types/lib/converters/ensureBlock.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ensureBlock;
      var _toBlock = require_toBlock();
      function ensureBlock(node, key = "body") {
        const result = (0, _toBlock.default)(node[key], node);
        node[key] = result;
        return result;
      }
    }
  });

  // node_modules/@babel/types/lib/converters/toIdentifier.js
  var require_toIdentifier = __commonJS({
    "node_modules/@babel/types/lib/converters/toIdentifier.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toIdentifier;
      var _isValidIdentifier = require_isValidIdentifier();
      var _helperValidatorIdentifier = require_lib2();
      function toIdentifier(input) {
        input = input + "";
        let name41 = "";
        for (const c of input) {
          name41 += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
        }
        name41 = name41.replace(/^[-0-9]+/, "");
        name41 = name41.replace(/[-\s]+(.)?/g, function(match, c) {
          return c ? c.toUpperCase() : "";
        });
        if (!(0, _isValidIdentifier.default)(name41)) {
          name41 = `_${name41}`;
        }
        return name41 || "_";
      }
    }
  });

  // node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
  var require_toBindingIdentifierName = __commonJS({
    "node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toBindingIdentifierName;
      var _toIdentifier = require_toIdentifier();
      function toBindingIdentifierName(name41) {
        name41 = (0, _toIdentifier.default)(name41);
        if (name41 === "eval" || name41 === "arguments")
          name41 = "_" + name41;
        return name41;
      }
    }
  });

  // node_modules/@babel/types/lib/converters/toComputedKey.js
  var require_toComputedKey = __commonJS({
    "node_modules/@babel/types/lib/converters/toComputedKey.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toComputedKey;
      var _generated = require_generated();
      var _generated2 = require_generated2();
      function toComputedKey(node, key = node.key || node.property) {
        if (!node.computed && (0, _generated.isIdentifier)(key))
          key = (0, _generated2.stringLiteral)(key.name);
        return key;
      }
    }
  });

  // node_modules/@babel/types/lib/converters/toExpression.js
  var require_toExpression = __commonJS({
    "node_modules/@babel/types/lib/converters/toExpression.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _generated = require_generated();
      var _default = toExpression;
      exports.default = _default;
      function toExpression(node) {
        if ((0, _generated.isExpressionStatement)(node)) {
          node = node.expression;
        }
        if ((0, _generated.isExpression)(node)) {
          return node;
        }
        if ((0, _generated.isClass)(node)) {
          node.type = "ClassExpression";
        } else if ((0, _generated.isFunction)(node)) {
          node.type = "FunctionExpression";
        }
        if (!(0, _generated.isExpression)(node)) {
          throw new Error(`cannot turn ${node.type} to an expression`);
        }
        return node;
      }
    }
  });

  // node_modules/@babel/types/lib/traverse/traverseFast.js
  var require_traverseFast = __commonJS({
    "node_modules/@babel/types/lib/traverse/traverseFast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = traverseFast;
      var _definitions = require_definitions();
      function traverseFast(node, enter, opts) {
        if (!node)
          return;
        const keys = _definitions.VISITOR_KEYS[node.type];
        if (!keys)
          return;
        opts = opts || {};
        enter(node, opts);
        for (const key of keys) {
          const subNode = node[key];
          if (Array.isArray(subNode)) {
            for (const node2 of subNode) {
              traverseFast(node2, enter, opts);
            }
          } else {
            traverseFast(subNode, enter, opts);
          }
        }
      }
    }
  });

  // node_modules/@babel/types/lib/modifications/removeProperties.js
  var require_removeProperties = __commonJS({
    "node_modules/@babel/types/lib/modifications/removeProperties.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = removeProperties;
      var _constants = require_constants();
      var CLEAR_KEYS = [
        "tokens",
        "start",
        "end",
        "loc",
        "raw",
        "rawValue"
      ];
      var CLEAR_KEYS_PLUS_COMMENTS = [..._constants.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
      function removeProperties(node, opts = {}) {
        const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
        for (const key of map) {
          if (node[key] != null)
            node[key] = void 0;
        }
        for (const key of Object.keys(node)) {
          if (key[0] === "_" && node[key] != null)
            node[key] = void 0;
        }
        const symbols = Object.getOwnPropertySymbols(node);
        for (const sym of symbols) {
          node[sym] = null;
        }
      }
    }
  });

  // node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
  var require_removePropertiesDeep = __commonJS({
    "node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = removePropertiesDeep;
      var _traverseFast = require_traverseFast();
      var _removeProperties = require_removeProperties();
      function removePropertiesDeep(tree, opts) {
        (0, _traverseFast.default)(tree, _removeProperties.default, opts);
        return tree;
      }
    }
  });

  // node_modules/@babel/types/lib/converters/toKeyAlias.js
  var require_toKeyAlias = __commonJS({
    "node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toKeyAlias;
      var _generated = require_generated();
      var _cloneNode = require_cloneNode();
      var _removePropertiesDeep = require_removePropertiesDeep();
      function toKeyAlias(node, key = node.key) {
        let alias;
        if (node.kind === "method") {
          return toKeyAlias.increment() + "";
        } else if ((0, _generated.isIdentifier)(key)) {
          alias = key.name;
        } else if ((0, _generated.isStringLiteral)(key)) {
          alias = JSON.stringify(key.value);
        } else {
          alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
        }
        if (node.computed) {
          alias = `[${alias}]`;
        }
        if (node.static) {
          alias = `static:${alias}`;
        }
        return alias;
      }
      toKeyAlias.uid = 0;
      toKeyAlias.increment = function() {
        if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
          return toKeyAlias.uid = 0;
        } else {
          return toKeyAlias.uid++;
        }
      };
    }
  });

  // node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
  var require_getBindingIdentifiers = __commonJS({
    "node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = getBindingIdentifiers;
      var _generated = require_generated();
      function getBindingIdentifiers(node, duplicates, outerOnly) {
        const search = [].concat(node);
        const ids = /* @__PURE__ */ Object.create(null);
        while (search.length) {
          const id = search.shift();
          if (!id)
            continue;
          const keys = getBindingIdentifiers.keys[id.type];
          if ((0, _generated.isIdentifier)(id)) {
            if (duplicates) {
              const _ids = ids[id.name] = ids[id.name] || [];
              _ids.push(id);
            } else {
              ids[id.name] = id;
            }
            continue;
          }
          if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {
            if ((0, _generated.isDeclaration)(id.declaration)) {
              search.push(id.declaration);
            }
            continue;
          }
          if (outerOnly) {
            if ((0, _generated.isFunctionDeclaration)(id)) {
              search.push(id.id);
              continue;
            }
            if ((0, _generated.isFunctionExpression)(id)) {
              continue;
            }
          }
          if (keys) {
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const nodes = id[key];
              if (nodes) {
                Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
              }
            }
          }
        }
        return ids;
      }
      getBindingIdentifiers.keys = {
        DeclareClass: ["id"],
        DeclareFunction: ["id"],
        DeclareModule: ["id"],
        DeclareVariable: ["id"],
        DeclareInterface: ["id"],
        DeclareTypeAlias: ["id"],
        DeclareOpaqueType: ["id"],
        InterfaceDeclaration: ["id"],
        TypeAlias: ["id"],
        OpaqueType: ["id"],
        CatchClause: ["param"],
        LabeledStatement: ["label"],
        UnaryExpression: ["argument"],
        AssignmentExpression: ["left"],
        ImportSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportDefaultSpecifier: ["local"],
        ImportDeclaration: ["specifiers"],
        ExportSpecifier: ["exported"],
        ExportNamespaceSpecifier: ["exported"],
        ExportDefaultSpecifier: ["exported"],
        FunctionDeclaration: ["id", "params"],
        FunctionExpression: ["id", "params"],
        ArrowFunctionExpression: ["params"],
        ObjectMethod: ["params"],
        ClassMethod: ["params"],
        ClassPrivateMethod: ["params"],
        ForInStatement: ["left"],
        ForOfStatement: ["left"],
        ClassDeclaration: ["id"],
        ClassExpression: ["id"],
        RestElement: ["argument"],
        UpdateExpression: ["argument"],
        ObjectProperty: ["value"],
        AssignmentPattern: ["left"],
        ArrayPattern: ["elements"],
        ObjectPattern: ["properties"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id"]
      };
    }
  });

  // node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
  var require_gatherSequenceExpressions = __commonJS({
    "node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = gatherSequenceExpressions;
      var _getBindingIdentifiers = require_getBindingIdentifiers();
      var _generated = require_generated();
      var _generated2 = require_generated2();
      var _cloneNode = require_cloneNode();
      function gatherSequenceExpressions(nodes, scope, declars) {
        const exprs = [];
        let ensureLastUndefined = true;
        for (const node of nodes) {
          if (!(0, _generated.isEmptyStatement)(node)) {
            ensureLastUndefined = false;
          }
          if ((0, _generated.isExpression)(node)) {
            exprs.push(node);
          } else if ((0, _generated.isExpressionStatement)(node)) {
            exprs.push(node.expression);
          } else if ((0, _generated.isVariableDeclaration)(node)) {
            if (node.kind !== "var")
              return;
            for (const declar of node.declarations) {
              const bindings = (0, _getBindingIdentifiers.default)(declar);
              for (const key of Object.keys(bindings)) {
                declars.push({
                  kind: node.kind,
                  id: (0, _cloneNode.default)(bindings[key])
                });
              }
              if (declar.init) {
                exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
              }
            }
            ensureLastUndefined = true;
          } else if ((0, _generated.isIfStatement)(node)) {
            const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
            const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
            if (!consequent || !alternate)
              return;
            exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
          } else if ((0, _generated.isBlockStatement)(node)) {
            const body = gatherSequenceExpressions(node.body, scope, declars);
            if (!body)
              return;
            exprs.push(body);
          } else if ((0, _generated.isEmptyStatement)(node)) {
            if (nodes.indexOf(node) === 0) {
              ensureLastUndefined = true;
            }
          } else {
            return;
          }
        }
        if (ensureLastUndefined) {
          exprs.push(scope.buildUndefinedNode());
        }
        if (exprs.length === 1) {
          return exprs[0];
        } else {
          return (0, _generated2.sequenceExpression)(exprs);
        }
      }
    }
  });

  // node_modules/@babel/types/lib/converters/toSequenceExpression.js
  var require_toSequenceExpression = __commonJS({
    "node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toSequenceExpression;
      var _gatherSequenceExpressions = require_gatherSequenceExpressions();
      function toSequenceExpression(nodes, scope) {
        if (!(nodes != null && nodes.length))
          return;
        const declars = [];
        const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
        if (!result)
          return;
        for (const declar of declars) {
          scope.push(declar);
        }
        return result;
      }
    }
  });

  // node_modules/@babel/types/lib/converters/toStatement.js
  var require_toStatement = __commonJS({
    "node_modules/@babel/types/lib/converters/toStatement.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _generated = require_generated();
      var _generated2 = require_generated2();
      var _default = toStatement;
      exports.default = _default;
      function toStatement(node, ignore) {
        if ((0, _generated.isStatement)(node)) {
          return node;
        }
        let mustHaveId = false;
        let newType;
        if ((0, _generated.isClass)(node)) {
          mustHaveId = true;
          newType = "ClassDeclaration";
        } else if ((0, _generated.isFunction)(node)) {
          mustHaveId = true;
          newType = "FunctionDeclaration";
        } else if ((0, _generated.isAssignmentExpression)(node)) {
          return (0, _generated2.expressionStatement)(node);
        }
        if (mustHaveId && !node.id) {
          newType = false;
        }
        if (!newType) {
          if (ignore) {
            return false;
          } else {
            throw new Error(`cannot turn ${node.type} to a statement`);
          }
        }
        node.type = newType;
        return node;
      }
    }
  });

  // node_modules/@babel/types/lib/converters/valueToNode.js
  var require_valueToNode = __commonJS({
    "node_modules/@babel/types/lib/converters/valueToNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _isValidIdentifier = require_isValidIdentifier();
      var _generated = require_generated2();
      var _default = valueToNode;
      exports.default = _default;
      var objectToString = Function.call.bind(Object.prototype.toString);
      function isRegExp(value) {
        return objectToString(value) === "[object RegExp]";
      }
      function isPlainObject(value) {
        if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
          return false;
        }
        const proto = Object.getPrototypeOf(value);
        return proto === null || Object.getPrototypeOf(proto) === null;
      }
      function valueToNode(value) {
        if (value === void 0) {
          return (0, _generated.identifier)("undefined");
        }
        if (value === true || value === false) {
          return (0, _generated.booleanLiteral)(value);
        }
        if (value === null) {
          return (0, _generated.nullLiteral)();
        }
        if (typeof value === "string") {
          return (0, _generated.stringLiteral)(value);
        }
        if (typeof value === "number") {
          let result;
          if (Number.isFinite(value)) {
            result = (0, _generated.numericLiteral)(Math.abs(value));
          } else {
            let numerator;
            if (Number.isNaN(value)) {
              numerator = (0, _generated.numericLiteral)(0);
            } else {
              numerator = (0, _generated.numericLiteral)(1);
            }
            result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
          }
          if (value < 0 || Object.is(value, -0)) {
            result = (0, _generated.unaryExpression)("-", result);
          }
          return result;
        }
        if (isRegExp(value)) {
          const pattern = value.source;
          const flags = value.toString().match(/\/([a-z]+|)$/)[1];
          return (0, _generated.regExpLiteral)(pattern, flags);
        }
        if (Array.isArray(value)) {
          return (0, _generated.arrayExpression)(value.map(valueToNode));
        }
        if (isPlainObject(value)) {
          const props = [];
          for (const key of Object.keys(value)) {
            let nodeKey;
            if ((0, _isValidIdentifier.default)(key)) {
              nodeKey = (0, _generated.identifier)(key);
            } else {
              nodeKey = (0, _generated.stringLiteral)(key);
            }
            props.push((0, _generated.objectProperty)(nodeKey, valueToNode(
              value[key]
            )));
          }
          return (0, _generated.objectExpression)(props);
        }
        throw new Error("don't know how to turn this value into a node");
      }
    }
  });

  // node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
  var require_appendToMemberExpression = __commonJS({
    "node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = appendToMemberExpression;
      var _generated = require_generated2();
      function appendToMemberExpression(member, append2, computed2 = false) {
        member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
        member.property = append2;
        member.computed = !!computed2;
        return member;
      }
    }
  });

  // node_modules/@babel/types/lib/modifications/inherits.js
  var require_inherits = __commonJS({
    "node_modules/@babel/types/lib/modifications/inherits.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inherits;
      var _constants = require_constants();
      var _inheritsComments = require_inheritsComments();
      function inherits(child, parent) {
        if (!child || !parent)
          return child;
        for (const key of _constants.INHERIT_KEYS.optional) {
          if (child[key] == null) {
            child[key] = parent[key];
          }
        }
        for (const key of Object.keys(parent)) {
          if (key[0] === "_" && key !== "__clone") {
            child[key] = parent[key];
          }
        }
        for (const key of _constants.INHERIT_KEYS.force) {
          child[key] = parent[key];
        }
        (0, _inheritsComments.default)(child, parent);
        return child;
      }
    }
  });

  // node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
  var require_prependToMemberExpression = __commonJS({
    "node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = prependToMemberExpression;
      var _generated = require_generated2();
      var _ = require_lib4();
      function prependToMemberExpression(member, prepend) {
        if ((0, _.isSuper)(member.object)) {
          throw new Error("Cannot prepend node to super property access (`super.foo`).");
        }
        member.object = (0, _generated.memberExpression)(prepend, member.object);
        return member;
      }
    }
  });

  // node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
  var require_getOuterBindingIdentifiers = __commonJS({
    "node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _getBindingIdentifiers = require_getBindingIdentifiers();
      var _default = getOuterBindingIdentifiers;
      exports.default = _default;
      function getOuterBindingIdentifiers(node, duplicates) {
        return (0, _getBindingIdentifiers.default)(node, duplicates, true);
      }
    }
  });

  // node_modules/@babel/types/lib/traverse/traverse.js
  var require_traverse = __commonJS({
    "node_modules/@babel/types/lib/traverse/traverse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = traverse;
      var _definitions = require_definitions();
      function traverse(node, handlers, state) {
        if (typeof handlers === "function") {
          handlers = {
            enter: handlers
          };
        }
        const {
          enter,
          exit
        } = handlers;
        traverseSimpleImpl(node, enter, exit, state, []);
      }
      function traverseSimpleImpl(node, enter, exit, state, ancestors) {
        const keys = _definitions.VISITOR_KEYS[node.type];
        if (!keys)
          return;
        if (enter)
          enter(node, ancestors, state);
        for (const key of keys) {
          const subNode = node[key];
          if (Array.isArray(subNode)) {
            for (let i = 0; i < subNode.length; i++) {
              const child = subNode[i];
              if (!child)
                continue;
              ancestors.push({
                node,
                key,
                index: i
              });
              traverseSimpleImpl(child, enter, exit, state, ancestors);
              ancestors.pop();
            }
          } else if (subNode) {
            ancestors.push({
              node,
              key
            });
            traverseSimpleImpl(subNode, enter, exit, state, ancestors);
            ancestors.pop();
          }
        }
        if (exit)
          exit(node, ancestors, state);
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isBinding.js
  var require_isBinding = __commonJS({
    "node_modules/@babel/types/lib/validators/isBinding.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBinding;
      var _getBindingIdentifiers = require_getBindingIdentifiers();
      function isBinding(node, parent, grandparent) {
        if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
          return false;
        }
        const keys = _getBindingIdentifiers.default.keys[parent.type];
        if (keys) {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const val = parent[key];
            if (Array.isArray(val)) {
              if (val.indexOf(node) >= 0)
                return true;
            } else {
              if (val === node)
                return true;
            }
          }
        }
        return false;
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isLet.js
  var require_isLet = __commonJS({
    "node_modules/@babel/types/lib/validators/isLet.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isLet;
      var _generated = require_generated();
      var _constants = require_constants();
      function isLet(node) {
        return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isBlockScoped.js
  var require_isBlockScoped = __commonJS({
    "node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBlockScoped;
      var _generated = require_generated();
      var _isLet = require_isLet();
      function isBlockScoped(node) {
        return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isImmutable.js
  var require_isImmutable = __commonJS({
    "node_modules/@babel/types/lib/validators/isImmutable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isImmutable;
      var _isType = require_isType();
      var _generated = require_generated();
      function isImmutable(node) {
        if ((0, _isType.default)(node.type, "Immutable"))
          return true;
        if ((0, _generated.isIdentifier)(node)) {
          if (node.name === "undefined") {
            return true;
          } else {
            return false;
          }
        }
        return false;
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isNodesEquivalent.js
  var require_isNodesEquivalent = __commonJS({
    "node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isNodesEquivalent;
      var _definitions = require_definitions();
      function isNodesEquivalent(a, b) {
        if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
          return a === b;
        }
        if (a.type !== b.type) {
          return false;
        }
        const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
        const visitorKeys = _definitions.VISITOR_KEYS[a.type];
        for (const field of fields) {
          const val_a = a[field];
          const val_b = b[field];
          if (typeof val_a !== typeof val_b) {
            return false;
          }
          if (val_a == null && val_b == null) {
            continue;
          } else if (val_a == null || val_b == null) {
            return false;
          }
          if (Array.isArray(val_a)) {
            if (!Array.isArray(val_b)) {
              return false;
            }
            if (val_a.length !== val_b.length) {
              return false;
            }
            for (let i = 0; i < val_a.length; i++) {
              if (!isNodesEquivalent(val_a[i], val_b[i])) {
                return false;
              }
            }
            continue;
          }
          if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
            for (const key of Object.keys(val_a)) {
              if (val_a[key] !== val_b[key]) {
                return false;
              }
            }
            continue;
          }
          if (!isNodesEquivalent(val_a, val_b)) {
            return false;
          }
        }
        return true;
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isReferenced.js
  var require_isReferenced = __commonJS({
    "node_modules/@babel/types/lib/validators/isReferenced.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isReferenced;
      function isReferenced(node, parent, grandparent) {
        switch (parent.type) {
          case "MemberExpression":
          case "OptionalMemberExpression":
            if (parent.property === node) {
              return !!parent.computed;
            }
            return parent.object === node;
          case "JSXMemberExpression":
            return parent.object === node;
          case "VariableDeclarator":
            return parent.init === node;
          case "ArrowFunctionExpression":
            return parent.body === node;
          case "PrivateName":
            return false;
          case "ClassMethod":
          case "ClassPrivateMethod":
          case "ObjectMethod":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return false;
          case "ObjectProperty":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return !grandparent || grandparent.type !== "ObjectPattern";
          case "ClassProperty":
          case "ClassAccessorProperty":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return true;
          case "ClassPrivateProperty":
            return parent.key !== node;
          case "ClassDeclaration":
          case "ClassExpression":
            return parent.superClass === node;
          case "AssignmentExpression":
            return parent.right === node;
          case "AssignmentPattern":
            return parent.right === node;
          case "LabeledStatement":
            return false;
          case "CatchClause":
            return false;
          case "RestElement":
            return false;
          case "BreakStatement":
          case "ContinueStatement":
            return false;
          case "FunctionDeclaration":
          case "FunctionExpression":
            return false;
          case "ExportNamespaceSpecifier":
          case "ExportDefaultSpecifier":
            return false;
          case "ExportSpecifier":
            if (grandparent != null && grandparent.source) {
              return false;
            }
            return parent.local === node;
          case "ImportDefaultSpecifier":
          case "ImportNamespaceSpecifier":
          case "ImportSpecifier":
            return false;
          case "ImportAttribute":
            return false;
          case "JSXAttribute":
            return false;
          case "ObjectPattern":
          case "ArrayPattern":
            return false;
          case "MetaProperty":
            return false;
          case "ObjectTypeProperty":
            return parent.key !== node;
          case "TSEnumMember":
            return parent.id !== node;
          case "TSPropertySignature":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return true;
        }
        return true;
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isScope.js
  var require_isScope = __commonJS({
    "node_modules/@babel/types/lib/validators/isScope.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isScope;
      var _generated = require_generated();
      function isScope(node, parent) {
        if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {
          return false;
        }
        if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {
          return true;
        }
        return (0, _generated.isScopable)(node);
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isSpecifierDefault.js
  var require_isSpecifierDefault = __commonJS({
    "node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isSpecifierDefault;
      var _generated = require_generated();
      function isSpecifierDefault(specifier) {
        return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
          name: "default"
        });
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isValidES3Identifier.js
  var require_isValidES3Identifier = __commonJS({
    "node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isValidES3Identifier;
      var _isValidIdentifier = require_isValidIdentifier();
      var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
      function isValidES3Identifier(name41) {
        return (0, _isValidIdentifier.default)(name41) && !RESERVED_WORDS_ES3_ONLY.has(name41);
      }
    }
  });

  // node_modules/@babel/types/lib/validators/isVar.js
  var require_isVar = __commonJS({
    "node_modules/@babel/types/lib/validators/isVar.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isVar;
      var _generated = require_generated();
      var _constants = require_constants();
      function isVar(node) {
        return (0, _generated.isVariableDeclaration)(node, {
          kind: "var"
        }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
      }
    }
  });

  // node_modules/@babel/types/lib/ast-types/generated/index.js
  var require_generated5 = __commonJS({
    "node_modules/@babel/types/lib/ast-types/generated/index.js"() {
    }
  });

  // node_modules/@babel/types/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/@babel/types/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _exportNames = {
        react: true,
        assertNode: true,
        createTypeAnnotationBasedOnTypeof: true,
        createUnionTypeAnnotation: true,
        createFlowUnionType: true,
        createTSUnionType: true,
        cloneNode: true,
        clone: true,
        cloneDeep: true,
        cloneDeepWithoutLoc: true,
        cloneWithoutLoc: true,
        addComment: true,
        addComments: true,
        inheritInnerComments: true,
        inheritLeadingComments: true,
        inheritsComments: true,
        inheritTrailingComments: true,
        removeComments: true,
        ensureBlock: true,
        toBindingIdentifierName: true,
        toBlock: true,
        toComputedKey: true,
        toExpression: true,
        toIdentifier: true,
        toKeyAlias: true,
        toSequenceExpression: true,
        toStatement: true,
        valueToNode: true,
        appendToMemberExpression: true,
        inherits: true,
        prependToMemberExpression: true,
        removeProperties: true,
        removePropertiesDeep: true,
        removeTypeDuplicates: true,
        getBindingIdentifiers: true,
        getOuterBindingIdentifiers: true,
        traverse: true,
        traverseFast: true,
        shallowEqual: true,
        is: true,
        isBinding: true,
        isBlockScoped: true,
        isImmutable: true,
        isLet: true,
        isNode: true,
        isNodesEquivalent: true,
        isPlaceholderType: true,
        isReferenced: true,
        isScope: true,
        isSpecifierDefault: true,
        isType: true,
        isValidES3Identifier: true,
        isValidIdentifier: true,
        isVar: true,
        matchesPattern: true,
        validate: true,
        buildMatchMemberExpression: true
      };
      Object.defineProperty(exports, "addComment", {
        enumerable: true,
        get: function() {
          return _addComment.default;
        }
      });
      Object.defineProperty(exports, "addComments", {
        enumerable: true,
        get: function() {
          return _addComments.default;
        }
      });
      Object.defineProperty(exports, "appendToMemberExpression", {
        enumerable: true,
        get: function() {
          return _appendToMemberExpression.default;
        }
      });
      Object.defineProperty(exports, "assertNode", {
        enumerable: true,
        get: function() {
          return _assertNode.default;
        }
      });
      Object.defineProperty(exports, "buildMatchMemberExpression", {
        enumerable: true,
        get: function() {
          return _buildMatchMemberExpression.default;
        }
      });
      Object.defineProperty(exports, "clone", {
        enumerable: true,
        get: function() {
          return _clone.default;
        }
      });
      Object.defineProperty(exports, "cloneDeep", {
        enumerable: true,
        get: function() {
          return _cloneDeep.default;
        }
      });
      Object.defineProperty(exports, "cloneDeepWithoutLoc", {
        enumerable: true,
        get: function() {
          return _cloneDeepWithoutLoc.default;
        }
      });
      Object.defineProperty(exports, "cloneNode", {
        enumerable: true,
        get: function() {
          return _cloneNode.default;
        }
      });
      Object.defineProperty(exports, "cloneWithoutLoc", {
        enumerable: true,
        get: function() {
          return _cloneWithoutLoc.default;
        }
      });
      Object.defineProperty(exports, "createFlowUnionType", {
        enumerable: true,
        get: function() {
          return _createFlowUnionType.default;
        }
      });
      Object.defineProperty(exports, "createTSUnionType", {
        enumerable: true,
        get: function() {
          return _createTSUnionType.default;
        }
      });
      Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
        enumerable: true,
        get: function() {
          return _createTypeAnnotationBasedOnTypeof.default;
        }
      });
      Object.defineProperty(exports, "createUnionTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _createFlowUnionType.default;
        }
      });
      Object.defineProperty(exports, "ensureBlock", {
        enumerable: true,
        get: function() {
          return _ensureBlock.default;
        }
      });
      Object.defineProperty(exports, "getBindingIdentifiers", {
        enumerable: true,
        get: function() {
          return _getBindingIdentifiers.default;
        }
      });
      Object.defineProperty(exports, "getOuterBindingIdentifiers", {
        enumerable: true,
        get: function() {
          return _getOuterBindingIdentifiers.default;
        }
      });
      Object.defineProperty(exports, "inheritInnerComments", {
        enumerable: true,
        get: function() {
          return _inheritInnerComments.default;
        }
      });
      Object.defineProperty(exports, "inheritLeadingComments", {
        enumerable: true,
        get: function() {
          return _inheritLeadingComments.default;
        }
      });
      Object.defineProperty(exports, "inheritTrailingComments", {
        enumerable: true,
        get: function() {
          return _inheritTrailingComments.default;
        }
      });
      Object.defineProperty(exports, "inherits", {
        enumerable: true,
        get: function() {
          return _inherits.default;
        }
      });
      Object.defineProperty(exports, "inheritsComments", {
        enumerable: true,
        get: function() {
          return _inheritsComments.default;
        }
      });
      Object.defineProperty(exports, "is", {
        enumerable: true,
        get: function() {
          return _is.default;
        }
      });
      Object.defineProperty(exports, "isBinding", {
        enumerable: true,
        get: function() {
          return _isBinding.default;
        }
      });
      Object.defineProperty(exports, "isBlockScoped", {
        enumerable: true,
        get: function() {
          return _isBlockScoped.default;
        }
      });
      Object.defineProperty(exports, "isImmutable", {
        enumerable: true,
        get: function() {
          return _isImmutable.default;
        }
      });
      Object.defineProperty(exports, "isLet", {
        enumerable: true,
        get: function() {
          return _isLet.default;
        }
      });
      Object.defineProperty(exports, "isNode", {
        enumerable: true,
        get: function() {
          return _isNode.default;
        }
      });
      Object.defineProperty(exports, "isNodesEquivalent", {
        enumerable: true,
        get: function() {
          return _isNodesEquivalent.default;
        }
      });
      Object.defineProperty(exports, "isPlaceholderType", {
        enumerable: true,
        get: function() {
          return _isPlaceholderType.default;
        }
      });
      Object.defineProperty(exports, "isReferenced", {
        enumerable: true,
        get: function() {
          return _isReferenced.default;
        }
      });
      Object.defineProperty(exports, "isScope", {
        enumerable: true,
        get: function() {
          return _isScope.default;
        }
      });
      Object.defineProperty(exports, "isSpecifierDefault", {
        enumerable: true,
        get: function() {
          return _isSpecifierDefault.default;
        }
      });
      Object.defineProperty(exports, "isType", {
        enumerable: true,
        get: function() {
          return _isType.default;
        }
      });
      Object.defineProperty(exports, "isValidES3Identifier", {
        enumerable: true,
        get: function() {
          return _isValidES3Identifier.default;
        }
      });
      Object.defineProperty(exports, "isValidIdentifier", {
        enumerable: true,
        get: function() {
          return _isValidIdentifier.default;
        }
      });
      Object.defineProperty(exports, "isVar", {
        enumerable: true,
        get: function() {
          return _isVar.default;
        }
      });
      Object.defineProperty(exports, "matchesPattern", {
        enumerable: true,
        get: function() {
          return _matchesPattern.default;
        }
      });
      Object.defineProperty(exports, "prependToMemberExpression", {
        enumerable: true,
        get: function() {
          return _prependToMemberExpression.default;
        }
      });
      exports.react = void 0;
      Object.defineProperty(exports, "removeComments", {
        enumerable: true,
        get: function() {
          return _removeComments.default;
        }
      });
      Object.defineProperty(exports, "removeProperties", {
        enumerable: true,
        get: function() {
          return _removeProperties.default;
        }
      });
      Object.defineProperty(exports, "removePropertiesDeep", {
        enumerable: true,
        get: function() {
          return _removePropertiesDeep.default;
        }
      });
      Object.defineProperty(exports, "removeTypeDuplicates", {
        enumerable: true,
        get: function() {
          return _removeTypeDuplicates.default;
        }
      });
      Object.defineProperty(exports, "shallowEqual", {
        enumerable: true,
        get: function() {
          return _shallowEqual.default;
        }
      });
      Object.defineProperty(exports, "toBindingIdentifierName", {
        enumerable: true,
        get: function() {
          return _toBindingIdentifierName.default;
        }
      });
      Object.defineProperty(exports, "toBlock", {
        enumerable: true,
        get: function() {
          return _toBlock.default;
        }
      });
      Object.defineProperty(exports, "toComputedKey", {
        enumerable: true,
        get: function() {
          return _toComputedKey.default;
        }
      });
      Object.defineProperty(exports, "toExpression", {
        enumerable: true,
        get: function() {
          return _toExpression.default;
        }
      });
      Object.defineProperty(exports, "toIdentifier", {
        enumerable: true,
        get: function() {
          return _toIdentifier.default;
        }
      });
      Object.defineProperty(exports, "toKeyAlias", {
        enumerable: true,
        get: function() {
          return _toKeyAlias.default;
        }
      });
      Object.defineProperty(exports, "toSequenceExpression", {
        enumerable: true,
        get: function() {
          return _toSequenceExpression.default;
        }
      });
      Object.defineProperty(exports, "toStatement", {
        enumerable: true,
        get: function() {
          return _toStatement.default;
        }
      });
      Object.defineProperty(exports, "traverse", {
        enumerable: true,
        get: function() {
          return _traverse2.default;
        }
      });
      Object.defineProperty(exports, "traverseFast", {
        enumerable: true,
        get: function() {
          return _traverseFast.default;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function() {
          return _validate.default;
        }
      });
      Object.defineProperty(exports, "valueToNode", {
        enumerable: true,
        get: function() {
          return _valueToNode.default;
        }
      });
      var _isReactComponent = require_isReactComponent();
      var _isCompatTag = require_isCompatTag();
      var _buildChildren = require_buildChildren();
      var _assertNode = require_assertNode();
      var _generated = require_generated3();
      Object.keys(_generated).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _generated[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _generated[key];
          }
        });
      });
      var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
      var _createFlowUnionType = require_createFlowUnionType();
      var _createTSUnionType = require_createTSUnionType();
      var _generated2 = require_generated2();
      Object.keys(_generated2).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _generated2[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _generated2[key];
          }
        });
      });
      var _uppercase = require_uppercase();
      Object.keys(_uppercase).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _uppercase[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _uppercase[key];
          }
        });
      });
      var _cloneNode = require_cloneNode();
      var _clone = require_clone();
      var _cloneDeep = require_cloneDeep();
      var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
      var _cloneWithoutLoc = require_cloneWithoutLoc();
      var _addComment = require_addComment();
      var _addComments = require_addComments();
      var _inheritInnerComments = require_inheritInnerComments();
      var _inheritLeadingComments = require_inheritLeadingComments();
      var _inheritsComments = require_inheritsComments();
      var _inheritTrailingComments = require_inheritTrailingComments();
      var _removeComments = require_removeComments();
      var _generated3 = require_generated4();
      Object.keys(_generated3).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _generated3[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _generated3[key];
          }
        });
      });
      var _constants = require_constants();
      Object.keys(_constants).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _constants[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _constants[key];
          }
        });
      });
      var _ensureBlock = require_ensureBlock();
      var _toBindingIdentifierName = require_toBindingIdentifierName();
      var _toBlock = require_toBlock();
      var _toComputedKey = require_toComputedKey();
      var _toExpression = require_toExpression();
      var _toIdentifier = require_toIdentifier();
      var _toKeyAlias = require_toKeyAlias();
      var _toSequenceExpression = require_toSequenceExpression();
      var _toStatement = require_toStatement();
      var _valueToNode = require_valueToNode();
      var _definitions = require_definitions();
      Object.keys(_definitions).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _definitions[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _definitions[key];
          }
        });
      });
      var _appendToMemberExpression = require_appendToMemberExpression();
      var _inherits = require_inherits();
      var _prependToMemberExpression = require_prependToMemberExpression();
      var _removeProperties = require_removeProperties();
      var _removePropertiesDeep = require_removePropertiesDeep();
      var _removeTypeDuplicates = require_removeTypeDuplicates();
      var _getBindingIdentifiers = require_getBindingIdentifiers();
      var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
      var _traverse2 = require_traverse();
      Object.keys(_traverse2).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _traverse2[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _traverse2[key];
          }
        });
      });
      var _traverseFast = require_traverseFast();
      var _shallowEqual = require_shallowEqual();
      var _is = require_is();
      var _isBinding = require_isBinding();
      var _isBlockScoped = require_isBlockScoped();
      var _isImmutable = require_isImmutable();
      var _isLet = require_isLet();
      var _isNode = require_isNode();
      var _isNodesEquivalent = require_isNodesEquivalent();
      var _isPlaceholderType = require_isPlaceholderType();
      var _isReferenced = require_isReferenced();
      var _isScope = require_isScope();
      var _isSpecifierDefault = require_isSpecifierDefault();
      var _isType = require_isType();
      var _isValidES3Identifier = require_isValidES3Identifier();
      var _isValidIdentifier = require_isValidIdentifier();
      var _isVar = require_isVar();
      var _matchesPattern = require_matchesPattern();
      var _validate = require_validate();
      var _buildMatchMemberExpression = require_buildMatchMemberExpression();
      var _generated4 = require_generated();
      Object.keys(_generated4).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _generated4[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _generated4[key];
          }
        });
      });
      var _generated5 = require_generated5();
      Object.keys(_generated5).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _generated5[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _generated5[key];
          }
        });
      });
      var react = {
        isReactComponent: _isReactComponent.default,
        isCompatTag: _isCompatTag.default,
        buildChildren: _buildChildren.default
      };
      exports.react = react;
    }
  });

  // node_modules/@jridgewell/set-array/dist/set-array.umd.js
  var require_set_array_umd = __commonJS({
    "node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.setArray = {}));
      })(exports, function(exports2) {
        "use strict";
        exports2.get = void 0;
        exports2.put = void 0;
        exports2.pop = void 0;
        class SetArray {
          constructor() {
            this._indexes = { __proto__: null };
            this.array = [];
          }
        }
        (() => {
          exports2.get = (strarr, key) => strarr._indexes[key];
          exports2.put = (strarr, key) => {
            const index = exports2.get(strarr, key);
            if (index !== void 0)
              return index;
            const { array, _indexes: indexes } = strarr;
            return indexes[key] = array.push(key) - 1;
          };
          exports2.pop = (strarr) => {
            const { array, _indexes: indexes } = strarr;
            if (array.length === 0)
              return;
            const last = array.pop();
            indexes[last] = void 0;
          };
        })();
        exports2.SetArray = SetArray;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
  var require_sourcemap_codec_umd = __commonJS({
    "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
      })(exports, function(exports2) {
        "use strict";
        const comma = ",".charCodeAt(0);
        const semicolon = ";".charCodeAt(0);
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        const intToChar = new Uint8Array(64);
        const charToInt = new Uint8Array(128);
        for (let i = 0; i < chars.length; i++) {
          const c = chars.charCodeAt(i);
          intToChar[i] = c;
          charToInt[c] = i;
        }
        const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
          decode(buf) {
            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
            return out.toString();
          }
        } : {
          decode(buf) {
            let out = "";
            for (let i = 0; i < buf.length; i++) {
              out += String.fromCharCode(buf[i]);
            }
            return out;
          }
        };
        function decode3(mappings) {
          const state = new Int32Array(5);
          const decoded = [];
          let index = 0;
          do {
            const semi = indexOf(mappings, index);
            const line = [];
            let sorted = true;
            let lastCol = 0;
            state[0] = 0;
            for (let i = index; i < semi; i++) {
              let seg;
              i = decodeInteger(mappings, i, state, 0);
              const col = state[0];
              if (col < lastCol)
                sorted = false;
              lastCol = col;
              if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 1);
                i = decodeInteger(mappings, i, state, 2);
                i = decodeInteger(mappings, i, state, 3);
                if (hasMoreVlq(mappings, i, semi)) {
                  i = decodeInteger(mappings, i, state, 4);
                  seg = [col, state[1], state[2], state[3], state[4]];
                } else {
                  seg = [col, state[1], state[2], state[3]];
                }
              } else {
                seg = [col];
              }
              line.push(seg);
            }
            if (!sorted)
              sort(line);
            decoded.push(line);
            index = semi + 1;
          } while (index <= mappings.length);
          return decoded;
        }
        function indexOf(mappings, index) {
          const idx = mappings.indexOf(";", index);
          return idx === -1 ? mappings.length : idx;
        }
        function decodeInteger(mappings, pos, state, j) {
          let value = 0;
          let shift = 0;
          let integer2 = 0;
          do {
            const c = mappings.charCodeAt(pos++);
            integer2 = charToInt[c];
            value |= (integer2 & 31) << shift;
            shift += 5;
          } while (integer2 & 32);
          const shouldNegate = value & 1;
          value >>>= 1;
          if (shouldNegate) {
            value = -2147483648 | -value;
          }
          state[j] += value;
          return pos;
        }
        function hasMoreVlq(mappings, i, length) {
          if (i >= length)
            return false;
          return mappings.charCodeAt(i) !== comma;
        }
        function sort(line) {
          line.sort(sortComparator);
        }
        function sortComparator(a, b) {
          return a[0] - b[0];
        }
        function encode3(decoded) {
          const state = new Int32Array(5);
          const bufLength = 1024 * 16;
          const subLength = bufLength - 36;
          const buf = new Uint8Array(bufLength);
          const sub = buf.subarray(0, subLength);
          let pos = 0;
          let out = "";
          for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            if (i > 0) {
              if (pos === bufLength) {
                out += td.decode(buf);
                pos = 0;
              }
              buf[pos++] = semicolon;
            }
            if (line.length === 0)
              continue;
            state[0] = 0;
            for (let j = 0; j < line.length; j++) {
              const segment = line[j];
              if (pos > subLength) {
                out += td.decode(sub);
                buf.copyWithin(0, subLength, pos);
                pos -= subLength;
              }
              if (j > 0)
                buf[pos++] = comma;
              pos = encodeInteger(buf, pos, state, segment, 0);
              if (segment.length === 1)
                continue;
              pos = encodeInteger(buf, pos, state, segment, 1);
              pos = encodeInteger(buf, pos, state, segment, 2);
              pos = encodeInteger(buf, pos, state, segment, 3);
              if (segment.length === 4)
                continue;
              pos = encodeInteger(buf, pos, state, segment, 4);
            }
          }
          return out + td.decode(buf.subarray(0, pos));
        }
        function encodeInteger(buf, pos, state, segment, j) {
          const next = segment[j];
          let num = next - state[j];
          state[j] = next;
          num = num < 0 ? -num << 1 | 1 : num << 1;
          do {
            let clamped = num & 31;
            num >>>= 5;
            if (num > 0)
              clamped |= 32;
            buf[pos++] = intToChar[clamped];
          } while (num > 0);
          return pos;
        }
        exports2.decode = decode3;
        exports2.encode = encode3;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
  var require_resolve_uri_umd = __commonJS({
    "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
      })(exports, function() {
        "use strict";
        const schemeRegex = /^[\w+.-]+:\/\//;
        const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
        const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
        var UrlType;
        (function(UrlType2) {
          UrlType2[UrlType2["Empty"] = 1] = "Empty";
          UrlType2[UrlType2["Hash"] = 2] = "Hash";
          UrlType2[UrlType2["Query"] = 3] = "Query";
          UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
          UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
          UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
          UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
        })(UrlType || (UrlType = {}));
        function isAbsoluteUrl(input) {
          return schemeRegex.test(input);
        }
        function isSchemeRelativeUrl(input) {
          return input.startsWith("//");
        }
        function isAbsolutePath(input) {
          return input.startsWith("/");
        }
        function isFileUrl(input) {
          return input.startsWith("file:");
        }
        function isRelative(input) {
          return /^[.?#]/.test(input);
        }
        function parseAbsoluteUrl(input) {
          const match = urlRegex.exec(input);
          return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
        }
        function parseFileUrl(input) {
          const match = fileRegex.exec(input);
          const path = match[2];
          return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
        }
        function makeUrl(scheme, user, host, port, path, query, hash) {
          return {
            scheme,
            user,
            host,
            port,
            path,
            query,
            hash,
            type: UrlType.Absolute
          };
        }
        function parseUrl(input) {
          if (isSchemeRelativeUrl(input)) {
            const url2 = parseAbsoluteUrl("http:" + input);
            url2.scheme = "";
            url2.type = UrlType.SchemeRelative;
            return url2;
          }
          if (isAbsolutePath(input)) {
            const url2 = parseAbsoluteUrl("http://foo.com" + input);
            url2.scheme = "";
            url2.host = "";
            url2.type = UrlType.AbsolutePath;
            return url2;
          }
          if (isFileUrl(input))
            return parseFileUrl(input);
          if (isAbsoluteUrl(input))
            return parseAbsoluteUrl(input);
          const url = parseAbsoluteUrl("http://foo.com/" + input);
          url.scheme = "";
          url.host = "";
          url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
          return url;
        }
        function stripPathFilename(path) {
          if (path.endsWith("/.."))
            return path;
          const index = path.lastIndexOf("/");
          return path.slice(0, index + 1);
        }
        function mergePaths(url, base) {
          normalizePath(base, base.type);
          if (url.path === "/") {
            url.path = base.path;
          } else {
            url.path = stripPathFilename(base.path) + url.path;
          }
        }
        function normalizePath(url, type) {
          const rel = type <= UrlType.RelativePath;
          const pieces = url.path.split("/");
          let pointer = 1;
          let positive = 0;
          let addTrailingSlash = false;
          for (let i = 1; i < pieces.length; i++) {
            const piece = pieces[i];
            if (!piece) {
              addTrailingSlash = true;
              continue;
            }
            addTrailingSlash = false;
            if (piece === ".")
              continue;
            if (piece === "..") {
              if (positive) {
                addTrailingSlash = true;
                positive--;
                pointer--;
              } else if (rel) {
                pieces[pointer++] = piece;
              }
              continue;
            }
            pieces[pointer++] = piece;
            positive++;
          }
          let path = "";
          for (let i = 1; i < pointer; i++) {
            path += "/" + pieces[i];
          }
          if (!path || addTrailingSlash && !path.endsWith("/..")) {
            path += "/";
          }
          url.path = path;
        }
        function resolve(input, base) {
          if (!input && !base)
            return "";
          const url = parseUrl(input);
          let inputType = url.type;
          if (base && inputType !== UrlType.Absolute) {
            const baseUrl = parseUrl(base);
            const baseType = baseUrl.type;
            switch (inputType) {
              case UrlType.Empty:
                url.hash = baseUrl.hash;
              case UrlType.Hash:
                url.query = baseUrl.query;
              case UrlType.Query:
              case UrlType.RelativePath:
                mergePaths(url, baseUrl);
              case UrlType.AbsolutePath:
                url.user = baseUrl.user;
                url.host = baseUrl.host;
                url.port = baseUrl.port;
              case UrlType.SchemeRelative:
                url.scheme = baseUrl.scheme;
            }
            if (baseType > inputType)
              inputType = baseType;
          }
          normalizePath(url, inputType);
          const queryHash = url.query + url.hash;
          switch (inputType) {
            case UrlType.Hash:
            case UrlType.Query:
              return queryHash;
            case UrlType.RelativePath: {
              const path = url.path.slice(1);
              if (!path)
                return queryHash || ".";
              if (isRelative(base || input) && !isRelative(path)) {
                return "./" + path + queryHash;
              }
              return path + queryHash;
            }
            case UrlType.AbsolutePath:
              return url.path + queryHash;
            default:
              return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
          }
        }
        return resolve;
      });
    }
  });

  // node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
  var require_trace_mapping_umd = __commonJS({
    "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
      })(exports, function(exports2, sourcemapCodec, resolveUri) {
        "use strict";
        function _interopDefaultLegacy(e) {
          return e && typeof e === "object" && "default" in e ? e : { "default": e };
        }
        var resolveUri__default = /* @__PURE__ */ _interopDefaultLegacy(resolveUri);
        function resolve(input, base) {
          if (base && !base.endsWith("/"))
            base += "/";
          return resolveUri__default["default"](input, base);
        }
        function stripFilename(path) {
          if (!path)
            return "";
          const index = path.lastIndexOf("/");
          return path.slice(0, index + 1);
        }
        const COLUMN = 0;
        const SOURCES_INDEX = 1;
        const SOURCE_LINE = 2;
        const SOURCE_COLUMN = 3;
        const NAMES_INDEX = 4;
        const REV_GENERATED_LINE = 1;
        const REV_GENERATED_COLUMN = 2;
        function maybeSort(mappings, owned) {
          const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
          if (unsortedIndex === mappings.length)
            return mappings;
          if (!owned)
            mappings = mappings.slice();
          for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
            mappings[i] = sortSegments(mappings[i], owned);
          }
          return mappings;
        }
        function nextUnsortedSegmentLine(mappings, start) {
          for (let i = start; i < mappings.length; i++) {
            if (!isSorted(mappings[i]))
              return i;
          }
          return mappings.length;
        }
        function isSorted(line) {
          for (let j = 1; j < line.length; j++) {
            if (line[j][COLUMN] < line[j - 1][COLUMN]) {
              return false;
            }
          }
          return true;
        }
        function sortSegments(line, owned) {
          if (!owned)
            line = line.slice();
          return line.sort(sortComparator);
        }
        function sortComparator(a, b) {
          return a[COLUMN] - b[COLUMN];
        }
        let found = false;
        function binarySearch(haystack, needle, low, high) {
          while (low <= high) {
            const mid = low + (high - low >> 1);
            const cmp = haystack[mid][COLUMN] - needle;
            if (cmp === 0) {
              found = true;
              return mid;
            }
            if (cmp < 0) {
              low = mid + 1;
            } else {
              high = mid - 1;
            }
          }
          found = false;
          return low - 1;
        }
        function upperBound(haystack, needle, index) {
          for (let i = index + 1; i < haystack.length; index = i++) {
            if (haystack[i][COLUMN] !== needle)
              break;
          }
          return index;
        }
        function lowerBound(haystack, needle, index) {
          for (let i = index - 1; i >= 0; index = i--) {
            if (haystack[i][COLUMN] !== needle)
              break;
          }
          return index;
        }
        function memoizedState() {
          return {
            lastKey: -1,
            lastNeedle: -1,
            lastIndex: -1
          };
        }
        function memoizedBinarySearch(haystack, needle, state, key) {
          const { lastKey, lastNeedle, lastIndex } = state;
          let low = 0;
          let high = haystack.length - 1;
          if (key === lastKey) {
            if (needle === lastNeedle) {
              found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
              return lastIndex;
            }
            if (needle >= lastNeedle) {
              low = lastIndex === -1 ? 0 : lastIndex;
            } else {
              high = lastIndex;
            }
          }
          state.lastKey = key;
          state.lastNeedle = needle;
          return state.lastIndex = binarySearch(haystack, needle, low, high);
        }
        function buildBySources(decoded, memos) {
          const sources = memos.map(buildNullArray);
          for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              if (seg.length === 1)
                continue;
              const sourceIndex = seg[SOURCES_INDEX];
              const sourceLine = seg[SOURCE_LINE];
              const sourceColumn = seg[SOURCE_COLUMN];
              const originalSource = sources[sourceIndex];
              const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
              const memo = memos[sourceIndex];
              const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
              insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);
            }
          }
          return sources;
        }
        function insert(array, index, value) {
          for (let i = array.length; i > index; i--) {
            array[i] = array[i - 1];
          }
          array[index] = value;
        }
        function buildNullArray() {
          return { __proto__: null };
        }
        const AnyMap = function(map, mapUrl) {
          const parsed = typeof map === "string" ? JSON.parse(map) : map;
          if (!("sections" in parsed))
            return new TraceMap(parsed, mapUrl);
          const mappings = [];
          const sources = [];
          const sourcesContent = [];
          const names = [];
          recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);
          const joined = {
            version: 3,
            file: parsed.file,
            names,
            sources,
            sourcesContent,
            mappings
          };
          return exports2.presortedDecodedMap(joined);
        };
        function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
          const { sections } = input;
          for (let i = 0; i < sections.length; i++) {
            const { map, offset } = sections[i];
            let sl = stopLine;
            let sc = stopColumn;
            if (i + 1 < sections.length) {
              const nextOffset = sections[i + 1].offset;
              sl = Math.min(stopLine, lineOffset + nextOffset.line);
              if (sl === stopLine) {
                sc = Math.min(stopColumn, columnOffset + nextOffset.column);
              } else if (sl < stopLine) {
                sc = columnOffset + nextOffset.column;
              }
            }
            addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
          }
        }
        function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
          if ("sections" in input)
            return recurse(...arguments);
          const map = new TraceMap(input, mapUrl);
          const sourcesOffset = sources.length;
          const namesOffset = names.length;
          const decoded = exports2.decodedMappings(map);
          const { resolvedSources, sourcesContent: contents } = map;
          append2(sources, resolvedSources);
          append2(names, map.names);
          if (contents)
            append2(sourcesContent, contents);
          else
            for (let i = 0; i < resolvedSources.length; i++)
              sourcesContent.push(null);
          for (let i = 0; i < decoded.length; i++) {
            const lineI = lineOffset + i;
            if (lineI > stopLine)
              return;
            const out = getLine(mappings, lineI);
            const cOffset = i === 0 ? columnOffset : 0;
            const line = decoded[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              const column = cOffset + seg[COLUMN];
              if (lineI === stopLine && column >= stopColumn)
                return;
              if (seg.length === 1) {
                out.push([column]);
                continue;
              }
              const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
              const sourceLine = seg[SOURCE_LINE];
              const sourceColumn = seg[SOURCE_COLUMN];
              out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
            }
          }
        }
        function append2(arr, other) {
          for (let i = 0; i < other.length; i++)
            arr.push(other[i]);
        }
        function getLine(arr, index) {
          for (let i = arr.length; i <= index; i++)
            arr[i] = [];
          return arr[index];
        }
        const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
        const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
        const LEAST_UPPER_BOUND = -1;
        const GREATEST_LOWER_BOUND = 1;
        exports2.encodedMappings = void 0;
        exports2.decodedMappings = void 0;
        exports2.traceSegment = void 0;
        exports2.originalPositionFor = void 0;
        exports2.generatedPositionFor = void 0;
        exports2.allGeneratedPositionsFor = void 0;
        exports2.eachMapping = void 0;
        exports2.sourceContentFor = void 0;
        exports2.presortedDecodedMap = void 0;
        exports2.decodedMap = void 0;
        exports2.encodedMap = void 0;
        class TraceMap {
          constructor(map, mapUrl) {
            const isString = typeof map === "string";
            if (!isString && map._decodedMemo)
              return map;
            const parsed = isString ? JSON.parse(map) : map;
            const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
            this.version = version;
            this.file = file;
            this.names = names;
            this.sourceRoot = sourceRoot;
            this.sources = sources;
            this.sourcesContent = sourcesContent;
            const from = resolve(sourceRoot || "", stripFilename(mapUrl));
            this.resolvedSources = sources.map((s) => resolve(s || "", from));
            const { mappings } = parsed;
            if (typeof mappings === "string") {
              this._encoded = mappings;
              this._decoded = void 0;
            } else {
              this._encoded = void 0;
              this._decoded = maybeSort(mappings, isString);
            }
            this._decodedMemo = memoizedState();
            this._bySources = void 0;
            this._bySourceMemos = void 0;
          }
        }
        (() => {
          exports2.encodedMappings = (map) => {
            var _a;
            return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = sourcemapCodec.encode(map._decoded);
          };
          exports2.decodedMappings = (map) => {
            return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded));
          };
          exports2.traceSegment = (map, line, column) => {
            const decoded = exports2.decodedMappings(map);
            if (line >= decoded.length)
              return null;
            const segments = decoded[line];
            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
            return index === -1 ? null : segments[index];
          };
          exports2.originalPositionFor = (map, { line, column, bias }) => {
            line--;
            if (line < 0)
              throw new Error(LINE_GTR_ZERO);
            if (column < 0)
              throw new Error(COL_GTR_EQ_ZERO);
            const decoded = exports2.decodedMappings(map);
            if (line >= decoded.length)
              return OMapping(null, null, null, null);
            const segments = decoded[line];
            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
            if (index === -1)
              return OMapping(null, null, null, null);
            const segment = segments[index];
            if (segment.length === 1)
              return OMapping(null, null, null, null);
            const { names, resolvedSources } = map;
            return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
          };
          exports2.allGeneratedPositionsFor = (map, { source, line, column, bias }) => {
            return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
          };
          exports2.generatedPositionFor = (map, { source, line, column, bias }) => {
            return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
          };
          exports2.eachMapping = (map, cb) => {
            const decoded = exports2.decodedMappings(map);
            const { names, resolvedSources } = map;
            for (let i = 0; i < decoded.length; i++) {
              const line = decoded[i];
              for (let j = 0; j < line.length; j++) {
                const seg = line[j];
                const generatedLine = i + 1;
                const generatedColumn = seg[0];
                let source = null;
                let originalLine = null;
                let originalColumn = null;
                let name41 = null;
                if (seg.length !== 1) {
                  source = resolvedSources[seg[1]];
                  originalLine = seg[2] + 1;
                  originalColumn = seg[3];
                }
                if (seg.length === 5)
                  name41 = names[seg[4]];
                cb({
                  generatedLine,
                  generatedColumn,
                  source,
                  originalLine,
                  originalColumn,
                  name: name41
                });
              }
            }
          };
          exports2.sourceContentFor = (map, source) => {
            const { sources, resolvedSources, sourcesContent } = map;
            if (sourcesContent == null)
              return null;
            let index = sources.indexOf(source);
            if (index === -1)
              index = resolvedSources.indexOf(source);
            return index === -1 ? null : sourcesContent[index];
          };
          exports2.presortedDecodedMap = (map, mapUrl) => {
            const tracer = new TraceMap(clone2(map, []), mapUrl);
            tracer._decoded = map.mappings;
            return tracer;
          };
          exports2.decodedMap = (map) => {
            return clone2(map, exports2.decodedMappings(map));
          };
          exports2.encodedMap = (map) => {
            return clone2(map, exports2.encodedMappings(map));
          };
          function generatedPosition(map, source, line, column, bias, all) {
            line--;
            if (line < 0)
              throw new Error(LINE_GTR_ZERO);
            if (column < 0)
              throw new Error(COL_GTR_EQ_ZERO);
            const { sources, resolvedSources } = map;
            let sourceIndex = sources.indexOf(source);
            if (sourceIndex === -1)
              sourceIndex = resolvedSources.indexOf(source);
            if (sourceIndex === -1)
              return all ? [] : GMapping(null, null);
            const generated = map._bySources || (map._bySources = buildBySources(exports2.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));
            const segments = generated[sourceIndex][line];
            if (segments == null)
              return all ? [] : GMapping(null, null);
            const memo = map._bySourceMemos[sourceIndex];
            if (all)
              return sliceGeneratedPositions(segments, memo, line, column, bias);
            const index = traceSegmentInternal(segments, memo, line, column, bias);
            if (index === -1)
              return GMapping(null, null);
            const segment = segments[index];
            return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
          }
        })();
        function clone2(map, mappings) {
          return {
            version: map.version,
            file: map.file,
            names: map.names,
            sourceRoot: map.sourceRoot,
            sources: map.sources,
            sourcesContent: map.sourcesContent,
            mappings
          };
        }
        function OMapping(source, line, column, name41) {
          return { source, line, column, name: name41 };
        }
        function GMapping(line, column) {
          return { line, column };
        }
        function traceSegmentInternal(segments, memo, line, column, bias) {
          let index = memoizedBinarySearch(segments, column, memo, line);
          if (found) {
            index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
          } else if (bias === LEAST_UPPER_BOUND)
            index++;
          if (index === -1 || index === segments.length)
            return -1;
          return index;
        }
        function sliceGeneratedPositions(segments, memo, line, column, bias) {
          let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
          if (!found && bias === LEAST_UPPER_BOUND)
            min++;
          if (min === -1 || min === segments.length)
            return [];
          const matchedColumn = found ? column : segments[min][COLUMN];
          if (!found)
            min = lowerBound(segments, matchedColumn, min);
          const max = upperBound(segments, matchedColumn, min);
          const result = [];
          for (; min <= max; min++) {
            const segment = segments[min];
            result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
          }
          return result;
        }
        exports2.AnyMap = AnyMap;
        exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
        exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
        exports2.TraceMap = TraceMap;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
  var require_gen_mapping_umd = __commonJS({
    "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.genMapping = {}, global2.setArray, global2.sourcemapCodec, global2.traceMapping));
      })(exports, function(exports2, setArray, sourcemapCodec, traceMapping) {
        "use strict";
        const COLUMN = 0;
        const SOURCES_INDEX = 1;
        const SOURCE_LINE = 2;
        const SOURCE_COLUMN = 3;
        const NAMES_INDEX = 4;
        const NO_NAME = -1;
        exports2.addSegment = void 0;
        exports2.addMapping = void 0;
        exports2.maybeAddSegment = void 0;
        exports2.maybeAddMapping = void 0;
        exports2.setSourceContent = void 0;
        exports2.toDecodedMap = void 0;
        exports2.toEncodedMap = void 0;
        exports2.fromMap = void 0;
        exports2.allMappings = void 0;
        let addSegmentInternal;
        class GenMapping {
          constructor({ file, sourceRoot } = {}) {
            this._names = new setArray.SetArray();
            this._sources = new setArray.SetArray();
            this._sourcesContent = [];
            this._mappings = [];
            this.file = file;
            this.sourceRoot = sourceRoot;
          }
        }
        (() => {
          exports2.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name41, content) => {
            return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name41, content);
          };
          exports2.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name41, content) => {
            return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name41, content);
          };
          exports2.addMapping = (map, mapping) => {
            return addMappingInternal(false, map, mapping);
          };
          exports2.maybeAddMapping = (map, mapping) => {
            return addMappingInternal(true, map, mapping);
          };
          exports2.setSourceContent = (map, source, content) => {
            const { _sources: sources, _sourcesContent: sourcesContent } = map;
            sourcesContent[setArray.put(sources, source)] = content;
          };
          exports2.toDecodedMap = (map) => {
            const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
            removeEmptyFinalLines(mappings);
            return {
              version: 3,
              file: file || void 0,
              names: names.array,
              sourceRoot: sourceRoot || void 0,
              sources: sources.array,
              sourcesContent,
              mappings
            };
          };
          exports2.toEncodedMap = (map) => {
            const decoded = exports2.toDecodedMap(map);
            return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
          };
          exports2.allMappings = (map) => {
            const out = [];
            const { _mappings: mappings, _sources: sources, _names: names } = map;
            for (let i = 0; i < mappings.length; i++) {
              const line = mappings[i];
              for (let j = 0; j < line.length; j++) {
                const seg = line[j];
                const generated = { line: i + 1, column: seg[COLUMN] };
                let source = void 0;
                let original = void 0;
                let name41 = void 0;
                if (seg.length !== 1) {
                  source = sources.array[seg[SOURCES_INDEX]];
                  original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
                  if (seg.length === 5)
                    name41 = names.array[seg[NAMES_INDEX]];
                }
                out.push({ generated, source, original, name: name41 });
              }
            }
            return out;
          };
          exports2.fromMap = (input) => {
            const map = new traceMapping.TraceMap(input);
            const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
            putAll(gen._names, map.names);
            putAll(gen._sources, map.sources);
            gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);
            gen._mappings = traceMapping.decodedMappings(map);
            return gen;
          };
          addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name41, content) => {
            const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
            const line = getLine(mappings, genLine);
            const index = getColumnIndex(line, genColumn);
            if (!source) {
              if (skipable && skipSourceless(line, index))
                return;
              return insert(line, index, [genColumn]);
            }
            const sourcesIndex = setArray.put(sources, source);
            const namesIndex = name41 ? setArray.put(names, name41) : NO_NAME;
            if (sourcesIndex === sourcesContent.length)
              sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
            if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
              return;
            }
            return insert(line, index, name41 ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
          };
        })();
        function getLine(mappings, index) {
          for (let i = mappings.length; i <= index; i++) {
            mappings[i] = [];
          }
          return mappings[index];
        }
        function getColumnIndex(line, genColumn) {
          let index = line.length;
          for (let i = index - 1; i >= 0; index = i--) {
            const current = line[i];
            if (genColumn >= current[COLUMN])
              break;
          }
          return index;
        }
        function insert(array, index, value) {
          for (let i = array.length; i > index; i--) {
            array[i] = array[i - 1];
          }
          array[index] = value;
        }
        function removeEmptyFinalLines(mappings) {
          const { length } = mappings;
          let len = length;
          for (let i = len - 1; i >= 0; len = i, i--) {
            if (mappings[i].length > 0)
              break;
          }
          if (len < length)
            mappings.length = len;
        }
        function putAll(strarr, array) {
          for (let i = 0; i < array.length; i++)
            setArray.put(strarr, array[i]);
        }
        function skipSourceless(line, index) {
          if (index === 0)
            return true;
          const prev = line[index - 1];
          return prev.length === 1;
        }
        function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
          if (index === 0)
            return false;
          const prev = line[index - 1];
          if (prev.length === 1)
            return false;
          return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
        }
        function addMappingInternal(skipable, map, mapping) {
          const { generated, source, original, name: name41, content } = mapping;
          if (!source) {
            return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
          }
          const s = source;
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name41, content);
        }
        exports2.GenMapping = GenMapping;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@babel/generator/lib/source-map.js
  var require_source_map = __commonJS({
    "node_modules/@babel/generator/lib/source-map.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _genMapping = require_gen_mapping_umd();
      var SourceMap = class {
        constructor(opts, code2) {
          var _opts$sourceFileName;
          this._map = void 0;
          this._rawMappings = void 0;
          this._sourceFileName = void 0;
          this._lastGenLine = 0;
          this._lastSourceLine = 0;
          this._lastSourceColumn = 0;
          const map = this._map = new _genMapping.GenMapping({
            sourceRoot: opts.sourceRoot
          });
          this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
          this._rawMappings = void 0;
          if (typeof code2 === "string") {
            (0, _genMapping.setSourceContent)(map, this._sourceFileName, code2);
          } else if (typeof code2 === "object") {
            Object.keys(code2).forEach((sourceFileName) => {
              (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code2[sourceFileName]);
            });
          }
        }
        get() {
          return (0, _genMapping.toEncodedMap)(this._map);
        }
        getDecoded() {
          return (0, _genMapping.toDecodedMap)(this._map);
        }
        getRawMappings() {
          return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
        }
        mark(generated, line, column, identifierName, filename) {
          this._rawMappings = void 0;
          (0, _genMapping.maybeAddMapping)(this._map, {
            name: identifierName,
            generated,
            source: line == null ? void 0 : (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
            original: line == null ? void 0 : {
              line,
              column
            }
          });
        }
      };
      exports.default = SourceMap;
    }
  });

  // node_modules/@babel/generator/lib/buffer.js
  var require_buffer2 = __commonJS({
    "node_modules/@babel/generator/lib/buffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var Buffer3 = class {
        constructor(map) {
          this._map = null;
          this._buf = "";
          this._str = "";
          this._appendCount = 0;
          this._last = 0;
          this._queue = [];
          this._queueCursor = 0;
          this._position = {
            line: 1,
            column: 0
          };
          this._sourcePosition = {
            identifierName: void 0,
            line: void 0,
            column: void 0,
            filename: void 0
          };
          this._map = map;
          this._allocQueue();
        }
        _allocQueue() {
          const queue = this._queue;
          for (let i = 0; i < 16; i++) {
            queue.push({
              char: 0,
              repeat: 1,
              line: void 0,
              column: void 0,
              identifierName: void 0,
              filename: ""
            });
          }
        }
        _pushQueue(char, repeat, line, column, identifierName, filename) {
          const cursor = this._queueCursor;
          if (cursor === this._queue.length) {
            this._allocQueue();
          }
          const item = this._queue[cursor];
          item.char = char;
          item.repeat = repeat;
          item.line = line;
          item.column = column;
          item.identifierName = identifierName;
          item.filename = filename;
          this._queueCursor++;
        }
        _popQueue() {
          if (this._queueCursor === 0) {
            throw new Error("Cannot pop from empty queue");
          }
          return this._queue[--this._queueCursor];
        }
        get() {
          this._flush();
          const map = this._map;
          const result = {
            code: (this._buf + this._str).trimRight(),
            decodedMap: map == null ? void 0 : map.getDecoded(),
            get map() {
              const resultMap = map ? map.get() : null;
              result.map = resultMap;
              return resultMap;
            },
            set map(value) {
              Object.defineProperty(result, "map", {
                value,
                writable: true
              });
            },
            get rawMappings() {
              const mappings = map == null ? void 0 : map.getRawMappings();
              result.rawMappings = mappings;
              return mappings;
            },
            set rawMappings(value) {
              Object.defineProperty(result, "rawMappings", {
                value,
                writable: true
              });
            }
          };
          return result;
        }
        append(str, maybeNewline) {
          this._flush();
          this._append(str, this._sourcePosition, maybeNewline);
        }
        appendChar(char) {
          this._flush();
          this._appendChar(char, 1, this._sourcePosition);
        }
        queue(char) {
          if (char === 10) {
            while (this._queueCursor !== 0) {
              const char2 = this._queue[this._queueCursor - 1].char;
              if (char2 !== 32 && char2 !== 9) {
                break;
              }
              this._queueCursor--;
            }
          }
          const sourcePosition = this._sourcePosition;
          this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.identifierName, sourcePosition.filename);
        }
        queueIndentation(char, repeat) {
          this._pushQueue(char, repeat, void 0, void 0, void 0, void 0);
        }
        _flush() {
          const queueCursor = this._queueCursor;
          const queue = this._queue;
          for (let i = 0; i < queueCursor; i++) {
            const item = queue[i];
            this._appendChar(item.char, item.repeat, item);
          }
          this._queueCursor = 0;
        }
        _appendChar(char, repeat, sourcePos) {
          this._last = char;
          this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
          if (char !== 10) {
            this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.filename);
            this._position.column += repeat;
          } else {
            this._position.line++;
            this._position.column = 0;
          }
        }
        _append(str, sourcePos, maybeNewline) {
          const len = str.length;
          const position = this._position;
          this._last = str.charCodeAt(len - 1);
          if (++this._appendCount > 4096) {
            +this._str;
            this._buf += this._str;
            this._str = str;
            this._appendCount = 0;
          } else {
            this._str += str;
          }
          if (!maybeNewline && !this._map) {
            position.column += len;
            return;
          }
          const {
            column,
            identifierName,
            filename
          } = sourcePos;
          let line = sourcePos.line;
          let i = str.indexOf("\n");
          let last = 0;
          if (i !== 0) {
            this._mark(line, column, identifierName, filename);
          }
          while (i !== -1) {
            position.line++;
            position.column = 0;
            last = i + 1;
            if (last < len && line !== void 0) {
              this._mark(++line, 0, identifierName, filename);
            }
            i = str.indexOf("\n", last);
          }
          position.column += len - last;
        }
        _mark(line, column, identifierName, filename) {
          var _this$_map;
          (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, filename);
        }
        removeTrailingNewline() {
          const queueCursor = this._queueCursor;
          if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
            this._queueCursor--;
          }
        }
        removeLastSemicolon() {
          const queueCursor = this._queueCursor;
          if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
            this._queueCursor--;
          }
        }
        getLastChar() {
          const queueCursor = this._queueCursor;
          return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
        }
        getNewlineCount() {
          const queueCursor = this._queueCursor;
          let count = 0;
          if (queueCursor === 0)
            return this._last === 10 ? 1 : 0;
          for (let i = queueCursor - 1; i >= 0; i--) {
            if (this._queue[i].char !== 10) {
              break;
            }
            count++;
          }
          return count === queueCursor && this._last === 10 ? count + 1 : count;
        }
        endsWithCharAndNewline() {
          const queue = this._queue;
          const queueCursor = this._queueCursor;
          if (queueCursor !== 0) {
            const lastCp = queue[queueCursor - 1].char;
            if (lastCp !== 10)
              return;
            if (queueCursor > 1) {
              return queue[queueCursor - 2].char;
            } else {
              return this._last;
            }
          }
        }
        hasContent() {
          return this._queueCursor !== 0 || !!this._last;
        }
        exactSource(loc, cb) {
          if (!this._map)
            return cb();
          this.source("start", loc);
          cb();
          this.source("end", loc);
        }
        source(prop, loc) {
          if (!this._map)
            return;
          this._normalizePosition(prop, loc, 0, 0);
        }
        sourceWithOffset(prop, loc, lineOffset, columnOffset) {
          if (!this._map)
            return;
          this._normalizePosition(prop, loc, lineOffset, columnOffset);
        }
        withSource(prop, loc, cb) {
          if (!this._map)
            return cb();
          this.source(prop, loc);
          cb();
        }
        _normalizePosition(prop, loc, lineOffset, columnOffset) {
          const pos = loc[prop];
          const target = this._sourcePosition;
          target.identifierName = prop === "start" && loc.identifierName || void 0;
          if (pos) {
            target.line = pos.line + lineOffset;
            target.column = pos.column + columnOffset;
            target.filename = loc.filename;
          }
        }
        getCurrentColumn() {
          const queue = this._queue;
          const queueCursor = this._queueCursor;
          let lastIndex = -1;
          let len = 0;
          for (let i = 0; i < queueCursor; i++) {
            const item = queue[i];
            if (item.char === 10) {
              lastIndex = len;
            }
            len += item.repeat;
          }
          return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
        }
        getCurrentLine() {
          let count = 0;
          const queue = this._queue;
          for (let i = 0; i < this._queueCursor; i++) {
            if (queue[i].char === 10) {
              count++;
            }
          }
          return this._position.line + count;
        }
      };
      exports.default = Buffer3;
    }
  });

  // node_modules/@babel/generator/lib/node/whitespace.js
  var require_whitespace = __commonJS({
    "node_modules/@babel/generator/lib/node/whitespace.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nodes = void 0;
      var _t = require_lib4();
      var {
        FLIPPED_ALIAS_KEYS,
        isArrayExpression: isArrayExpression2,
        isAssignmentExpression: isAssignmentExpression2,
        isBinary,
        isBlockStatement,
        isCallExpression,
        isFunction,
        isIdentifier: isIdentifier2,
        isLiteral,
        isMemberExpression: isMemberExpression2,
        isObjectExpression,
        isOptionalCallExpression,
        isOptionalMemberExpression,
        isStringLiteral
      } = _t;
      function crawlInternal(node, state) {
        if (!node)
          return state;
        if (isMemberExpression2(node) || isOptionalMemberExpression(node)) {
          crawlInternal(node.object, state);
          if (node.computed)
            crawlInternal(node.property, state);
        } else if (isBinary(node) || isAssignmentExpression2(node)) {
          crawlInternal(node.left, state);
          crawlInternal(node.right, state);
        } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
          state.hasCall = true;
          crawlInternal(node.callee, state);
        } else if (isFunction(node)) {
          state.hasFunction = true;
        } else if (isIdentifier2(node)) {
          state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
        }
        return state;
      }
      function crawl(node) {
        return crawlInternal(node, {
          hasCall: false,
          hasFunction: false,
          hasHelper: false
        });
      }
      function isHelper(node) {
        if (!node)
          return false;
        if (isMemberExpression2(node)) {
          return isHelper(node.object) || isHelper(node.property);
        } else if (isIdentifier2(node)) {
          return node.name === "require" || node.name.charCodeAt(0) === 95;
        } else if (isCallExpression(node)) {
          return isHelper(node.callee);
        } else if (isBinary(node) || isAssignmentExpression2(node)) {
          return isIdentifier2(node.left) && isHelper(node.left) || isHelper(node.right);
        } else {
          return false;
        }
      }
      function isType2(node) {
        return isLiteral(node) || isObjectExpression(node) || isArrayExpression2(node) || isIdentifier2(node) || isMemberExpression2(node);
      }
      var nodes = {
        AssignmentExpression(node) {
          const state = crawl(node.right);
          if (state.hasCall && state.hasHelper || state.hasFunction) {
            return state.hasFunction ? 1 | 2 : 2;
          }
        },
        SwitchCase(node, parent) {
          return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
        },
        LogicalExpression(node) {
          if (isFunction(node.left) || isFunction(node.right)) {
            return 2;
          }
        },
        Literal(node) {
          if (isStringLiteral(node) && node.value === "use strict") {
            return 2;
          }
        },
        CallExpression(node) {
          if (isFunction(node.callee) || isHelper(node)) {
            return 1 | 2;
          }
        },
        OptionalCallExpression(node) {
          if (isFunction(node.callee)) {
            return 1 | 2;
          }
        },
        VariableDeclaration(node) {
          for (let i = 0; i < node.declarations.length; i++) {
            const declar = node.declarations[i];
            let enabled = isHelper(declar.id) && !isType2(declar.init);
            if (!enabled && declar.init) {
              const state = crawl(declar.init);
              enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
            }
            if (enabled) {
              return 1 | 2;
            }
          }
        },
        IfStatement(node) {
          if (isBlockStatement(node.consequent)) {
            return 1 | 2;
          }
        }
      };
      exports.nodes = nodes;
      nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
        if (parent.properties[0] === node) {
          return 1;
        }
      };
      nodes.ObjectTypeCallProperty = function(node, parent) {
        var _parent$properties;
        if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
          return 1;
        }
      };
      nodes.ObjectTypeIndexer = function(node, parent) {
        var _parent$properties2, _parent$callPropertie;
        if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
          return 1;
        }
      };
      nodes.ObjectTypeInternalSlot = function(node, parent) {
        var _parent$properties3, _parent$callPropertie2, _parent$indexers;
        if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
          return 1;
        }
      };
      [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
        [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
          const ret = amounts ? 1 | 2 : 0;
          nodes[type2] = () => ret;
        });
      });
    }
  });

  // node_modules/@babel/generator/lib/node/parentheses.js
  var require_parentheses = __commonJS({
    "node_modules/@babel/generator/lib/node/parentheses.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArrowFunctionExpression = ArrowFunctionExpression;
      exports.AssignmentExpression = AssignmentExpression;
      exports.Binary = Binary;
      exports.BinaryExpression = BinaryExpression;
      exports.ClassExpression = ClassExpression;
      exports.ConditionalExpression = ConditionalExpression;
      exports.DoExpression = DoExpression;
      exports.FunctionExpression = FunctionExpression;
      exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
      exports.Identifier = Identifier;
      exports.LogicalExpression = LogicalExpression;
      exports.NullableTypeAnnotation = NullableTypeAnnotation;
      exports.ObjectExpression = ObjectExpression;
      exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
      exports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
      exports.SequenceExpression = SequenceExpression;
      exports.TSTypeAssertion = exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;
      exports.TSInferType = TSInferType;
      exports.TSInstantiationExpression = TSInstantiationExpression;
      exports.TSIntersectionType = exports.TSUnionType = TSUnionType;
      exports.UnaryLike = UnaryLike;
      exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
      exports.UpdateExpression = UpdateExpression;
      exports.AwaitExpression = exports.YieldExpression = YieldExpression;
      var _t = require_lib4();
      var {
        isArrayTypeAnnotation,
        isArrowFunctionExpression: isArrowFunctionExpression2,
        isAssignmentExpression: isAssignmentExpression2,
        isAwaitExpression,
        isBinary,
        isBinaryExpression,
        isUpdateExpression,
        isCallExpression,
        isClass,
        isClassExpression,
        isConditional,
        isConditionalExpression,
        isExportDeclaration,
        isExportDefaultDeclaration,
        isExpressionStatement: isExpressionStatement2,
        isFor,
        isForInStatement,
        isForOfStatement,
        isForStatement,
        isFunctionExpression,
        isIfStatement,
        isIndexedAccessType,
        isIntersectionTypeAnnotation,
        isLogicalExpression,
        isMemberExpression: isMemberExpression2,
        isNewExpression,
        isNullableTypeAnnotation,
        isObjectPattern,
        isOptionalCallExpression,
        isOptionalMemberExpression,
        isReturnStatement,
        isSequenceExpression: isSequenceExpression2,
        isSwitchStatement,
        isTSArrayType,
        isTSAsExpression,
        isTSInstantiationExpression,
        isTSIntersectionType,
        isTSNonNullExpression,
        isTSOptionalType,
        isTSRestType,
        isTSTypeAssertion,
        isTSUnionType,
        isTaggedTemplateExpression,
        isThrowStatement,
        isTypeAnnotation,
        isUnaryLike,
        isUnionTypeAnnotation,
        isVariableDeclarator,
        isWhileStatement,
        isYieldExpression,
        isTSSatisfiesExpression
      } = _t;
      var PRECEDENCE = {
        "||": 0,
        "??": 0,
        "|>": 0,
        "&&": 1,
        "|": 2,
        "^": 3,
        "&": 4,
        "==": 5,
        "===": 5,
        "!=": 5,
        "!==": 5,
        "<": 6,
        ">": 6,
        "<=": 6,
        ">=": 6,
        in: 6,
        instanceof: 6,
        ">>": 7,
        "<<": 7,
        ">>>": 7,
        "+": 8,
        "-": 8,
        "*": 9,
        "/": 9,
        "%": 9,
        "**": 10
      };
      function isTSTypeExpression(node) {
        return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node);
      }
      var isClassExtendsClause = (node, parent) => isClass(parent, {
        superClass: node
      });
      var hasPostfixPart = (node, parent) => (isMemberExpression2(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);
      function NullableTypeAnnotation(node, parent) {
        return isArrayTypeAnnotation(parent);
      }
      function FunctionTypeAnnotation(node, parent, printStack) {
        if (printStack.length < 3)
          return;
        return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression2(printStack[printStack.length - 3]);
      }
      function UpdateExpression(node, parent) {
        return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
      }
      function ObjectExpression(node, parent, printStack) {
        return isFirstInContext(printStack, 1 | 2);
      }
      function DoExpression(node, parent, printStack) {
        return !node.async && isFirstInContext(printStack, 1);
      }
      function Binary(node, parent) {
        if (node.operator === "**" && isBinaryExpression(parent, {
          operator: "**"
        })) {
          return parent.left === node;
        }
        if (isClassExtendsClause(node, parent)) {
          return true;
        }
        if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {
          return true;
        }
        if (isBinary(parent)) {
          const parentOp = parent.operator;
          const parentPos = PRECEDENCE[parentOp];
          const nodeOp = node.operator;
          const nodePos = PRECEDENCE[nodeOp];
          if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {
            return true;
          }
        }
      }
      function UnionTypeAnnotation(node, parent) {
        return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
      }
      function OptionalIndexedAccessType(node, parent) {
        return isIndexedAccessType(parent, {
          objectType: node
        });
      }
      function TSAsExpression() {
        return true;
      }
      function TSUnionType(node, parent) {
        return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
      }
      function TSInferType(node, parent) {
        return isTSArrayType(parent) || isTSOptionalType(parent);
      }
      function TSInstantiationExpression(node, parent) {
        return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;
      }
      function BinaryExpression(node, parent) {
        return node.operator === "in" && (isVariableDeclarator(parent) || isFor(parent));
      }
      function SequenceExpression(node, parent) {
        if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement2(parent) && parent.expression === node) {
          return false;
        }
        return true;
      }
      function YieldExpression(node, parent) {
        return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
      }
      function ClassExpression(node, parent, printStack) {
        return isFirstInContext(printStack, 1 | 4);
      }
      function UnaryLike(node, parent) {
        return hasPostfixPart(node, parent) || isBinaryExpression(parent, {
          operator: "**",
          left: node
        }) || isClassExtendsClause(node, parent);
      }
      function FunctionExpression(node, parent, printStack) {
        return isFirstInContext(printStack, 1 | 4);
      }
      function ArrowFunctionExpression(node, parent) {
        return isExportDeclaration(parent) || ConditionalExpression(node, parent);
      }
      function ConditionalExpression(node, parent) {
        if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {
          test: node
        }) || isAwaitExpression(parent) || isTSTypeExpression(parent)) {
          return true;
        }
        return UnaryLike(node, parent);
      }
      function OptionalMemberExpression(node, parent) {
        return isCallExpression(parent, {
          callee: node
        }) || isMemberExpression2(parent, {
          object: node
        });
      }
      function AssignmentExpression(node, parent) {
        if (isObjectPattern(node.left)) {
          return true;
        } else {
          return ConditionalExpression(node, parent);
        }
      }
      function LogicalExpression(node, parent) {
        if (isTSTypeExpression(parent))
          return true;
        switch (node.operator) {
          case "||":
            if (!isLogicalExpression(parent))
              return false;
            return parent.operator === "??" || parent.operator === "&&";
          case "&&":
            return isLogicalExpression(parent, {
              operator: "??"
            });
          case "??":
            return isLogicalExpression(parent) && parent.operator !== "??";
        }
      }
      function Identifier(node, parent, printStack) {
        var _node$extra;
        if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression2(parent, {
          left: node
        }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) {
          return true;
        }
        if (node.name === "let") {
          const isFollowedByBracket = isMemberExpression2(parent, {
            object: node,
            computed: true
          }) || isOptionalMemberExpression(parent, {
            object: node,
            computed: true,
            optional: false
          });
          return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);
        }
        return node.name === "async" && isForOfStatement(parent) && node === parent.left;
      }
      function isFirstInContext(printStack, checkParam) {
        const expressionStatement2 = checkParam & 1;
        const arrowBody = checkParam & 2;
        const exportDefault = checkParam & 4;
        const forHead = checkParam & 8;
        const forInHead = checkParam & 16;
        const forOfHead = checkParam & 32;
        let i = printStack.length - 1;
        if (i <= 0)
          return;
        let node = printStack[i];
        i--;
        let parent = printStack[i];
        while (i >= 0) {
          if (expressionStatement2 && isExpressionStatement2(parent, {
            expression: node
          }) || exportDefault && isExportDefaultDeclaration(parent, {
            declaration: node
          }) || arrowBody && isArrowFunctionExpression2(parent, {
            body: node
          }) || forHead && isForStatement(parent, {
            init: node
          }) || forInHead && isForInStatement(parent, {
            left: node
          }) || forOfHead && isForOfStatement(parent, {
            left: node
          })) {
            return true;
          }
          if (i > 0 && (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression2(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {
            test: node
          }) || isBinary(parent, {
            left: node
          }) || isAssignmentExpression2(parent, {
            left: node
          }))) {
            node = parent;
            i--;
            parent = printStack[i];
          } else {
            return false;
          }
        }
        return false;
      }
    }
  });

  // node_modules/@babel/generator/lib/node/index.js
  var require_node = __commonJS({
    "node_modules/@babel/generator/lib/node/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.needsParens = needsParens;
      exports.needsWhitespace = needsWhitespace;
      exports.needsWhitespaceAfter = needsWhitespaceAfter;
      exports.needsWhitespaceBefore = needsWhitespaceBefore;
      var whitespace = require_whitespace();
      var parens = require_parentheses();
      var _t = require_lib4();
      var {
        FLIPPED_ALIAS_KEYS,
        isCallExpression,
        isExpressionStatement: isExpressionStatement2,
        isMemberExpression: isMemberExpression2,
        isNewExpression
      } = _t;
      function expandAliases(obj) {
        const newObj = {};
        function add(type, func2) {
          const fn = newObj[type];
          newObj[type] = fn ? function(node, parent, stack) {
            const result = fn(node, parent, stack);
            return result == null ? func2(node, parent, stack) : result;
          } : func2;
        }
        for (const type of Object.keys(obj)) {
          const aliases = FLIPPED_ALIAS_KEYS[type];
          if (aliases) {
            for (const alias of aliases) {
              add(alias, obj[type]);
            }
          } else {
            add(type, obj[type]);
          }
        }
        return newObj;
      }
      var expandedParens = expandAliases(parens);
      var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
      function find2(obj, node, parent, printStack) {
        const fn = obj[node.type];
        return fn ? fn(node, parent, printStack) : null;
      }
      function isOrHasCallExpression(node) {
        if (isCallExpression(node)) {
          return true;
        }
        return isMemberExpression2(node) && isOrHasCallExpression(node.object);
      }
      function needsWhitespace(node, parent, type) {
        if (!node)
          return false;
        if (isExpressionStatement2(node)) {
          node = node.expression;
        }
        const flag = find2(expandedWhitespaceNodes, node, parent);
        if (typeof flag === "number") {
          return (flag & type) !== 0;
        }
        return false;
      }
      function needsWhitespaceBefore(node, parent) {
        return needsWhitespace(node, parent, 1);
      }
      function needsWhitespaceAfter(node, parent) {
        return needsWhitespace(node, parent, 2);
      }
      function needsParens(node, parent, printStack) {
        if (!parent)
          return false;
        if (isNewExpression(parent) && parent.callee === node) {
          if (isOrHasCallExpression(node))
            return true;
        }
        return find2(expandedParens, node, parent, printStack);
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/template-literals.js
  var require_template_literals = __commonJS({
    "node_modules/@babel/generator/lib/generators/template-literals.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TaggedTemplateExpression = TaggedTemplateExpression;
      exports.TemplateElement = TemplateElement;
      exports.TemplateLiteral = TemplateLiteral;
      function TaggedTemplateExpression(node) {
        this.print(node.tag, node);
        this.print(node.typeParameters, node);
        this.print(node.quasi, node);
      }
      function TemplateElement(node, parent) {
        const isFirst = parent.quasis[0] === node;
        const isLast = parent.quasis[parent.quasis.length - 1] === node;
        const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
        this.token(value, true);
      }
      function TemplateLiteral(node) {
        const quasis = node.quasis;
        for (let i = 0; i < quasis.length; i++) {
          this.print(quasis[i], node);
          if (i + 1 < quasis.length) {
            this.print(node.expressions[i], node);
          }
        }
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/expressions.js
  var require_expressions = __commonJS({
    "node_modules/@babel/generator/lib/generators/expressions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
      exports.AssignmentPattern = AssignmentPattern;
      exports.AwaitExpression = AwaitExpression;
      exports.BindExpression = BindExpression;
      exports.CallExpression = CallExpression;
      exports.ConditionalExpression = ConditionalExpression;
      exports.Decorator = Decorator;
      exports.DoExpression = DoExpression;
      exports.EmptyStatement = EmptyStatement;
      exports.ExpressionStatement = ExpressionStatement;
      exports.Import = Import;
      exports.MemberExpression = MemberExpression;
      exports.MetaProperty = MetaProperty;
      exports.ModuleExpression = ModuleExpression;
      exports.NewExpression = NewExpression;
      exports.OptionalCallExpression = OptionalCallExpression;
      exports.OptionalMemberExpression = OptionalMemberExpression;
      exports.ParenthesizedExpression = ParenthesizedExpression;
      exports.PrivateName = PrivateName;
      exports.SequenceExpression = SequenceExpression;
      exports.Super = Super;
      exports.ThisExpression = ThisExpression;
      exports.UnaryExpression = UnaryExpression;
      exports.UpdateExpression = UpdateExpression;
      exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
      exports.YieldExpression = YieldExpression;
      var _t = require_lib4();
      var n = require_node();
      var {
        isCallExpression,
        isLiteral,
        isMemberExpression: isMemberExpression2,
        isNewExpression
      } = _t;
      function UnaryExpression(node) {
        if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
          this.word(node.operator);
          this.space();
        } else {
          this.token(node.operator);
        }
        this.print(node.argument, node);
      }
      function DoExpression(node) {
        if (node.async) {
          this.word("async", true);
          this.space();
        }
        this.word("do");
        this.space();
        this.print(node.body, node);
      }
      function ParenthesizedExpression(node) {
        this.tokenChar(40);
        this.print(node.expression, node);
        this.tokenChar(41);
      }
      function UpdateExpression(node) {
        if (node.prefix) {
          this.token(node.operator);
          this.print(node.argument, node);
        } else {
          this.printTerminatorless(node.argument, node, true);
          this.token(node.operator);
        }
      }
      function ConditionalExpression(node) {
        this.print(node.test, node);
        this.space();
        this.tokenChar(63);
        this.space();
        this.print(node.consequent, node);
        this.space();
        this.tokenChar(58);
        this.space();
        this.print(node.alternate, node);
      }
      function NewExpression(node, parent) {
        this.word("new");
        this.space();
        this.print(node.callee, node);
        if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
          callee: node
        }) && !isMemberExpression2(parent) && !isNewExpression(parent)) {
          return;
        }
        this.print(node.typeArguments, node);
        this.print(node.typeParameters, node);
        if (node.optional) {
          this.token("?.");
        }
        this.tokenChar(40);
        this.printList(node.arguments, node);
        this.tokenChar(41);
      }
      function SequenceExpression(node) {
        this.printList(node.expressions, node);
      }
      function ThisExpression() {
        this.word("this");
      }
      function Super() {
        this.word("super");
      }
      function isDecoratorMemberExpression(node) {
        switch (node.type) {
          case "Identifier":
            return true;
          case "MemberExpression":
            return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
          default:
            return false;
        }
      }
      function shouldParenthesizeDecoratorExpression(node) {
        if (node.type === "ParenthesizedExpression") {
          return false;
        }
        return !isDecoratorMemberExpression(node.type === "CallExpression" ? node.callee : node);
      }
      function Decorator(node) {
        this.tokenChar(64);
        const {
          expression
        } = node;
        if (shouldParenthesizeDecoratorExpression(expression)) {
          this.tokenChar(40);
          this.print(expression, node);
          this.tokenChar(41);
        } else {
          this.print(expression, node);
        }
        this.newline();
      }
      function OptionalMemberExpression(node) {
        this.print(node.object, node);
        if (!node.computed && isMemberExpression2(node.property)) {
          throw new TypeError("Got a MemberExpression for MemberExpression property");
        }
        let computed2 = node.computed;
        if (isLiteral(node.property) && typeof node.property.value === "number") {
          computed2 = true;
        }
        if (node.optional) {
          this.token("?.");
        }
        if (computed2) {
          this.tokenChar(91);
          this.print(node.property, node);
          this.tokenChar(93);
        } else {
          if (!node.optional) {
            this.tokenChar(46);
          }
          this.print(node.property, node);
        }
      }
      function OptionalCallExpression(node) {
        this.print(node.callee, node);
        this.print(node.typeParameters, node);
        if (node.optional) {
          this.token("?.");
        }
        this.print(node.typeArguments, node);
        this.tokenChar(40);
        this.printList(node.arguments, node);
        this.tokenChar(41);
      }
      function CallExpression(node) {
        this.print(node.callee, node);
        this.print(node.typeArguments, node);
        this.print(node.typeParameters, node);
        this.tokenChar(40);
        this.printList(node.arguments, node);
        this.tokenChar(41);
      }
      function Import() {
        this.word("import");
      }
      function AwaitExpression(node) {
        this.word("await");
        if (node.argument) {
          this.space();
          this.printTerminatorless(node.argument, node, false);
        }
      }
      function YieldExpression(node) {
        this.word("yield", true);
        if (node.delegate) {
          this.tokenChar(42);
          if (node.argument) {
            this.space();
            this.print(node.argument, node);
          }
        } else {
          if (node.argument) {
            this.space();
            this.printTerminatorless(node.argument, node, false);
          }
        }
      }
      function EmptyStatement() {
        this.semicolon(true);
      }
      function ExpressionStatement(node) {
        this.print(node.expression, node);
        this.semicolon();
      }
      function AssignmentPattern(node) {
        this.print(node.left, node);
        if (node.left.optional)
          this.tokenChar(63);
        this.print(node.left.typeAnnotation, node);
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.right, node);
      }
      function AssignmentExpression(node, parent) {
        const parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);
        if (parens) {
          this.tokenChar(40);
        }
        this.print(node.left, node);
        this.space();
        if (node.operator === "in" || node.operator === "instanceof") {
          this.word(node.operator);
        } else {
          this.token(node.operator);
        }
        this.space();
        this.print(node.right, node);
        if (parens) {
          this.tokenChar(41);
        }
      }
      function BindExpression(node) {
        this.print(node.object, node);
        this.token("::");
        this.print(node.callee, node);
      }
      function MemberExpression(node) {
        this.print(node.object, node);
        if (!node.computed && isMemberExpression2(node.property)) {
          throw new TypeError("Got a MemberExpression for MemberExpression property");
        }
        let computed2 = node.computed;
        if (isLiteral(node.property) && typeof node.property.value === "number") {
          computed2 = true;
        }
        if (computed2) {
          this.tokenChar(91);
          this.print(node.property, node);
          this.tokenChar(93);
        } else {
          this.tokenChar(46);
          this.print(node.property, node);
        }
      }
      function MetaProperty(node) {
        this.print(node.meta, node);
        this.tokenChar(46);
        this.print(node.property, node);
      }
      function PrivateName(node) {
        this.tokenChar(35);
        this.print(node.id, node);
      }
      function V8IntrinsicIdentifier(node) {
        this.tokenChar(37);
        this.word(node.name);
      }
      function ModuleExpression(node) {
        this.word("module", true);
        this.space();
        this.tokenChar(123);
        this.indent();
        const {
          body
        } = node;
        if (body.body.length || body.directives.length) {
          this.newline();
        }
        this.print(body, node);
        this.dedent();
        this.sourceWithOffset("end", node.loc, 0, -1);
        this.rightBrace();
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/statements.js
  var require_statements = __commonJS({
    "node_modules/@babel/generator/lib/generators/statements.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BreakStatement = BreakStatement;
      exports.CatchClause = CatchClause;
      exports.ContinueStatement = ContinueStatement;
      exports.DebuggerStatement = DebuggerStatement;
      exports.DoWhileStatement = DoWhileStatement;
      exports.ForOfStatement = exports.ForInStatement = void 0;
      exports.ForStatement = ForStatement;
      exports.IfStatement = IfStatement;
      exports.LabeledStatement = LabeledStatement;
      exports.ReturnStatement = ReturnStatement;
      exports.SwitchCase = SwitchCase;
      exports.SwitchStatement = SwitchStatement;
      exports.ThrowStatement = ThrowStatement;
      exports.TryStatement = TryStatement;
      exports.VariableDeclaration = VariableDeclaration;
      exports.VariableDeclarator = VariableDeclarator;
      exports.WhileStatement = WhileStatement;
      exports.WithStatement = WithStatement;
      var _t = require_lib4();
      var {
        isFor,
        isForStatement,
        isIfStatement,
        isStatement
      } = _t;
      function WithStatement(node) {
        this.word("with");
        this.space();
        this.tokenChar(40);
        this.print(node.object, node);
        this.tokenChar(41);
        this.printBlock(node);
      }
      function IfStatement(node) {
        this.word("if");
        this.space();
        this.tokenChar(40);
        this.print(node.test, node);
        this.tokenChar(41);
        this.space();
        const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
        if (needsBlock) {
          this.tokenChar(123);
          this.newline();
          this.indent();
        }
        this.printAndIndentOnComments(node.consequent, node);
        if (needsBlock) {
          this.dedent();
          this.newline();
          this.tokenChar(125);
        }
        if (node.alternate) {
          if (this.endsWith(125))
            this.space();
          this.word("else");
          this.space();
          this.printAndIndentOnComments(node.alternate, node);
        }
      }
      function getLastStatement(statement) {
        const {
          body
        } = statement;
        if (isStatement(body) === false) {
          return statement;
        }
        return getLastStatement(body);
      }
      function ForStatement(node) {
        this.word("for");
        this.space();
        this.tokenChar(40);
        this.inForStatementInitCounter++;
        this.print(node.init, node);
        this.inForStatementInitCounter--;
        this.tokenChar(59);
        if (node.test) {
          this.space();
          this.print(node.test, node);
        }
        this.tokenChar(59);
        if (node.update) {
          this.space();
          this.print(node.update, node);
        }
        this.tokenChar(41);
        this.printBlock(node);
      }
      function WhileStatement(node) {
        this.word("while");
        this.space();
        this.tokenChar(40);
        this.print(node.test, node);
        this.tokenChar(41);
        this.printBlock(node);
      }
      function ForXStatement(node) {
        this.word("for");
        this.space();
        const isForOf = node.type === "ForOfStatement";
        if (isForOf && node.await) {
          this.word("await");
          this.space();
        }
        this.noIndentInnerCommentsHere();
        this.tokenChar(40);
        this.print(node.left, node);
        this.space();
        this.word(isForOf ? "of" : "in");
        this.space();
        this.print(node.right, node);
        this.tokenChar(41);
        this.printBlock(node);
      }
      var ForInStatement = ForXStatement;
      exports.ForInStatement = ForInStatement;
      var ForOfStatement = ForXStatement;
      exports.ForOfStatement = ForOfStatement;
      function DoWhileStatement(node) {
        this.word("do");
        this.space();
        this.print(node.body, node);
        this.space();
        this.word("while");
        this.space();
        this.tokenChar(40);
        this.print(node.test, node);
        this.tokenChar(41);
        this.semicolon();
      }
      function printStatementAfterKeyword(printer, node, parent, isLabel) {
        if (node) {
          printer.space();
          printer.printTerminatorless(node, parent, isLabel);
        }
        printer.semicolon();
      }
      function BreakStatement(node) {
        this.word("break");
        printStatementAfterKeyword(this, node.label, node, true);
      }
      function ContinueStatement(node) {
        this.word("continue");
        printStatementAfterKeyword(this, node.label, node, true);
      }
      function ReturnStatement(node) {
        this.word("return");
        printStatementAfterKeyword(this, node.argument, node, false);
      }
      function ThrowStatement(node) {
        this.word("throw");
        printStatementAfterKeyword(this, node.argument, node, false);
      }
      function LabeledStatement(node) {
        this.print(node.label, node);
        this.tokenChar(58);
        this.space();
        this.print(node.body, node);
      }
      function TryStatement(node) {
        this.word("try");
        this.space();
        this.print(node.block, node);
        this.space();
        if (node.handlers) {
          this.print(node.handlers[0], node);
        } else {
          this.print(node.handler, node);
        }
        if (node.finalizer) {
          this.space();
          this.word("finally");
          this.space();
          this.print(node.finalizer, node);
        }
      }
      function CatchClause(node) {
        this.word("catch");
        this.space();
        if (node.param) {
          this.tokenChar(40);
          this.print(node.param, node);
          this.print(node.param.typeAnnotation, node);
          this.tokenChar(41);
          this.space();
        }
        this.print(node.body, node);
      }
      function SwitchStatement(node) {
        this.word("switch");
        this.space();
        this.tokenChar(40);
        this.print(node.discriminant, node);
        this.tokenChar(41);
        this.space();
        this.tokenChar(123);
        this.printSequence(node.cases, node, {
          indent: true,
          addNewlines(leading, cas) {
            if (!leading && node.cases[node.cases.length - 1] === cas)
              return -1;
          }
        });
        this.tokenChar(125);
      }
      function SwitchCase(node) {
        if (node.test) {
          this.word("case");
          this.space();
          this.print(node.test, node);
          this.tokenChar(58);
        } else {
          this.word("default");
          this.tokenChar(58);
        }
        if (node.consequent.length) {
          this.newline();
          this.printSequence(node.consequent, node, {
            indent: true
          });
        }
      }
      function DebuggerStatement() {
        this.word("debugger");
        this.semicolon();
      }
      function VariableDeclaration(node, parent) {
        if (node.declare) {
          this.word("declare");
          this.space();
        }
        const {
          kind
        } = node;
        this.word(kind, kind === "using");
        this.space();
        let hasInits = false;
        if (!isFor(parent)) {
          for (const declar of node.declarations) {
            if (declar.init) {
              hasInits = true;
            }
          }
        }
        this.printList(node.declarations, node, {
          separator: hasInits ? function() {
            this.tokenChar(44);
            this.newline();
          } : void 0,
          indent: node.declarations.length > 1 ? true : false
        });
        if (isFor(parent)) {
          if (isForStatement(parent)) {
            if (parent.init === node)
              return;
          } else {
            if (parent.left === node)
              return;
          }
        }
        this.semicolon();
      }
      function VariableDeclarator(node) {
        this.print(node.id, node);
        if (node.definite)
          this.tokenChar(33);
        this.print(node.id.typeAnnotation, node);
        if (node.init) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.init, node);
        }
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/classes.js
  var require_classes = __commonJS({
    "node_modules/@babel/generator/lib/generators/classes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ClassAccessorProperty = ClassAccessorProperty;
      exports.ClassBody = ClassBody;
      exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
      exports.ClassMethod = ClassMethod;
      exports.ClassPrivateMethod = ClassPrivateMethod;
      exports.ClassPrivateProperty = ClassPrivateProperty;
      exports.ClassProperty = ClassProperty;
      exports.StaticBlock = StaticBlock;
      exports._classMethodHead = _classMethodHead;
      var _t = require_lib4();
      var {
        isExportDefaultDeclaration,
        isExportNamedDeclaration
      } = _t;
      function ClassDeclaration(node, parent) {
        {
          if (!this.format.decoratorsBeforeExport || !isExportDefaultDeclaration(parent) && !isExportNamedDeclaration(parent)) {
            this.printJoin(node.decorators, node);
          }
        }
        if (node.declare) {
          this.word("declare");
          this.space();
        }
        if (node.abstract) {
          this.word("abstract");
          this.space();
        }
        this.word("class");
        if (node.id) {
          this.space();
          this.print(node.id, node);
        }
        this.print(node.typeParameters, node);
        if (node.superClass) {
          this.space();
          this.word("extends");
          this.space();
          this.print(node.superClass, node);
          this.print(node.superTypeParameters, node);
        }
        if (node.implements) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node.implements, node);
        }
        this.space();
        this.print(node.body, node);
      }
      function ClassBody(node) {
        this.tokenChar(123);
        if (node.body.length === 0) {
          this.tokenChar(125);
        } else {
          this.newline();
          this.indent();
          this.printSequence(node.body, node);
          this.dedent();
          if (!this.endsWith(10))
            this.newline();
          this.sourceWithOffset("end", node.loc, 0, -1);
          this.rightBrace();
        }
      }
      function ClassProperty(node) {
        var _node$key$loc, _node$key$loc$end;
        this.printJoin(node.decorators, node);
        const endLine = (_node$key$loc = node.key.loc) == null ? void 0 : (_node$key$loc$end = _node$key$loc.end) == null ? void 0 : _node$key$loc$end.line;
        if (endLine)
          this.catchUp(endLine);
        this.tsPrintClassMemberModifiers(node);
        if (node.computed) {
          this.tokenChar(91);
          this.print(node.key, node);
          this.tokenChar(93);
        } else {
          this._variance(node);
          this.print(node.key, node);
        }
        if (node.optional) {
          this.tokenChar(63);
        }
        if (node.definite) {
          this.tokenChar(33);
        }
        this.print(node.typeAnnotation, node);
        if (node.value) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.value, node);
        }
        this.semicolon();
      }
      function ClassAccessorProperty(node) {
        var _node$key$loc2, _node$key$loc2$end;
        this.printJoin(node.decorators, node);
        const endLine = (_node$key$loc2 = node.key.loc) == null ? void 0 : (_node$key$loc2$end = _node$key$loc2.end) == null ? void 0 : _node$key$loc2$end.line;
        if (endLine)
          this.catchUp(endLine);
        this.tsPrintClassMemberModifiers(node);
        this.word("accessor", true);
        this.space();
        if (node.computed) {
          this.tokenChar(91);
          this.print(node.key, node);
          this.tokenChar(93);
        } else {
          this._variance(node);
          this.print(node.key, node);
        }
        if (node.optional) {
          this.tokenChar(63);
        }
        if (node.definite) {
          this.tokenChar(33);
        }
        this.print(node.typeAnnotation, node);
        if (node.value) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.value, node);
        }
        this.semicolon();
      }
      function ClassPrivateProperty(node) {
        this.printJoin(node.decorators, node);
        if (node.static) {
          this.word("static");
          this.space();
        }
        this.print(node.key, node);
        this.print(node.typeAnnotation, node);
        if (node.value) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.value, node);
        }
        this.semicolon();
      }
      function ClassMethod(node) {
        this._classMethodHead(node);
        this.space();
        this.print(node.body, node);
      }
      function ClassPrivateMethod(node) {
        this._classMethodHead(node);
        this.space();
        this.print(node.body, node);
      }
      function _classMethodHead(node) {
        var _node$key$loc3, _node$key$loc3$end;
        this.printJoin(node.decorators, node);
        const endLine = (_node$key$loc3 = node.key.loc) == null ? void 0 : (_node$key$loc3$end = _node$key$loc3.end) == null ? void 0 : _node$key$loc3$end.line;
        if (endLine)
          this.catchUp(endLine);
        this.tsPrintClassMemberModifiers(node);
        this._methodHead(node);
      }
      function StaticBlock(node) {
        this.word("static");
        this.space();
        this.tokenChar(123);
        if (node.body.length === 0) {
          this.tokenChar(125);
        } else {
          this.newline();
          this.printSequence(node.body, node, {
            indent: true
          });
          this.sourceWithOffset("end", node.loc, 0, -1);
          this.rightBrace();
        }
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/methods.js
  var require_methods = __commonJS({
    "node_modules/@babel/generator/lib/generators/methods.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArrowFunctionExpression = ArrowFunctionExpression;
      exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
      exports._functionHead = _functionHead;
      exports._methodHead = _methodHead;
      exports._param = _param;
      exports._parameters = _parameters;
      exports._params = _params;
      exports._predicate = _predicate;
      var _t = require_lib4();
      var {
        isIdentifier: isIdentifier2
      } = _t;
      function _params(node) {
        this.print(node.typeParameters, node);
        this.tokenChar(40);
        this._parameters(node.params, node);
        this.tokenChar(41);
        const noLineTerminator = node.type === "ArrowFunctionExpression";
        this.print(node.returnType, node, noLineTerminator);
        this._noLineTerminator = noLineTerminator;
      }
      function _parameters(parameters, parent) {
        const paramLength = parameters.length;
        for (let i = 0; i < paramLength; i++) {
          this._param(parameters[i], parent);
          if (i < parameters.length - 1) {
            this.tokenChar(44);
            this.space();
          }
        }
      }
      function _param(parameter, parent) {
        this.printJoin(parameter.decorators, parameter);
        this.print(parameter, parent);
        if (parameter.optional) {
          this.tokenChar(63);
        }
        this.print(parameter.typeAnnotation, parameter);
      }
      function _methodHead(node) {
        const kind = node.kind;
        const key = node.key;
        if (kind === "get" || kind === "set") {
          this.word(kind);
          this.space();
        }
        if (node.async) {
          this.word("async", true);
          this.space();
        }
        if (kind === "method" || kind === "init") {
          if (node.generator) {
            this.tokenChar(42);
          }
        }
        if (node.computed) {
          this.tokenChar(91);
          this.print(key, node);
          this.tokenChar(93);
        } else {
          this.print(key, node);
        }
        if (node.optional) {
          this.tokenChar(63);
        }
        this._params(node);
      }
      function _predicate(node, noLineTerminatorAfter) {
        if (node.predicate) {
          if (!node.returnType) {
            this.tokenChar(58);
          }
          this.space();
          this.print(node.predicate, node, noLineTerminatorAfter);
        }
      }
      function _functionHead(node) {
        if (node.async) {
          this.word("async");
          this._endsWithInnerRaw = false;
          this.space();
        }
        this.word("function");
        if (node.generator) {
          this._endsWithInnerRaw = false;
          this.tokenChar(42);
        }
        this.space();
        if (node.id) {
          this.print(node.id, node);
        }
        this._params(node);
        if (node.type !== "TSDeclareFunction") {
          this._predicate(node);
        }
      }
      function FunctionExpression(node) {
        this._functionHead(node);
        this.space();
        this.print(node.body, node);
      }
      function ArrowFunctionExpression(node) {
        if (node.async) {
          this.word("async", true);
          this.space();
        }
        let firstParam;
        if (!this.format.retainLines && node.params.length === 1 && isIdentifier2(firstParam = node.params[0]) && !hasTypesOrComments(node, firstParam)) {
          this.print(firstParam, node, true);
        } else {
          this._params(node);
        }
        this._predicate(node, true);
        this.space();
        this.printInnerComments();
        this.token("=>");
        this.space();
        this.print(node.body, node);
      }
      function hasTypesOrComments(node, param) {
        var _param$leadingComment, _param$trailingCommen;
        return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/modules.js
  var require_modules = __commonJS({
    "node_modules/@babel/generator/lib/generators/modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ExportAllDeclaration = ExportAllDeclaration;
      exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
      exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
      exports.ExportNamedDeclaration = ExportNamedDeclaration;
      exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
      exports.ExportSpecifier = ExportSpecifier;
      exports.ImportAttribute = ImportAttribute;
      exports.ImportDeclaration = ImportDeclaration;
      exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
      exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
      exports.ImportSpecifier = ImportSpecifier;
      exports._printAssertions = _printAssertions;
      var _t = require_lib4();
      var {
        isClassDeclaration,
        isExportDefaultSpecifier,
        isExportNamespaceSpecifier,
        isImportDefaultSpecifier,
        isImportNamespaceSpecifier,
        isStatement
      } = _t;
      function ImportSpecifier(node) {
        if (node.importKind === "type" || node.importKind === "typeof") {
          this.word(node.importKind);
          this.space();
        }
        this.print(node.imported, node);
        if (node.local && node.local.name !== node.imported.name) {
          this.space();
          this.word("as");
          this.space();
          this.print(node.local, node);
        }
      }
      function ImportDefaultSpecifier(node) {
        this.print(node.local, node);
      }
      function ExportDefaultSpecifier(node) {
        this.print(node.exported, node);
      }
      function ExportSpecifier(node) {
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }
        this.print(node.local, node);
        if (node.exported && node.local.name !== node.exported.name) {
          this.space();
          this.word("as");
          this.space();
          this.print(node.exported, node);
        }
      }
      function ExportNamespaceSpecifier(node) {
        this.tokenChar(42);
        this.space();
        this.word("as");
        this.space();
        this.print(node.exported, node);
      }
      function _printAssertions(node) {
        this.word("assert");
        this.space();
        this.tokenChar(123);
        this.space();
        this.printList(node.assertions, node);
        this.space();
        this.tokenChar(125);
      }
      function ExportAllDeclaration(node) {
        var _node$assertions;
        this.word("export");
        this.space();
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }
        this.tokenChar(42);
        this.space();
        this.word("from");
        this.space();
        if ((_node$assertions = node.assertions) != null && _node$assertions.length) {
          this.print(node.source, node, true);
          this.space();
          this._printAssertions(node);
        } else {
          this.print(node.source, node);
        }
        this.semicolon();
      }
      function ExportNamedDeclaration(node) {
        {
          if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
            this.printJoin(node.declaration.decorators, node);
          }
        }
        this.word("export");
        this.space();
        if (node.declaration) {
          const declar = node.declaration;
          this.print(declar, node);
          if (!isStatement(declar))
            this.semicolon();
        } else {
          if (node.exportKind === "type") {
            this.word("type");
            this.space();
          }
          const specifiers = node.specifiers.slice(0);
          let hasSpecial = false;
          for (; ; ) {
            const first = specifiers[0];
            if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
              hasSpecial = true;
              this.print(specifiers.shift(), node);
              if (specifiers.length) {
                this.tokenChar(44);
                this.space();
              }
            } else {
              break;
            }
          }
          if (specifiers.length || !specifiers.length && !hasSpecial) {
            this.tokenChar(123);
            if (specifiers.length) {
              this.space();
              this.printList(specifiers, node);
              this.space();
            }
            this.tokenChar(125);
          }
          if (node.source) {
            var _node$assertions2;
            this.space();
            this.word("from");
            this.space();
            if ((_node$assertions2 = node.assertions) != null && _node$assertions2.length) {
              this.print(node.source, node, true);
              this.space();
              this._printAssertions(node);
            } else {
              this.print(node.source, node);
            }
          }
          this.semicolon();
        }
      }
      function ExportDefaultDeclaration(node) {
        {
          if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
            this.printJoin(node.declaration.decorators, node);
          }
        }
        this.word("export");
        this.noIndentInnerCommentsHere();
        this.space();
        this.word("default");
        this.space();
        const declar = node.declaration;
        this.print(declar, node);
        if (!isStatement(declar))
          this.semicolon();
      }
      function ImportDeclaration(node) {
        var _node$assertions3;
        this.word("import");
        this.space();
        const isTypeKind = node.importKind === "type" || node.importKind === "typeof";
        if (isTypeKind) {
          this.noIndentInnerCommentsHere();
          this.word(node.importKind);
          this.space();
        } else if (node.module) {
          this.noIndentInnerCommentsHere();
          this.word("module");
          this.space();
        }
        const specifiers = node.specifiers.slice(0);
        const hasSpecifiers = !!specifiers.length;
        while (hasSpecifiers) {
          const first = specifiers[0];
          if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
            this.print(specifiers.shift(), node);
            if (specifiers.length) {
              this.tokenChar(44);
              this.space();
            }
          } else {
            break;
          }
        }
        if (specifiers.length) {
          this.tokenChar(123);
          this.space();
          this.printList(specifiers, node);
          this.space();
          this.tokenChar(125);
        } else if (isTypeKind && !hasSpecifiers) {
          this.tokenChar(123);
          this.tokenChar(125);
        }
        if (hasSpecifiers || isTypeKind) {
          this.space();
          this.word("from");
          this.space();
        }
        if ((_node$assertions3 = node.assertions) != null && _node$assertions3.length) {
          this.print(node.source, node, true);
          this.space();
          this._printAssertions(node);
        } else {
          this.print(node.source, node);
        }
        {
          var _node$attributes;
          if ((_node$attributes = node.attributes) != null && _node$attributes.length) {
            this.space();
            this.word("with");
            this.space();
            this.printList(node.attributes, node);
          }
        }
        this.semicolon();
      }
      function ImportAttribute(node) {
        this.print(node.key);
        this.tokenChar(58);
        this.space();
        this.print(node.value);
      }
      function ImportNamespaceSpecifier(node) {
        this.tokenChar(42);
        this.space();
        this.word("as");
        this.space();
        this.print(node.local, node);
      }
    }
  });

  // node_modules/jsesc/jsesc.js
  var require_jsesc = __commonJS({
    "node_modules/jsesc/jsesc.js"(exports, module) {
      "use strict";
      var object = {};
      var hasOwnProperty6 = object.hasOwnProperty;
      var forOwn = (object2, callback) => {
        for (const key in object2) {
          if (hasOwnProperty6.call(object2, key)) {
            callback(key, object2[key]);
          }
        }
      };
      var extend = (destination, source) => {
        if (!source) {
          return destination;
        }
        forOwn(source, (key, value) => {
          destination[key] = value;
        });
        return destination;
      };
      var forEach = (array, callback) => {
        const length = array.length;
        let index = -1;
        while (++index < length) {
          callback(array[index]);
        }
      };
      var toString = object.toString;
      var isArray = Array.isArray;
      var isBuffer = Buffer.isBuffer;
      var isObject2 = (value) => {
        return toString.call(value) == "[object Object]";
      };
      var isString = (value) => {
        return typeof value == "string" || toString.call(value) == "[object String]";
      };
      var isNumber = (value) => {
        return typeof value == "number" || toString.call(value) == "[object Number]";
      };
      var isFunction = (value) => {
        return typeof value == "function";
      };
      var isMap = (value) => {
        return toString.call(value) == "[object Map]";
      };
      var isSet = (value) => {
        return toString.call(value) == "[object Set]";
      };
      var singleEscapes = {
        '"': '\\"',
        "'": "\\'",
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t"
        // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
        // '\v': '\\x0B'
      };
      var regexSingleEscape = /["'\\\b\f\n\r\t]/;
      var regexDigit = /[0-9]/;
      var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;
      var jsesc = (argument, options) => {
        const increaseIndentation = () => {
          oldIndent = indent;
          ++options.indentLevel;
          indent = options.indent.repeat(options.indentLevel);
        };
        const defaults = {
          "escapeEverything": false,
          "minimal": false,
          "isScriptContext": false,
          "quotes": "single",
          "wrap": false,
          "es6": false,
          "json": false,
          "compact": true,
          "lowercaseHex": false,
          "numbers": "decimal",
          "indent": "	",
          "indentLevel": 0,
          "__inline1__": false,
          "__inline2__": false
        };
        const json = options && options.json;
        if (json) {
          defaults.quotes = "double";
          defaults.wrap = true;
        }
        options = extend(defaults, options);
        if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
          options.quotes = "single";
        }
        const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
        const compact = options.compact;
        const lowercaseHex = options.lowercaseHex;
        let indent = options.indent.repeat(options.indentLevel);
        let oldIndent = "";
        const inline1 = options.__inline1__;
        const inline2 = options.__inline2__;
        const newLine = compact ? "" : "\n";
        let result;
        let isEmpty = true;
        const useBinNumbers = options.numbers == "binary";
        const useOctNumbers = options.numbers == "octal";
        const useDecNumbers = options.numbers == "decimal";
        const useHexNumbers = options.numbers == "hexadecimal";
        if (json && argument && isFunction(argument.toJSON)) {
          argument = argument.toJSON();
        }
        if (!isString(argument)) {
          if (isMap(argument)) {
            if (argument.size == 0) {
              return "new Map()";
            }
            if (!compact) {
              options.__inline1__ = true;
              options.__inline2__ = false;
            }
            return "new Map(" + jsesc(Array.from(argument), options) + ")";
          }
          if (isSet(argument)) {
            if (argument.size == 0) {
              return "new Set()";
            }
            return "new Set(" + jsesc(Array.from(argument), options) + ")";
          }
          if (isBuffer(argument)) {
            if (argument.length == 0) {
              return "Buffer.from([])";
            }
            return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
          }
          if (isArray(argument)) {
            result = [];
            options.wrap = true;
            if (inline1) {
              options.__inline1__ = false;
              options.__inline2__ = true;
            }
            if (!inline2) {
              increaseIndentation();
            }
            forEach(argument, (value) => {
              isEmpty = false;
              if (inline2) {
                options.__inline2__ = false;
              }
              result.push(
                (compact || inline2 ? "" : indent) + jsesc(value, options)
              );
            });
            if (isEmpty) {
              return "[]";
            }
            if (inline2) {
              return "[" + result.join(", ") + "]";
            }
            return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
          } else if (isNumber(argument)) {
            if (json) {
              return JSON.stringify(argument);
            }
            if (useDecNumbers) {
              return String(argument);
            }
            if (useHexNumbers) {
              let hexadecimal = argument.toString(16);
              if (!lowercaseHex) {
                hexadecimal = hexadecimal.toUpperCase();
              }
              return "0x" + hexadecimal;
            }
            if (useBinNumbers) {
              return "0b" + argument.toString(2);
            }
            if (useOctNumbers) {
              return "0o" + argument.toString(8);
            }
          } else if (!isObject2(argument)) {
            if (json) {
              return JSON.stringify(argument) || "null";
            }
            return String(argument);
          } else {
            result = [];
            options.wrap = true;
            increaseIndentation();
            forOwn(argument, (key, value) => {
              isEmpty = false;
              result.push(
                (compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options)
              );
            });
            if (isEmpty) {
              return "{}";
            }
            return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
          }
        }
        const string = argument;
        let index = -1;
        const length = string.length;
        result = "";
        while (++index < length) {
          const character = string.charAt(index);
          if (options.es6) {
            const first = string.charCodeAt(index);
            if (
              // check if it’s the start of a surrogate pair
              first >= 55296 && first <= 56319 && // high surrogate
              length > index + 1
            ) {
              const second = string.charCodeAt(index + 1);
              if (second >= 56320 && second <= 57343) {
                const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
                let hexadecimal2 = codePoint.toString(16);
                if (!lowercaseHex) {
                  hexadecimal2 = hexadecimal2.toUpperCase();
                }
                result += "\\u{" + hexadecimal2 + "}";
                ++index;
                continue;
              }
            }
          }
          if (!options.escapeEverything) {
            if (regexWhitelist.test(character)) {
              result += character;
              continue;
            }
            if (character == '"') {
              result += quote == character ? '\\"' : character;
              continue;
            }
            if (character == "`") {
              result += quote == character ? "\\`" : character;
              continue;
            }
            if (character == "'") {
              result += quote == character ? "\\'" : character;
              continue;
            }
          }
          if (character == "\0" && !json && !regexDigit.test(string.charAt(index + 1))) {
            result += "\\0";
            continue;
          }
          if (regexSingleEscape.test(character)) {
            result += singleEscapes[character];
            continue;
          }
          const charCode2 = character.charCodeAt(0);
          if (options.minimal && charCode2 != 8232 && charCode2 != 8233) {
            result += character;
            continue;
          }
          let hexadecimal = charCode2.toString(16);
          if (!lowercaseHex) {
            hexadecimal = hexadecimal.toUpperCase();
          }
          const longhand = hexadecimal.length > 2 || json;
          const escaped = "\\" + (longhand ? "u" : "x") + ("0000" + hexadecimal).slice(longhand ? -4 : -2);
          result += escaped;
          continue;
        }
        if (options.wrap) {
          result = quote + result + quote;
        }
        if (quote == "`") {
          result = result.replace(/\$\{/g, "\\${");
        }
        if (options.isScriptContext) {
          return result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
        }
        return result;
      };
      jsesc.version = "2.5.2";
      module.exports = jsesc;
    }
  });

  // node_modules/@babel/generator/lib/generators/types.js
  var require_types = __commonJS({
    "node_modules/@babel/generator/lib/generators/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArgumentPlaceholder = ArgumentPlaceholder;
      exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
      exports.BigIntLiteral = BigIntLiteral;
      exports.BooleanLiteral = BooleanLiteral;
      exports.DecimalLiteral = DecimalLiteral;
      exports.Identifier = Identifier;
      exports.NullLiteral = NullLiteral;
      exports.NumericLiteral = NumericLiteral;
      exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
      exports.ObjectMethod = ObjectMethod;
      exports.ObjectProperty = ObjectProperty;
      exports.PipelineBareFunction = PipelineBareFunction;
      exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
      exports.PipelineTopicExpression = PipelineTopicExpression;
      exports.RecordExpression = RecordExpression;
      exports.RegExpLiteral = RegExpLiteral;
      exports.SpreadElement = exports.RestElement = RestElement;
      exports.StringLiteral = StringLiteral;
      exports.TopicReference = TopicReference;
      exports.TupleExpression = TupleExpression;
      var _t = require_lib4();
      var _jsesc = require_jsesc();
      var {
        isAssignmentPattern,
        isIdentifier: isIdentifier2
      } = _t;
      function Identifier(node) {
        this.word(node.name);
      }
      function ArgumentPlaceholder() {
        this.tokenChar(63);
      }
      function RestElement(node) {
        this.token("...");
        this.print(node.argument, node);
      }
      function ObjectExpression(node) {
        const props = node.properties;
        this.tokenChar(123);
        if (props.length) {
          this.space();
          this.printList(props, node, {
            indent: true,
            statement: true
          });
          this.space();
        }
        this.sourceWithOffset("end", node.loc, 0, -1);
        this.tokenChar(125);
      }
      function ObjectMethod(node) {
        this.printJoin(node.decorators, node);
        this._methodHead(node);
        this.space();
        this.print(node.body, node);
      }
      function ObjectProperty(node) {
        this.printJoin(node.decorators, node);
        if (node.computed) {
          this.tokenChar(91);
          this.print(node.key, node);
          this.tokenChar(93);
        } else {
          if (isAssignmentPattern(node.value) && isIdentifier2(node.key) && node.key.name === node.value.left.name) {
            this.print(node.value, node);
            return;
          }
          this.print(node.key, node);
          if (node.shorthand && isIdentifier2(node.key) && isIdentifier2(node.value) && node.key.name === node.value.name) {
            return;
          }
        }
        this.tokenChar(58);
        this.space();
        this.print(node.value, node);
      }
      function ArrayExpression(node) {
        const elems = node.elements;
        const len = elems.length;
        this.tokenChar(91);
        for (let i = 0; i < elems.length; i++) {
          const elem = elems[i];
          if (elem) {
            if (i > 0)
              this.space();
            this.print(elem, node);
            if (i < len - 1)
              this.tokenChar(44);
          } else {
            this.tokenChar(44);
          }
        }
        this.tokenChar(93);
      }
      function RecordExpression(node) {
        const props = node.properties;
        let startToken;
        let endToken;
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "{|";
          endToken = "|}";
        } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
          throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
        } else {
          startToken = "#{";
          endToken = "}";
        }
        this.token(startToken);
        if (props.length) {
          this.space();
          this.printList(props, node, {
            indent: true,
            statement: true
          });
          this.space();
        }
        this.token(endToken);
      }
      function TupleExpression(node) {
        const elems = node.elements;
        const len = elems.length;
        let startToken;
        let endToken;
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "[|";
          endToken = "|]";
        } else if (this.format.recordAndTupleSyntaxType === "hash") {
          startToken = "#[";
          endToken = "]";
        } else {
          throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
        }
        this.token(startToken);
        for (let i = 0; i < elems.length; i++) {
          const elem = elems[i];
          if (elem) {
            if (i > 0)
              this.space();
            this.print(elem, node);
            if (i < len - 1)
              this.tokenChar(44);
          }
        }
        this.token(endToken);
      }
      function RegExpLiteral(node) {
        this.word(`/${node.pattern}/${node.flags}`);
      }
      function BooleanLiteral(node) {
        this.word(node.value ? "true" : "false");
      }
      function NullLiteral() {
        this.word("null");
      }
      function NumericLiteral(node) {
        const raw = this.getPossibleRaw(node);
        const opts = this.format.jsescOption;
        const value = node.value + "";
        if (opts.numbers) {
          this.number(_jsesc(node.value, opts));
        } else if (raw == null) {
          this.number(value);
        } else if (this.format.minified) {
          this.number(raw.length < value.length ? raw : value);
        } else {
          this.number(raw);
        }
      }
      function StringLiteral(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && raw !== void 0) {
          this.token(raw);
          return;
        }
        const val = _jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {
          json: true
        }));
        return this.token(val);
      }
      function BigIntLiteral(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && raw !== void 0) {
          this.word(raw);
          return;
        }
        this.word(node.value + "n");
      }
      function DecimalLiteral(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && raw !== void 0) {
          this.word(raw);
          return;
        }
        this.word(node.value + "m");
      }
      var validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
      function TopicReference() {
        const {
          topicToken
        } = this.format;
        if (validTopicTokenSet.has(topicToken)) {
          this.token(topicToken);
        } else {
          const givenTopicTokenJSON = JSON.stringify(topicToken);
          const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
          throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
        }
      }
      function PipelineTopicExpression(node) {
        this.print(node.expression, node);
      }
      function PipelineBareFunction(node) {
        this.print(node.callee, node);
      }
      function PipelinePrimaryTopicReference() {
        this.tokenChar(35);
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/flow.js
  var require_flow2 = __commonJS({
    "node_modules/@babel/generator/lib/generators/flow.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AnyTypeAnnotation = AnyTypeAnnotation;
      exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
      exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
      exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
      exports.DeclareClass = DeclareClass;
      exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
      exports.DeclareExportDeclaration = DeclareExportDeclaration;
      exports.DeclareFunction = DeclareFunction;
      exports.DeclareInterface = DeclareInterface;
      exports.DeclareModule = DeclareModule;
      exports.DeclareModuleExports = DeclareModuleExports;
      exports.DeclareOpaqueType = DeclareOpaqueType;
      exports.DeclareTypeAlias = DeclareTypeAlias;
      exports.DeclareVariable = DeclareVariable;
      exports.DeclaredPredicate = DeclaredPredicate;
      exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
      exports.EnumBooleanBody = EnumBooleanBody;
      exports.EnumBooleanMember = EnumBooleanMember;
      exports.EnumDeclaration = EnumDeclaration;
      exports.EnumDefaultedMember = EnumDefaultedMember;
      exports.EnumNumberBody = EnumNumberBody;
      exports.EnumNumberMember = EnumNumberMember;
      exports.EnumStringBody = EnumStringBody;
      exports.EnumStringMember = EnumStringMember;
      exports.EnumSymbolBody = EnumSymbolBody;
      exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
      exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
      exports.FunctionTypeParam = FunctionTypeParam;
      exports.IndexedAccessType = IndexedAccessType;
      exports.InferredPredicate = InferredPredicate;
      exports.InterfaceDeclaration = InterfaceDeclaration;
      exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
      exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
      exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
      exports.MixedTypeAnnotation = MixedTypeAnnotation;
      exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
      exports.NullableTypeAnnotation = NullableTypeAnnotation;
      Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _types2.NumericLiteral;
        }
      });
      exports.NumberTypeAnnotation = NumberTypeAnnotation;
      exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
      exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
      exports.ObjectTypeIndexer = ObjectTypeIndexer;
      exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
      exports.ObjectTypeProperty = ObjectTypeProperty;
      exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
      exports.OpaqueType = OpaqueType;
      exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
      exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
      Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _types2.StringLiteral;
        }
      });
      exports.StringTypeAnnotation = StringTypeAnnotation;
      exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
      exports.ThisTypeAnnotation = ThisTypeAnnotation;
      exports.TupleTypeAnnotation = TupleTypeAnnotation;
      exports.TypeAlias = TypeAlias;
      exports.TypeAnnotation = TypeAnnotation;
      exports.TypeCastExpression = TypeCastExpression;
      exports.TypeParameter = TypeParameter;
      exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
      exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
      exports.UnionTypeAnnotation = UnionTypeAnnotation;
      exports.Variance = Variance;
      exports.VoidTypeAnnotation = VoidTypeAnnotation;
      exports._interfaceish = _interfaceish;
      exports._variance = _variance;
      var _t = require_lib4();
      var _modules = require_modules();
      var _types2 = require_types();
      var {
        isDeclareExportDeclaration,
        isStatement
      } = _t;
      function AnyTypeAnnotation() {
        this.word("any");
      }
      function ArrayTypeAnnotation(node) {
        this.print(node.elementType, node, true);
        this.tokenChar(91);
        this.tokenChar(93);
      }
      function BooleanTypeAnnotation() {
        this.word("boolean");
      }
      function BooleanLiteralTypeAnnotation(node) {
        this.word(node.value ? "true" : "false");
      }
      function NullLiteralTypeAnnotation() {
        this.word("null");
      }
      function DeclareClass(node, parent) {
        if (!isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.word("class");
        this.space();
        this._interfaceish(node);
      }
      function DeclareFunction(node, parent) {
        if (!isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.word("function");
        this.space();
        this.print(node.id, node);
        this.print(node.id.typeAnnotation.typeAnnotation, node);
        if (node.predicate) {
          this.space();
          this.print(node.predicate, node);
        }
        this.semicolon();
      }
      function InferredPredicate() {
        this.tokenChar(37);
        this.word("checks");
      }
      function DeclaredPredicate(node) {
        this.tokenChar(37);
        this.word("checks");
        this.tokenChar(40);
        this.print(node.value, node);
        this.tokenChar(41);
      }
      function DeclareInterface(node) {
        this.word("declare");
        this.space();
        this.InterfaceDeclaration(node);
      }
      function DeclareModule(node) {
        this.word("declare");
        this.space();
        this.word("module");
        this.space();
        this.print(node.id, node);
        this.space();
        this.print(node.body, node);
      }
      function DeclareModuleExports(node) {
        this.word("declare");
        this.space();
        this.word("module");
        this.tokenChar(46);
        this.word("exports");
        this.print(node.typeAnnotation, node);
      }
      function DeclareTypeAlias(node) {
        this.word("declare");
        this.space();
        this.TypeAlias(node);
      }
      function DeclareOpaqueType(node, parent) {
        if (!isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.OpaqueType(node);
      }
      function DeclareVariable(node, parent) {
        if (!isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.word("var");
        this.space();
        this.print(node.id, node);
        this.print(node.id.typeAnnotation, node);
        this.semicolon();
      }
      function DeclareExportDeclaration(node) {
        this.word("declare");
        this.space();
        this.word("export");
        this.space();
        if (node.default) {
          this.word("default");
          this.space();
        }
        FlowExportDeclaration.call(this, node);
      }
      function DeclareExportAllDeclaration(node) {
        this.word("declare");
        this.space();
        _modules.ExportAllDeclaration.call(this, node);
      }
      function EnumDeclaration(node) {
        const {
          id,
          body
        } = node;
        this.word("enum");
        this.space();
        this.print(id, node);
        this.print(body, node);
      }
      function enumExplicitType(context, name41, hasExplicitType) {
        if (hasExplicitType) {
          context.space();
          context.word("of");
          context.space();
          context.word(name41);
        }
        context.space();
      }
      function enumBody(context, node) {
        const {
          members
        } = node;
        context.token("{");
        context.indent();
        context.newline();
        for (const member of members) {
          context.print(member, node);
          context.newline();
        }
        if (node.hasUnknownMembers) {
          context.token("...");
          context.newline();
        }
        context.dedent();
        context.token("}");
      }
      function EnumBooleanBody(node) {
        const {
          explicitType
        } = node;
        enumExplicitType(this, "boolean", explicitType);
        enumBody(this, node);
      }
      function EnumNumberBody(node) {
        const {
          explicitType
        } = node;
        enumExplicitType(this, "number", explicitType);
        enumBody(this, node);
      }
      function EnumStringBody(node) {
        const {
          explicitType
        } = node;
        enumExplicitType(this, "string", explicitType);
        enumBody(this, node);
      }
      function EnumSymbolBody(node) {
        enumExplicitType(this, "symbol", true);
        enumBody(this, node);
      }
      function EnumDefaultedMember(node) {
        const {
          id
        } = node;
        this.print(id, node);
        this.tokenChar(44);
      }
      function enumInitializedMember(context, node) {
        const {
          id,
          init
        } = node;
        context.print(id, node);
        context.space();
        context.token("=");
        context.space();
        context.print(init, node);
        context.token(",");
      }
      function EnumBooleanMember(node) {
        enumInitializedMember(this, node);
      }
      function EnumNumberMember(node) {
        enumInitializedMember(this, node);
      }
      function EnumStringMember(node) {
        enumInitializedMember(this, node);
      }
      function FlowExportDeclaration(node) {
        if (node.declaration) {
          const declar = node.declaration;
          this.print(declar, node);
          if (!isStatement(declar))
            this.semicolon();
        } else {
          this.tokenChar(123);
          if (node.specifiers.length) {
            this.space();
            this.printList(node.specifiers, node);
            this.space();
          }
          this.tokenChar(125);
          if (node.source) {
            this.space();
            this.word("from");
            this.space();
            this.print(node.source, node);
          }
          this.semicolon();
        }
      }
      function ExistsTypeAnnotation() {
        this.tokenChar(42);
      }
      function FunctionTypeAnnotation(node, parent) {
        this.print(node.typeParameters, node);
        this.tokenChar(40);
        if (node.this) {
          this.word("this");
          this.tokenChar(58);
          this.space();
          this.print(node.this.typeAnnotation, node);
          if (node.params.length || node.rest) {
            this.tokenChar(44);
            this.space();
          }
        }
        this.printList(node.params, node);
        if (node.rest) {
          if (node.params.length) {
            this.tokenChar(44);
            this.space();
          }
          this.token("...");
          this.print(node.rest, node);
        }
        this.tokenChar(41);
        if (parent && (parent.type === "ObjectTypeCallProperty" || parent.type === "ObjectTypeInternalSlot" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method)) {
          this.tokenChar(58);
        } else {
          this.space();
          this.token("=>");
        }
        this.space();
        this.print(node.returnType, node);
      }
      function FunctionTypeParam(node) {
        this.print(node.name, node);
        if (node.optional)
          this.tokenChar(63);
        if (node.name) {
          this.tokenChar(58);
          this.space();
        }
        this.print(node.typeAnnotation, node);
      }
      function InterfaceExtends(node) {
        this.print(node.id, node);
        this.print(node.typeParameters, node, true);
      }
      function _interfaceish(node) {
        var _node$extends;
        this.print(node.id, node);
        this.print(node.typeParameters, node);
        if ((_node$extends = node.extends) != null && _node$extends.length) {
          this.space();
          this.word("extends");
          this.space();
          this.printList(node.extends, node);
        }
        if (node.mixins && node.mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node.mixins, node);
        }
        if (node.implements && node.implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node.implements, node);
        }
        this.space();
        this.print(node.body, node);
      }
      function _variance(node) {
        if (node.variance) {
          if (node.variance.kind === "plus") {
            this.tokenChar(43);
          } else if (node.variance.kind === "minus") {
            this.tokenChar(45);
          }
        }
      }
      function InterfaceDeclaration(node) {
        this.word("interface");
        this.space();
        this._interfaceish(node);
      }
      function andSeparator() {
        this.space();
        this.tokenChar(38);
        this.space();
      }
      function InterfaceTypeAnnotation(node) {
        this.word("interface");
        if (node.extends && node.extends.length) {
          this.space();
          this.word("extends");
          this.space();
          this.printList(node.extends, node);
        }
        this.space();
        this.print(node.body, node);
      }
      function IntersectionTypeAnnotation(node) {
        this.printJoin(node.types, node, {
          separator: andSeparator
        });
      }
      function MixedTypeAnnotation() {
        this.word("mixed");
      }
      function EmptyTypeAnnotation() {
        this.word("empty");
      }
      function NullableTypeAnnotation(node) {
        this.tokenChar(63);
        this.print(node.typeAnnotation, node);
      }
      function NumberTypeAnnotation() {
        this.word("number");
      }
      function StringTypeAnnotation() {
        this.word("string");
      }
      function ThisTypeAnnotation() {
        this.word("this");
      }
      function TupleTypeAnnotation(node) {
        this.tokenChar(91);
        this.printList(node.types, node);
        this.tokenChar(93);
      }
      function TypeofTypeAnnotation(node) {
        this.word("typeof");
        this.space();
        this.print(node.argument, node);
      }
      function TypeAlias(node) {
        this.word("type");
        this.space();
        this.print(node.id, node);
        this.print(node.typeParameters, node);
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.right, node);
        this.semicolon();
      }
      function TypeAnnotation(node) {
        this.tokenChar(58);
        this.space();
        if (node.optional)
          this.tokenChar(63);
        this.print(node.typeAnnotation, node);
      }
      function TypeParameterInstantiation(node) {
        this.tokenChar(60);
        this.printList(node.params, node, {});
        this.tokenChar(62);
      }
      function TypeParameter(node) {
        this._variance(node);
        this.word(node.name);
        if (node.bound) {
          this.print(node.bound, node);
        }
        if (node.default) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.default, node);
        }
      }
      function OpaqueType(node) {
        this.word("opaque");
        this.space();
        this.word("type");
        this.space();
        this.print(node.id, node);
        this.print(node.typeParameters, node);
        if (node.supertype) {
          this.tokenChar(58);
          this.space();
          this.print(node.supertype, node);
        }
        if (node.impltype) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.impltype, node);
        }
        this.semicolon();
      }
      function ObjectTypeAnnotation(node) {
        if (node.exact) {
          this.token("{|");
        } else {
          this.tokenChar(123);
        }
        const props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
        if (props.length) {
          this.newline();
          this.space();
          this.printJoin(props, node, {
            addNewlines(leading) {
              if (leading && !props[0])
                return 1;
            },
            indent: true,
            statement: true,
            iterator: () => {
              if (props.length !== 1 || node.inexact) {
                this.tokenChar(44);
                this.space();
              }
            }
          });
          this.space();
        }
        if (node.inexact) {
          this.indent();
          this.token("...");
          if (props.length) {
            this.newline();
          }
          this.dedent();
        }
        if (node.exact) {
          this.token("|}");
        } else {
          this.tokenChar(125);
        }
      }
      function ObjectTypeInternalSlot(node) {
        if (node.static) {
          this.word("static");
          this.space();
        }
        this.tokenChar(91);
        this.tokenChar(91);
        this.print(node.id, node);
        this.tokenChar(93);
        this.tokenChar(93);
        if (node.optional)
          this.tokenChar(63);
        if (!node.method) {
          this.tokenChar(58);
          this.space();
        }
        this.print(node.value, node);
      }
      function ObjectTypeCallProperty(node) {
        if (node.static) {
          this.word("static");
          this.space();
        }
        this.print(node.value, node);
      }
      function ObjectTypeIndexer(node) {
        if (node.static) {
          this.word("static");
          this.space();
        }
        this._variance(node);
        this.tokenChar(91);
        if (node.id) {
          this.print(node.id, node);
          this.tokenChar(58);
          this.space();
        }
        this.print(node.key, node);
        this.tokenChar(93);
        this.tokenChar(58);
        this.space();
        this.print(node.value, node);
      }
      function ObjectTypeProperty(node) {
        if (node.proto) {
          this.word("proto");
          this.space();
        }
        if (node.static) {
          this.word("static");
          this.space();
        }
        if (node.kind === "get" || node.kind === "set") {
          this.word(node.kind);
          this.space();
        }
        this._variance(node);
        this.print(node.key, node);
        if (node.optional)
          this.tokenChar(63);
        if (!node.method) {
          this.tokenChar(58);
          this.space();
        }
        this.print(node.value, node);
      }
      function ObjectTypeSpreadProperty(node) {
        this.token("...");
        this.print(node.argument, node);
      }
      function QualifiedTypeIdentifier(node) {
        this.print(node.qualification, node);
        this.tokenChar(46);
        this.print(node.id, node);
      }
      function SymbolTypeAnnotation() {
        this.word("symbol");
      }
      function orSeparator() {
        this.space();
        this.tokenChar(124);
        this.space();
      }
      function UnionTypeAnnotation(node) {
        this.printJoin(node.types, node, {
          separator: orSeparator
        });
      }
      function TypeCastExpression(node) {
        this.tokenChar(40);
        this.print(node.expression, node);
        this.print(node.typeAnnotation, node);
        this.tokenChar(41);
      }
      function Variance(node) {
        if (node.kind === "plus") {
          this.tokenChar(43);
        } else {
          this.tokenChar(45);
        }
      }
      function VoidTypeAnnotation() {
        this.word("void");
      }
      function IndexedAccessType(node) {
        this.print(node.objectType, node, true);
        this.tokenChar(91);
        this.print(node.indexType, node);
        this.tokenChar(93);
      }
      function OptionalIndexedAccessType(node) {
        this.print(node.objectType, node);
        if (node.optional) {
          this.token("?.");
        }
        this.tokenChar(91);
        this.print(node.indexType, node);
        this.tokenChar(93);
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/base.js
  var require_base = __commonJS({
    "node_modules/@babel/generator/lib/generators/base.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BlockStatement = BlockStatement;
      exports.Directive = Directive;
      exports.DirectiveLiteral = DirectiveLiteral;
      exports.File = File;
      exports.InterpreterDirective = InterpreterDirective;
      exports.Placeholder = Placeholder;
      exports.Program = Program;
      function File(node) {
        if (node.program) {
          this.print(node.program.interpreter, node);
        }
        this.print(node.program, node);
      }
      function Program(node) {
        var _node$directives;
        this.noIndentInnerCommentsHere();
        this.printInnerComments();
        const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
        if (directivesLen) {
          var _node$directives$trai;
          const newline = node.body.length ? 2 : 1;
          this.printSequence(node.directives, node, {
            trailingCommentsLineOffset: newline
          });
          if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
            this.newline(newline);
          }
        }
        this.printSequence(node.body, node);
      }
      function BlockStatement(node) {
        var _node$directives2;
        this.tokenChar(123);
        const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;
        if (directivesLen) {
          var _node$directives$trai2;
          const newline = node.body.length ? 2 : 1;
          this.printSequence(node.directives, node, {
            indent: true,
            trailingCommentsLineOffset: newline
          });
          if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
            this.newline(newline);
          }
        }
        this.printSequence(node.body, node, {
          indent: true
        });
        this.sourceWithOffset("end", node.loc, 0, -1);
        this.rightBrace();
      }
      function Directive(node) {
        this.print(node.value, node);
        this.semicolon();
      }
      var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
      var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
      function DirectiveLiteral(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && raw !== void 0) {
          this.token(raw);
          return;
        }
        const {
          value
        } = node;
        if (!unescapedDoubleQuoteRE.test(value)) {
          this.token(`"${value}"`);
        } else if (!unescapedSingleQuoteRE.test(value)) {
          this.token(`'${value}'`);
        } else {
          throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
        }
      }
      function InterpreterDirective(node) {
        this.token(`#!${node.value}`);
        this.newline(1, true);
      }
      function Placeholder(node) {
        this.token("%%");
        this.print(node.name);
        this.token("%%");
        if (node.expectedNode === "Statement") {
          this.semicolon();
        }
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/jsx.js
  var require_jsx2 = __commonJS({
    "node_modules/@babel/generator/lib/generators/jsx.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.JSXAttribute = JSXAttribute;
      exports.JSXClosingElement = JSXClosingElement;
      exports.JSXClosingFragment = JSXClosingFragment;
      exports.JSXElement = JSXElement;
      exports.JSXEmptyExpression = JSXEmptyExpression;
      exports.JSXExpressionContainer = JSXExpressionContainer;
      exports.JSXFragment = JSXFragment;
      exports.JSXIdentifier = JSXIdentifier;
      exports.JSXMemberExpression = JSXMemberExpression;
      exports.JSXNamespacedName = JSXNamespacedName;
      exports.JSXOpeningElement = JSXOpeningElement;
      exports.JSXOpeningFragment = JSXOpeningFragment;
      exports.JSXSpreadAttribute = JSXSpreadAttribute;
      exports.JSXSpreadChild = JSXSpreadChild;
      exports.JSXText = JSXText;
      function JSXAttribute(node) {
        this.print(node.name, node);
        if (node.value) {
          this.tokenChar(61);
          this.print(node.value, node);
        }
      }
      function JSXIdentifier(node) {
        this.word(node.name);
      }
      function JSXNamespacedName(node) {
        this.print(node.namespace, node);
        this.tokenChar(58);
        this.print(node.name, node);
      }
      function JSXMemberExpression(node) {
        this.print(node.object, node);
        this.tokenChar(46);
        this.print(node.property, node);
      }
      function JSXSpreadAttribute(node) {
        this.tokenChar(123);
        this.token("...");
        this.print(node.argument, node);
        this.tokenChar(125);
      }
      function JSXExpressionContainer(node) {
        this.tokenChar(123);
        this.print(node.expression, node);
        this.tokenChar(125);
      }
      function JSXSpreadChild(node) {
        this.tokenChar(123);
        this.token("...");
        this.print(node.expression, node);
        this.tokenChar(125);
      }
      function JSXText(node) {
        const raw = this.getPossibleRaw(node);
        if (raw !== void 0) {
          this.token(raw, true);
        } else {
          this.token(node.value, true);
        }
      }
      function JSXElement(node) {
        const open = node.openingElement;
        this.print(open, node);
        if (open.selfClosing)
          return;
        this.indent();
        for (const child of node.children) {
          this.print(child, node);
        }
        this.dedent();
        this.print(node.closingElement, node);
      }
      function spaceSeparator() {
        this.space();
      }
      function JSXOpeningElement(node) {
        this.tokenChar(60);
        this.print(node.name, node);
        this.print(node.typeParameters, node);
        if (node.attributes.length > 0) {
          this.space();
          this.printJoin(node.attributes, node, {
            separator: spaceSeparator
          });
        }
        if (node.selfClosing) {
          this.space();
          this.token("/>");
        } else {
          this.tokenChar(62);
        }
      }
      function JSXClosingElement(node) {
        this.token("</");
        this.print(node.name, node);
        this.tokenChar(62);
      }
      function JSXEmptyExpression() {
        this.printInnerComments();
      }
      function JSXFragment(node) {
        this.print(node.openingFragment, node);
        this.indent();
        for (const child of node.children) {
          this.print(child, node);
        }
        this.dedent();
        this.print(node.closingFragment, node);
      }
      function JSXOpeningFragment() {
        this.tokenChar(60);
        this.tokenChar(62);
      }
      function JSXClosingFragment() {
        this.token("</");
        this.tokenChar(62);
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/typescript.js
  var require_typescript2 = __commonJS({
    "node_modules/@babel/generator/lib/generators/typescript.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TSAnyKeyword = TSAnyKeyword;
      exports.TSArrayType = TSArrayType;
      exports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;
      exports.TSBigIntKeyword = TSBigIntKeyword;
      exports.TSBooleanKeyword = TSBooleanKeyword;
      exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
      exports.TSConditionalType = TSConditionalType;
      exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
      exports.TSConstructorType = TSConstructorType;
      exports.TSDeclareFunction = TSDeclareFunction;
      exports.TSDeclareMethod = TSDeclareMethod;
      exports.TSEnumDeclaration = TSEnumDeclaration;
      exports.TSEnumMember = TSEnumMember;
      exports.TSExportAssignment = TSExportAssignment;
      exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
      exports.TSExternalModuleReference = TSExternalModuleReference;
      exports.TSFunctionType = TSFunctionType;
      exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
      exports.TSImportType = TSImportType;
      exports.TSIndexSignature = TSIndexSignature;
      exports.TSIndexedAccessType = TSIndexedAccessType;
      exports.TSInferType = TSInferType;
      exports.TSInstantiationExpression = TSInstantiationExpression;
      exports.TSInterfaceBody = TSInterfaceBody;
      exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
      exports.TSIntersectionType = TSIntersectionType;
      exports.TSIntrinsicKeyword = TSIntrinsicKeyword;
      exports.TSLiteralType = TSLiteralType;
      exports.TSMappedType = TSMappedType;
      exports.TSMethodSignature = TSMethodSignature;
      exports.TSModuleBlock = TSModuleBlock;
      exports.TSModuleDeclaration = TSModuleDeclaration;
      exports.TSNamedTupleMember = TSNamedTupleMember;
      exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
      exports.TSNeverKeyword = TSNeverKeyword;
      exports.TSNonNullExpression = TSNonNullExpression;
      exports.TSNullKeyword = TSNullKeyword;
      exports.TSNumberKeyword = TSNumberKeyword;
      exports.TSObjectKeyword = TSObjectKeyword;
      exports.TSOptionalType = TSOptionalType;
      exports.TSParameterProperty = TSParameterProperty;
      exports.TSParenthesizedType = TSParenthesizedType;
      exports.TSPropertySignature = TSPropertySignature;
      exports.TSQualifiedName = TSQualifiedName;
      exports.TSRestType = TSRestType;
      exports.TSStringKeyword = TSStringKeyword;
      exports.TSSymbolKeyword = TSSymbolKeyword;
      exports.TSThisType = TSThisType;
      exports.TSTupleType = TSTupleType;
      exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
      exports.TSTypeAnnotation = TSTypeAnnotation;
      exports.TSTypeAssertion = TSTypeAssertion;
      exports.TSTypeLiteral = TSTypeLiteral;
      exports.TSTypeOperator = TSTypeOperator;
      exports.TSTypeParameter = TSTypeParameter;
      exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
      exports.TSTypePredicate = TSTypePredicate;
      exports.TSTypeQuery = TSTypeQuery;
      exports.TSTypeReference = TSTypeReference;
      exports.TSUndefinedKeyword = TSUndefinedKeyword;
      exports.TSUnionType = TSUnionType;
      exports.TSUnknownKeyword = TSUnknownKeyword;
      exports.TSVoidKeyword = TSVoidKeyword;
      exports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
      exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
      exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
      exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
      exports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
      function TSTypeAnnotation(node) {
        this.tokenChar(58);
        this.space();
        if (node.optional)
          this.tokenChar(63);
        this.print(node.typeAnnotation, node);
      }
      function TSTypeParameterInstantiation(node, parent) {
        this.tokenChar(60);
        this.printList(node.params, node, {});
        if (parent.type === "ArrowFunctionExpression" && node.params.length === 1) {
          this.tokenChar(44);
        }
        this.tokenChar(62);
      }
      function TSTypeParameter(node) {
        if (node.in) {
          this.word("in");
          this.space();
        }
        if (node.out) {
          this.word("out");
          this.space();
        }
        this.word(node.name);
        if (node.constraint) {
          this.space();
          this.word("extends");
          this.space();
          this.print(node.constraint, node);
        }
        if (node.default) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.default, node);
        }
      }
      function TSParameterProperty(node) {
        if (node.accessibility) {
          this.word(node.accessibility);
          this.space();
        }
        if (node.readonly) {
          this.word("readonly");
          this.space();
        }
        this._param(node.parameter);
      }
      function TSDeclareFunction(node) {
        if (node.declare) {
          this.word("declare");
          this.space();
        }
        this._functionHead(node);
        this.tokenChar(59);
      }
      function TSDeclareMethod(node) {
        this._classMethodHead(node);
        this.tokenChar(59);
      }
      function TSQualifiedName(node) {
        this.print(node.left, node);
        this.tokenChar(46);
        this.print(node.right, node);
      }
      function TSCallSignatureDeclaration(node) {
        this.tsPrintSignatureDeclarationBase(node);
        this.tokenChar(59);
      }
      function TSConstructSignatureDeclaration(node) {
        this.word("new");
        this.space();
        this.tsPrintSignatureDeclarationBase(node);
        this.tokenChar(59);
      }
      function TSPropertySignature(node) {
        const {
          readonly,
          initializer
        } = node;
        if (readonly) {
          this.word("readonly");
          this.space();
        }
        this.tsPrintPropertyOrMethodName(node);
        this.print(node.typeAnnotation, node);
        if (initializer) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(initializer, node);
        }
        this.tokenChar(59);
      }
      function tsPrintPropertyOrMethodName(node) {
        if (node.computed) {
          this.tokenChar(91);
        }
        this.print(node.key, node);
        if (node.computed) {
          this.tokenChar(93);
        }
        if (node.optional) {
          this.tokenChar(63);
        }
      }
      function TSMethodSignature(node) {
        const {
          kind
        } = node;
        if (kind === "set" || kind === "get") {
          this.word(kind);
          this.space();
        }
        this.tsPrintPropertyOrMethodName(node);
        this.tsPrintSignatureDeclarationBase(node);
        this.tokenChar(59);
      }
      function TSIndexSignature(node) {
        const {
          readonly,
          static: isStatic
        } = node;
        if (isStatic) {
          this.word("static");
          this.space();
        }
        if (readonly) {
          this.word("readonly");
          this.space();
        }
        this.tokenChar(91);
        this._parameters(node.parameters, node);
        this.tokenChar(93);
        this.print(node.typeAnnotation, node);
        this.tokenChar(59);
      }
      function TSAnyKeyword() {
        this.word("any");
      }
      function TSBigIntKeyword() {
        this.word("bigint");
      }
      function TSUnknownKeyword() {
        this.word("unknown");
      }
      function TSNumberKeyword() {
        this.word("number");
      }
      function TSObjectKeyword() {
        this.word("object");
      }
      function TSBooleanKeyword() {
        this.word("boolean");
      }
      function TSStringKeyword() {
        this.word("string");
      }
      function TSSymbolKeyword() {
        this.word("symbol");
      }
      function TSVoidKeyword() {
        this.word("void");
      }
      function TSUndefinedKeyword() {
        this.word("undefined");
      }
      function TSNullKeyword() {
        this.word("null");
      }
      function TSNeverKeyword() {
        this.word("never");
      }
      function TSIntrinsicKeyword() {
        this.word("intrinsic");
      }
      function TSThisType() {
        this.word("this");
      }
      function TSFunctionType(node) {
        this.tsPrintFunctionOrConstructorType(node);
      }
      function TSConstructorType(node) {
        if (node.abstract) {
          this.word("abstract");
          this.space();
        }
        this.word("new");
        this.space();
        this.tsPrintFunctionOrConstructorType(node);
      }
      function tsPrintFunctionOrConstructorType(node) {
        const {
          typeParameters
        } = node;
        const parameters = node.parameters;
        this.print(typeParameters, node);
        this.tokenChar(40);
        this._parameters(parameters, node);
        this.tokenChar(41);
        this.space();
        this.token("=>");
        this.space();
        const returnType = node.typeAnnotation;
        this.print(returnType.typeAnnotation, node);
      }
      function TSTypeReference(node) {
        this.print(node.typeName, node, true);
        this.print(node.typeParameters, node, true);
      }
      function TSTypePredicate(node) {
        if (node.asserts) {
          this.word("asserts");
          this.space();
        }
        this.print(node.parameterName);
        if (node.typeAnnotation) {
          this.space();
          this.word("is");
          this.space();
          this.print(node.typeAnnotation.typeAnnotation);
        }
      }
      function TSTypeQuery(node) {
        this.word("typeof");
        this.space();
        this.print(node.exprName);
        if (node.typeParameters) {
          this.print(node.typeParameters, node);
        }
      }
      function TSTypeLiteral(node) {
        this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
      }
      function tsPrintTypeLiteralOrInterfaceBody(members, node) {
        tsPrintBraced(this, members, node);
      }
      function tsPrintBraced(printer, members, node) {
        printer.token("{");
        if (members.length) {
          printer.indent();
          printer.newline();
          for (const member of members) {
            printer.print(member, node);
            printer.newline();
          }
          printer.dedent();
        }
        printer.sourceWithOffset("end", node.loc, 0, -1);
        printer.rightBrace();
      }
      function TSArrayType(node) {
        this.print(node.elementType, node, true);
        this.token("[]");
      }
      function TSTupleType(node) {
        this.tokenChar(91);
        this.printList(node.elementTypes, node);
        this.tokenChar(93);
      }
      function TSOptionalType(node) {
        this.print(node.typeAnnotation, node);
        this.tokenChar(63);
      }
      function TSRestType(node) {
        this.token("...");
        this.print(node.typeAnnotation, node);
      }
      function TSNamedTupleMember(node) {
        this.print(node.label, node);
        if (node.optional)
          this.tokenChar(63);
        this.tokenChar(58);
        this.space();
        this.print(node.elementType, node);
      }
      function TSUnionType(node) {
        tsPrintUnionOrIntersectionType(this, node, "|");
      }
      function TSIntersectionType(node) {
        tsPrintUnionOrIntersectionType(this, node, "&");
      }
      function tsPrintUnionOrIntersectionType(printer, node, sep) {
        printer.printJoin(node.types, node, {
          separator() {
            this.space();
            this.token(sep);
            this.space();
          }
        });
      }
      function TSConditionalType(node) {
        this.print(node.checkType);
        this.space();
        this.word("extends");
        this.space();
        this.print(node.extendsType);
        this.space();
        this.tokenChar(63);
        this.space();
        this.print(node.trueType);
        this.space();
        this.tokenChar(58);
        this.space();
        this.print(node.falseType);
      }
      function TSInferType(node) {
        this.token("infer");
        this.space();
        this.print(node.typeParameter);
      }
      function TSParenthesizedType(node) {
        this.tokenChar(40);
        this.print(node.typeAnnotation, node);
        this.tokenChar(41);
      }
      function TSTypeOperator(node) {
        this.word(node.operator);
        this.space();
        this.print(node.typeAnnotation, node);
      }
      function TSIndexedAccessType(node) {
        this.print(node.objectType, node, true);
        this.tokenChar(91);
        this.print(node.indexType, node);
        this.tokenChar(93);
      }
      function TSMappedType(node) {
        const {
          nameType,
          optional,
          readonly,
          typeParameter
        } = node;
        this.tokenChar(123);
        this.space();
        if (readonly) {
          tokenIfPlusMinus(this, readonly);
          this.word("readonly");
          this.space();
        }
        this.tokenChar(91);
        this.word(typeParameter.name);
        this.space();
        this.word("in");
        this.space();
        this.print(typeParameter.constraint, typeParameter);
        if (nameType) {
          this.space();
          this.word("as");
          this.space();
          this.print(nameType, node);
        }
        this.tokenChar(93);
        if (optional) {
          tokenIfPlusMinus(this, optional);
          this.tokenChar(63);
        }
        this.tokenChar(58);
        this.space();
        this.print(node.typeAnnotation, node);
        this.space();
        this.tokenChar(125);
      }
      function tokenIfPlusMinus(self2, tok) {
        if (tok !== true) {
          self2.token(tok);
        }
      }
      function TSLiteralType(node) {
        this.print(node.literal, node);
      }
      function TSExpressionWithTypeArguments(node) {
        this.print(node.expression, node);
        this.print(node.typeParameters, node);
      }
      function TSInterfaceDeclaration(node) {
        const {
          declare,
          id,
          typeParameters,
          extends: extendz,
          body
        } = node;
        if (declare) {
          this.word("declare");
          this.space();
        }
        this.word("interface");
        this.space();
        this.print(id, node);
        this.print(typeParameters, node);
        if (extendz != null && extendz.length) {
          this.space();
          this.word("extends");
          this.space();
          this.printList(extendz, node);
        }
        this.space();
        this.print(body, node);
      }
      function TSInterfaceBody(node) {
        this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
      }
      function TSTypeAliasDeclaration(node) {
        const {
          declare,
          id,
          typeParameters,
          typeAnnotation
        } = node;
        if (declare) {
          this.word("declare");
          this.space();
        }
        this.word("type");
        this.space();
        this.print(id, node);
        this.print(typeParameters, node);
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(typeAnnotation, node);
        this.tokenChar(59);
      }
      function TSTypeExpression(node) {
        var _expression$trailingC;
        const {
          type,
          expression,
          typeAnnotation
        } = node;
        const forceParens = !!((_expression$trailingC = expression.trailingComments) != null && _expression$trailingC.length);
        this.print(expression, node, true, void 0, forceParens);
        this.space();
        this.word(type === "TSAsExpression" ? "as" : "satisfies");
        this.space();
        this.print(typeAnnotation, node);
      }
      function TSTypeAssertion(node) {
        const {
          typeAnnotation,
          expression
        } = node;
        this.tokenChar(60);
        this.print(typeAnnotation, node);
        this.tokenChar(62);
        this.space();
        this.print(expression, node);
      }
      function TSInstantiationExpression(node) {
        this.print(node.expression, node);
        this.print(node.typeParameters, node);
      }
      function TSEnumDeclaration(node) {
        const {
          declare,
          const: isConst,
          id,
          members
        } = node;
        if (declare) {
          this.word("declare");
          this.space();
        }
        if (isConst) {
          this.word("const");
          this.space();
        }
        this.word("enum");
        this.space();
        this.print(id, node);
        this.space();
        tsPrintBraced(this, members, node);
      }
      function TSEnumMember(node) {
        const {
          id,
          initializer
        } = node;
        this.print(id, node);
        if (initializer) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(initializer, node);
        }
        this.tokenChar(44);
      }
      function TSModuleDeclaration(node) {
        const {
          declare,
          id
        } = node;
        if (declare) {
          this.word("declare");
          this.space();
        }
        if (!node.global) {
          this.word(id.type === "Identifier" ? "namespace" : "module");
          this.space();
        }
        this.print(id, node);
        if (!node.body) {
          this.tokenChar(59);
          return;
        }
        let body = node.body;
        while (body.type === "TSModuleDeclaration") {
          this.tokenChar(46);
          this.print(body.id, body);
          body = body.body;
        }
        this.space();
        this.print(body, node);
      }
      function TSModuleBlock(node) {
        tsPrintBraced(this, node.body, node);
      }
      function TSImportType(node) {
        const {
          argument,
          qualifier,
          typeParameters
        } = node;
        this.word("import");
        this.tokenChar(40);
        this.print(argument, node);
        this.tokenChar(41);
        if (qualifier) {
          this.tokenChar(46);
          this.print(qualifier, node);
        }
        if (typeParameters) {
          this.print(typeParameters, node);
        }
      }
      function TSImportEqualsDeclaration(node) {
        const {
          isExport,
          id,
          moduleReference
        } = node;
        if (isExport) {
          this.word("export");
          this.space();
        }
        this.word("import");
        this.space();
        this.print(id, node);
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(moduleReference, node);
        this.tokenChar(59);
      }
      function TSExternalModuleReference(node) {
        this.token("require(");
        this.print(node.expression, node);
        this.tokenChar(41);
      }
      function TSNonNullExpression(node) {
        this.print(node.expression, node);
        this.tokenChar(33);
      }
      function TSExportAssignment(node) {
        this.word("export");
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.expression, node);
        this.tokenChar(59);
      }
      function TSNamespaceExportDeclaration(node) {
        this.word("export");
        this.space();
        this.word("as");
        this.space();
        this.word("namespace");
        this.space();
        this.print(node.id, node);
      }
      function tsPrintSignatureDeclarationBase(node) {
        const {
          typeParameters
        } = node;
        const parameters = node.parameters;
        this.print(typeParameters, node);
        this.tokenChar(40);
        this._parameters(parameters, node);
        this.tokenChar(41);
        const returnType = node.typeAnnotation;
        this.print(returnType, node);
      }
      function tsPrintClassMemberModifiers(node) {
        const isField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
        if (isField && node.declare) {
          this.word("declare");
          this.space();
        }
        if (node.accessibility) {
          this.word(node.accessibility);
          this.space();
        }
        if (node.static) {
          this.word("static");
          this.space();
        }
        if (node.override) {
          this.word("override");
          this.space();
        }
        if (node.abstract) {
          this.word("abstract");
          this.space();
        }
        if (isField && node.readonly) {
          this.word("readonly");
          this.space();
        }
      }
    }
  });

  // node_modules/@babel/generator/lib/generators/index.js
  var require_generators = __commonJS({
    "node_modules/@babel/generator/lib/generators/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _templateLiterals = require_template_literals();
      Object.keys(_templateLiterals).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _templateLiterals[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _templateLiterals[key];
          }
        });
      });
      var _expressions = require_expressions();
      Object.keys(_expressions).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _expressions[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _expressions[key];
          }
        });
      });
      var _statements = require_statements();
      Object.keys(_statements).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _statements[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _statements[key];
          }
        });
      });
      var _classes = require_classes();
      Object.keys(_classes).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _classes[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _classes[key];
          }
        });
      });
      var _methods = require_methods();
      Object.keys(_methods).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _methods[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _methods[key];
          }
        });
      });
      var _modules = require_modules();
      Object.keys(_modules).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _modules[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _modules[key];
          }
        });
      });
      var _types = require_types();
      Object.keys(_types).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _types[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _types[key];
          }
        });
      });
      var _flow = require_flow2();
      Object.keys(_flow).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _flow[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _flow[key];
          }
        });
      });
      var _base = require_base();
      Object.keys(_base).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _base[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _base[key];
          }
        });
      });
      var _jsx = require_jsx2();
      Object.keys(_jsx).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _jsx[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _jsx[key];
          }
        });
      });
      var _typescript = require_typescript2();
      Object.keys(_typescript).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _typescript[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _typescript[key];
          }
        });
      });
    }
  });

  // node_modules/@babel/generator/lib/printer.js
  var require_printer = __commonJS({
    "node_modules/@babel/generator/lib/printer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _buffer = require_buffer2();
      var n = require_node();
      var _t = require_lib4();
      var generatorFunctions = require_generators();
      var {
        isFunction,
        isStatement,
        isClassBody,
        isTSInterfaceBody,
        isTSEnumDeclaration
      } = _t;
      var SCIENTIFIC_NOTATION = /e/i;
      var ZERO_DECIMAL_INTEGER = /\.0+$/;
      var NON_DECIMAL_LITERAL = /^0[box]/;
      var PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;
      var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
      var HAS_BlOCK_COMMENT_END = /\*\//;
      var {
        needsParens
      } = n;
      var Printer = class {
        constructor(format2, map) {
          this.inForStatementInitCounter = 0;
          this._printStack = [];
          this._indent = 0;
          this._indentChar = 0;
          this._indentRepeat = 0;
          this._insideAux = false;
          this._parenPushNewlineState = null;
          this._noLineTerminator = false;
          this._printAuxAfterOnNextUserNode = false;
          this._printedComments = /* @__PURE__ */ new Set();
          this._endsWithInteger = false;
          this._endsWithWord = false;
          this._lastCommentLine = 0;
          this._endsWithInnerRaw = false;
          this._indentInnerComments = true;
          this.format = format2;
          this._buf = new _buffer.default(map);
          this._indentChar = format2.indent.style.charCodeAt(0);
          this._indentRepeat = format2.indent.style.length;
        }
        generate(ast) {
          this.print(ast);
          this._maybeAddAuxComment();
          return this._buf.get();
        }
        indent() {
          if (this.format.compact || this.format.concise)
            return;
          this._indent++;
        }
        dedent() {
          if (this.format.compact || this.format.concise)
            return;
          this._indent--;
        }
        semicolon(force = false) {
          this._maybeAddAuxComment();
          if (force) {
            this._appendChar(59);
          } else {
            this._queue(59);
          }
          this._noLineTerminator = false;
        }
        rightBrace() {
          if (this.format.minified) {
            this._buf.removeLastSemicolon();
          }
          this.tokenChar(125);
        }
        space(force = false) {
          if (this.format.compact)
            return;
          if (force) {
            this._space();
          } else if (this._buf.hasContent()) {
            const lastCp = this.getLastChar();
            if (lastCp !== 32 && lastCp !== 10) {
              this._space();
            }
          }
        }
        word(str, noLineTerminatorAfter = false) {
          this._maybePrintInnerComments();
          if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {
            this._space();
          }
          this._maybeAddAuxComment();
          this._append(str, false);
          this._endsWithWord = true;
          this._noLineTerminator = noLineTerminatorAfter;
        }
        number(str) {
          this.word(str);
          this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
        }
        token(str, maybeNewline = false) {
          this._maybePrintInnerComments();
          const lastChar = this.getLastChar();
          const strFirst = str.charCodeAt(0);
          if (lastChar === 33 && str === "--" || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
            this._space();
          }
          this._maybeAddAuxComment();
          this._append(str, maybeNewline);
          this._noLineTerminator = false;
        }
        tokenChar(char) {
          this._maybePrintInnerComments();
          const lastChar = this.getLastChar();
          if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
            this._space();
          }
          this._maybeAddAuxComment();
          this._appendChar(char);
          this._noLineTerminator = false;
        }
        newline(i = 1, force) {
          if (i <= 0)
            return;
          if (!force) {
            if (this.format.retainLines || this.format.compact)
              return;
            if (this.format.concise) {
              this.space();
              return;
            }
          }
          if (i > 2)
            i = 2;
          i -= this._buf.getNewlineCount();
          for (let j = 0; j < i; j++) {
            this._newline();
          }
          return;
        }
        endsWith(char) {
          return this.getLastChar() === char;
        }
        getLastChar() {
          return this._buf.getLastChar();
        }
        endsWithCharAndNewline() {
          return this._buf.endsWithCharAndNewline();
        }
        removeTrailingNewline() {
          this._buf.removeTrailingNewline();
        }
        exactSource(loc, cb) {
          if (!loc)
            return cb();
          this._catchUp("start", loc);
          this._buf.exactSource(loc, cb);
        }
        source(prop, loc) {
          if (!loc)
            return;
          this._catchUp(prop, loc);
          this._buf.source(prop, loc);
        }
        sourceWithOffset(prop, loc, lineOffset, columnOffset) {
          if (!loc)
            return;
          this._catchUp(prop, loc);
          this._buf.sourceWithOffset(prop, loc, lineOffset, columnOffset);
        }
        withSource(prop, loc, cb) {
          if (!loc)
            return cb();
          this._catchUp(prop, loc);
          this._buf.withSource(prop, loc, cb);
        }
        _space() {
          this._queue(32);
        }
        _newline() {
          this._queue(10);
        }
        _append(str, maybeNewline) {
          this._maybeAddParen(str);
          this._maybeIndent(str.charCodeAt(0));
          this._buf.append(str, maybeNewline);
          this._endsWithWord = false;
          this._endsWithInteger = false;
        }
        _appendChar(char) {
          this._maybeAddParenChar(char);
          this._maybeIndent(char);
          this._buf.appendChar(char);
          this._endsWithWord = false;
          this._endsWithInteger = false;
        }
        _queue(char) {
          this._maybeAddParenChar(char);
          this._maybeIndent(char);
          this._buf.queue(char);
          this._endsWithWord = false;
          this._endsWithInteger = false;
        }
        _maybeIndent(firstChar) {
          if (this._indent && firstChar !== 10 && this.endsWith(10)) {
            this._buf.queueIndentation(this._indentChar, this._getIndent());
          }
        }
        _shouldIndent(firstChar) {
          if (this._indent && firstChar !== 10 && this.endsWith(10)) {
            return true;
          }
        }
        _maybeAddParenChar(char) {
          const parenPushNewlineState = this._parenPushNewlineState;
          if (!parenPushNewlineState)
            return;
          if (char === 32) {
            return;
          }
          if (char !== 10) {
            this._parenPushNewlineState = null;
            return;
          }
          this.tokenChar(40);
          this.indent();
          parenPushNewlineState.printed = true;
        }
        _maybeAddParen(str) {
          const parenPushNewlineState = this._parenPushNewlineState;
          if (!parenPushNewlineState)
            return;
          const len = str.length;
          let i;
          for (i = 0; i < len && str.charCodeAt(i) === 32; i++)
            continue;
          if (i === len) {
            return;
          }
          const cha = str.charCodeAt(i);
          if (cha !== 10) {
            if (cha !== 47 || i + 1 === len) {
              this._parenPushNewlineState = null;
              return;
            }
            const chaPost = str.charCodeAt(i + 1);
            if (chaPost === 42) {
              if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {
                return;
              }
            } else if (chaPost !== 47) {
              this._parenPushNewlineState = null;
              return;
            }
          }
          this.tokenChar(40);
          this.indent();
          parenPushNewlineState.printed = true;
        }
        catchUp(line) {
          if (!this.format.retainLines)
            return;
          const count = line - this._buf.getCurrentLine();
          for (let i = 0; i < count; i++) {
            this._newline();
          }
        }
        _catchUp(prop, loc) {
          if (!this.format.retainLines)
            return;
          const pos = loc ? loc[prop] : null;
          if ((pos == null ? void 0 : pos.line) != null) {
            const count = pos.line - this._buf.getCurrentLine();
            for (let i = 0; i < count; i++) {
              this._newline();
            }
          }
        }
        _getIndent() {
          return this._indentRepeat * this._indent;
        }
        printTerminatorless(node, parent, isLabel) {
          if (isLabel) {
            this._noLineTerminator = true;
            this.print(node, parent);
          } else {
            const terminatorState = {
              printed: false
            };
            this._parenPushNewlineState = terminatorState;
            this.print(node, parent);
            if (terminatorState.printed) {
              this.dedent();
              this.newline();
              this.tokenChar(41);
            }
          }
        }
        print(node, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {
          if (!node)
            return;
          this._endsWithInnerRaw = false;
          const nodeType = node.type;
          const format2 = this.format;
          const oldConcise = format2.concise;
          if (node._compact) {
            format2.concise = true;
          }
          const printMethod = this[nodeType];
          if (printMethod === void 0) {
            throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
          }
          this._printStack.push(node);
          const oldInAux = this._insideAux;
          this._insideAux = node.loc == void 0;
          this._maybeAddAuxComment(this._insideAux && !oldInAux);
          let shouldPrintParens = false;
          if (forceParens) {
            shouldPrintParens = true;
          } else if (format2.retainFunctionParens && nodeType === "FunctionExpression" && node.extra && node.extra.parenthesized) {
            shouldPrintParens = true;
          } else {
            shouldPrintParens = needsParens(node, parent, this._printStack);
          }
          if (shouldPrintParens) {
            this.tokenChar(40);
            this._endsWithInnerRaw = false;
          }
          this._lastCommentLine = 0;
          this._printLeadingComments(node, parent);
          const loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
          this.exactSource(loc, printMethod.bind(this, node, parent));
          if (shouldPrintParens) {
            this._printTrailingComments(node, parent);
            this.tokenChar(41);
            this._noLineTerminator = noLineTerminatorAfter;
          } else if (noLineTerminatorAfter && !this._noLineTerminator) {
            this._noLineTerminator = true;
            this._printTrailingComments(node, parent);
          } else {
            this._printTrailingComments(node, parent, trailingCommentsLineOffset);
          }
          this._printStack.pop();
          format2.concise = oldConcise;
          this._insideAux = oldInAux;
          this._endsWithInnerRaw = false;
        }
        _maybeAddAuxComment(enteredPositionlessNode) {
          if (enteredPositionlessNode)
            this._printAuxBeforeComment();
          if (!this._insideAux)
            this._printAuxAfterComment();
        }
        _printAuxBeforeComment() {
          if (this._printAuxAfterOnNextUserNode)
            return;
          this._printAuxAfterOnNextUserNode = true;
          const comment = this.format.auxiliaryCommentBefore;
          if (comment) {
            this._printComment({
              type: "CommentBlock",
              value: comment
            }, 0);
          }
        }
        _printAuxAfterComment() {
          if (!this._printAuxAfterOnNextUserNode)
            return;
          this._printAuxAfterOnNextUserNode = false;
          const comment = this.format.auxiliaryCommentAfter;
          if (comment) {
            this._printComment({
              type: "CommentBlock",
              value: comment
            }, 0);
          }
        }
        getPossibleRaw(node) {
          const extra = node.extra;
          if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
            return extra.raw;
          }
        }
        printJoin(nodes, parent, opts = {}) {
          if (!(nodes != null && nodes.length))
            return;
          if (opts.indent)
            this.indent();
          const newlineOpts = {
            addNewlines: opts.addNewlines,
            nextNodeStartLine: 0
          };
          const separator = opts.separator ? opts.separator.bind(this) : null;
          const len = nodes.length;
          for (let i = 0; i < len; i++) {
            const node = nodes[i];
            if (!node)
              continue;
            if (opts.statement)
              this._printNewline(i === 0, newlineOpts);
            this.print(node, parent, void 0, opts.trailingCommentsLineOffset || 0);
            opts.iterator == null ? void 0 : opts.iterator(node, i);
            if (i < len - 1)
              separator == null ? void 0 : separator();
            if (opts.statement) {
              if (i + 1 === len) {
                this.newline(1);
              } else {
                var _nextNode$loc;
                const nextNode = nodes[i + 1];
                newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
                this._printNewline(true, newlineOpts);
              }
            }
          }
          if (opts.indent)
            this.dedent();
        }
        printAndIndentOnComments(node, parent) {
          const indent = node.leadingComments && node.leadingComments.length > 0;
          if (indent)
            this.indent();
          this.print(node, parent);
          if (indent)
            this.dedent();
        }
        printBlock(parent) {
          const node = parent.body;
          if (node.type !== "EmptyStatement") {
            this.space();
          }
          this.print(node, parent);
        }
        _printTrailingComments(node, parent, lineOffset) {
          const {
            innerComments,
            trailingComments
          } = node;
          if (innerComments != null && innerComments.length) {
            this._printComments(2, innerComments, node, parent, lineOffset);
          }
          if (trailingComments != null && trailingComments.length) {
            this._printComments(2, trailingComments, node, parent, lineOffset);
          }
        }
        _printLeadingComments(node, parent) {
          const comments = node.leadingComments;
          if (!(comments != null && comments.length))
            return;
          this._printComments(0, comments, node, parent);
        }
        _maybePrintInnerComments() {
          if (this._endsWithInnerRaw)
            this.printInnerComments();
          this._endsWithInnerRaw = true;
          this._indentInnerComments = true;
        }
        printInnerComments() {
          const node = this._printStack[this._printStack.length - 1];
          const comments = node.innerComments;
          if (!(comments != null && comments.length))
            return;
          const hasSpace = this.endsWith(32);
          const indent = this._indentInnerComments;
          const printedCommentsCount = this._printedComments.size;
          if (indent)
            this.indent();
          this._printComments(1, comments, node);
          if (hasSpace && printedCommentsCount !== this._printedComments.size) {
            this.space();
          }
          if (indent)
            this.dedent();
        }
        noIndentInnerCommentsHere() {
          this._indentInnerComments = false;
        }
        printSequence(nodes, parent, opts = {}) {
          opts.statement = true;
          return this.printJoin(nodes, parent, opts);
        }
        printList(items, parent, opts = {}) {
          if (opts.separator == null) {
            opts.separator = commaSeparator;
          }
          return this.printJoin(items, parent, opts);
        }
        _printNewline(newLine, opts) {
          if (this.format.retainLines || this.format.compact)
            return;
          if (this.format.concise) {
            this.space();
            return;
          }
          if (!newLine) {
            return;
          }
          const startLine = opts.nextNodeStartLine;
          const lastCommentLine = this._lastCommentLine;
          if (startLine > 0 && lastCommentLine > 0) {
            const offset = startLine - lastCommentLine;
            if (offset >= 0) {
              this.newline(offset || 1);
              return;
            }
          }
          if (this._buf.hasContent()) {
            this.newline(1);
          }
        }
        _shouldPrintComment(comment) {
          if (comment.ignore)
            return 0;
          if (this._printedComments.has(comment))
            return 0;
          if (this._noLineTerminator && (HAS_NEWLINE.test(comment.value) || HAS_BlOCK_COMMENT_END.test(comment.value))) {
            return 2;
          }
          this._printedComments.add(comment);
          if (!this.format.shouldPrintComment(comment.value)) {
            return 0;
          }
          return 1;
        }
        _printComment(comment, skipNewLines) {
          const noLineTerminator = this._noLineTerminator;
          const isBlockComment = comment.type === "CommentBlock";
          const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
          if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
            this.newline(1);
          }
          const lastCharCode = this.getLastChar();
          if (lastCharCode !== 91 && lastCharCode !== 123) {
            this.space();
          }
          let val;
          if (isBlockComment) {
            val = `/*${comment.value}*/`;
            if (this.format.indent.adjustMultilineComment) {
              var _comment$loc;
              const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
              if (offset) {
                const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
                val = val.replace(newlineRegex, "\n");
              }
              let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
              if (this._shouldIndent(47) || this.format.retainLines) {
                indentSize += this._getIndent();
              }
              val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
            }
          } else if (!noLineTerminator) {
            val = `//${comment.value}`;
          } else {
            val = `/*${comment.value}*/`;
          }
          if (this.endsWith(47))
            this._space();
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
          if (!isBlockComment && !noLineTerminator) {
            this.newline(1, true);
          }
          if (printNewLines && skipNewLines !== 3) {
            this.newline(1);
          }
        }
        _printComments(type, comments, node, parent, lineOffset = 0) {
          const nodeLoc = node.loc;
          const len = comments.length;
          let hasLoc = !!nodeLoc;
          const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
          const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
          let lastLine = 0;
          let leadingCommentNewline = 0;
          const maybeNewline = this._noLineTerminator ? function() {
          } : this.newline.bind(this);
          for (let i = 0; i < len; i++) {
            const comment = comments[i];
            const shouldPrint = this._shouldPrintComment(comment);
            if (shouldPrint === 2) {
              hasLoc = false;
              break;
            }
            if (hasLoc && comment.loc && shouldPrint === 1) {
              const commentStartLine = comment.loc.start.line;
              const commentEndLine = comment.loc.end.line;
              if (type === 0) {
                let offset = 0;
                if (i === 0) {
                  if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine != commentEndLine)) {
                    offset = leadingCommentNewline = 1;
                  }
                } else {
                  offset = commentStartLine - lastLine;
                }
                lastLine = commentEndLine;
                maybeNewline(offset);
                this._printComment(comment, 1);
                if (i + 1 === len) {
                  maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
                  lastLine = nodeStartLine;
                }
              } else if (type === 1) {
                const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
                lastLine = commentEndLine;
                maybeNewline(offset);
                this._printComment(comment, 1);
                if (i + 1 === len) {
                  maybeNewline(Math.min(1, nodeEndLine - lastLine));
                  lastLine = nodeEndLine;
                }
              } else {
                const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
                lastLine = commentEndLine;
                maybeNewline(offset);
                this._printComment(comment, 1);
              }
            } else {
              hasLoc = false;
              if (shouldPrint !== 1) {
                continue;
              }
              if (len === 1) {
                const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
                const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);
                if (type === 0) {
                  this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                    body: node
                  }) ? 1 : 0);
                } else if (shouldSkipNewline && type === 2) {
                  this._printComment(comment, 1);
                } else {
                  this._printComment(comment, 0);
                }
              } else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") {
                this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
              } else {
                this._printComment(comment, 0);
              }
            }
          }
          if (type === 2 && hasLoc && lastLine) {
            this._lastCommentLine = lastLine;
          }
        }
      };
      Object.assign(Printer.prototype, generatorFunctions);
      {
        Printer.prototype.Noop = function Noop() {
        };
      }
      var _default = Printer;
      exports.default = _default;
      function commaSeparator() {
        this.tokenChar(44);
        this.space();
      }
    }
  });

  // node_modules/@babel/generator/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/@babel/generator/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CodeGenerator = void 0;
      exports.default = generate43;
      var _sourceMap = require_source_map();
      var _printer = require_printer();
      var Generator = class extends _printer.default {
        constructor(ast, opts = {}, code2) {
          const format2 = normalizeOptions(code2, opts);
          const map = opts.sourceMaps ? new _sourceMap.default(opts, code2) : null;
          super(format2, map);
          this.ast = void 0;
          this.ast = ast;
        }
        generate() {
          return super.generate(this.ast);
        }
      };
      function normalizeOptions(code2, opts) {
        const format2 = {
          auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
          auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
          shouldPrintComment: opts.shouldPrintComment,
          retainLines: opts.retainLines,
          retainFunctionParens: opts.retainFunctionParens,
          comments: opts.comments == null || opts.comments,
          compact: opts.compact,
          minified: opts.minified,
          concise: opts.concise,
          indent: {
            adjustMultilineComment: true,
            style: "  "
          },
          jsescOption: Object.assign({
            quotes: "double",
            wrap: true,
            minimal: false
          }, opts.jsescOption),
          recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType,
          topicToken: opts.topicToken
        };
        {
          format2.decoratorsBeforeExport = !!opts.decoratorsBeforeExport;
          format2.jsonCompatibleStrings = opts.jsonCompatibleStrings;
        }
        if (format2.minified) {
          format2.compact = true;
          format2.shouldPrintComment = format2.shouldPrintComment || (() => format2.comments);
        } else {
          format2.shouldPrintComment = format2.shouldPrintComment || ((value) => format2.comments || value.includes("@license") || value.includes("@preserve"));
        }
        if (format2.compact === "auto") {
          format2.compact = code2.length > 5e5;
          if (format2.compact) {
            console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
          }
        }
        if (format2.compact) {
          format2.indent.adjustMultilineComment = false;
        }
        const {
          auxiliaryCommentBefore,
          auxiliaryCommentAfter,
          shouldPrintComment
        } = format2;
        if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
          format2.auxiliaryCommentBefore = void 0;
        }
        if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
          format2.auxiliaryCommentAfter = void 0;
        }
        return format2;
      }
      var CodeGenerator = class {
        constructor(ast, opts, code2) {
          this._generator = void 0;
          this._generator = new Generator(ast, opts, code2);
        }
        generate() {
          return this._generator.generate();
        }
      };
      exports.CodeGenerator = CodeGenerator;
      function generate43(ast, opts, code2) {
        const gen = new Generator(ast, opts, code2);
        return gen.generate();
      }
    }
  });

  // node_modules/@babel/template/lib/formatters.js
  var require_formatters = __commonJS({
    "node_modules/@babel/template/lib/formatters.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;
      var _t = require_lib4();
      var {
        assertExpressionStatement
      } = _t;
      function makeStatementFormatter(fn) {
        return {
          code: (str) => `/* @babel/template */;
${str}`,
          validate: () => {
          },
          unwrap: (ast) => {
            return fn(ast.program.body.slice(1));
          }
        };
      }
      var smart = makeStatementFormatter((body) => {
        if (body.length > 1) {
          return body;
        } else {
          return body[0];
        }
      });
      exports.smart = smart;
      var statements = makeStatementFormatter((body) => body);
      exports.statements = statements;
      var statement = makeStatementFormatter((body) => {
        if (body.length === 0) {
          throw new Error("Found nothing to return.");
        }
        if (body.length > 1) {
          throw new Error("Found multiple statements but wanted one");
        }
        return body[0];
      });
      exports.statement = statement;
      var expression = {
        code: (str) => `(
${str}
)`,
        validate: (ast) => {
          if (ast.program.body.length > 1) {
            throw new Error("Found multiple statements but wanted one");
          }
          if (expression.unwrap(ast).start === 0) {
            throw new Error("Parse result included parens.");
          }
        },
        unwrap: ({
          program: program3
        }) => {
          const [stmt] = program3.body;
          assertExpressionStatement(stmt);
          return stmt.expression;
        }
      };
      exports.expression = expression;
      var program2 = {
        code: (str) => str,
        validate: () => {
        },
        unwrap: (ast) => ast.program
      };
      exports.program = program2;
    }
  });

  // node_modules/@babel/template/lib/options.js
  var require_options = __commonJS({
    "node_modules/@babel/template/lib/options.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.merge = merge;
      exports.normalizeReplacements = normalizeReplacements;
      exports.validate = validate;
      var _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      function merge(a, b) {
        const {
          placeholderWhitelist = a.placeholderWhitelist,
          placeholderPattern = a.placeholderPattern,
          preserveComments = a.preserveComments,
          syntacticPlaceholders = a.syntacticPlaceholders
        } = b;
        return {
          parser: Object.assign({}, a.parser, b.parser),
          placeholderWhitelist,
          placeholderPattern,
          preserveComments,
          syntacticPlaceholders
        };
      }
      function validate(opts) {
        if (opts != null && typeof opts !== "object") {
          throw new Error("Unknown template options.");
        }
        const _ref = opts || {}, {
          placeholderWhitelist,
          placeholderPattern,
          preserveComments,
          syntacticPlaceholders
        } = _ref, parser = _objectWithoutPropertiesLoose(_ref, _excluded);
        if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
          throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
        }
        if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
          throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
        }
        if (preserveComments != null && typeof preserveComments !== "boolean") {
          throw new Error("'.preserveComments' must be a boolean, null, or undefined");
        }
        if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
          throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
        }
        if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
          throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
        }
        return {
          parser,
          placeholderWhitelist: placeholderWhitelist || void 0,
          placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
          preserveComments: preserveComments == null ? void 0 : preserveComments,
          syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
        };
      }
      function normalizeReplacements(replacements) {
        if (Array.isArray(replacements)) {
          return replacements.reduce((acc, replacement, i) => {
            acc["$" + i] = replacement;
            return acc;
          }, {});
        } else if (typeof replacements === "object" || replacements == null) {
          return replacements || void 0;
        }
        throw new Error("Template replacements must be an array, object, null, or undefined");
      }
    }
  });

  // node_modules/js-tokens/index.js
  var require_js_tokens = __commonJS({
    "node_modules/js-tokens/index.js"(exports) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
      exports.matchToToken = function(match) {
        var token = { type: "invalid", value: match[0], closed: void 0 };
        if (match[1])
          token.type = "string", token.closed = !!(match[3] || match[4]);
        else if (match[5])
          token.type = "comment";
        else if (match[6])
          token.type = "comment", token.closed = !!match[7];
        else if (match[8])
          token.type = "regex";
        else if (match[9])
          token.type = "number";
        else if (match[10])
          token.type = "name";
        else if (match[11])
          token.type = "punctuator";
        else if (match[12])
          token.type = "whitespace";
        return token;
      };
    }
  });

  // node_modules/escape-string-regexp/index.js
  var require_escape_string_regexp = __commonJS({
    "node_modules/escape-string-regexp/index.js"(exports, module) {
      "use strict";
      var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
      module.exports = function(str) {
        if (typeof str !== "string") {
          throw new TypeError("Expected a string");
        }
        return str.replace(matchOperatorsRe, "\\$&");
      };
    }
  });

  // node_modules/color-convert/node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "node_modules/color-convert/node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // node_modules/color-convert/conversions.js
  var require_conversions = __commonJS({
    "node_modules/color-convert/conversions.js"(exports, module) {
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (key in cssKeywords) {
        if (cssKeywords.hasOwnProperty(key)) {
          reverseKeywords[cssKeywords[key]] = key;
        }
      }
      var key;
      var convert = module.exports = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      for (model in convert) {
        if (convert.hasOwnProperty(model)) {
          if (!("channels" in convert[model])) {
            throw new Error("missing channels property: " + model);
          }
          if (!("labels" in convert[model])) {
            throw new Error("missing channel labels property: " + model);
          }
          if (convert[model].labels.length !== convert[model].channels) {
            throw new Error("channel and label counts mismatch: " + model);
          }
          channels = convert[model].channels;
          labels = convert[model].labels;
          delete convert[model].channels;
          delete convert[model].labels;
          Object.defineProperty(convert[model], "channels", { value: channels });
          Object.defineProperty(convert[model], "labels", { value: labels });
        }
      }
      var channels;
      var labels;
      var model;
      convert.rgb.hsl = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var h2;
        var s;
        var l;
        if (max === min) {
          h2 = 0;
        } else if (r === max) {
          h2 = (g - b) / delta;
        } else if (g === max) {
          h2 = 2 + (b - r) / delta;
        } else if (b === max) {
          h2 = 4 + (r - g) / delta;
        }
        h2 = Math.min(h2 * 60, 360);
        if (h2 < 0) {
          h2 += 360;
        }
        l = (min + max) / 2;
        if (max === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max + min);
        } else {
          s = delta / (2 - max - min);
        }
        return [h2, s * 100, l * 100];
      };
      convert.rgb.hsv = function(rgb) {
        var rdif;
        var gdif;
        var bdif;
        var h2;
        var s;
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var v = Math.max(r, g, b);
        var diff = v - Math.min(r, g, b);
        var diffc = function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h2 = s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);
          if (r === v) {
            h2 = bdif - gdif;
          } else if (g === v) {
            h2 = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h2 = 2 / 3 + gdif - rdif;
          }
          if (h2 < 0) {
            h2 += 1;
          } else if (h2 > 1) {
            h2 -= 1;
          }
        }
        return [
          h2 * 360,
          s * 100,
          v * 100
        ];
      };
      convert.rgb.hwb = function(rgb) {
        var r = rgb[0];
        var g = rgb[1];
        var b = rgb[2];
        var h2 = convert.rgb.hsl(rgb)[0];
        var w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h2, w * 100, b * 100];
      };
      convert.rgb.cmyk = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var c;
        var m;
        var y;
        var k;
        k = Math.min(1 - r, 1 - g, 1 - b);
        c = (1 - r - k) / (1 - k) || 0;
        m = (1 - g - k) / (1 - k) || 0;
        y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };
      function comparativeDistance(x, y) {
        return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
      }
      convert.rgb.keyword = function(rgb) {
        var reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        var currentClosestDistance = Infinity;
        var currentClosestKeyword;
        for (var keyword2 in cssKeywords) {
          if (cssKeywords.hasOwnProperty(keyword2)) {
            var value = cssKeywords[keyword2];
            var distance = comparativeDistance(rgb, value);
            if (distance < currentClosestDistance) {
              currentClosestDistance = distance;
              currentClosestKeyword = keyword2;
            }
          }
        }
        return currentClosestKeyword;
      };
      convert.keyword.rgb = function(keyword2) {
        return cssKeywords[keyword2];
      };
      convert.rgb.xyz = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert.rgb.lab = function(rgb) {
        var xyz = convert.rgb.xyz(rgb);
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };
      convert.hsl.rgb = function(hsl) {
        var h2 = hsl[0] / 360;
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var t1;
        var t22;
        var t32;
        var rgb;
        var val;
        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t22 = l * (1 + s);
        } else {
          t22 = l + s - l * s;
        }
        t1 = 2 * l - t22;
        rgb = [0, 0, 0];
        for (var i = 0; i < 3; i++) {
          t32 = h2 + 1 / 3 * -(i - 1);
          if (t32 < 0) {
            t32++;
          }
          if (t32 > 1) {
            t32--;
          }
          if (6 * t32 < 1) {
            val = t1 + (t22 - t1) * 6 * t32;
          } else if (2 * t32 < 1) {
            val = t22;
          } else if (3 * t32 < 2) {
            val = t1 + (t22 - t1) * (2 / 3 - t32) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return rgb;
      };
      convert.hsl.hsv = function(hsl) {
        var h2 = hsl[0];
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var smin = s;
        var lmin = Math.max(l, 0.01);
        var sv;
        var v;
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        v = (l + s) / 2;
        sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h2, sv * 100, v * 100];
      };
      convert.hsv.rgb = function(hsv) {
        var h2 = hsv[0] / 60;
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var hi = Math.floor(h2) % 6;
        var f = h2 - Math.floor(h2);
        var p = 255 * v * (1 - s);
        var q = 255 * v * (1 - s * f);
        var t4 = 255 * v * (1 - s * (1 - f));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t4, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t4];
          case 3:
            return [p, q, v];
          case 4:
            return [t4, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert.hsv.hsl = function(hsv) {
        var h2 = hsv[0];
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var vmin = Math.max(v, 0.01);
        var lmin;
        var sl;
        var l;
        l = (2 - s) * v;
        lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h2, sl * 100, l * 100];
      };
      convert.hwb.rgb = function(hwb) {
        var h2 = hwb[0] / 360;
        var wh = hwb[1] / 100;
        var bl = hwb[2] / 100;
        var ratio = wh + bl;
        var i;
        var v;
        var f;
        var n;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        i = Math.floor(6 * h2);
        v = 1 - bl;
        f = 6 * h2 - i;
        if ((i & 1) !== 0) {
          f = 1 - f;
        }
        n = wh + f * (v - wh);
        var r;
        var g;
        var b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;
          case 1:
            r = n;
            g = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g = v;
            b = n;
            break;
          case 3:
            r = wh;
            g = n;
            b = v;
            break;
          case 4:
            r = n;
            g = wh;
            b = v;
            break;
          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }
        return [r * 255, g * 255, b * 255];
      };
      convert.cmyk.rgb = function(cmyk) {
        var c = cmyk[0] / 100;
        var m = cmyk[1] / 100;
        var y = cmyk[2] / 100;
        var k = cmyk[3] / 100;
        var r;
        var g;
        var b;
        r = 1 - Math.min(1, c * (1 - k) + k);
        g = 1 - Math.min(1, m * (1 - k) + k);
        b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      };
      convert.xyz.rgb = function(xyz) {
        var x = xyz[0] / 100;
        var y = xyz[1] / 100;
        var z = xyz[2] / 100;
        var r;
        var g;
        var b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };
      convert.xyz.lab = function(xyz) {
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };
      convert.lab.xyz = function(lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var x;
        var y;
        var z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        var y2 = Math.pow(y, 3);
        var x2 = Math.pow(x, 3);
        var z2 = Math.pow(z, 3);
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert.lab.lch = function(lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var hr;
        var h2;
        var c;
        hr = Math.atan2(b, a);
        h2 = hr * 360 / 2 / Math.PI;
        if (h2 < 0) {
          h2 += 360;
        }
        c = Math.sqrt(a * a + b * b);
        return [l, c, h2];
      };
      convert.lch.lab = function(lch) {
        var l = lch[0];
        var c = lch[1];
        var h2 = lch[2];
        var a;
        var b;
        var hr;
        hr = h2 / 360 * 2 * Math.PI;
        a = c * Math.cos(hr);
        b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert.rgb.ansi16 = function(args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert.hsv.ansi16 = function(args) {
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
      };
      convert.rgb.ansi256 = function(args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert.ansi16.rgb = function(args) {
        var color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        var mult = (~~(args > 50) + 1) * 0.5;
        var r = (color & 1) * mult * 255;
        var g = (color >> 1 & 1) * mult * 255;
        var b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };
      convert.ansi256.rgb = function(args) {
        if (args >= 232) {
          var c = (args - 232) * 10 + 8;
          return [c, c, c];
        }
        args -= 16;
        var rem;
        var r = Math.floor(args / 36) / 5 * 255;
        var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        var b = rem % 6 / 5 * 255;
        return [r, g, b];
      };
      convert.rgb.hex = function(args) {
        var integer2 = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        var string = integer2.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.hex.rgb = function(args) {
        var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        var colorString = match[0];
        if (match[0].length === 3) {
          colorString = colorString.split("").map(function(char) {
            return char + char;
          }).join("");
        }
        var integer2 = parseInt(colorString, 16);
        var r = integer2 >> 16 & 255;
        var g = integer2 >> 8 & 255;
        var b = integer2 & 255;
        return [r, g, b];
      };
      convert.rgb.hcg = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var max = Math.max(Math.max(r, g), b);
        var min = Math.min(Math.min(r, g), b);
        var chroma = max - min;
        var grayscale;
        var hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max === r) {
          hue = (g - b) / chroma % 6;
        } else if (max === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma + 4;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert.hsl.hcg = function(hsl) {
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var c = 1;
        var f = 0;
        if (l < 0.5) {
          c = 2 * s * l;
        } else {
          c = 2 * s * (1 - l);
        }
        if (c < 1) {
          f = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f * 100];
      };
      convert.hsv.hcg = function(hsv) {
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var c = s * v;
        var f = 0;
        if (c < 1) {
          f = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f * 100];
      };
      convert.hcg.rgb = function(hcg) {
        var h2 = hcg[0] / 360;
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        if (c === 0) {
          return [g * 255, g * 255, g * 255];
        }
        var pure = [0, 0, 0];
        var hi = h2 % 1 * 6;
        var v = hi % 1;
        var w = 1 - v;
        var mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert.hcg.hsv = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1 - c);
        var f = 0;
        if (v > 0) {
          f = c / v;
        }
        return [hcg[0], f * 100, v * 100];
      };
      convert.hcg.hsl = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var l = g * (1 - c) + 0.5 * c;
        var s = 0;
        if (l > 0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
      };
      convert.hcg.hwb = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert.hwb.hcg = function(hwb) {
        var w = hwb[1] / 100;
        var b = hwb[2] / 100;
        var v = 1 - b;
        var c = v - w;
        var g = 0;
        if (c < 1) {
          g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
      };
      convert.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert.gray.hsl = convert.gray.hsv = function(args) {
        return [0, 0, args[0]];
      };
      convert.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert.gray.hex = function(gray) {
        var val = Math.round(gray[0] / 100 * 255) & 255;
        var integer2 = (val << 16) + (val << 8) + val;
        var string = integer2.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.rgb.gray = function(rgb) {
        var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // node_modules/color-convert/route.js
  var require_route = __commonJS({
    "node_modules/color-convert/route.js"(exports, module) {
      var conversions = require_conversions();
      function buildGraph() {
        var graph = {};
        var models = Object.keys(conversions);
        for (var len = models.length, i = 0; i < len; i++) {
          graph[models[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      function deriveBFS(fromModel) {
        var graph = buildGraph();
        var queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          var current = queue.pop();
          var adjacents = Object.keys(conversions[current]);
          for (var len = adjacents.length, i = 0; i < len; i++) {
            var adjacent = adjacents[i];
            var node = graph[adjacent];
            if (node.distance === -1) {
              node.distance = graph[current].distance + 1;
              node.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      function link(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      function wrapConversion(toModel, graph) {
        var path = [graph[toModel].parent, toModel];
        var fn = conversions[graph[toModel].parent][toModel];
        var cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path.unshift(graph[cur].parent);
          fn = link(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path;
        return fn;
      }
      module.exports = function(fromModel) {
        var graph = deriveBFS(fromModel);
        var conversion = {};
        var models = Object.keys(graph);
        for (var len = models.length, i = 0; i < len; i++) {
          var toModel = models[i];
          var node = graph[toModel];
          if (node.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    }
  });

  // node_modules/color-convert/index.js
  var require_color_convert = __commonJS({
    "node_modules/color-convert/index.js"(exports, module) {
      var conversions = require_conversions();
      var route = require_route();
      var convert = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        var wrappedFn = function(args) {
          if (args === void 0 || args === null) {
            return args;
          }
          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments);
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        var wrappedFn = function(args) {
          if (args === void 0 || args === null) {
            return args;
          }
          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments);
          }
          var result = fn(args);
          if (typeof result === "object") {
            for (var len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach(function(fromModel) {
        convert[fromModel] = {};
        Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
        var routes = route(fromModel);
        var routeModels = Object.keys(routes);
        routeModels.forEach(function(toModel) {
          var fn = routes[toModel];
          convert[fromModel][toModel] = wrapRounded(fn);
          convert[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module.exports = convert;
    }
  });

  // node_modules/@babel/highlight/node_modules/ansi-styles/index.js
  var require_ansi_styles = __commonJS({
    "node_modules/@babel/highlight/node_modules/ansi-styles/index.js"(exports, module) {
      "use strict";
      var colorConvert = require_color_convert();
      var wrapAnsi16 = (fn, offset) => function() {
        const code2 = fn.apply(colorConvert, arguments);
        return `\x1B[${code2 + offset}m`;
      };
      var wrapAnsi256 = (fn, offset) => function() {
        const code2 = fn.apply(colorConvert, arguments);
        return `\x1B[${38 + offset};5;${code2}m`;
      };
      var wrapAnsi16m = (fn, offset) => function() {
        const rgb = fn.apply(colorConvert, arguments);
        return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      };
      function assembleStyles() {
        const codes = /* @__PURE__ */ new Map();
        const styles = {
          modifier: {
            reset: [0, 0],
            // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39],
            // Bright color
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles.color.grey = styles.color.gray;
        for (const groupName of Object.keys(styles)) {
          const group = styles[groupName];
          for (const styleName of Object.keys(group)) {
            const style = group[styleName];
            styles[styleName] = {
              open: `\x1B[${style[0]}m`,
              close: `\x1B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
          });
          Object.defineProperty(styles, "codes", {
            value: codes,
            enumerable: false
          });
        }
        const ansi2ansi = (n) => n;
        const rgb2rgb = (r, g, b) => [r, g, b];
        styles.color.close = "\x1B[39m";
        styles.bgColor.close = "\x1B[49m";
        styles.color.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 0)
        };
        styles.color.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 0)
        };
        styles.color.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 0)
        };
        styles.bgColor.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 10)
        };
        styles.bgColor.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 10)
        };
        styles.bgColor.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 10)
        };
        for (let key of Object.keys(colorConvert)) {
          if (typeof colorConvert[key] !== "object") {
            continue;
          }
          const suite = colorConvert[key];
          if (key === "ansi16") {
            key = "ansi";
          }
          if ("ansi16" in suite) {
            styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
            styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
          }
          if ("ansi256" in suite) {
            styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
            styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
          }
          if ("rgb" in suite) {
            styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
            styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
          }
        }
        return styles;
      }
      Object.defineProperty(module, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    }
  });

  // node_modules/@babel/highlight/node_modules/supports-color/browser.js
  var require_browser2 = __commonJS({
    "node_modules/@babel/highlight/node_modules/supports-color/browser.js"(exports, module) {
      "use strict";
      module.exports = {
        stdout: false,
        stderr: false
      };
    }
  });

  // node_modules/@babel/highlight/node_modules/chalk/templates.js
  var require_templates = __commonJS({
    "node_modules/@babel/highlight/node_modules/chalk/templates.js"(exports, module) {
      "use strict";
      var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
      var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
      var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
      var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
      var ESCAPES = /* @__PURE__ */ new Map([
        ["n", "\n"],
        ["r", "\r"],
        ["t", "	"],
        ["b", "\b"],
        ["f", "\f"],
        ["v", "\v"],
        ["0", "\0"],
        ["\\", "\\"],
        ["e", "\x1B"],
        ["a", "\x07"]
      ]);
      function unescape(c) {
        if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
          return String.fromCharCode(parseInt(c.slice(1), 16));
        }
        return ESCAPES.get(c) || c;
      }
      function parseArguments(name41, args) {
        const results = [];
        const chunks = args.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
          if (!isNaN(chunk)) {
            results.push(Number(chunk));
          } else if (matches = chunk.match(STRING_REGEX)) {
            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
          } else {
            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name41}')`);
          }
        }
        return results;
      }
      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name41 = matches[1];
          if (matches[2]) {
            const args = parseArguments(name41, matches[2]);
            results.push([name41].concat(args));
          } else {
            results.push([name41]);
          }
        }
        return results;
      }
      function buildStyle(chalk, styles) {
        const enabled = {};
        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
          }
        }
        let current = chalk;
        for (const styleName of Object.keys(enabled)) {
          if (Array.isArray(enabled[styleName])) {
            if (!(styleName in current)) {
              throw new Error(`Unknown Chalk style: ${styleName}`);
            }
            if (enabled[styleName].length > 0) {
              current = current[styleName].apply(current, enabled[styleName]);
            } else {
              current = current[styleName];
            }
          }
        }
        return current;
      }
      module.exports = (chalk, tmp) => {
        const styles = [];
        const chunks = [];
        let chunk = [];
        tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
          if (escapeChar) {
            chunk.push(unescape(escapeChar));
          } else if (style) {
            const str = chunk.join("");
            chunk = [];
            chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
            styles.push({ inverse, styles: parseStyle(style) });
          } else if (close) {
            if (styles.length === 0) {
              throw new Error("Found extraneous } in Chalk template literal");
            }
            chunks.push(buildStyle(chalk, styles)(chunk.join("")));
            chunk = [];
            styles.pop();
          } else {
            chunk.push(chr);
          }
        });
        chunks.push(chunk.join(""));
        if (styles.length > 0) {
          const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(errMsg);
        }
        return chunks.join("");
      };
    }
  });

  // node_modules/@babel/highlight/node_modules/chalk/index.js
  var require_chalk = __commonJS({
    "node_modules/@babel/highlight/node_modules/chalk/index.js"(exports, module) {
      "use strict";
      var escapeStringRegexp = require_escape_string_regexp();
      var ansiStyles = require_ansi_styles();
      var stdoutColor = require_browser2().stdout;
      var template = require_templates();
      var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
      var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
      var skipModels = /* @__PURE__ */ new Set(["gray"]);
      var styles = /* @__PURE__ */ Object.create(null);
      function applyOptions(obj, options) {
        options = options || {};
        const scLevel = stdoutColor ? stdoutColor.level : 0;
        obj.level = options.level === void 0 ? scLevel : options.level;
        obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
      }
      function Chalk(options) {
        if (!this || !(this instanceof Chalk) || this.template) {
          const chalk = {};
          applyOptions(chalk, options);
          chalk.template = function() {
            const args = [].slice.call(arguments);
            return chalkTag.apply(null, [chalk.template].concat(args));
          };
          Object.setPrototypeOf(chalk, Chalk.prototype);
          Object.setPrototypeOf(chalk.template, chalk);
          chalk.template.constructor = Chalk;
          return chalk.template;
        }
        applyOptions(this, options);
      }
      if (isSimpleWindowsTerm) {
        ansiStyles.blue.open = "\x1B[94m";
      }
      for (const key of Object.keys(ansiStyles)) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        styles[key] = {
          get() {
            const codes = ansiStyles[key];
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
          }
        };
      }
      styles.visible = {
        get() {
          return build.call(this, this._styles || [], true, "visible");
        }
      };
      ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
      for (const model of Object.keys(ansiStyles.color.ansi)) {
        if (skipModels.has(model)) {
          continue;
        }
        styles[model] = {
          get() {
            const level = this.level;
            return function() {
              const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
              const codes = {
                open,
                close: ansiStyles.color.close,
                closeRe: ansiStyles.color.closeRe
              };
              return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
            };
          }
        };
      }
      ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
      for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
        if (skipModels.has(model)) {
          continue;
        }
        const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles[bgModel] = {
          get() {
            const level = this.level;
            return function() {
              const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
              const codes = {
                open,
                close: ansiStyles.bgColor.close,
                closeRe: ansiStyles.bgColor.closeRe
              };
              return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
            };
          }
        };
      }
      var proto = Object.defineProperties(() => {
      }, styles);
      function build(_styles, _empty, key) {
        const builder = function() {
          return applyStyle.apply(builder, arguments);
        };
        builder._styles = _styles;
        builder._empty = _empty;
        const self2 = this;
        Object.defineProperty(builder, "level", {
          enumerable: true,
          get() {
            return self2.level;
          },
          set(level) {
            self2.level = level;
          }
        });
        Object.defineProperty(builder, "enabled", {
          enumerable: true,
          get() {
            return self2.enabled;
          },
          set(enabled) {
            self2.enabled = enabled;
          }
        });
        builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
        builder.__proto__ = proto;
        return builder;
      }
      function applyStyle() {
        const args = arguments;
        const argsLen = args.length;
        let str = String(arguments[0]);
        if (argsLen === 0) {
          return "";
        }
        if (argsLen > 1) {
          for (let a = 1; a < argsLen; a++) {
            str += " " + args[a];
          }
        }
        if (!this.enabled || this.level <= 0 || !str) {
          return this._empty ? "" : str;
        }
        const originalDim = ansiStyles.dim.open;
        if (isSimpleWindowsTerm && this.hasGrey) {
          ansiStyles.dim.open = "";
        }
        for (const code2 of this._styles.slice().reverse()) {
          str = code2.open + str.replace(code2.closeRe, code2.open) + code2.close;
          str = str.replace(/\r?\n/g, `${code2.close}$&${code2.open}`);
        }
        ansiStyles.dim.open = originalDim;
        return str;
      }
      function chalkTag(chalk, strings) {
        if (!Array.isArray(strings)) {
          return [].slice.call(arguments, 1).join(" ");
        }
        const args = [].slice.call(arguments, 2);
        const parts = [strings.raw[0]];
        for (let i = 1; i < strings.length; i++) {
          parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
          parts.push(String(strings.raw[i]));
        }
        return template(chalk, parts.join(""));
      }
      Object.defineProperties(Chalk.prototype, styles);
      module.exports = Chalk();
      module.exports.supportsColor = stdoutColor;
      module.exports.default = module.exports;
    }
  });

  // node_modules/@babel/highlight/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/@babel/highlight/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = highlight;
      exports.getChalk = getChalk;
      exports.shouldHighlight = shouldHighlight;
      var _jsTokens = require_js_tokens();
      var _helperValidatorIdentifier = require_lib2();
      var _chalk = require_chalk();
      var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
      function getDefs(chalk) {
        return {
          keyword: chalk.cyan,
          capitalized: chalk.yellow,
          jsxIdentifier: chalk.yellow,
          punctuator: chalk.yellow,
          number: chalk.magenta,
          string: chalk.green,
          regex: chalk.magenta,
          comment: chalk.grey,
          invalid: chalk.white.bgRed.bold
        };
      }
      var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
      var BRACKET = /^[()[\]{}]$/;
      var tokenize3;
      {
        const JSX_TAG = /^[a-z][\w-]*$/i;
        const getTokenType = function(token, offset, text) {
          if (token.type === "name") {
            if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
              return "keyword";
            }
            if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
              return "jsxIdentifier";
            }
            if (token.value[0] !== token.value[0].toLowerCase()) {
              return "capitalized";
            }
          }
          if (token.type === "punctuator" && BRACKET.test(token.value)) {
            return "bracket";
          }
          if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
            return "punctuator";
          }
          return token.type;
        };
        tokenize3 = function* (text) {
          let match;
          while (match = _jsTokens.default.exec(text)) {
            const token = _jsTokens.matchToToken(match);
            yield {
              type: getTokenType(token, match.index, text),
              value: token.value
            };
          }
        };
      }
      function highlightTokens(defs, text) {
        let highlighted = "";
        for (const {
          type,
          value
        } of tokenize3(text)) {
          const colorize = defs[type];
          if (colorize) {
            highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
          } else {
            highlighted += value;
          }
        }
        return highlighted;
      }
      function shouldHighlight(options) {
        return !!_chalk.supportsColor || options.forceColor;
      }
      function getChalk(options) {
        return options.forceColor ? new _chalk.constructor({
          enabled: true,
          level: 1
        }) : _chalk;
      }
      function highlight(code2, options = {}) {
        if (code2 !== "" && shouldHighlight(options)) {
          const chalk = getChalk(options);
          const defs = getDefs(chalk);
          return highlightTokens(defs, code2);
        } else {
          return code2;
        }
      }
    }
  });

  // node_modules/@babel/code-frame/lib/index.js
  var require_lib7 = __commonJS({
    "node_modules/@babel/code-frame/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.codeFrameColumns = codeFrameColumns;
      exports.default = _default;
      var _highlight = require_lib6();
      var deprecationWarningShown = false;
      function getDefs(chalk) {
        return {
          gutter: chalk.grey,
          marker: chalk.red.bold,
          message: chalk.red.bold
        };
      }
      var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
      function getMarkerLines(loc, source, opts) {
        const startLoc = Object.assign({
          column: 0,
          line: -1
        }, loc.start);
        const endLoc = Object.assign({}, startLoc, loc.end);
        const {
          linesAbove = 2,
          linesBelow = 3
        } = opts || {};
        const startLine = startLoc.line;
        const startColumn = startLoc.column;
        const endLine = endLoc.line;
        const endColumn = endLoc.column;
        let start = Math.max(startLine - (linesAbove + 1), 0);
        let end = Math.min(source.length, endLine + linesBelow);
        if (startLine === -1) {
          start = 0;
        }
        if (endLine === -1) {
          end = source.length;
        }
        const lineDiff = endLine - startLine;
        const markerLines = {};
        if (lineDiff) {
          for (let i = 0; i <= lineDiff; i++) {
            const lineNumber = i + startLine;
            if (!startColumn) {
              markerLines[lineNumber] = true;
            } else if (i === 0) {
              const sourceLength = source[lineNumber - 1].length;
              markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
            } else if (i === lineDiff) {
              markerLines[lineNumber] = [0, endColumn];
            } else {
              const sourceLength = source[lineNumber - i].length;
              markerLines[lineNumber] = [0, sourceLength];
            }
          }
        } else {
          if (startColumn === endColumn) {
            if (startColumn) {
              markerLines[startLine] = [startColumn, 0];
            } else {
              markerLines[startLine] = true;
            }
          } else {
            markerLines[startLine] = [startColumn, endColumn - startColumn];
          }
        }
        return {
          start,
          end,
          markerLines
        };
      }
      function codeFrameColumns(rawLines, loc, opts = {}) {
        const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
        const chalk = (0, _highlight.getChalk)(opts);
        const defs = getDefs(chalk);
        const maybeHighlight = (chalkFn, string) => {
          return highlighted ? chalkFn(string) : string;
        };
        const lines = rawLines.split(NEWLINE);
        const {
          start,
          end,
          markerLines
        } = getMarkerLines(loc, lines, opts);
        const hasColumns = loc.start && typeof loc.start.column === "number";
        const numberMaxWidth = String(end).length;
        const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
        let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
          const number2 = start + 1 + index;
          const paddedNumber = ` ${number2}`.slice(-numberMaxWidth);
          const gutter = ` ${paddedNumber} |`;
          const hasMarker = markerLines[number2];
          const lastMarkerLine = !markerLines[number2 + 1];
          if (hasMarker) {
            let markerLine = "";
            if (Array.isArray(hasMarker)) {
              const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
              const numberOfMarkers = hasMarker[1] || 1;
              markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
              if (lastMarkerLine && opts.message) {
                markerLine += " " + maybeHighlight(defs.message, opts.message);
              }
            }
            return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
          } else {
            return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
          }
        }).join("\n");
        if (opts.message && !hasColumns) {
          frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
        }
        if (highlighted) {
          return chalk.reset(frame);
        } else {
          return frame;
        }
      }
      function _default(rawLines, lineNumber, colNumber, opts = {}) {
        if (!deprecationWarningShown) {
          deprecationWarningShown = true;
          const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
          if (process.emitWarning) {
            process.emitWarning(message, "DeprecationWarning");
          } else {
            const deprecationError = new Error(message);
            deprecationError.name = "DeprecationWarning";
            console.warn(new Error(message));
          }
        }
        colNumber = Math.max(colNumber, 0);
        const location = {
          start: {
            column: colNumber,
            line: lineNumber
          }
        };
        return codeFrameColumns(rawLines, location, opts);
      }
    }
  });

  // node_modules/@babel/template/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/@babel/template/lib/parse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = parseAndBuildMetadata;
      var _t = require_lib4();
      var _parser = require_lib();
      var _codeFrame = require_lib7();
      var {
        isCallExpression,
        isExpressionStatement: isExpressionStatement2,
        isFunction,
        isIdentifier: isIdentifier2,
        isJSXIdentifier,
        isNewExpression,
        isPlaceholder,
        isStatement,
        isStringLiteral,
        removePropertiesDeep,
        traverse
      } = _t;
      var PATTERN = /^[_$A-Z0-9]+$/;
      function parseAndBuildMetadata(formatter, code2, opts) {
        const {
          placeholderWhitelist,
          placeholderPattern,
          preserveComments,
          syntacticPlaceholders
        } = opts;
        const ast = parseWithCodeFrame(code2, opts.parser, syntacticPlaceholders);
        removePropertiesDeep(ast, {
          preserveComments
        });
        formatter.validate(ast);
        const syntactic = {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        };
        const legacy = {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        };
        const isLegacyRef = {
          value: void 0
        };
        traverse(ast, placeholderVisitorHandler, {
          syntactic,
          legacy,
          isLegacyRef,
          placeholderWhitelist,
          placeholderPattern,
          syntacticPlaceholders
        });
        return Object.assign({
          ast
        }, isLegacyRef.value ? legacy : syntactic);
      }
      function placeholderVisitorHandler(node, ancestors, state) {
        var _state$placeholderWhi;
        let name41;
        if (isPlaceholder(node)) {
          if (state.syntacticPlaceholders === false) {
            throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
          } else {
            name41 = node.name.name;
            state.isLegacyRef.value = false;
          }
        } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
          return;
        } else if (isIdentifier2(node) || isJSXIdentifier(node)) {
          name41 = node.name;
          state.isLegacyRef.value = true;
        } else if (isStringLiteral(node)) {
          name41 = node.value;
          state.isLegacyRef.value = true;
        } else {
          return;
        }
        if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
          throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
        }
        if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name41)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name41))) {
          return;
        }
        ancestors = ancestors.slice();
        const {
          node: parent,
          key
        } = ancestors[ancestors.length - 1];
        let type;
        if (isStringLiteral(node) || isPlaceholder(node, {
          expectedNode: "StringLiteral"
        })) {
          type = "string";
        } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
          type = "param";
        } else if (isExpressionStatement2(parent) && !isPlaceholder(node)) {
          type = "statement";
          ancestors = ancestors.slice(0, -1);
        } else if (isStatement(node) && isPlaceholder(node)) {
          type = "statement";
        } else {
          type = "other";
        }
        const {
          placeholders,
          placeholderNames
        } = state.isLegacyRef.value ? state.legacy : state.syntactic;
        placeholders.push({
          name: name41,
          type,
          resolve: (ast) => resolveAncestors(ast, ancestors),
          isDuplicate: placeholderNames.has(name41)
        });
        placeholderNames.add(name41);
      }
      function resolveAncestors(ast, ancestors) {
        let parent = ast;
        for (let i = 0; i < ancestors.length - 1; i++) {
          const {
            key: key2,
            index: index2
          } = ancestors[i];
          if (index2 === void 0) {
            parent = parent[key2];
          } else {
            parent = parent[key2][index2];
          }
        }
        const {
          key,
          index
        } = ancestors[ancestors.length - 1];
        return {
          parent,
          key,
          index
        };
      }
      function parseWithCodeFrame(code2, parserOpts, syntacticPlaceholders) {
        const plugins = (parserOpts.plugins || []).slice();
        if (syntacticPlaceholders !== false) {
          plugins.push("placeholders");
        }
        parserOpts = Object.assign({
          allowReturnOutsideFunction: true,
          allowSuperOutsideMethod: true,
          sourceType: "module"
        }, parserOpts, {
          plugins
        });
        try {
          return (0, _parser.parse)(code2, parserOpts);
        } catch (err) {
          const loc = err.loc;
          if (loc) {
            err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code2, {
              start: loc
            });
            err.code = "BABEL_TEMPLATE_PARSE_ERROR";
          }
          throw err;
        }
      }
    }
  });

  // node_modules/@babel/template/lib/populate.js
  var require_populate = __commonJS({
    "node_modules/@babel/template/lib/populate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = populatePlaceholders;
      var _t = require_lib4();
      var {
        blockStatement: blockStatement2,
        cloneNode,
        emptyStatement,
        expressionStatement: expressionStatement2,
        identifier: identifier4,
        isStatement,
        isStringLiteral,
        stringLiteral: stringLiteral2,
        validate
      } = _t;
      function populatePlaceholders(metadata, replacements) {
        const ast = cloneNode(metadata.ast);
        if (replacements) {
          metadata.placeholders.forEach((placeholder) => {
            if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
              const placeholderName = placeholder.name;
              throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
            }
          });
          Object.keys(replacements).forEach((key) => {
            if (!metadata.placeholderNames.has(key)) {
              throw new Error(`Unknown substitution "${key}" given`);
            }
          });
        }
        metadata.placeholders.slice().reverse().forEach((placeholder) => {
          try {
            applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
          } catch (e) {
            e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
            throw e;
          }
        });
        return ast;
      }
      function applyReplacement(placeholder, ast, replacement) {
        if (placeholder.isDuplicate) {
          if (Array.isArray(replacement)) {
            replacement = replacement.map((node) => cloneNode(node));
          } else if (typeof replacement === "object") {
            replacement = cloneNode(replacement);
          }
        }
        const {
          parent,
          key,
          index
        } = placeholder.resolve(ast);
        if (placeholder.type === "string") {
          if (typeof replacement === "string") {
            replacement = stringLiteral2(replacement);
          }
          if (!replacement || !isStringLiteral(replacement)) {
            throw new Error("Expected string substitution");
          }
        } else if (placeholder.type === "statement") {
          if (index === void 0) {
            if (!replacement) {
              replacement = emptyStatement();
            } else if (Array.isArray(replacement)) {
              replacement = blockStatement2(replacement);
            } else if (typeof replacement === "string") {
              replacement = expressionStatement2(identifier4(replacement));
            } else if (!isStatement(replacement)) {
              replacement = expressionStatement2(replacement);
            }
          } else {
            if (replacement && !Array.isArray(replacement)) {
              if (typeof replacement === "string") {
                replacement = identifier4(replacement);
              }
              if (!isStatement(replacement)) {
                replacement = expressionStatement2(replacement);
              }
            }
          }
        } else if (placeholder.type === "param") {
          if (typeof replacement === "string") {
            replacement = identifier4(replacement);
          }
          if (index === void 0)
            throw new Error("Assertion failure.");
        } else {
          if (typeof replacement === "string") {
            replacement = identifier4(replacement);
          }
          if (Array.isArray(replacement)) {
            throw new Error("Cannot replace single expression with an array.");
          }
        }
        if (index === void 0) {
          validate(parent, key, replacement);
          parent[key] = replacement;
        } else {
          const items = parent[key].slice();
          if (placeholder.type === "statement" || placeholder.type === "param") {
            if (replacement == null) {
              items.splice(index, 1);
            } else if (Array.isArray(replacement)) {
              items.splice(index, 1, ...replacement);
            } else {
              items[index] = replacement;
            }
          } else {
            items[index] = replacement;
          }
          validate(parent, key, items);
          parent[key] = items;
        }
      }
    }
  });

  // node_modules/@babel/template/lib/string.js
  var require_string = __commonJS({
    "node_modules/@babel/template/lib/string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = stringTemplate;
      var _options = require_options();
      var _parse = require_parse();
      var _populate = require_populate();
      function stringTemplate(formatter, code2, opts) {
        code2 = formatter.code(code2);
        let metadata;
        return (arg) => {
          const replacements = (0, _options.normalizeReplacements)(arg);
          if (!metadata)
            metadata = (0, _parse.default)(formatter, code2, opts);
          return formatter.unwrap((0, _populate.default)(metadata, replacements));
        };
      }
    }
  });

  // node_modules/@babel/template/lib/literal.js
  var require_literal = __commonJS({
    "node_modules/@babel/template/lib/literal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = literalTemplate;
      var _options = require_options();
      var _parse = require_parse();
      var _populate = require_populate();
      function literalTemplate(formatter, tpl, opts) {
        const {
          metadata,
          names
        } = buildLiteralData(formatter, tpl, opts);
        return (arg) => {
          const defaultReplacements = {};
          arg.forEach((replacement, i) => {
            defaultReplacements[names[i]] = replacement;
          });
          return (arg2) => {
            const replacements = (0, _options.normalizeReplacements)(arg2);
            if (replacements) {
              Object.keys(replacements).forEach((key) => {
                if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
                  throw new Error("Unexpected replacement overlap.");
                }
              });
            }
            return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
          };
        };
      }
      function buildLiteralData(formatter, tpl, opts) {
        let names;
        let nameSet;
        let metadata;
        let prefix = "";
        do {
          prefix += "$";
          const result = buildTemplateCode(tpl, prefix);
          names = result.names;
          nameSet = new Set(names);
          metadata = (0, _parse.default)(formatter, formatter.code(result.code), {
            parser: opts.parser,
            placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
            placeholderPattern: opts.placeholderPattern,
            preserveComments: opts.preserveComments,
            syntacticPlaceholders: opts.syntacticPlaceholders
          });
        } while (metadata.placeholders.some((placeholder) => placeholder.isDuplicate && nameSet.has(placeholder.name)));
        return {
          metadata,
          names
        };
      }
      function buildTemplateCode(tpl, prefix) {
        const names = [];
        let code2 = tpl[0];
        for (let i = 1; i < tpl.length; i++) {
          const value = `${prefix}${i - 1}`;
          names.push(value);
          code2 += value + tpl[i];
        }
        return {
          names,
          code: code2
        };
      }
    }
  });

  // node_modules/@babel/template/lib/builder.js
  var require_builder = __commonJS({
    "node_modules/@babel/template/lib/builder.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = createTemplateBuilder;
      var _options = require_options();
      var _string = require_string();
      var _literal = require_literal();
      var NO_PLACEHOLDER = (0, _options.validate)({
        placeholderPattern: false
      });
      function createTemplateBuilder(formatter, defaultOpts) {
        const templateFnCache = /* @__PURE__ */ new WeakMap();
        const templateAstCache = /* @__PURE__ */ new WeakMap();
        const cachedOpts = defaultOpts || (0, _options.validate)(null);
        return Object.assign((tpl, ...args) => {
          if (typeof tpl === "string") {
            if (args.length > 1)
              throw new Error("Unexpected extra params.");
            return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
          } else if (Array.isArray(tpl)) {
            let builder = templateFnCache.get(tpl);
            if (!builder) {
              builder = (0, _literal.default)(formatter, tpl, cachedOpts);
              templateFnCache.set(tpl, builder);
            }
            return extendedTrace(builder(args));
          } else if (typeof tpl === "object" && tpl) {
            if (args.length > 0)
              throw new Error("Unexpected extra params.");
            return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
          }
          throw new Error(`Unexpected template param ${typeof tpl}`);
        }, {
          ast: (tpl, ...args) => {
            if (typeof tpl === "string") {
              if (args.length > 1)
                throw new Error("Unexpected extra params.");
              return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
            } else if (Array.isArray(tpl)) {
              let builder = templateAstCache.get(tpl);
              if (!builder) {
                builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
                templateAstCache.set(tpl, builder);
              }
              return builder(args)();
            }
            throw new Error(`Unexpected template param ${typeof tpl}`);
          }
        });
      }
      function extendedTrace(fn) {
        let rootStack = "";
        try {
          throw new Error();
        } catch (error) {
          if (error.stack) {
            rootStack = error.stack.split("\n").slice(3).join("\n");
          }
        }
        return (arg) => {
          try {
            return fn(arg);
          } catch (err) {
            err.stack += `
    =============
${rootStack}`;
            throw err;
          }
        };
      }
    }
  });

  // node_modules/@babel/template/lib/index.js
  var require_lib8 = __commonJS({
    "node_modules/@babel/template/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.statements = exports.statement = exports.smart = exports.program = exports.expression = exports.default = void 0;
      var formatters = require_formatters();
      var _builder = require_builder();
      var smart = (0, _builder.default)(formatters.smart);
      exports.smart = smart;
      var statement = (0, _builder.default)(formatters.statement);
      exports.statement = statement;
      var statements = (0, _builder.default)(formatters.statements);
      exports.statements = statements;
      var expression = (0, _builder.default)(formatters.expression);
      exports.expression = expression;
      var program2 = (0, _builder.default)(formatters.program);
      exports.program = program2;
      var _default = Object.assign(smart.bind(void 0), {
        smart,
        statement,
        statements,
        expression,
        program: program2,
        ast: smart.ast
      });
      exports.default = _default;
    }
  });

  // node_modules/@babel/traverse/lib/path/lib/virtual-types.js
  var require_virtual_types = __commonJS({
    "node_modules/@babel/traverse/lib/path/lib/virtual-types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;
      var ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
      exports.ReferencedIdentifier = ReferencedIdentifier;
      var ReferencedMemberExpression = ["MemberExpression"];
      exports.ReferencedMemberExpression = ReferencedMemberExpression;
      var BindingIdentifier = ["Identifier"];
      exports.BindingIdentifier = BindingIdentifier;
      var Statement = ["Statement"];
      exports.Statement = Statement;
      var Expression = ["Expression"];
      exports.Expression = Expression;
      var Scope = ["Scopable", "Pattern"];
      exports.Scope = Scope;
      var Referenced = null;
      exports.Referenced = Referenced;
      var BlockScoped = null;
      exports.BlockScoped = BlockScoped;
      var Var = ["VariableDeclaration"];
      exports.Var = Var;
      var User = null;
      exports.User = User;
      var Generated = null;
      exports.Generated = Generated;
      var Pure = null;
      exports.Pure = Pure;
      var Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
      exports.Flow = Flow;
      var RestProperty = ["RestElement"];
      exports.RestProperty = RestProperty;
      var SpreadProperty = ["RestElement"];
      exports.SpreadProperty = SpreadProperty;
      var ExistentialTypeParam = ["ExistsTypeAnnotation"];
      exports.ExistentialTypeParam = ExistentialTypeParam;
      var NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
      exports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;
      var ForAwaitStatement = ["ForOfStatement"];
      exports.ForAwaitStatement = ForAwaitStatement;
    }
  });

  // node_modules/@babel/traverse/lib/visitors.js
  var require_visitors = __commonJS({
    "node_modules/@babel/traverse/lib/visitors.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.explode = explode;
      exports.merge = merge;
      exports.verify = verify;
      var virtualTypes = require_virtual_types();
      var _t = require_lib4();
      var {
        DEPRECATED_KEYS,
        FLIPPED_ALIAS_KEYS,
        TYPES
      } = _t;
      function isVirtualType(type) {
        return type in virtualTypes;
      }
      function explode(visitor) {
        if (visitor._exploded)
          return visitor;
        visitor._exploded = true;
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType))
            continue;
          const parts = nodeType.split("|");
          if (parts.length === 1)
            continue;
          const fns = visitor[nodeType];
          delete visitor[nodeType];
          for (const part of parts) {
            visitor[part] = fns;
          }
        }
        verify(visitor);
        delete visitor.__esModule;
        ensureEntranceObjects(visitor);
        ensureCallbackArrays(visitor);
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType))
            continue;
          if (!isVirtualType(nodeType))
            continue;
          const fns = visitor[nodeType];
          for (const type of Object.keys(fns)) {
            fns[type] = wrapCheck(nodeType, fns[type]);
          }
          delete visitor[nodeType];
          const types = virtualTypes[nodeType];
          if (types !== null) {
            for (const type of types) {
              if (visitor[type]) {
                mergePair(visitor[type], fns);
              } else {
                visitor[type] = fns;
              }
            }
          } else {
            mergePair(visitor, fns);
          }
        }
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType))
            continue;
          const fns = visitor[nodeType];
          let aliases = FLIPPED_ALIAS_KEYS[nodeType];
          const deprecatedKey = DEPRECATED_KEYS[nodeType];
          if (deprecatedKey) {
            console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);
            aliases = [deprecatedKey];
          }
          if (!aliases)
            continue;
          delete visitor[nodeType];
          for (const alias of aliases) {
            const existing = visitor[alias];
            if (existing) {
              mergePair(existing, fns);
            } else {
              visitor[alias] = Object.assign({}, fns);
            }
          }
        }
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType))
            continue;
          ensureCallbackArrays(visitor[nodeType]);
        }
        return visitor;
      }
      function verify(visitor) {
        if (visitor._verified)
          return;
        if (typeof visitor === "function") {
          throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
        }
        for (const nodeType of Object.keys(visitor)) {
          if (nodeType === "enter" || nodeType === "exit") {
            validateVisitorMethods(nodeType, visitor[nodeType]);
          }
          if (shouldIgnoreKey(nodeType))
            continue;
          if (TYPES.indexOf(nodeType) < 0) {
            throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
          }
          const visitors = visitor[nodeType];
          if (typeof visitors === "object") {
            for (const visitorKey of Object.keys(visitors)) {
              if (visitorKey === "enter" || visitorKey === "exit") {
                validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
              } else {
                throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
              }
            }
          }
        }
        visitor._verified = true;
      }
      function validateVisitorMethods(path, val) {
        const fns = [].concat(val);
        for (const fn of fns) {
          if (typeof fn !== "function") {
            throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
          }
        }
      }
      function merge(visitors, states = [], wrapper) {
        const rootVisitor = {};
        for (let i = 0; i < visitors.length; i++) {
          const visitor = visitors[i];
          const state = states[i];
          explode(visitor);
          for (const type of Object.keys(visitor)) {
            let visitorType = visitor[type];
            if (state || wrapper) {
              visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
            }
            const nodeVisitor = rootVisitor[type] || (rootVisitor[type] = {});
            mergePair(nodeVisitor, visitorType);
          }
        }
        return rootVisitor;
      }
      function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
        const newVisitor = {};
        for (const key of Object.keys(oldVisitor)) {
          let fns = oldVisitor[key];
          if (!Array.isArray(fns))
            continue;
          fns = fns.map(function(fn) {
            let newFn = fn;
            if (state) {
              newFn = function(path) {
                return fn.call(state, path, state);
              };
            }
            if (wrapper) {
              newFn = wrapper(state.key, key, newFn);
            }
            if (newFn !== fn) {
              newFn.toString = () => fn.toString();
            }
            return newFn;
          });
          newVisitor[key] = fns;
        }
        return newVisitor;
      }
      function ensureEntranceObjects(obj) {
        for (const key of Object.keys(obj)) {
          if (shouldIgnoreKey(key))
            continue;
          const fns = obj[key];
          if (typeof fns === "function") {
            obj[key] = {
              enter: fns
            };
          }
        }
      }
      function ensureCallbackArrays(obj) {
        if (obj.enter && !Array.isArray(obj.enter))
          obj.enter = [obj.enter];
        if (obj.exit && !Array.isArray(obj.exit))
          obj.exit = [obj.exit];
      }
      function wrapCheck(nodeType, fn) {
        const newFn = function(path) {
          if (path[`is${nodeType}`]()) {
            return fn.apply(this, arguments);
          }
        };
        newFn.toString = () => fn.toString();
        return newFn;
      }
      function shouldIgnoreKey(key) {
        if (key[0] === "_")
          return true;
        if (key === "enter" || key === "exit" || key === "shouldSkip")
          return true;
        if (key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist") {
          return true;
        }
        return false;
      }
      function mergePair(dest, src) {
        for (const key of Object.keys(src)) {
          dest[key] = [].concat(dest[key] || [], src[key]);
        }
      }
    }
  });

  // node_modules/@babel/traverse/lib/cache.js
  var require_cache = __commonJS({
    "node_modules/@babel/traverse/lib/cache.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.clear = clear;
      exports.clearPath = clearPath;
      exports.clearScope = clearScope;
      exports.scope = exports.path = void 0;
      var path = /* @__PURE__ */ new WeakMap();
      exports.path = path;
      var scope = /* @__PURE__ */ new WeakMap();
      exports.scope = scope;
      function clear() {
        clearPath();
        clearScope();
      }
      function clearPath() {
        exports.path = path = /* @__PURE__ */ new WeakMap();
      }
      function clearScope() {
        exports.scope = scope = /* @__PURE__ */ new WeakMap();
      }
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports, module) {
      var s = 1e3;
      var m = s * 60;
      var h2 = m * 60;
      var d = h2 * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse44(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse44(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h2;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h2) {
          return Math.round(ms / h2) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h2) {
          return plural(ms, msAbs, h2, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name41) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name41 + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/debug/src/common.js"(exports, module) {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format2];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name41) {
          if (name41[name41.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name41)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name41)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser3 = __commonJS({
    "node_modules/debug/src/browser.js"(exports, module) {
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/@babel/helper-split-export-declaration/lib/index.js
  var require_lib9 = __commonJS({
    "node_modules/@babel/helper-split-export-declaration/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = splitExportDeclaration;
      var _t = require_lib4();
      var {
        cloneNode,
        exportNamedDeclaration,
        exportSpecifier,
        identifier: identifier4,
        variableDeclaration: variableDeclaration2,
        variableDeclarator: variableDeclarator2
      } = _t;
      function splitExportDeclaration(exportDeclaration) {
        if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration()) {
          throw new Error("Only default and named export declarations can be split.");
        }
        if (exportDeclaration.isExportDefaultDeclaration()) {
          const declaration2 = exportDeclaration.get("declaration");
          const standaloneDeclaration = declaration2.isFunctionDeclaration() || declaration2.isClassDeclaration();
          const scope = declaration2.isScope() ? declaration2.scope.parent : declaration2.scope;
          let id = declaration2.node.id;
          let needBindingRegistration = false;
          if (!id) {
            needBindingRegistration = true;
            id = scope.generateUidIdentifier("default");
            if (standaloneDeclaration || declaration2.isFunctionExpression() || declaration2.isClassExpression()) {
              declaration2.node.id = cloneNode(id);
            }
          }
          const updatedDeclaration = standaloneDeclaration ? declaration2.node : variableDeclaration2("var", [variableDeclarator2(cloneNode(id), declaration2.node)]);
          const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier4("default"))]);
          exportDeclaration.insertAfter(updatedExportDeclaration);
          exportDeclaration.replaceWith(updatedDeclaration);
          if (needBindingRegistration) {
            scope.registerDeclaration(exportDeclaration);
          }
          return exportDeclaration;
        } else if (exportDeclaration.get("specifiers").length > 0) {
          throw new Error("It doesn't make sense to split exported specifiers.");
        }
        const declaration = exportDeclaration.get("declaration");
        const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
        const specifiers = Object.keys(bindingIdentifiers).map((name41) => {
          return exportSpecifier(identifier4(name41), identifier4(name41));
        });
        const aliasDeclar = exportNamedDeclaration(null, specifiers);
        exportDeclaration.insertAfter(aliasDeclar);
        exportDeclaration.replaceWith(declaration.node);
        return exportDeclaration;
      }
    }
  });

  // node_modules/@babel/helper-environment-visitor/lib/index.js
  var require_lib10 = __commonJS({
    "node_modules/@babel/helper-environment-visitor/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      exports.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
      exports.skipAllButComputedKey = skipAllButComputedKey;
      function skipAllButComputedKey(path) {
        path.skip();
        if (path.node.computed) {
          path.context.maybeQueue(path.get("key"));
        }
      }
      function requeueComputedKeyAndDecorators(path) {
        const {
          context,
          node
        } = path;
        if (node.computed) {
          context.maybeQueue(path.get("key"));
        }
        if (node.decorators) {
          for (const decorator of path.get("decorators")) {
            context.maybeQueue(decorator);
          }
        }
      }
      var visitor = {
        FunctionParent(path) {
          if (path.isArrowFunctionExpression()) {
            return;
          } else {
            path.skip();
            if (path.isMethod()) {
              requeueComputedKeyAndDecorators(path);
            }
          }
        },
        Property(path) {
          if (path.isObjectProperty()) {
            return;
          }
          path.skip();
          requeueComputedKeyAndDecorators(path);
        }
      };
      var _default = visitor;
      exports.default = _default;
    }
  });

  // node_modules/@babel/traverse/lib/scope/lib/renamer.js
  var require_renamer = __commonJS({
    "node_modules/@babel/traverse/lib/scope/lib/renamer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _helperSplitExportDeclaration = require_lib9();
      var t4 = require_lib4();
      var _helperEnvironmentVisitor = require_lib10();
      var _traverseNode = require_traverse_node();
      var _visitors = require_visitors();
      var renameVisitor = {
        ReferencedIdentifier({
          node
        }, state) {
          if (node.name === state.oldName) {
            node.name = state.newName;
          }
        },
        Scope(path, state) {
          if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
            path.skip();
            if (path.isMethod()) {
              (0, _helperEnvironmentVisitor.requeueComputedKeyAndDecorators)(path);
            }
          }
        },
        "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
          if (path.isVariableDeclaration())
            return;
          const ids = path.getOuterBindingIdentifiers();
          for (const name41 in ids) {
            if (name41 === state.oldName)
              ids[name41].name = state.newName;
          }
        }
      };
      var Renamer = class {
        constructor(binding, oldName, newName) {
          this.newName = newName;
          this.oldName = oldName;
          this.binding = binding;
        }
        maybeConvertFromExportDeclaration(parentDeclar) {
          const maybeExportDeclar = parentDeclar.parentPath;
          if (!maybeExportDeclar.isExportDeclaration()) {
            return;
          }
          if (maybeExportDeclar.isExportDefaultDeclaration()) {
            const {
              declaration
            } = maybeExportDeclar.node;
            if (t4.isDeclaration(declaration) && !declaration.id) {
              return;
            }
          }
          if (maybeExportDeclar.isExportAllDeclaration()) {
            return;
          }
          (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);
        }
        maybeConvertFromClassFunctionDeclaration(path) {
          return path;
        }
        maybeConvertFromClassFunctionExpression(path) {
          return path;
        }
        rename() {
          const {
            binding,
            oldName,
            newName
          } = this;
          const {
            scope,
            path
          } = binding;
          const parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
          if (parentDeclar) {
            const bindingIds = parentDeclar.getOuterBindingIdentifiers();
            if (bindingIds[oldName] === binding.identifier) {
              this.maybeConvertFromExportDeclaration(parentDeclar);
            }
          }
          const blockToTraverse = arguments[0] || scope.block;
          (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, {
            discriminant: true
          });
          if (!arguments[0]) {
            scope.removeOwnBinding(oldName);
            scope.bindings[newName] = binding;
            this.binding.identifier.name = newName;
          }
          if (parentDeclar) {
            this.maybeConvertFromClassFunctionDeclaration(path);
            this.maybeConvertFromClassFunctionExpression(path);
          }
        }
      };
      exports.default = Renamer;
    }
  });

  // node_modules/@babel/traverse/lib/scope/binding.js
  var require_binding = __commonJS({
    "node_modules/@babel/traverse/lib/scope/binding.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var Binding = class {
        constructor({
          identifier: identifier4,
          scope,
          path,
          kind
        }) {
          this.identifier = void 0;
          this.scope = void 0;
          this.path = void 0;
          this.kind = void 0;
          this.constantViolations = [];
          this.constant = true;
          this.referencePaths = [];
          this.referenced = false;
          this.references = 0;
          this.identifier = identifier4;
          this.scope = scope;
          this.path = path;
          this.kind = kind;
          if ((kind === "var" || kind === "hoisted") && isDeclaredInLoop(path || (() => {
            throw new Error("Internal Babel error: unreachable ");
          })())) {
            this.reassign(path);
          }
          this.clearValue();
        }
        deoptValue() {
          this.clearValue();
          this.hasDeoptedValue = true;
        }
        setValue(value) {
          if (this.hasDeoptedValue)
            return;
          this.hasValue = true;
          this.value = value;
        }
        clearValue() {
          this.hasDeoptedValue = false;
          this.hasValue = false;
          this.value = null;
        }
        reassign(path) {
          this.constant = false;
          if (this.constantViolations.indexOf(path) !== -1) {
            return;
          }
          this.constantViolations.push(path);
        }
        reference(path) {
          if (this.referencePaths.indexOf(path) !== -1) {
            return;
          }
          this.referenced = true;
          this.references++;
          this.referencePaths.push(path);
        }
        dereference() {
          this.references--;
          this.referenced = !!this.references;
        }
      };
      exports.default = Binding;
      function isDeclaredInLoop(path) {
        for (let {
          parentPath,
          key
        } = path; parentPath; {
          parentPath,
          key
        } = parentPath) {
          if (parentPath.isFunctionParent())
            return false;
          if (parentPath.isWhile() || parentPath.isForXStatement() || parentPath.isForStatement() && key === "body") {
            return true;
          }
        }
        return false;
      }
    }
  });

  // node_modules/globals/globals.json
  var require_globals = __commonJS({
    "node_modules/globals/globals.json"(exports, module) {
      module.exports = {
        builtin: {
          Array: false,
          ArrayBuffer: false,
          Atomics: false,
          BigInt: false,
          BigInt64Array: false,
          BigUint64Array: false,
          Boolean: false,
          constructor: false,
          DataView: false,
          Date: false,
          decodeURI: false,
          decodeURIComponent: false,
          encodeURI: false,
          encodeURIComponent: false,
          Error: false,
          escape: false,
          eval: false,
          EvalError: false,
          Float32Array: false,
          Float64Array: false,
          Function: false,
          globalThis: false,
          hasOwnProperty: false,
          Infinity: false,
          Int16Array: false,
          Int32Array: false,
          Int8Array: false,
          isFinite: false,
          isNaN: false,
          isPrototypeOf: false,
          JSON: false,
          Map: false,
          Math: false,
          NaN: false,
          Number: false,
          Object: false,
          parseFloat: false,
          parseInt: false,
          Promise: false,
          propertyIsEnumerable: false,
          Proxy: false,
          RangeError: false,
          ReferenceError: false,
          Reflect: false,
          RegExp: false,
          Set: false,
          SharedArrayBuffer: false,
          String: false,
          Symbol: false,
          SyntaxError: false,
          toLocaleString: false,
          toString: false,
          TypeError: false,
          Uint16Array: false,
          Uint32Array: false,
          Uint8Array: false,
          Uint8ClampedArray: false,
          undefined: false,
          unescape: false,
          URIError: false,
          valueOf: false,
          WeakMap: false,
          WeakSet: false
        },
        es5: {
          Array: false,
          Boolean: false,
          constructor: false,
          Date: false,
          decodeURI: false,
          decodeURIComponent: false,
          encodeURI: false,
          encodeURIComponent: false,
          Error: false,
          escape: false,
          eval: false,
          EvalError: false,
          Function: false,
          hasOwnProperty: false,
          Infinity: false,
          isFinite: false,
          isNaN: false,
          isPrototypeOf: false,
          JSON: false,
          Math: false,
          NaN: false,
          Number: false,
          Object: false,
          parseFloat: false,
          parseInt: false,
          propertyIsEnumerable: false,
          RangeError: false,
          ReferenceError: false,
          RegExp: false,
          String: false,
          SyntaxError: false,
          toLocaleString: false,
          toString: false,
          TypeError: false,
          undefined: false,
          unescape: false,
          URIError: false,
          valueOf: false
        },
        es2015: {
          Array: false,
          ArrayBuffer: false,
          Boolean: false,
          constructor: false,
          DataView: false,
          Date: false,
          decodeURI: false,
          decodeURIComponent: false,
          encodeURI: false,
          encodeURIComponent: false,
          Error: false,
          escape: false,
          eval: false,
          EvalError: false,
          Float32Array: false,
          Float64Array: false,
          Function: false,
          hasOwnProperty: false,
          Infinity: false,
          Int16Array: false,
          Int32Array: false,
          Int8Array: false,
          isFinite: false,
          isNaN: false,
          isPrototypeOf: false,
          JSON: false,
          Map: false,
          Math: false,
          NaN: false,
          Number: false,
          Object: false,
          parseFloat: false,
          parseInt: false,
          Promise: false,
          propertyIsEnumerable: false,
          Proxy: false,
          RangeError: false,
          ReferenceError: false,
          Reflect: false,
          RegExp: false,
          Set: false,
          String: false,
          Symbol: false,
          SyntaxError: false,
          toLocaleString: false,
          toString: false,
          TypeError: false,
          Uint16Array: false,
          Uint32Array: false,
          Uint8Array: false,
          Uint8ClampedArray: false,
          undefined: false,
          unescape: false,
          URIError: false,
          valueOf: false,
          WeakMap: false,
          WeakSet: false
        },
        es2017: {
          Array: false,
          ArrayBuffer: false,
          Atomics: false,
          Boolean: false,
          constructor: false,
          DataView: false,
          Date: false,
          decodeURI: false,
          decodeURIComponent: false,
          encodeURI: false,
          encodeURIComponent: false,
          Error: false,
          escape: false,
          eval: false,
          EvalError: false,
          Float32Array: false,
          Float64Array: false,
          Function: false,
          hasOwnProperty: false,
          Infinity: false,
          Int16Array: false,
          Int32Array: false,
          Int8Array: false,
          isFinite: false,
          isNaN: false,
          isPrototypeOf: false,
          JSON: false,
          Map: false,
          Math: false,
          NaN: false,
          Number: false,
          Object: false,
          parseFloat: false,
          parseInt: false,
          Promise: false,
          propertyIsEnumerable: false,
          Proxy: false,
          RangeError: false,
          ReferenceError: false,
          Reflect: false,
          RegExp: false,
          Set: false,
          SharedArrayBuffer: false,
          String: false,
          Symbol: false,
          SyntaxError: false,
          toLocaleString: false,
          toString: false,
          TypeError: false,
          Uint16Array: false,
          Uint32Array: false,
          Uint8Array: false,
          Uint8ClampedArray: false,
          undefined: false,
          unescape: false,
          URIError: false,
          valueOf: false,
          WeakMap: false,
          WeakSet: false
        },
        browser: {
          AbortController: false,
          AbortSignal: false,
          addEventListener: false,
          alert: false,
          AnalyserNode: false,
          Animation: false,
          AnimationEffectReadOnly: false,
          AnimationEffectTiming: false,
          AnimationEffectTimingReadOnly: false,
          AnimationEvent: false,
          AnimationPlaybackEvent: false,
          AnimationTimeline: false,
          applicationCache: false,
          ApplicationCache: false,
          ApplicationCacheErrorEvent: false,
          atob: false,
          Attr: false,
          Audio: false,
          AudioBuffer: false,
          AudioBufferSourceNode: false,
          AudioContext: false,
          AudioDestinationNode: false,
          AudioListener: false,
          AudioNode: false,
          AudioParam: false,
          AudioProcessingEvent: false,
          AudioScheduledSourceNode: false,
          "AudioWorkletGlobalScope ": false,
          AudioWorkletNode: false,
          AudioWorkletProcessor: false,
          BarProp: false,
          BaseAudioContext: false,
          BatteryManager: false,
          BeforeUnloadEvent: false,
          BiquadFilterNode: false,
          Blob: false,
          BlobEvent: false,
          blur: false,
          BroadcastChannel: false,
          btoa: false,
          BudgetService: false,
          ByteLengthQueuingStrategy: false,
          Cache: false,
          caches: false,
          CacheStorage: false,
          cancelAnimationFrame: false,
          cancelIdleCallback: false,
          CanvasCaptureMediaStreamTrack: false,
          CanvasGradient: false,
          CanvasPattern: false,
          CanvasRenderingContext2D: false,
          ChannelMergerNode: false,
          ChannelSplitterNode: false,
          CharacterData: false,
          clearInterval: false,
          clearTimeout: false,
          clientInformation: false,
          ClipboardEvent: false,
          close: false,
          closed: false,
          CloseEvent: false,
          Comment: false,
          CompositionEvent: false,
          confirm: false,
          console: false,
          ConstantSourceNode: false,
          ConvolverNode: false,
          CountQueuingStrategy: false,
          createImageBitmap: false,
          Credential: false,
          CredentialsContainer: false,
          crypto: false,
          Crypto: false,
          CryptoKey: false,
          CSS: false,
          CSSConditionRule: false,
          CSSFontFaceRule: false,
          CSSGroupingRule: false,
          CSSImportRule: false,
          CSSKeyframeRule: false,
          CSSKeyframesRule: false,
          CSSMediaRule: false,
          CSSNamespaceRule: false,
          CSSPageRule: false,
          CSSRule: false,
          CSSRuleList: false,
          CSSStyleDeclaration: false,
          CSSStyleRule: false,
          CSSStyleSheet: false,
          CSSSupportsRule: false,
          CustomElementRegistry: false,
          customElements: false,
          CustomEvent: false,
          DataTransfer: false,
          DataTransferItem: false,
          DataTransferItemList: false,
          defaultstatus: false,
          defaultStatus: false,
          DelayNode: false,
          DeviceMotionEvent: false,
          DeviceOrientationEvent: false,
          devicePixelRatio: false,
          dispatchEvent: false,
          document: false,
          Document: false,
          DocumentFragment: false,
          DocumentType: false,
          DOMError: false,
          DOMException: false,
          DOMImplementation: false,
          DOMMatrix: false,
          DOMMatrixReadOnly: false,
          DOMParser: false,
          DOMPoint: false,
          DOMPointReadOnly: false,
          DOMQuad: false,
          DOMRect: false,
          DOMRectReadOnly: false,
          DOMStringList: false,
          DOMStringMap: false,
          DOMTokenList: false,
          DragEvent: false,
          DynamicsCompressorNode: false,
          Element: false,
          ErrorEvent: false,
          event: false,
          Event: false,
          EventSource: false,
          EventTarget: false,
          external: false,
          fetch: false,
          File: false,
          FileList: false,
          FileReader: false,
          find: false,
          focus: false,
          FocusEvent: false,
          FontFace: false,
          FontFaceSetLoadEvent: false,
          FormData: false,
          frameElement: false,
          frames: false,
          GainNode: false,
          Gamepad: false,
          GamepadButton: false,
          GamepadEvent: false,
          getComputedStyle: false,
          getSelection: false,
          HashChangeEvent: false,
          Headers: false,
          history: false,
          History: false,
          HTMLAllCollection: false,
          HTMLAnchorElement: false,
          HTMLAreaElement: false,
          HTMLAudioElement: false,
          HTMLBaseElement: false,
          HTMLBodyElement: false,
          HTMLBRElement: false,
          HTMLButtonElement: false,
          HTMLCanvasElement: false,
          HTMLCollection: false,
          HTMLContentElement: false,
          HTMLDataElement: false,
          HTMLDataListElement: false,
          HTMLDetailsElement: false,
          HTMLDialogElement: false,
          HTMLDirectoryElement: false,
          HTMLDivElement: false,
          HTMLDListElement: false,
          HTMLDocument: false,
          HTMLElement: false,
          HTMLEmbedElement: false,
          HTMLFieldSetElement: false,
          HTMLFontElement: false,
          HTMLFormControlsCollection: false,
          HTMLFormElement: false,
          HTMLFrameElement: false,
          HTMLFrameSetElement: false,
          HTMLHeadElement: false,
          HTMLHeadingElement: false,
          HTMLHRElement: false,
          HTMLHtmlElement: false,
          HTMLIFrameElement: false,
          HTMLImageElement: false,
          HTMLInputElement: false,
          HTMLLabelElement: false,
          HTMLLegendElement: false,
          HTMLLIElement: false,
          HTMLLinkElement: false,
          HTMLMapElement: false,
          HTMLMarqueeElement: false,
          HTMLMediaElement: false,
          HTMLMenuElement: false,
          HTMLMetaElement: false,
          HTMLMeterElement: false,
          HTMLModElement: false,
          HTMLObjectElement: false,
          HTMLOListElement: false,
          HTMLOptGroupElement: false,
          HTMLOptionElement: false,
          HTMLOptionsCollection: false,
          HTMLOutputElement: false,
          HTMLParagraphElement: false,
          HTMLParamElement: false,
          HTMLPictureElement: false,
          HTMLPreElement: false,
          HTMLProgressElement: false,
          HTMLQuoteElement: false,
          HTMLScriptElement: false,
          HTMLSelectElement: false,
          HTMLShadowElement: false,
          HTMLSlotElement: false,
          HTMLSourceElement: false,
          HTMLSpanElement: false,
          HTMLStyleElement: false,
          HTMLTableCaptionElement: false,
          HTMLTableCellElement: false,
          HTMLTableColElement: false,
          HTMLTableElement: false,
          HTMLTableRowElement: false,
          HTMLTableSectionElement: false,
          HTMLTemplateElement: false,
          HTMLTextAreaElement: false,
          HTMLTimeElement: false,
          HTMLTitleElement: false,
          HTMLTrackElement: false,
          HTMLUListElement: false,
          HTMLUnknownElement: false,
          HTMLVideoElement: false,
          IDBCursor: false,
          IDBCursorWithValue: false,
          IDBDatabase: false,
          IDBFactory: false,
          IDBIndex: false,
          IDBKeyRange: false,
          IDBObjectStore: false,
          IDBOpenDBRequest: false,
          IDBRequest: false,
          IDBTransaction: false,
          IDBVersionChangeEvent: false,
          IdleDeadline: false,
          IIRFilterNode: false,
          Image: false,
          ImageBitmap: false,
          ImageBitmapRenderingContext: false,
          ImageCapture: false,
          ImageData: false,
          indexedDB: false,
          innerHeight: false,
          innerWidth: false,
          InputEvent: false,
          IntersectionObserver: false,
          IntersectionObserverEntry: false,
          Intl: false,
          isSecureContext: false,
          KeyboardEvent: false,
          KeyframeEffect: false,
          KeyframeEffectReadOnly: false,
          length: false,
          localStorage: false,
          location: true,
          Location: false,
          locationbar: false,
          matchMedia: false,
          MediaDeviceInfo: false,
          MediaDevices: false,
          MediaElementAudioSourceNode: false,
          MediaEncryptedEvent: false,
          MediaError: false,
          MediaKeyMessageEvent: false,
          MediaKeySession: false,
          MediaKeyStatusMap: false,
          MediaKeySystemAccess: false,
          MediaList: false,
          MediaQueryList: false,
          MediaQueryListEvent: false,
          MediaRecorder: false,
          MediaSettingsRange: false,
          MediaSource: false,
          MediaStream: false,
          MediaStreamAudioDestinationNode: false,
          MediaStreamAudioSourceNode: false,
          MediaStreamEvent: false,
          MediaStreamTrack: false,
          MediaStreamTrackEvent: false,
          menubar: false,
          MessageChannel: false,
          MessageEvent: false,
          MessagePort: false,
          MIDIAccess: false,
          MIDIConnectionEvent: false,
          MIDIInput: false,
          MIDIInputMap: false,
          MIDIMessageEvent: false,
          MIDIOutput: false,
          MIDIOutputMap: false,
          MIDIPort: false,
          MimeType: false,
          MimeTypeArray: false,
          MouseEvent: false,
          moveBy: false,
          moveTo: false,
          MutationEvent: false,
          MutationObserver: false,
          MutationRecord: false,
          name: false,
          NamedNodeMap: false,
          NavigationPreloadManager: false,
          navigator: false,
          Navigator: false,
          NetworkInformation: false,
          Node: false,
          NodeFilter: false,
          NodeIterator: false,
          NodeList: false,
          Notification: false,
          OfflineAudioCompletionEvent: false,
          OfflineAudioContext: false,
          offscreenBuffering: false,
          OffscreenCanvas: true,
          onabort: true,
          onafterprint: true,
          onanimationend: true,
          onanimationiteration: true,
          onanimationstart: true,
          onappinstalled: true,
          onauxclick: true,
          onbeforeinstallprompt: true,
          onbeforeprint: true,
          onbeforeunload: true,
          onblur: true,
          oncancel: true,
          oncanplay: true,
          oncanplaythrough: true,
          onchange: true,
          onclick: true,
          onclose: true,
          oncontextmenu: true,
          oncuechange: true,
          ondblclick: true,
          ondevicemotion: true,
          ondeviceorientation: true,
          ondeviceorientationabsolute: true,
          ondrag: true,
          ondragend: true,
          ondragenter: true,
          ondragleave: true,
          ondragover: true,
          ondragstart: true,
          ondrop: true,
          ondurationchange: true,
          onemptied: true,
          onended: true,
          onerror: true,
          onfocus: true,
          ongotpointercapture: true,
          onhashchange: true,
          oninput: true,
          oninvalid: true,
          onkeydown: true,
          onkeypress: true,
          onkeyup: true,
          onlanguagechange: true,
          onload: true,
          onloadeddata: true,
          onloadedmetadata: true,
          onloadstart: true,
          onlostpointercapture: true,
          onmessage: true,
          onmessageerror: true,
          onmousedown: true,
          onmouseenter: true,
          onmouseleave: true,
          onmousemove: true,
          onmouseout: true,
          onmouseover: true,
          onmouseup: true,
          onmousewheel: true,
          onoffline: true,
          ononline: true,
          onpagehide: true,
          onpageshow: true,
          onpause: true,
          onplay: true,
          onplaying: true,
          onpointercancel: true,
          onpointerdown: true,
          onpointerenter: true,
          onpointerleave: true,
          onpointermove: true,
          onpointerout: true,
          onpointerover: true,
          onpointerup: true,
          onpopstate: true,
          onprogress: true,
          onratechange: true,
          onrejectionhandled: true,
          onreset: true,
          onresize: true,
          onscroll: true,
          onsearch: true,
          onseeked: true,
          onseeking: true,
          onselect: true,
          onstalled: true,
          onstorage: true,
          onsubmit: true,
          onsuspend: true,
          ontimeupdate: true,
          ontoggle: true,
          ontransitionend: true,
          onunhandledrejection: true,
          onunload: true,
          onvolumechange: true,
          onwaiting: true,
          onwheel: true,
          open: false,
          openDatabase: false,
          opener: false,
          Option: false,
          origin: false,
          OscillatorNode: false,
          outerHeight: false,
          outerWidth: false,
          PageTransitionEvent: false,
          pageXOffset: false,
          pageYOffset: false,
          PannerNode: false,
          parent: false,
          Path2D: false,
          PaymentAddress: false,
          PaymentRequest: false,
          PaymentRequestUpdateEvent: false,
          PaymentResponse: false,
          performance: false,
          Performance: false,
          PerformanceEntry: false,
          PerformanceLongTaskTiming: false,
          PerformanceMark: false,
          PerformanceMeasure: false,
          PerformanceNavigation: false,
          PerformanceNavigationTiming: false,
          PerformanceObserver: false,
          PerformanceObserverEntryList: false,
          PerformancePaintTiming: false,
          PerformanceResourceTiming: false,
          PerformanceTiming: false,
          PeriodicWave: false,
          Permissions: false,
          PermissionStatus: false,
          personalbar: false,
          PhotoCapabilities: false,
          Plugin: false,
          PluginArray: false,
          PointerEvent: false,
          PopStateEvent: false,
          postMessage: false,
          Presentation: false,
          PresentationAvailability: false,
          PresentationConnection: false,
          PresentationConnectionAvailableEvent: false,
          PresentationConnectionCloseEvent: false,
          PresentationConnectionList: false,
          PresentationReceiver: false,
          PresentationRequest: false,
          print: false,
          ProcessingInstruction: false,
          ProgressEvent: false,
          PromiseRejectionEvent: false,
          prompt: false,
          PushManager: false,
          PushSubscription: false,
          PushSubscriptionOptions: false,
          queueMicrotask: false,
          RadioNodeList: false,
          Range: false,
          ReadableStream: false,
          registerProcessor: false,
          RemotePlayback: false,
          removeEventListener: false,
          Request: false,
          requestAnimationFrame: false,
          requestIdleCallback: false,
          resizeBy: false,
          ResizeObserver: false,
          ResizeObserverEntry: false,
          resizeTo: false,
          Response: false,
          RTCCertificate: false,
          RTCDataChannel: false,
          RTCDataChannelEvent: false,
          RTCDtlsTransport: false,
          RTCIceCandidate: false,
          RTCIceGatherer: false,
          RTCIceTransport: false,
          RTCPeerConnection: false,
          RTCPeerConnectionIceEvent: false,
          RTCRtpContributingSource: false,
          RTCRtpReceiver: false,
          RTCRtpSender: false,
          RTCSctpTransport: false,
          RTCSessionDescription: false,
          RTCStatsReport: false,
          RTCTrackEvent: false,
          screen: false,
          Screen: false,
          screenLeft: false,
          ScreenOrientation: false,
          screenTop: false,
          screenX: false,
          screenY: false,
          ScriptProcessorNode: false,
          scroll: false,
          scrollbars: false,
          scrollBy: false,
          scrollTo: false,
          scrollX: false,
          scrollY: false,
          SecurityPolicyViolationEvent: false,
          Selection: false,
          self: false,
          ServiceWorker: false,
          ServiceWorkerContainer: false,
          ServiceWorkerRegistration: false,
          sessionStorage: false,
          setInterval: false,
          setTimeout: false,
          ShadowRoot: false,
          SharedWorker: false,
          SourceBuffer: false,
          SourceBufferList: false,
          speechSynthesis: false,
          SpeechSynthesisEvent: false,
          SpeechSynthesisUtterance: false,
          StaticRange: false,
          status: false,
          statusbar: false,
          StereoPannerNode: false,
          stop: false,
          Storage: false,
          StorageEvent: false,
          StorageManager: false,
          styleMedia: false,
          StyleSheet: false,
          StyleSheetList: false,
          SubtleCrypto: false,
          SVGAElement: false,
          SVGAngle: false,
          SVGAnimatedAngle: false,
          SVGAnimatedBoolean: false,
          SVGAnimatedEnumeration: false,
          SVGAnimatedInteger: false,
          SVGAnimatedLength: false,
          SVGAnimatedLengthList: false,
          SVGAnimatedNumber: false,
          SVGAnimatedNumberList: false,
          SVGAnimatedPreserveAspectRatio: false,
          SVGAnimatedRect: false,
          SVGAnimatedString: false,
          SVGAnimatedTransformList: false,
          SVGAnimateElement: false,
          SVGAnimateMotionElement: false,
          SVGAnimateTransformElement: false,
          SVGAnimationElement: false,
          SVGCircleElement: false,
          SVGClipPathElement: false,
          SVGComponentTransferFunctionElement: false,
          SVGDefsElement: false,
          SVGDescElement: false,
          SVGDiscardElement: false,
          SVGElement: false,
          SVGEllipseElement: false,
          SVGFEBlendElement: false,
          SVGFEColorMatrixElement: false,
          SVGFEComponentTransferElement: false,
          SVGFECompositeElement: false,
          SVGFEConvolveMatrixElement: false,
          SVGFEDiffuseLightingElement: false,
          SVGFEDisplacementMapElement: false,
          SVGFEDistantLightElement: false,
          SVGFEDropShadowElement: false,
          SVGFEFloodElement: false,
          SVGFEFuncAElement: false,
          SVGFEFuncBElement: false,
          SVGFEFuncGElement: false,
          SVGFEFuncRElement: false,
          SVGFEGaussianBlurElement: false,
          SVGFEImageElement: false,
          SVGFEMergeElement: false,
          SVGFEMergeNodeElement: false,
          SVGFEMorphologyElement: false,
          SVGFEOffsetElement: false,
          SVGFEPointLightElement: false,
          SVGFESpecularLightingElement: false,
          SVGFESpotLightElement: false,
          SVGFETileElement: false,
          SVGFETurbulenceElement: false,
          SVGFilterElement: false,
          SVGForeignObjectElement: false,
          SVGGElement: false,
          SVGGeometryElement: false,
          SVGGradientElement: false,
          SVGGraphicsElement: false,
          SVGImageElement: false,
          SVGLength: false,
          SVGLengthList: false,
          SVGLinearGradientElement: false,
          SVGLineElement: false,
          SVGMarkerElement: false,
          SVGMaskElement: false,
          SVGMatrix: false,
          SVGMetadataElement: false,
          SVGMPathElement: false,
          SVGNumber: false,
          SVGNumberList: false,
          SVGPathElement: false,
          SVGPatternElement: false,
          SVGPoint: false,
          SVGPointList: false,
          SVGPolygonElement: false,
          SVGPolylineElement: false,
          SVGPreserveAspectRatio: false,
          SVGRadialGradientElement: false,
          SVGRect: false,
          SVGRectElement: false,
          SVGScriptElement: false,
          SVGSetElement: false,
          SVGStopElement: false,
          SVGStringList: false,
          SVGStyleElement: false,
          SVGSVGElement: false,
          SVGSwitchElement: false,
          SVGSymbolElement: false,
          SVGTextContentElement: false,
          SVGTextElement: false,
          SVGTextPathElement: false,
          SVGTextPositioningElement: false,
          SVGTitleElement: false,
          SVGTransform: false,
          SVGTransformList: false,
          SVGTSpanElement: false,
          SVGUnitTypes: false,
          SVGUseElement: false,
          SVGViewElement: false,
          TaskAttributionTiming: false,
          Text: false,
          TextDecoder: false,
          TextEncoder: false,
          TextEvent: false,
          TextMetrics: false,
          TextTrack: false,
          TextTrackCue: false,
          TextTrackCueList: false,
          TextTrackList: false,
          TimeRanges: false,
          toolbar: false,
          top: false,
          Touch: false,
          TouchEvent: false,
          TouchList: false,
          TrackEvent: false,
          TransitionEvent: false,
          TreeWalker: false,
          UIEvent: false,
          URL: false,
          URLSearchParams: false,
          ValidityState: false,
          visualViewport: false,
          VisualViewport: false,
          VTTCue: false,
          WaveShaperNode: false,
          WebAssembly: false,
          WebGL2RenderingContext: false,
          WebGLActiveInfo: false,
          WebGLBuffer: false,
          WebGLContextEvent: false,
          WebGLFramebuffer: false,
          WebGLProgram: false,
          WebGLQuery: false,
          WebGLRenderbuffer: false,
          WebGLRenderingContext: false,
          WebGLSampler: false,
          WebGLShader: false,
          WebGLShaderPrecisionFormat: false,
          WebGLSync: false,
          WebGLTexture: false,
          WebGLTransformFeedback: false,
          WebGLUniformLocation: false,
          WebGLVertexArrayObject: false,
          WebSocket: false,
          WheelEvent: false,
          window: false,
          Window: false,
          Worker: false,
          WritableStream: false,
          XMLDocument: false,
          XMLHttpRequest: false,
          XMLHttpRequestEventTarget: false,
          XMLHttpRequestUpload: false,
          XMLSerializer: false,
          XPathEvaluator: false,
          XPathExpression: false,
          XPathResult: false,
          XSLTProcessor: false
        },
        worker: {
          addEventListener: false,
          applicationCache: false,
          atob: false,
          Blob: false,
          BroadcastChannel: false,
          btoa: false,
          Cache: false,
          caches: false,
          clearInterval: false,
          clearTimeout: false,
          close: true,
          console: false,
          fetch: false,
          FileReaderSync: false,
          FormData: false,
          Headers: false,
          IDBCursor: false,
          IDBCursorWithValue: false,
          IDBDatabase: false,
          IDBFactory: false,
          IDBIndex: false,
          IDBKeyRange: false,
          IDBObjectStore: false,
          IDBOpenDBRequest: false,
          IDBRequest: false,
          IDBTransaction: false,
          IDBVersionChangeEvent: false,
          ImageData: false,
          importScripts: true,
          indexedDB: false,
          location: false,
          MessageChannel: false,
          MessagePort: false,
          name: false,
          navigator: false,
          Notification: false,
          onclose: true,
          onconnect: true,
          onerror: true,
          onlanguagechange: true,
          onmessage: true,
          onoffline: true,
          ononline: true,
          onrejectionhandled: true,
          onunhandledrejection: true,
          performance: false,
          Performance: false,
          PerformanceEntry: false,
          PerformanceMark: false,
          PerformanceMeasure: false,
          PerformanceNavigation: false,
          PerformanceResourceTiming: false,
          PerformanceTiming: false,
          postMessage: true,
          Promise: false,
          queueMicrotask: false,
          removeEventListener: false,
          Request: false,
          Response: false,
          self: true,
          ServiceWorkerRegistration: false,
          setInterval: false,
          setTimeout: false,
          TextDecoder: false,
          TextEncoder: false,
          URL: false,
          URLSearchParams: false,
          WebSocket: false,
          Worker: false,
          WorkerGlobalScope: false,
          XMLHttpRequest: false
        },
        node: {
          __dirname: false,
          __filename: false,
          Buffer: false,
          clearImmediate: false,
          clearInterval: false,
          clearTimeout: false,
          console: false,
          exports: true,
          global: false,
          Intl: false,
          module: false,
          process: false,
          queueMicrotask: false,
          require: false,
          setImmediate: false,
          setInterval: false,
          setTimeout: false,
          TextDecoder: false,
          TextEncoder: false,
          URL: false,
          URLSearchParams: false
        },
        commonjs: {
          exports: true,
          global: false,
          module: false,
          require: false
        },
        amd: {
          define: false,
          require: false
        },
        mocha: {
          after: false,
          afterEach: false,
          before: false,
          beforeEach: false,
          context: false,
          describe: false,
          it: false,
          mocha: false,
          run: false,
          setup: false,
          specify: false,
          suite: false,
          suiteSetup: false,
          suiteTeardown: false,
          teardown: false,
          test: false,
          xcontext: false,
          xdescribe: false,
          xit: false,
          xspecify: false
        },
        jasmine: {
          afterAll: false,
          afterEach: false,
          beforeAll: false,
          beforeEach: false,
          describe: false,
          expect: false,
          fail: false,
          fdescribe: false,
          fit: false,
          it: false,
          jasmine: false,
          pending: false,
          runs: false,
          spyOn: false,
          spyOnProperty: false,
          waits: false,
          waitsFor: false,
          xdescribe: false,
          xit: false
        },
        jest: {
          afterAll: false,
          afterEach: false,
          beforeAll: false,
          beforeEach: false,
          describe: false,
          expect: false,
          fdescribe: false,
          fit: false,
          it: false,
          jest: false,
          pit: false,
          require: false,
          test: false,
          xdescribe: false,
          xit: false,
          xtest: false
        },
        qunit: {
          asyncTest: false,
          deepEqual: false,
          equal: false,
          expect: false,
          module: false,
          notDeepEqual: false,
          notEqual: false,
          notOk: false,
          notPropEqual: false,
          notStrictEqual: false,
          ok: false,
          propEqual: false,
          QUnit: false,
          raises: false,
          start: false,
          stop: false,
          strictEqual: false,
          test: false,
          throws: false
        },
        phantomjs: {
          console: true,
          exports: true,
          phantom: true,
          require: true,
          WebPage: true
        },
        couch: {
          emit: false,
          exports: false,
          getRow: false,
          log: false,
          module: false,
          provides: false,
          require: false,
          respond: false,
          send: false,
          start: false,
          sum: false
        },
        rhino: {
          defineClass: false,
          deserialize: false,
          gc: false,
          help: false,
          importClass: false,
          importPackage: false,
          java: false,
          load: false,
          loadClass: false,
          Packages: false,
          print: false,
          quit: false,
          readFile: false,
          readUrl: false,
          runCommand: false,
          seal: false,
          serialize: false,
          spawn: false,
          sync: false,
          toint32: false,
          version: false
        },
        nashorn: {
          __DIR__: false,
          __FILE__: false,
          __LINE__: false,
          com: false,
          edu: false,
          exit: false,
          java: false,
          Java: false,
          javafx: false,
          JavaImporter: false,
          javax: false,
          JSAdapter: false,
          load: false,
          loadWithNewGlobal: false,
          org: false,
          Packages: false,
          print: false,
          quit: false
        },
        wsh: {
          ActiveXObject: true,
          Enumerator: true,
          GetObject: true,
          ScriptEngine: true,
          ScriptEngineBuildVersion: true,
          ScriptEngineMajorVersion: true,
          ScriptEngineMinorVersion: true,
          VBArray: true,
          WScript: true,
          WSH: true,
          XDomainRequest: true
        },
        jquery: {
          $: false,
          jQuery: false
        },
        yui: {
          YAHOO: false,
          YAHOO_config: false,
          YUI: false,
          YUI_config: false
        },
        shelljs: {
          cat: false,
          cd: false,
          chmod: false,
          config: false,
          cp: false,
          dirs: false,
          echo: false,
          env: false,
          error: false,
          exec: false,
          exit: false,
          find: false,
          grep: false,
          ln: false,
          ls: false,
          mkdir: false,
          mv: false,
          popd: false,
          pushd: false,
          pwd: false,
          rm: false,
          sed: false,
          set: false,
          target: false,
          tempdir: false,
          test: false,
          touch: false,
          which: false
        },
        prototypejs: {
          $: false,
          $$: false,
          $A: false,
          $break: false,
          $continue: false,
          $F: false,
          $H: false,
          $R: false,
          $w: false,
          Abstract: false,
          Ajax: false,
          Autocompleter: false,
          Builder: false,
          Class: false,
          Control: false,
          Draggable: false,
          Draggables: false,
          Droppables: false,
          Effect: false,
          Element: false,
          Enumerable: false,
          Event: false,
          Field: false,
          Form: false,
          Hash: false,
          Insertion: false,
          ObjectRange: false,
          PeriodicalExecuter: false,
          Position: false,
          Prototype: false,
          Scriptaculous: false,
          Selector: false,
          Sortable: false,
          SortableObserver: false,
          Sound: false,
          Template: false,
          Toggle: false,
          Try: false
        },
        meteor: {
          _: false,
          $: false,
          Accounts: false,
          AccountsClient: false,
          AccountsCommon: false,
          AccountsServer: false,
          App: false,
          Assets: false,
          Blaze: false,
          check: false,
          Cordova: false,
          DDP: false,
          DDPRateLimiter: false,
          DDPServer: false,
          Deps: false,
          EJSON: false,
          Email: false,
          HTTP: false,
          Log: false,
          Match: false,
          Meteor: false,
          Mongo: false,
          MongoInternals: false,
          Npm: false,
          Package: false,
          Plugin: false,
          process: false,
          Random: false,
          ReactiveDict: false,
          ReactiveVar: false,
          Router: false,
          ServiceConfiguration: false,
          Session: false,
          share: false,
          Spacebars: false,
          Template: false,
          Tinytest: false,
          Tracker: false,
          UI: false,
          Utils: false,
          WebApp: false,
          WebAppInternals: false
        },
        mongo: {
          _isWindows: false,
          _rand: false,
          BulkWriteResult: false,
          cat: false,
          cd: false,
          connect: false,
          db: false,
          getHostName: false,
          getMemInfo: false,
          hostname: false,
          ISODate: false,
          listFiles: false,
          load: false,
          ls: false,
          md5sumFile: false,
          mkdir: false,
          Mongo: false,
          NumberInt: false,
          NumberLong: false,
          ObjectId: false,
          PlanCache: false,
          print: false,
          printjson: false,
          pwd: false,
          quit: false,
          removeFile: false,
          rs: false,
          sh: false,
          UUID: false,
          version: false,
          WriteResult: false
        },
        applescript: {
          $: false,
          Application: false,
          Automation: false,
          console: false,
          delay: false,
          Library: false,
          ObjC: false,
          ObjectSpecifier: false,
          Path: false,
          Progress: false,
          Ref: false
        },
        serviceworker: {
          addEventListener: false,
          applicationCache: false,
          atob: false,
          Blob: false,
          BroadcastChannel: false,
          btoa: false,
          Cache: false,
          caches: false,
          CacheStorage: false,
          clearInterval: false,
          clearTimeout: false,
          Client: false,
          clients: false,
          Clients: false,
          close: true,
          console: false,
          ExtendableEvent: false,
          ExtendableMessageEvent: false,
          fetch: false,
          FetchEvent: false,
          FileReaderSync: false,
          FormData: false,
          Headers: false,
          IDBCursor: false,
          IDBCursorWithValue: false,
          IDBDatabase: false,
          IDBFactory: false,
          IDBIndex: false,
          IDBKeyRange: false,
          IDBObjectStore: false,
          IDBOpenDBRequest: false,
          IDBRequest: false,
          IDBTransaction: false,
          IDBVersionChangeEvent: false,
          ImageData: false,
          importScripts: false,
          indexedDB: false,
          location: false,
          MessageChannel: false,
          MessagePort: false,
          name: false,
          navigator: false,
          Notification: false,
          onclose: true,
          onconnect: true,
          onerror: true,
          onfetch: true,
          oninstall: true,
          onlanguagechange: true,
          onmessage: true,
          onmessageerror: true,
          onnotificationclick: true,
          onnotificationclose: true,
          onoffline: true,
          ononline: true,
          onpush: true,
          onpushsubscriptionchange: true,
          onrejectionhandled: true,
          onsync: true,
          onunhandledrejection: true,
          performance: false,
          Performance: false,
          PerformanceEntry: false,
          PerformanceMark: false,
          PerformanceMeasure: false,
          PerformanceNavigation: false,
          PerformanceResourceTiming: false,
          PerformanceTiming: false,
          postMessage: true,
          Promise: false,
          queueMicrotask: false,
          registration: false,
          removeEventListener: false,
          Request: false,
          Response: false,
          self: false,
          ServiceWorker: false,
          ServiceWorkerContainer: false,
          ServiceWorkerGlobalScope: false,
          ServiceWorkerMessageEvent: false,
          ServiceWorkerRegistration: false,
          setInterval: false,
          setTimeout: false,
          skipWaiting: false,
          TextDecoder: false,
          TextEncoder: false,
          URL: false,
          URLSearchParams: false,
          WebSocket: false,
          WindowClient: false,
          Worker: false,
          WorkerGlobalScope: false,
          XMLHttpRequest: false
        },
        atomtest: {
          advanceClock: false,
          fakeClearInterval: false,
          fakeClearTimeout: false,
          fakeSetInterval: false,
          fakeSetTimeout: false,
          resetTimeouts: false,
          waitsForPromise: false
        },
        embertest: {
          andThen: false,
          click: false,
          currentPath: false,
          currentRouteName: false,
          currentURL: false,
          fillIn: false,
          find: false,
          findAll: false,
          findWithAssert: false,
          keyEvent: false,
          pauseTest: false,
          resumeTest: false,
          triggerEvent: false,
          visit: false,
          wait: false
        },
        protractor: {
          $: false,
          $$: false,
          browser: false,
          by: false,
          By: false,
          DartObject: false,
          element: false,
          protractor: false
        },
        "shared-node-browser": {
          clearInterval: false,
          clearTimeout: false,
          console: false,
          setInterval: false,
          setTimeout: false,
          URL: false,
          URLSearchParams: false
        },
        webextensions: {
          browser: false,
          chrome: false,
          opr: false
        },
        greasemonkey: {
          cloneInto: false,
          createObjectIn: false,
          exportFunction: false,
          GM: false,
          GM_addStyle: false,
          GM_deleteValue: false,
          GM_getResourceText: false,
          GM_getResourceURL: false,
          GM_getValue: false,
          GM_info: false,
          GM_listValues: false,
          GM_log: false,
          GM_openInTab: false,
          GM_registerMenuCommand: false,
          GM_setClipboard: false,
          GM_setValue: false,
          GM_xmlhttpRequest: false,
          unsafeWindow: false
        },
        devtools: {
          $: false,
          $_: false,
          $$: false,
          $0: false,
          $1: false,
          $2: false,
          $3: false,
          $4: false,
          $x: false,
          chrome: false,
          clear: false,
          copy: false,
          debug: false,
          dir: false,
          dirxml: false,
          getEventListeners: false,
          inspect: false,
          keys: false,
          monitor: false,
          monitorEvents: false,
          profile: false,
          profileEnd: false,
          queryObjects: false,
          table: false,
          undebug: false,
          unmonitor: false,
          unmonitorEvents: false,
          values: false
        }
      };
    }
  });

  // node_modules/globals/index.js
  var require_globals2 = __commonJS({
    "node_modules/globals/index.js"(exports, module) {
      "use strict";
      module.exports = require_globals();
    }
  });

  // node_modules/@babel/traverse/lib/scope/index.js
  var require_scope = __commonJS({
    "node_modules/@babel/traverse/lib/scope/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _renamer = require_renamer();
      var _index = require_lib13();
      var _binding = require_binding();
      var _globals = require_globals2();
      var _t = require_lib4();
      var _cache = require_cache();
      var {
        NOT_LOCAL_BINDING,
        callExpression: callExpression4,
        cloneNode,
        getBindingIdentifiers,
        identifier: identifier4,
        isArrayExpression: isArrayExpression2,
        isBinary,
        isClass,
        isClassBody,
        isClassDeclaration,
        isExportAllDeclaration,
        isExportDefaultDeclaration,
        isExportNamedDeclaration,
        isFunctionDeclaration,
        isIdentifier: isIdentifier2,
        isImportDeclaration,
        isLiteral,
        isMethod,
        isModuleSpecifier,
        isNullLiteral,
        isObjectExpression,
        isProperty: isProperty2,
        isPureish,
        isRegExpLiteral,
        isSuper,
        isTaggedTemplateExpression,
        isTemplateLiteral,
        isThisExpression,
        isUnaryExpression,
        isVariableDeclaration,
        matchesPattern,
        memberExpression: memberExpression2,
        numericLiteral,
        toIdentifier,
        unaryExpression,
        variableDeclaration: variableDeclaration2,
        variableDeclarator: variableDeclarator2,
        isRecordExpression,
        isTupleExpression,
        isObjectProperty,
        isTopicReference,
        isMetaProperty,
        isPrivateName,
        isExportDeclaration
      } = _t;
      function gatherNodeParts(node, parts) {
        switch (node == null ? void 0 : node.type) {
          default:
            if (isImportDeclaration(node) || isExportDeclaration(node)) {
              if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
                gatherNodeParts(node.source, parts);
              } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {
                for (const e of node.specifiers)
                  gatherNodeParts(e, parts);
              } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
                gatherNodeParts(node.declaration, parts);
              }
            } else if (isModuleSpecifier(node)) {
              gatherNodeParts(node.local, parts);
            } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
              parts.push(node.value);
            }
            break;
          case "MemberExpression":
          case "OptionalMemberExpression":
          case "JSXMemberExpression":
            gatherNodeParts(node.object, parts);
            gatherNodeParts(node.property, parts);
            break;
          case "Identifier":
          case "JSXIdentifier":
            parts.push(node.name);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            gatherNodeParts(node.callee, parts);
            break;
          case "ObjectExpression":
          case "ObjectPattern":
            for (const e of node.properties) {
              gatherNodeParts(e, parts);
            }
            break;
          case "SpreadElement":
          case "RestElement":
            gatherNodeParts(node.argument, parts);
            break;
          case "ObjectProperty":
          case "ObjectMethod":
          case "ClassProperty":
          case "ClassMethod":
          case "ClassPrivateProperty":
          case "ClassPrivateMethod":
            gatherNodeParts(node.key, parts);
            break;
          case "ThisExpression":
            parts.push("this");
            break;
          case "Super":
            parts.push("super");
            break;
          case "Import":
            parts.push("import");
            break;
          case "DoExpression":
            parts.push("do");
            break;
          case "YieldExpression":
            parts.push("yield");
            gatherNodeParts(node.argument, parts);
            break;
          case "AwaitExpression":
            parts.push("await");
            gatherNodeParts(node.argument, parts);
            break;
          case "AssignmentExpression":
            gatherNodeParts(node.left, parts);
            break;
          case "VariableDeclarator":
            gatherNodeParts(node.id, parts);
            break;
          case "FunctionExpression":
          case "FunctionDeclaration":
          case "ClassExpression":
          case "ClassDeclaration":
            gatherNodeParts(node.id, parts);
            break;
          case "PrivateName":
            gatherNodeParts(node.id, parts);
            break;
          case "ParenthesizedExpression":
            gatherNodeParts(node.expression, parts);
            break;
          case "UnaryExpression":
          case "UpdateExpression":
            gatherNodeParts(node.argument, parts);
            break;
          case "MetaProperty":
            gatherNodeParts(node.meta, parts);
            gatherNodeParts(node.property, parts);
            break;
          case "JSXElement":
            gatherNodeParts(node.openingElement, parts);
            break;
          case "JSXOpeningElement":
            gatherNodeParts(node.name, parts);
            break;
          case "JSXFragment":
            gatherNodeParts(node.openingFragment, parts);
            break;
          case "JSXOpeningFragment":
            parts.push("Fragment");
            break;
          case "JSXNamespacedName":
            gatherNodeParts(node.namespace, parts);
            gatherNodeParts(node.name, parts);
            break;
        }
      }
      var collectorVisitor = {
        ForStatement(path) {
          const declar = path.get("init");
          if (declar.isVar()) {
            const {
              scope
            } = path;
            const parentScope = scope.getFunctionParent() || scope.getProgramParent();
            parentScope.registerBinding("var", declar);
          }
        },
        Declaration(path) {
          if (path.isBlockScoped())
            return;
          if (path.isImportDeclaration())
            return;
          if (path.isExportDeclaration())
            return;
          const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
          parent.registerDeclaration(path);
        },
        ImportDeclaration(path) {
          const parent = path.scope.getBlockParent();
          parent.registerDeclaration(path);
        },
        ReferencedIdentifier(path, state) {
          state.references.push(path);
        },
        ForXStatement(path, state) {
          const left = path.get("left");
          if (left.isPattern() || left.isIdentifier()) {
            state.constantViolations.push(path);
          } else if (left.isVar()) {
            const {
              scope
            } = path;
            const parentScope = scope.getFunctionParent() || scope.getProgramParent();
            parentScope.registerBinding("var", left);
          }
        },
        ExportDeclaration: {
          exit(path) {
            const {
              node,
              scope
            } = path;
            if (isExportAllDeclaration(node))
              return;
            const declar = node.declaration;
            if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
              const id = declar.id;
              if (!id)
                return;
              const binding = scope.getBinding(id.name);
              binding == null ? void 0 : binding.reference(path);
            } else if (isVariableDeclaration(declar)) {
              for (const decl of declar.declarations) {
                for (const name41 of Object.keys(getBindingIdentifiers(decl))) {
                  const binding = scope.getBinding(name41);
                  binding == null ? void 0 : binding.reference(path);
                }
              }
            }
          }
        },
        LabeledStatement(path) {
          path.scope.getBlockParent().registerDeclaration(path);
        },
        AssignmentExpression(path, state) {
          state.assignments.push(path);
        },
        UpdateExpression(path, state) {
          state.constantViolations.push(path);
        },
        UnaryExpression(path, state) {
          if (path.node.operator === "delete") {
            state.constantViolations.push(path);
          }
        },
        BlockScoped(path) {
          let scope = path.scope;
          if (scope.path === path)
            scope = scope.parent;
          const parent = scope.getBlockParent();
          parent.registerDeclaration(path);
          if (path.isClassDeclaration() && path.node.id) {
            const id = path.node.id;
            const name41 = id.name;
            path.scope.bindings[name41] = path.scope.parent.getBinding(name41);
          }
        },
        CatchClause(path) {
          path.scope.registerBinding("let", path);
        },
        Function(path) {
          const params = path.get("params");
          for (const param of params) {
            path.scope.registerBinding("param", param);
          }
          if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
            path.scope.registerBinding("local", path.get("id"), path);
          }
        },
        ClassExpression(path) {
          if (path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
            path.scope.registerBinding("local", path);
          }
        }
      };
      var uid = 0;
      var Scope = class {
        constructor(path) {
          this.uid = void 0;
          this.path = void 0;
          this.block = void 0;
          this.labels = void 0;
          this.inited = void 0;
          this.bindings = void 0;
          this.references = void 0;
          this.globals = void 0;
          this.uids = void 0;
          this.data = void 0;
          this.crawling = void 0;
          const {
            node
          } = path;
          const cached = _cache.scope.get(node);
          if ((cached == null ? void 0 : cached.path) === path) {
            return cached;
          }
          _cache.scope.set(node, this);
          this.uid = uid++;
          this.block = node;
          this.path = path;
          this.labels = /* @__PURE__ */ new Map();
          this.inited = false;
        }
        get parent() {
          var _parent;
          let parent, path = this.path;
          do {
            const shouldSkip = path.key === "key" || path.listKey === "decorators";
            path = path.parentPath;
            if (shouldSkip && path.isMethod())
              path = path.parentPath;
            if (path && path.isScope())
              parent = path;
          } while (path && !parent);
          return (_parent = parent) == null ? void 0 : _parent.scope;
        }
        get parentBlock() {
          return this.path.parent;
        }
        get hub() {
          return this.path.hub;
        }
        traverse(node, opts, state) {
          (0, _index.default)(node, opts, this, state, this.path);
        }
        generateDeclaredUidIdentifier(name41) {
          const id = this.generateUidIdentifier(name41);
          this.push({
            id
          });
          return cloneNode(id);
        }
        generateUidIdentifier(name41) {
          return identifier4(this.generateUid(name41));
        }
        generateUid(name41 = "temp") {
          name41 = toIdentifier(name41).replace(/^_+/, "").replace(/[0-9]+$/g, "");
          let uid2;
          let i = 1;
          do {
            uid2 = this._generateUid(name41, i);
            i++;
          } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
          const program2 = this.getProgramParent();
          program2.references[uid2] = true;
          program2.uids[uid2] = true;
          return uid2;
        }
        _generateUid(name41, i) {
          let id = name41;
          if (i > 1)
            id += i;
          return `_${id}`;
        }
        generateUidBasedOnNode(node, defaultName) {
          const parts = [];
          gatherNodeParts(node, parts);
          let id = parts.join("$");
          id = id.replace(/^_/, "") || defaultName || "ref";
          return this.generateUid(id.slice(0, 20));
        }
        generateUidIdentifierBasedOnNode(node, defaultName) {
          return identifier4(this.generateUidBasedOnNode(node, defaultName));
        }
        isStatic(node) {
          if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {
            return true;
          }
          if (isIdentifier2(node)) {
            const binding = this.getBinding(node.name);
            if (binding) {
              return binding.constant;
            } else {
              return this.hasBinding(node.name);
            }
          }
          return false;
        }
        maybeGenerateMemoised(node, dontPush) {
          if (this.isStatic(node)) {
            return null;
          } else {
            const id = this.generateUidIdentifierBasedOnNode(node);
            if (!dontPush) {
              this.push({
                id
              });
              return cloneNode(id);
            }
            return id;
          }
        }
        checkBlockScopedCollisions(local, kind, name41, id) {
          if (kind === "param")
            return;
          if (local.kind === "local")
            return;
          const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
          if (duplicate) {
            throw this.hub.buildError(id, `Duplicate declaration "${name41}"`, TypeError);
          }
        }
        rename(oldName, newName) {
          const binding = this.getBinding(oldName);
          if (binding) {
            newName || (newName = this.generateUidIdentifier(oldName).name);
            const renamer = new _renamer.default(binding, oldName, newName);
            return renamer.rename(arguments[2]);
          }
        }
        _renameFromMap(map, oldName, newName, value) {
          if (map[oldName]) {
            map[newName] = value;
            map[oldName] = null;
          }
        }
        dump() {
          const sep = "-".repeat(60);
          console.log(sep);
          let scope = this;
          do {
            console.log("#", scope.block.type);
            for (const name41 of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name41];
              console.log(" -", name41, {
                constant: binding.constant,
                references: binding.references,
                violations: binding.constantViolations.length,
                kind: binding.kind
              });
            }
          } while (scope = scope.parent);
          console.log(sep);
        }
        toArray(node, i, arrayLikeIsIterable) {
          if (isIdentifier2(node)) {
            const binding = this.getBinding(node.name);
            if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
              return node;
            }
          }
          if (isArrayExpression2(node)) {
            return node;
          }
          if (isIdentifier2(node, {
            name: "arguments"
          })) {
            return callExpression4(memberExpression2(memberExpression2(memberExpression2(identifier4("Array"), identifier4("prototype")), identifier4("slice")), identifier4("call")), [node]);
          }
          let helperName;
          const args = [node];
          if (i === true) {
            helperName = "toConsumableArray";
          } else if (typeof i === "number") {
            args.push(numericLiteral(i));
            helperName = "slicedToArray";
          } else {
            helperName = "toArray";
          }
          if (arrayLikeIsIterable) {
            args.unshift(this.hub.addHelper(helperName));
            helperName = "maybeArrayLike";
          }
          return callExpression4(this.hub.addHelper(helperName), args);
        }
        hasLabel(name41) {
          return !!this.getLabel(name41);
        }
        getLabel(name41) {
          return this.labels.get(name41);
        }
        registerLabel(path) {
          this.labels.set(path.node.label.name, path);
        }
        registerDeclaration(path) {
          if (path.isLabeledStatement()) {
            this.registerLabel(path);
          } else if (path.isFunctionDeclaration()) {
            this.registerBinding("hoisted", path.get("id"), path);
          } else if (path.isVariableDeclaration()) {
            const declarations = path.get("declarations");
            const {
              kind
            } = path.node;
            for (const declar of declarations) {
              this.registerBinding(kind === "using" ? "const" : kind, declar);
            }
          } else if (path.isClassDeclaration()) {
            if (path.node.declare)
              return;
            this.registerBinding("let", path);
          } else if (path.isImportDeclaration()) {
            const isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";
            const specifiers = path.get("specifiers");
            for (const specifier of specifiers) {
              const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
              this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
            }
          } else if (path.isExportDeclaration()) {
            const declar = path.get("declaration");
            if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
              this.registerDeclaration(declar);
            }
          } else {
            this.registerBinding("unknown", path);
          }
        }
        buildUndefinedNode() {
          return unaryExpression("void", numericLiteral(0), true);
        }
        registerConstantViolation(path) {
          const ids = path.getBindingIdentifiers();
          for (const name41 of Object.keys(ids)) {
            const binding = this.getBinding(name41);
            if (binding)
              binding.reassign(path);
          }
        }
        registerBinding(kind, path, bindingPath = path) {
          if (!kind)
            throw new ReferenceError("no `kind`");
          if (path.isVariableDeclaration()) {
            const declarators = path.get("declarations");
            for (const declar of declarators) {
              this.registerBinding(kind, declar);
            }
            return;
          }
          const parent = this.getProgramParent();
          const ids = path.getOuterBindingIdentifiers(true);
          for (const name41 of Object.keys(ids)) {
            parent.references[name41] = true;
            for (const id of ids[name41]) {
              const local = this.getOwnBinding(name41);
              if (local) {
                if (local.identifier === id)
                  continue;
                this.checkBlockScopedCollisions(local, kind, name41, id);
              }
              if (local) {
                this.registerConstantViolation(bindingPath);
              } else {
                this.bindings[name41] = new _binding.default({
                  identifier: id,
                  scope: this,
                  path: bindingPath,
                  kind
                });
              }
            }
          }
        }
        addGlobal(node) {
          this.globals[node.name] = node;
        }
        hasUid(name41) {
          let scope = this;
          do {
            if (scope.uids[name41])
              return true;
          } while (scope = scope.parent);
          return false;
        }
        hasGlobal(name41) {
          let scope = this;
          do {
            if (scope.globals[name41])
              return true;
          } while (scope = scope.parent);
          return false;
        }
        hasReference(name41) {
          return !!this.getProgramParent().references[name41];
        }
        isPure(node, constantsOnly) {
          if (isIdentifier2(node)) {
            const binding = this.getBinding(node.name);
            if (!binding)
              return false;
            if (constantsOnly)
              return binding.constant;
            return true;
          } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {
            return true;
          } else if (isClass(node)) {
            var _node$decorators;
            if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
              return false;
            }
            if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {
              return false;
            }
            return this.isPure(node.body, constantsOnly);
          } else if (isClassBody(node)) {
            for (const method of node.body) {
              if (!this.isPure(method, constantsOnly))
                return false;
            }
            return true;
          } else if (isBinary(node)) {
            return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
          } else if (isArrayExpression2(node) || isTupleExpression(node)) {
            for (const elem of node.elements) {
              if (elem !== null && !this.isPure(elem, constantsOnly))
                return false;
            }
            return true;
          } else if (isObjectExpression(node) || isRecordExpression(node)) {
            for (const prop of node.properties) {
              if (!this.isPure(prop, constantsOnly))
                return false;
            }
            return true;
          } else if (isMethod(node)) {
            var _node$decorators2;
            if (node.computed && !this.isPure(node.key, constantsOnly))
              return false;
            if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
              return false;
            }
            return true;
          } else if (isProperty2(node)) {
            var _node$decorators3;
            if (node.computed && !this.isPure(node.key, constantsOnly))
              return false;
            if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
              return false;
            }
            if (isObjectProperty(node) || node.static) {
              if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
                return false;
              }
            }
            return true;
          } else if (isUnaryExpression(node)) {
            return this.isPure(node.argument, constantsOnly);
          } else if (isTaggedTemplateExpression(node)) {
            return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
          } else if (isTemplateLiteral(node)) {
            for (const expression of node.expressions) {
              if (!this.isPure(expression, constantsOnly))
                return false;
            }
            return true;
          } else {
            return isPureish(node);
          }
        }
        setData(key, val) {
          return this.data[key] = val;
        }
        getData(key) {
          let scope = this;
          do {
            const data = scope.data[key];
            if (data != null)
              return data;
          } while (scope = scope.parent);
        }
        removeData(key) {
          let scope = this;
          do {
            const data = scope.data[key];
            if (data != null)
              scope.data[key] = null;
          } while (scope = scope.parent);
        }
        init() {
          if (!this.inited) {
            this.inited = true;
            this.crawl();
          }
        }
        crawl() {
          const path = this.path;
          this.references = /* @__PURE__ */ Object.create(null);
          this.bindings = /* @__PURE__ */ Object.create(null);
          this.globals = /* @__PURE__ */ Object.create(null);
          this.uids = /* @__PURE__ */ Object.create(null);
          this.data = /* @__PURE__ */ Object.create(null);
          const programParent = this.getProgramParent();
          if (programParent.crawling)
            return;
          const state = {
            references: [],
            constantViolations: [],
            assignments: []
          };
          this.crawling = true;
          if (path.type !== "Program" && collectorVisitor._exploded) {
            for (const visit of collectorVisitor.enter) {
              visit(path, state);
            }
            const typeVisitors = collectorVisitor[path.type];
            if (typeVisitors) {
              for (const visit of typeVisitors.enter) {
                visit(path, state);
              }
            }
          }
          path.traverse(collectorVisitor, state);
          this.crawling = false;
          for (const path2 of state.assignments) {
            const ids = path2.getBindingIdentifiers();
            for (const name41 of Object.keys(ids)) {
              if (path2.scope.getBinding(name41))
                continue;
              programParent.addGlobal(ids[name41]);
            }
            path2.scope.registerConstantViolation(path2);
          }
          for (const ref of state.references) {
            const binding = ref.scope.getBinding(ref.node.name);
            if (binding) {
              binding.reference(ref);
            } else {
              programParent.addGlobal(ref.node);
            }
          }
          for (const path2 of state.constantViolations) {
            path2.scope.registerConstantViolation(path2);
          }
        }
        push(opts) {
          let path = this.path;
          if (path.isPattern()) {
            path = this.getPatternParent().path;
          } else if (!path.isBlockStatement() && !path.isProgram()) {
            path = this.getBlockParent().path;
          }
          if (path.isSwitchStatement()) {
            path = (this.getFunctionParent() || this.getProgramParent()).path;
          }
          if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
            path.ensureBlock();
            path = path.get("body");
          }
          const unique = opts.unique;
          const kind = opts.kind || "var";
          const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
          const dataKey = `declaration:${kind}:${blockHoist}`;
          let declarPath = !unique && path.getData(dataKey);
          if (!declarPath) {
            const declar = variableDeclaration2(kind, []);
            declar._blockHoist = blockHoist;
            [declarPath] = path.unshiftContainer("body", [declar]);
            if (!unique)
              path.setData(dataKey, declarPath);
          }
          const declarator = variableDeclarator2(opts.id, opts.init);
          const len = declarPath.node.declarations.push(declarator);
          path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
        }
        getProgramParent() {
          let scope = this;
          do {
            if (scope.path.isProgram()) {
              return scope;
            }
          } while (scope = scope.parent);
          throw new Error("Couldn't find a Program");
        }
        getFunctionParent() {
          let scope = this;
          do {
            if (scope.path.isFunctionParent()) {
              return scope;
            }
          } while (scope = scope.parent);
          return null;
        }
        getBlockParent() {
          let scope = this;
          do {
            if (scope.path.isBlockParent()) {
              return scope;
            }
          } while (scope = scope.parent);
          throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
        }
        getPatternParent() {
          let scope = this;
          do {
            if (!scope.path.isPattern()) {
              return scope.getBlockParent();
            }
          } while (scope = scope.parent.parent);
          throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
        }
        getAllBindings() {
          const ids = /* @__PURE__ */ Object.create(null);
          let scope = this;
          do {
            for (const key of Object.keys(scope.bindings)) {
              if (key in ids === false) {
                ids[key] = scope.bindings[key];
              }
            }
            scope = scope.parent;
          } while (scope);
          return ids;
        }
        getAllBindingsOfKind(...kinds) {
          const ids = /* @__PURE__ */ Object.create(null);
          for (const kind of kinds) {
            let scope = this;
            do {
              for (const name41 of Object.keys(scope.bindings)) {
                const binding = scope.bindings[name41];
                if (binding.kind === kind)
                  ids[name41] = binding;
              }
              scope = scope.parent;
            } while (scope);
          }
          return ids;
        }
        bindingIdentifierEquals(name41, node) {
          return this.getBindingIdentifier(name41) === node;
        }
        getBinding(name41) {
          let scope = this;
          let previousPath;
          do {
            const binding = scope.getOwnBinding(name41);
            if (binding) {
              var _previousPath;
              if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {
              } else {
                return binding;
              }
            } else if (!binding && name41 === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
              break;
            }
            previousPath = scope.path;
          } while (scope = scope.parent);
        }
        getOwnBinding(name41) {
          return this.bindings[name41];
        }
        getBindingIdentifier(name41) {
          var _this$getBinding;
          return (_this$getBinding = this.getBinding(name41)) == null ? void 0 : _this$getBinding.identifier;
        }
        getOwnBindingIdentifier(name41) {
          const binding = this.bindings[name41];
          return binding == null ? void 0 : binding.identifier;
        }
        hasOwnBinding(name41) {
          return !!this.getOwnBinding(name41);
        }
        hasBinding(name41, opts) {
          var _opts, _opts2, _opts3;
          if (!name41)
            return false;
          if (this.hasOwnBinding(name41))
            return true;
          {
            if (typeof opts === "boolean")
              opts = {
                noGlobals: opts
              };
          }
          if (this.parentHasBinding(name41, opts))
            return true;
          if (!((_opts = opts) != null && _opts.noUids) && this.hasUid(name41))
            return true;
          if (!((_opts2 = opts) != null && _opts2.noGlobals) && Scope.globals.includes(name41))
            return true;
          if (!((_opts3 = opts) != null && _opts3.noGlobals) && Scope.contextVariables.includes(name41))
            return true;
          return false;
        }
        parentHasBinding(name41, opts) {
          var _this$parent;
          return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name41, opts);
        }
        moveBindingTo(name41, scope) {
          const info = this.getBinding(name41);
          if (info) {
            info.scope.removeOwnBinding(name41);
            info.scope = scope;
            scope.bindings[name41] = info;
          }
        }
        removeOwnBinding(name41) {
          delete this.bindings[name41];
        }
        removeBinding(name41) {
          var _this$getBinding2;
          (_this$getBinding2 = this.getBinding(name41)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name41);
          let scope = this;
          do {
            if (scope.uids[name41]) {
              scope.uids[name41] = false;
            }
          } while (scope = scope.parent);
        }
      };
      exports.default = Scope;
      Scope.globals = Object.keys(_globals.builtin);
      Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
    }
  });

  // node_modules/@babel/traverse/lib/path/ancestry.js
  var require_ancestry = __commonJS({
    "node_modules/@babel/traverse/lib/path/ancestry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.find = find2;
      exports.findParent = findParent;
      exports.getAncestry = getAncestry;
      exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
      exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
      exports.getFunctionParent = getFunctionParent;
      exports.getStatementParent = getStatementParent;
      exports.inType = inType;
      exports.isAncestor = isAncestor;
      exports.isDescendant = isDescendant;
      var _t = require_lib4();
      var {
        VISITOR_KEYS
      } = _t;
      function findParent(callback) {
        let path = this;
        while (path = path.parentPath) {
          if (callback(path))
            return path;
        }
        return null;
      }
      function find2(callback) {
        let path = this;
        do {
          if (callback(path))
            return path;
        } while (path = path.parentPath);
        return null;
      }
      function getFunctionParent() {
        return this.findParent((p) => p.isFunction());
      }
      function getStatementParent() {
        let path = this;
        do {
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
            break;
          } else {
            path = path.parentPath;
          }
        } while (path);
        if (path && (path.isProgram() || path.isFile())) {
          throw new Error("File/Program node, we can't possibly find a statement parent to this");
        }
        return path;
      }
      function getEarliestCommonAncestorFrom(paths) {
        return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
          let earliest;
          const keys = VISITOR_KEYS[deepest.type];
          for (const ancestry of ancestries) {
            const path = ancestry[i + 1];
            if (!earliest) {
              earliest = path;
              continue;
            }
            if (path.listKey && earliest.listKey === path.listKey) {
              if (path.key < earliest.key) {
                earliest = path;
                continue;
              }
            }
            const earliestKeyIndex = keys.indexOf(earliest.parentKey);
            const currentKeyIndex = keys.indexOf(path.parentKey);
            if (earliestKeyIndex > currentKeyIndex) {
              earliest = path;
            }
          }
          return earliest;
        });
      }
      function getDeepestCommonAncestorFrom(paths, filter) {
        if (!paths.length) {
          return this;
        }
        if (paths.length === 1) {
          return paths[0];
        }
        let minDepth = Infinity;
        let lastCommonIndex, lastCommon;
        const ancestries = paths.map((path) => {
          const ancestry = [];
          do {
            ancestry.unshift(path);
          } while ((path = path.parentPath) && path !== this);
          if (ancestry.length < minDepth) {
            minDepth = ancestry.length;
          }
          return ancestry;
        });
        const first = ancestries[0];
        depthLoop:
          for (let i = 0; i < minDepth; i++) {
            const shouldMatch = first[i];
            for (const ancestry of ancestries) {
              if (ancestry[i] !== shouldMatch) {
                break depthLoop;
              }
            }
            lastCommonIndex = i;
            lastCommon = shouldMatch;
          }
        if (lastCommon) {
          if (filter) {
            return filter(lastCommon, lastCommonIndex, ancestries);
          } else {
            return lastCommon;
          }
        } else {
          throw new Error("Couldn't find intersection");
        }
      }
      function getAncestry() {
        let path = this;
        const paths = [];
        do {
          paths.push(path);
        } while (path = path.parentPath);
        return paths;
      }
      function isAncestor(maybeDescendant) {
        return maybeDescendant.isDescendant(this);
      }
      function isDescendant(maybeAncestor) {
        return !!this.findParent((parent) => parent === maybeAncestor);
      }
      function inType(...candidateTypes) {
        let path = this;
        while (path) {
          for (const type of candidateTypes) {
            if (path.node.type === type)
              return true;
          }
          path = path.parentPath;
        }
        return false;
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/inference/util.js
  var require_util2 = __commonJS({
    "node_modules/@babel/traverse/lib/path/inference/util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUnionType = createUnionType;
      var _t = require_lib4();
      var {
        createFlowUnionType,
        createTSUnionType,
        createUnionTypeAnnotation,
        isFlowType,
        isTSType
      } = _t;
      function createUnionType(types) {
        {
          if (isFlowType(types[0])) {
            if (createFlowUnionType) {
              return createFlowUnionType(types);
            }
            return createUnionTypeAnnotation(types);
          } else {
            if (createTSUnionType) {
              return createTSUnionType(types);
            }
          }
        }
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
  var require_inferer_reference = __commonJS({
    "node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = _default;
      var _t = require_lib4();
      var _util = require_util2();
      var {
        BOOLEAN_NUMBER_BINARY_OPERATORS,
        createTypeAnnotationBasedOnTypeof,
        numberTypeAnnotation,
        voidTypeAnnotation
      } = _t;
      function _default(node) {
        if (!this.isReferenced())
          return;
        const binding = this.scope.getBinding(node.name);
        if (binding) {
          if (binding.identifier.typeAnnotation) {
            return binding.identifier.typeAnnotation;
          } else {
            return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
          }
        }
        if (node.name === "undefined") {
          return voidTypeAnnotation();
        } else if (node.name === "NaN" || node.name === "Infinity") {
          return numberTypeAnnotation();
        } else if (node.name === "arguments") {
        }
      }
      function getTypeAnnotationBindingConstantViolations(binding, path, name41) {
        const types = [];
        const functionConstantViolations = [];
        let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
        const testType = getConditionalAnnotation(binding, path, name41);
        if (testType) {
          const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
          constantViolations = constantViolations.filter((path2) => testConstantViolations.indexOf(path2) < 0);
          types.push(testType.typeAnnotation);
        }
        if (constantViolations.length) {
          constantViolations.push(...functionConstantViolations);
          for (const violation of constantViolations) {
            types.push(violation.getTypeAnnotation());
          }
        }
        if (!types.length) {
          return;
        }
        return (0, _util.createUnionType)(types);
      }
      function getConstantViolationsBefore(binding, path, functions) {
        const violations = binding.constantViolations.slice();
        violations.unshift(binding.path);
        return violations.filter((violation) => {
          violation = violation.resolve();
          const status = violation._guessExecutionStatusRelativeTo(path);
          if (functions && status === "unknown")
            functions.push(violation);
          return status === "before";
        });
      }
      function inferAnnotationFromBinaryExpression(name41, path) {
        const operator = path.node.operator;
        const right = path.get("right").resolve();
        const left = path.get("left").resolve();
        let target;
        if (left.isIdentifier({
          name: name41
        })) {
          target = right;
        } else if (right.isIdentifier({
          name: name41
        })) {
          target = left;
        }
        if (target) {
          if (operator === "===") {
            return target.getTypeAnnotation();
          }
          if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
            return numberTypeAnnotation();
          }
          return;
        }
        if (operator !== "===" && operator !== "==")
          return;
        let typeofPath;
        let typePath;
        if (left.isUnaryExpression({
          operator: "typeof"
        })) {
          typeofPath = left;
          typePath = right;
        } else if (right.isUnaryExpression({
          operator: "typeof"
        })) {
          typeofPath = right;
          typePath = left;
        }
        if (!typeofPath)
          return;
        if (!typeofPath.get("argument").isIdentifier({
          name: name41
        }))
          return;
        typePath = typePath.resolve();
        if (!typePath.isLiteral())
          return;
        const typeValue = typePath.node.value;
        if (typeof typeValue !== "string")
          return;
        return createTypeAnnotationBasedOnTypeof(typeValue);
      }
      function getParentConditionalPath(binding, path, name41) {
        let parentPath;
        while (parentPath = path.parentPath) {
          if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
            if (path.key === "test") {
              return;
            }
            return parentPath;
          }
          if (parentPath.isFunction()) {
            if (parentPath.parentPath.scope.getBinding(name41) !== binding)
              return;
          }
          path = parentPath;
        }
      }
      function getConditionalAnnotation(binding, path, name41) {
        const ifStatement = getParentConditionalPath(binding, path, name41);
        if (!ifStatement)
          return;
        const test = ifStatement.get("test");
        const paths = [test];
        const types = [];
        for (let i = 0; i < paths.length; i++) {
          const path2 = paths[i];
          if (path2.isLogicalExpression()) {
            if (path2.node.operator === "&&") {
              paths.push(path2.get("left"));
              paths.push(path2.get("right"));
            }
          } else if (path2.isBinaryExpression()) {
            const type = inferAnnotationFromBinaryExpression(name41, path2);
            if (type)
              types.push(type);
          }
        }
        if (types.length) {
          return {
            typeAnnotation: (0, _util.createUnionType)(types),
            ifStatement
          };
        }
        return getConditionalAnnotation(binding, ifStatement, name41);
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/inference/inferers.js
  var require_inferers = __commonJS({
    "node_modules/@babel/traverse/lib/path/inference/inferers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArrayExpression = ArrayExpression;
      exports.AssignmentExpression = AssignmentExpression;
      exports.BinaryExpression = BinaryExpression;
      exports.BooleanLiteral = BooleanLiteral;
      exports.CallExpression = CallExpression;
      exports.ConditionalExpression = ConditionalExpression;
      exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
      Object.defineProperty(exports, "Identifier", {
        enumerable: true,
        get: function() {
          return _infererReference.default;
        }
      });
      exports.LogicalExpression = LogicalExpression;
      exports.NewExpression = NewExpression;
      exports.NullLiteral = NullLiteral;
      exports.NumericLiteral = NumericLiteral;
      exports.ObjectExpression = ObjectExpression;
      exports.ParenthesizedExpression = ParenthesizedExpression;
      exports.RegExpLiteral = RegExpLiteral;
      exports.RestElement = RestElement;
      exports.SequenceExpression = SequenceExpression;
      exports.StringLiteral = StringLiteral;
      exports.TSAsExpression = TSAsExpression;
      exports.TSNonNullExpression = TSNonNullExpression;
      exports.TaggedTemplateExpression = TaggedTemplateExpression;
      exports.TemplateLiteral = TemplateLiteral;
      exports.TypeCastExpression = TypeCastExpression;
      exports.UnaryExpression = UnaryExpression;
      exports.UpdateExpression = UpdateExpression;
      exports.VariableDeclarator = VariableDeclarator;
      var _t = require_lib4();
      var _infererReference = require_inferer_reference();
      var _util = require_util2();
      var {
        BOOLEAN_BINARY_OPERATORS,
        BOOLEAN_UNARY_OPERATORS,
        NUMBER_BINARY_OPERATORS,
        NUMBER_UNARY_OPERATORS,
        STRING_UNARY_OPERATORS,
        anyTypeAnnotation,
        arrayTypeAnnotation,
        booleanTypeAnnotation,
        buildMatchMemberExpression,
        genericTypeAnnotation,
        identifier: identifier4,
        nullLiteralTypeAnnotation,
        numberTypeAnnotation,
        stringTypeAnnotation,
        tupleTypeAnnotation,
        unionTypeAnnotation,
        voidTypeAnnotation,
        isIdentifier: isIdentifier2
      } = _t;
      function VariableDeclarator() {
        if (!this.get("id").isIdentifier())
          return;
        return this.get("init").getTypeAnnotation();
      }
      function TypeCastExpression(node) {
        return node.typeAnnotation;
      }
      TypeCastExpression.validParent = true;
      function TSAsExpression(node) {
        return node.typeAnnotation;
      }
      TSAsExpression.validParent = true;
      function TSNonNullExpression() {
        return this.get("expression").getTypeAnnotation();
      }
      function NewExpression(node) {
        if (node.callee.type === "Identifier") {
          return genericTypeAnnotation(node.callee);
        }
      }
      function TemplateLiteral() {
        return stringTypeAnnotation();
      }
      function UnaryExpression(node) {
        const operator = node.operator;
        if (operator === "void") {
          return voidTypeAnnotation();
        } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
          return numberTypeAnnotation();
        } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
          return stringTypeAnnotation();
        } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
          return booleanTypeAnnotation();
        }
      }
      function BinaryExpression(node) {
        const operator = node.operator;
        if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
          return numberTypeAnnotation();
        } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
          return booleanTypeAnnotation();
        } else if (operator === "+") {
          const right = this.get("right");
          const left = this.get("left");
          if (left.isBaseType("number") && right.isBaseType("number")) {
            return numberTypeAnnotation();
          } else if (left.isBaseType("string") || right.isBaseType("string")) {
            return stringTypeAnnotation();
          }
          return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
        }
      }
      function LogicalExpression() {
        const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
        return (0, _util.createUnionType)(argumentTypes);
      }
      function ConditionalExpression() {
        const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
        return (0, _util.createUnionType)(argumentTypes);
      }
      function SequenceExpression() {
        return this.get("expressions").pop().getTypeAnnotation();
      }
      function ParenthesizedExpression() {
        return this.get("expression").getTypeAnnotation();
      }
      function AssignmentExpression() {
        return this.get("right").getTypeAnnotation();
      }
      function UpdateExpression(node) {
        const operator = node.operator;
        if (operator === "++" || operator === "--") {
          return numberTypeAnnotation();
        }
      }
      function StringLiteral() {
        return stringTypeAnnotation();
      }
      function NumericLiteral() {
        return numberTypeAnnotation();
      }
      function BooleanLiteral() {
        return booleanTypeAnnotation();
      }
      function NullLiteral() {
        return nullLiteralTypeAnnotation();
      }
      function RegExpLiteral() {
        return genericTypeAnnotation(identifier4("RegExp"));
      }
      function ObjectExpression() {
        return genericTypeAnnotation(identifier4("Object"));
      }
      function ArrayExpression() {
        return genericTypeAnnotation(identifier4("Array"));
      }
      function RestElement() {
        return ArrayExpression();
      }
      RestElement.validParent = true;
      function Func() {
        return genericTypeAnnotation(identifier4("Function"));
      }
      var isArrayFrom = buildMatchMemberExpression("Array.from");
      var isObjectKeys = buildMatchMemberExpression("Object.keys");
      var isObjectValues = buildMatchMemberExpression("Object.values");
      var isObjectEntries = buildMatchMemberExpression("Object.entries");
      function CallExpression() {
        const {
          callee
        } = this.node;
        if (isObjectKeys(callee)) {
          return arrayTypeAnnotation(stringTypeAnnotation());
        } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier2(callee, {
          name: "Array"
        })) {
          return arrayTypeAnnotation(anyTypeAnnotation());
        } else if (isObjectEntries(callee)) {
          return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
        }
        return resolveCall(this.get("callee"));
      }
      function TaggedTemplateExpression() {
        return resolveCall(this.get("tag"));
      }
      function resolveCall(callee) {
        callee = callee.resolve();
        if (callee.isFunction()) {
          const {
            node
          } = callee;
          if (node.async) {
            if (node.generator) {
              return genericTypeAnnotation(identifier4("AsyncIterator"));
            } else {
              return genericTypeAnnotation(identifier4("Promise"));
            }
          } else {
            if (node.generator) {
              return genericTypeAnnotation(identifier4("Iterator"));
            } else if (callee.node.returnType) {
              return callee.node.returnType;
            } else {
            }
          }
        }
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/inference/index.js
  var require_inference = __commonJS({
    "node_modules/@babel/traverse/lib/path/inference/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._getTypeAnnotation = _getTypeAnnotation;
      exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
      exports.couldBeBaseType = couldBeBaseType;
      exports.getTypeAnnotation = getTypeAnnotation;
      exports.isBaseType = isBaseType;
      exports.isGenericType = isGenericType;
      var inferers = require_inferers();
      var _t = require_lib4();
      var {
        anyTypeAnnotation,
        isAnyTypeAnnotation,
        isArrayTypeAnnotation,
        isBooleanTypeAnnotation,
        isEmptyTypeAnnotation,
        isFlowBaseAnnotation,
        isGenericTypeAnnotation,
        isIdentifier: isIdentifier2,
        isMixedTypeAnnotation,
        isNumberTypeAnnotation,
        isStringTypeAnnotation,
        isTSArrayType,
        isTSTypeAnnotation,
        isTSTypeReference,
        isTupleTypeAnnotation,
        isTypeAnnotation,
        isUnionTypeAnnotation,
        isVoidTypeAnnotation,
        stringTypeAnnotation,
        voidTypeAnnotation
      } = _t;
      function getTypeAnnotation() {
        let type = this.getData("typeAnnotation");
        if (type != null) {
          return type;
        }
        type = this._getTypeAnnotation() || anyTypeAnnotation();
        if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
          type = type.typeAnnotation;
        }
        this.setData("typeAnnotation", type);
        return type;
      }
      var typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
      function _getTypeAnnotation() {
        const node = this.node;
        if (!node) {
          if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
            const declar = this.parentPath.parentPath;
            const declarParent = declar.parentPath;
            if (declar.key === "left" && declarParent.isForInStatement()) {
              return stringTypeAnnotation();
            }
            if (declar.key === "left" && declarParent.isForOfStatement()) {
              return anyTypeAnnotation();
            }
            return voidTypeAnnotation();
          } else {
            return;
          }
        }
        if (node.typeAnnotation) {
          return node.typeAnnotation;
        }
        if (typeAnnotationInferringNodes.has(node)) {
          return;
        }
        typeAnnotationInferringNodes.add(node);
        try {
          var _inferer;
          let inferer = inferers[node.type];
          if (inferer) {
            return inferer.call(this, node);
          }
          inferer = inferers[this.parentPath.type];
          if ((_inferer = inferer) != null && _inferer.validParent) {
            return this.parentPath.getTypeAnnotation();
          }
        } finally {
          typeAnnotationInferringNodes.delete(node);
        }
      }
      function isBaseType(baseName, soft) {
        return _isBaseType(baseName, this.getTypeAnnotation(), soft);
      }
      function _isBaseType(baseName, type, soft) {
        if (baseName === "string") {
          return isStringTypeAnnotation(type);
        } else if (baseName === "number") {
          return isNumberTypeAnnotation(type);
        } else if (baseName === "boolean") {
          return isBooleanTypeAnnotation(type);
        } else if (baseName === "any") {
          return isAnyTypeAnnotation(type);
        } else if (baseName === "mixed") {
          return isMixedTypeAnnotation(type);
        } else if (baseName === "empty") {
          return isEmptyTypeAnnotation(type);
        } else if (baseName === "void") {
          return isVoidTypeAnnotation(type);
        } else {
          if (soft) {
            return false;
          } else {
            throw new Error(`Unknown base type ${baseName}`);
          }
        }
      }
      function couldBeBaseType(name41) {
        const type = this.getTypeAnnotation();
        if (isAnyTypeAnnotation(type))
          return true;
        if (isUnionTypeAnnotation(type)) {
          for (const type2 of type.types) {
            if (isAnyTypeAnnotation(type2) || _isBaseType(name41, type2, true)) {
              return true;
            }
          }
          return false;
        } else {
          return _isBaseType(name41, type, true);
        }
      }
      function baseTypeStrictlyMatches(rightArg) {
        const left = this.getTypeAnnotation();
        const right = rightArg.getTypeAnnotation();
        if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
          return right.type === left.type;
        }
        return false;
      }
      function isGenericType(genericName) {
        const type = this.getTypeAnnotation();
        if (genericName === "Array") {
          if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
            return true;
          }
        }
        return isGenericTypeAnnotation(type) && isIdentifier2(type.id, {
          name: genericName
        }) || isTSTypeReference(type) && isIdentifier2(type.typeName, {
          name: genericName
        });
      }
    }
  });

  // node_modules/@babel/helper-hoist-variables/lib/index.js
  var require_lib11 = __commonJS({
    "node_modules/@babel/helper-hoist-variables/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = hoistVariables;
      var _t = require_lib4();
      var {
        assignmentExpression,
        expressionStatement: expressionStatement2,
        identifier: identifier4
      } = _t;
      var visitor = {
        Scope(path, state) {
          if (state.kind === "let")
            path.skip();
        },
        FunctionParent(path) {
          path.skip();
        },
        VariableDeclaration(path, state) {
          if (state.kind && path.node.kind !== state.kind)
            return;
          const nodes = [];
          const declarations = path.get("declarations");
          let firstId;
          for (const declar of declarations) {
            firstId = declar.node.id;
            if (declar.node.init) {
              nodes.push(expressionStatement2(assignmentExpression("=", declar.node.id, declar.node.init)));
            }
            for (const name41 of Object.keys(declar.getBindingIdentifiers())) {
              state.emit(identifier4(name41), name41, declar.node.init !== null);
            }
          }
          if (path.parentPath.isFor({
            left: path.node
          })) {
            path.replaceWith(firstId);
          } else {
            path.replaceWithMultiple(nodes);
          }
        }
      };
      function hoistVariables(path, emit, kind = "var") {
        path.traverse(visitor, {
          kind,
          emit
        });
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/replacement.js
  var require_replacement = __commonJS({
    "node_modules/@babel/traverse/lib/path/replacement.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._replaceWith = _replaceWith;
      exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
      exports.replaceInline = replaceInline;
      exports.replaceWith = replaceWith;
      exports.replaceWithMultiple = replaceWithMultiple;
      exports.replaceWithSourceString = replaceWithSourceString;
      var _codeFrame = require_lib7();
      var _index = require_lib13();
      var _index2 = require_path();
      var _cache = require_cache();
      var _parser = require_lib();
      var _t = require_lib4();
      var _helperHoistVariables = require_lib11();
      var {
        FUNCTION_TYPES,
        arrowFunctionExpression: arrowFunctionExpression4,
        assignmentExpression,
        awaitExpression,
        blockStatement: blockStatement2,
        callExpression: callExpression4,
        cloneNode,
        expressionStatement: expressionStatement2,
        identifier: identifier4,
        inheritLeadingComments,
        inheritTrailingComments,
        inheritsComments,
        isExpression,
        isProgram: isProgram2,
        isStatement,
        removeComments,
        returnStatement: returnStatement2,
        toSequenceExpression,
        validate,
        yieldExpression
      } = _t;
      function replaceWithMultiple(nodes) {
        var _pathCache$get;
        this.resync();
        nodes = this._verifyNodeList(nodes);
        inheritLeadingComments(nodes[0], this.node);
        inheritTrailingComments(nodes[nodes.length - 1], this.node);
        (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);
        this.node = this.container[this.key] = null;
        const paths = this.insertAfter(nodes);
        if (this.node) {
          this.requeue();
        } else {
          this.remove();
        }
        return paths;
      }
      function replaceWithSourceString(replacement) {
        this.resync();
        let ast;
        try {
          replacement = `(${replacement})`;
          ast = (0, _parser.parse)(replacement);
        } catch (err) {
          const loc = err.loc;
          if (loc) {
            err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
              start: {
                line: loc.line,
                column: loc.column + 1
              }
            });
            err.code = "BABEL_REPLACE_SOURCE_ERROR";
          }
          throw err;
        }
        const expressionAST = ast.program.body[0].expression;
        _index.default.removeProperties(expressionAST);
        return this.replaceWith(expressionAST);
      }
      function replaceWith(replacementPath) {
        this.resync();
        if (this.removed) {
          throw new Error("You can't replace this node, we've already removed it");
        }
        let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
        if (!replacement) {
          throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
        }
        if (this.node === replacement) {
          return [this];
        }
        if (this.isProgram() && !isProgram2(replacement)) {
          throw new Error("You can only replace a Program root node with another Program node");
        }
        if (Array.isArray(replacement)) {
          throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
        }
        if (typeof replacement === "string") {
          throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
        }
        let nodePath = "";
        if (this.isNodeType("Statement") && isExpression(replacement)) {
          if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
            replacement = expressionStatement2(replacement);
            nodePath = "expression";
          }
        }
        if (this.isNodeType("Expression") && isStatement(replacement)) {
          if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
            return this.replaceExpressionWithStatements([replacement]);
          }
        }
        const oldNode = this.node;
        if (oldNode) {
          inheritsComments(replacement, oldNode);
          removeComments(oldNode);
        }
        this._replaceWith(replacement);
        this.type = replacement.type;
        this.setScope();
        this.requeue();
        return [nodePath ? this.get(nodePath) : this];
      }
      function _replaceWith(node) {
        var _pathCache$get2;
        if (!this.container) {
          throw new ReferenceError("Container is falsy");
        }
        if (this.inList) {
          validate(this.parent, this.key, [node]);
        } else {
          validate(this.parent, this.key, node);
        }
        this.debug(`Replace with ${node == null ? void 0 : node.type}`);
        (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);
        this.node = this.container[this.key] = node;
      }
      function replaceExpressionWithStatements(nodes) {
        this.resync();
        const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);
        if (nodesAsSequenceExpression) {
          return this.replaceWith(nodesAsSequenceExpression)[0].get("expressions");
        }
        const functionParent = this.getFunctionParent();
        const isParentAsync = functionParent == null ? void 0 : functionParent.is("async");
        const isParentGenerator = functionParent == null ? void 0 : functionParent.is("generator");
        const container = arrowFunctionExpression4([], blockStatement2(nodes));
        this.replaceWith(callExpression4(container, []));
        const callee = this.get("callee");
        (0, _helperHoistVariables.default)(callee.get("body"), (id) => {
          this.scope.push({
            id
          });
        }, "var");
        const completionRecords = this.get("callee").getCompletionRecords();
        for (const path of completionRecords) {
          if (!path.isExpressionStatement())
            continue;
          const loop = path.findParent((path2) => path2.isLoop());
          if (loop) {
            let uid = loop.getData("expressionReplacementReturnUid");
            if (!uid) {
              uid = callee.scope.generateDeclaredUidIdentifier("ret");
              callee.get("body").pushContainer("body", returnStatement2(cloneNode(uid)));
              loop.setData("expressionReplacementReturnUid", uid);
            } else {
              uid = identifier4(uid.name);
            }
            path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
          } else {
            path.replaceWith(returnStatement2(path.node.expression));
          }
        }
        callee.arrowFunctionToExpression();
        const newCallee = callee;
        const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
        const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
        if (needToAwaitFunction) {
          newCallee.set("async", true);
          if (!needToYieldFunction) {
            this.replaceWith(awaitExpression(this.node));
          }
        }
        if (needToYieldFunction) {
          newCallee.set("generator", true);
          this.replaceWith(yieldExpression(this.node, true));
        }
        return newCallee.get("body.body");
      }
      function replaceInline(nodes) {
        this.resync();
        if (Array.isArray(nodes)) {
          if (Array.isArray(this.container)) {
            nodes = this._verifyNodeList(nodes);
            const paths = this._containerInsertAfter(nodes);
            this.remove();
            return paths;
          } else {
            return this.replaceWithMultiple(nodes);
          }
        } else {
          return this.replaceWith(nodes);
        }
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/evaluation.js
  var require_evaluation = __commonJS({
    "node_modules/@babel/traverse/lib/path/evaluation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.evaluate = evaluate;
      exports.evaluateTruthy = evaluateTruthy;
      var VALID_CALLEES = ["String", "Number", "Math"];
      var INVALID_METHODS = ["random"];
      function isValidCallee(val) {
        return VALID_CALLEES.includes(val);
      }
      function isInvalidMethod(val) {
        return INVALID_METHODS.includes(val);
      }
      function evaluateTruthy() {
        const res = this.evaluate();
        if (res.confident)
          return !!res.value;
      }
      function deopt(path, state) {
        if (!state.confident)
          return;
        state.deoptPath = path;
        state.confident = false;
      }
      function evaluateCached(path, state) {
        const {
          node
        } = path;
        const {
          seen
        } = state;
        if (seen.has(node)) {
          const existing = seen.get(node);
          if (existing.resolved) {
            return existing.value;
          } else {
            deopt(path, state);
            return;
          }
        } else {
          const item = {
            resolved: false
          };
          seen.set(node, item);
          const val = _evaluate(path, state);
          if (state.confident) {
            item.resolved = true;
            item.value = val;
          }
          return val;
        }
      }
      function _evaluate(path, state) {
        if (!state.confident)
          return;
        if (path.isSequenceExpression()) {
          const exprs = path.get("expressions");
          return evaluateCached(exprs[exprs.length - 1], state);
        }
        if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
          return path.node.value;
        }
        if (path.isNullLiteral()) {
          return null;
        }
        if (path.isTemplateLiteral()) {
          return evaluateQuasis(path, path.node.quasis, state);
        }
        if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
          const object = path.get("tag.object");
          const {
            node: {
              name: name41
            }
          } = object;
          const property2 = path.get("tag.property");
          if (object.isIdentifier() && name41 === "String" && !path.scope.getBinding(name41) && property2.isIdentifier() && property2.node.name === "raw") {
            return evaluateQuasis(path, path.node.quasi.quasis, state, true);
          }
        }
        if (path.isConditionalExpression()) {
          const testResult = evaluateCached(path.get("test"), state);
          if (!state.confident)
            return;
          if (testResult) {
            return evaluateCached(path.get("consequent"), state);
          } else {
            return evaluateCached(path.get("alternate"), state);
          }
        }
        if (path.isExpressionWrapper()) {
          return evaluateCached(path.get("expression"), state);
        }
        if (path.isMemberExpression() && !path.parentPath.isCallExpression({
          callee: path.node
        })) {
          const property2 = path.get("property");
          const object = path.get("object");
          if (object.isLiteral()) {
            const value = object.node.value;
            const type = typeof value;
            let key = null;
            if (path.node.computed) {
              key = evaluateCached(property2, state);
              if (!state.confident)
                return;
            } else if (property2.isIdentifier()) {
              key = property2.node.name;
            }
            if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) {
              return value[key];
            }
          }
        }
        if (path.isReferencedIdentifier()) {
          const binding = path.scope.getBinding(path.node.name);
          if (binding && binding.constantViolations.length > 0) {
            return deopt(binding.path, state);
          }
          if (binding && path.node.start < binding.path.node.end) {
            return deopt(binding.path, state);
          }
          if (binding != null && binding.hasValue) {
            return binding.value;
          } else {
            if (path.node.name === "undefined") {
              return binding ? deopt(binding.path, state) : void 0;
            } else if (path.node.name === "Infinity") {
              return binding ? deopt(binding.path, state) : Infinity;
            } else if (path.node.name === "NaN") {
              return binding ? deopt(binding.path, state) : NaN;
            }
            const resolved = path.resolve();
            if (resolved === path) {
              return deopt(path, state);
            } else {
              return evaluateCached(resolved, state);
            }
          }
        }
        if (path.isUnaryExpression({
          prefix: true
        })) {
          if (path.node.operator === "void") {
            return void 0;
          }
          const argument = path.get("argument");
          if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
            return "function";
          }
          const arg = evaluateCached(argument, state);
          if (!state.confident)
            return;
          switch (path.node.operator) {
            case "!":
              return !arg;
            case "+":
              return +arg;
            case "-":
              return -arg;
            case "~":
              return ~arg;
            case "typeof":
              return typeof arg;
          }
        }
        if (path.isArrayExpression()) {
          const arr = [];
          const elems = path.get("elements");
          for (const elem of elems) {
            const elemValue = elem.evaluate();
            if (elemValue.confident) {
              arr.push(elemValue.value);
            } else {
              return deopt(elemValue.deopt, state);
            }
          }
          return arr;
        }
        if (path.isObjectExpression()) {
          const obj = {};
          const props = path.get("properties");
          for (const prop of props) {
            if (prop.isObjectMethod() || prop.isSpreadElement()) {
              return deopt(prop, state);
            }
            const keyPath = prop.get("key");
            let key;
            if (prop.node.computed) {
              key = keyPath.evaluate();
              if (!key.confident) {
                return deopt(key.deopt, state);
              }
              key = key.value;
            } else if (keyPath.isIdentifier()) {
              key = keyPath.node.name;
            } else {
              key = keyPath.node.value;
            }
            const valuePath = prop.get("value");
            let value = valuePath.evaluate();
            if (!value.confident) {
              return deopt(value.deopt, state);
            }
            value = value.value;
            obj[key] = value;
          }
          return obj;
        }
        if (path.isLogicalExpression()) {
          const wasConfident = state.confident;
          const left = evaluateCached(path.get("left"), state);
          const leftConfident = state.confident;
          state.confident = wasConfident;
          const right = evaluateCached(path.get("right"), state);
          const rightConfident = state.confident;
          switch (path.node.operator) {
            case "||":
              state.confident = leftConfident && (!!left || rightConfident);
              if (!state.confident)
                return;
              return left || right;
            case "&&":
              state.confident = leftConfident && (!left || rightConfident);
              if (!state.confident)
                return;
              return left && right;
            case "??":
              state.confident = leftConfident && (left != null || rightConfident);
              if (!state.confident)
                return;
              return left != null ? left : right;
          }
        }
        if (path.isBinaryExpression()) {
          const left = evaluateCached(path.get("left"), state);
          if (!state.confident)
            return;
          const right = evaluateCached(path.get("right"), state);
          if (!state.confident)
            return;
          switch (path.node.operator) {
            case "-":
              return left - right;
            case "+":
              return left + right;
            case "/":
              return left / right;
            case "*":
              return left * right;
            case "%":
              return left % right;
            case "**":
              return Math.pow(left, right);
            case "<":
              return left < right;
            case ">":
              return left > right;
            case "<=":
              return left <= right;
            case ">=":
              return left >= right;
            case "==":
              return left == right;
            case "!=":
              return left != right;
            case "===":
              return left === right;
            case "!==":
              return left !== right;
            case "|":
              return left | right;
            case "&":
              return left & right;
            case "^":
              return left ^ right;
            case "<<":
              return left << right;
            case ">>":
              return left >> right;
            case ">>>":
              return left >>> right;
          }
        }
        if (path.isCallExpression()) {
          const callee = path.get("callee");
          let context;
          let func2;
          if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name)) {
            func2 = global[callee.node.name];
          }
          if (callee.isMemberExpression()) {
            const object = callee.get("object");
            const property2 = callee.get("property");
            if (object.isIdentifier() && property2.isIdentifier() && isValidCallee(object.node.name) && !isInvalidMethod(property2.node.name)) {
              context = global[object.node.name];
              func2 = context[property2.node.name];
            }
            if (object.isLiteral() && property2.isIdentifier()) {
              const type = typeof object.node.value;
              if (type === "string" || type === "number") {
                context = object.node.value;
                func2 = context[property2.node.name];
              }
            }
          }
          if (func2) {
            const args = path.get("arguments").map((arg) => evaluateCached(arg, state));
            if (!state.confident)
              return;
            return func2.apply(context, args);
          }
        }
        deopt(path, state);
      }
      function evaluateQuasis(path, quasis, state, raw = false) {
        let str = "";
        let i = 0;
        const exprs = path.isTemplateLiteral() ? path.get("expressions") : path.get("quasi.expressions");
        for (const elem of quasis) {
          if (!state.confident)
            break;
          str += raw ? elem.value.raw : elem.value.cooked;
          const expr = exprs[i++];
          if (expr)
            str += String(evaluateCached(expr, state));
        }
        if (!state.confident)
          return;
        return str;
      }
      function evaluate() {
        const state = {
          confident: true,
          deoptPath: null,
          seen: /* @__PURE__ */ new Map()
        };
        let value = evaluateCached(this, state);
        if (!state.confident)
          value = void 0;
        return {
          confident: state.confident,
          deopt: state.deoptPath,
          value
        };
      }
    }
  });

  // node_modules/@babel/helper-function-name/lib/index.js
  var require_lib12 = __commonJS({
    "node_modules/@babel/helper-function-name/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = _default;
      var _template2 = require_lib8();
      var _t = require_lib4();
      var {
        NOT_LOCAL_BINDING,
        cloneNode,
        identifier: identifier4,
        isAssignmentExpression: isAssignmentExpression2,
        isAssignmentPattern,
        isFunction,
        isIdentifier: isIdentifier2,
        isLiteral,
        isNullLiteral,
        isObjectMethod,
        isObjectProperty,
        isRegExpLiteral,
        isRestElement,
        isTemplateLiteral,
        isVariableDeclarator,
        toBindingIdentifierName
      } = _t;
      function getFunctionArity(node) {
        const count = node.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
        return count === -1 ? node.params.length : count;
      }
      var buildPropertyMethodAssignmentWrapper = _template2.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`);
      var buildGeneratorPropertyMethodAssignmentWrapper = _template2.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`);
      var visitor = {
        "ReferencedIdentifier|BindingIdentifier"(path, state) {
          if (path.node.name !== state.name)
            return;
          const localDeclar = path.scope.getBindingIdentifier(state.name);
          if (localDeclar !== state.outerDeclar)
            return;
          state.selfReference = true;
          path.stop();
        }
      };
      function getNameFromLiteralId(id) {
        if (isNullLiteral(id)) {
          return "null";
        }
        if (isRegExpLiteral(id)) {
          return `_${id.pattern}_${id.flags}`;
        }
        if (isTemplateLiteral(id)) {
          return id.quasis.map((quasi) => quasi.value.raw).join("");
        }
        if (id.value !== void 0) {
          return id.value + "";
        }
        return "";
      }
      function wrap(state, method, id, scope) {
        if (state.selfReference) {
          if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
            scope.rename(id.name);
          } else {
            if (!isFunction(method))
              return;
            let build = buildPropertyMethodAssignmentWrapper;
            if (method.generator) {
              build = buildGeneratorPropertyMethodAssignmentWrapper;
            }
            const template = build({
              FUNCTION: method,
              FUNCTION_ID: id,
              FUNCTION_KEY: scope.generateUidIdentifier(id.name)
            }).expression;
            const params = template.callee.body.body[0].params;
            for (let i = 0, len = getFunctionArity(method); i < len; i++) {
              params.push(scope.generateUidIdentifier("x"));
            }
            return template;
          }
        }
        method.id = id;
        scope.getProgramParent().references[id.name] = true;
      }
      function visit(node, name41, scope) {
        const state = {
          selfAssignment: false,
          selfReference: false,
          outerDeclar: scope.getBindingIdentifier(name41),
          name: name41
        };
        const binding = scope.getOwnBinding(name41);
        if (binding) {
          if (binding.kind === "param") {
            state.selfReference = true;
          } else {
          }
        } else if (state.outerDeclar || scope.hasGlobal(name41)) {
          scope.traverse(node, visitor, state);
        }
        return state;
      }
      function _default({
        node,
        parent,
        scope,
        id
      }, localBinding = false, supportUnicodeId = false) {
        if (node.id)
          return;
        if ((isObjectProperty(parent) || isObjectMethod(parent, {
          kind: "method"
        })) && (!parent.computed || isLiteral(parent.key))) {
          id = parent.key;
        } else if (isVariableDeclarator(parent)) {
          id = parent.id;
          if (isIdentifier2(id) && !localBinding) {
            const binding = scope.parent.getBinding(id.name);
            if (binding && binding.constant && scope.getBinding(id.name) === binding) {
              node.id = cloneNode(id);
              node.id[NOT_LOCAL_BINDING] = true;
              return;
            }
          }
        } else if (isAssignmentExpression2(parent, {
          operator: "="
        })) {
          id = parent.left;
        } else if (!id) {
          return;
        }
        let name41;
        if (id && isLiteral(id)) {
          name41 = getNameFromLiteralId(id);
        } else if (id && isIdentifier2(id)) {
          name41 = id.name;
        }
        if (name41 === void 0) {
          return;
        }
        if (!supportUnicodeId && isFunction(node) && /[\uD800-\uDFFF]/.test(name41)) {
          return;
        }
        name41 = toBindingIdentifierName(name41);
        const newId = identifier4(name41);
        newId[NOT_LOCAL_BINDING] = true;
        const state = visit(node, name41, scope);
        return wrap(state, node, newId, scope) || node;
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/conversion.js
  var require_conversion = __commonJS({
    "node_modules/@babel/traverse/lib/path/conversion.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.arrowFunctionToExpression = arrowFunctionToExpression;
      exports.arrowFunctionToShadowed = arrowFunctionToShadowed;
      exports.ensureBlock = ensureBlock;
      exports.toComputedKey = toComputedKey;
      exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
      var _t = require_lib4();
      var _helperEnvironmentVisitor = require_lib10();
      var _helperFunctionName = require_lib12();
      var _visitors = require_visitors();
      var {
        arrowFunctionExpression: arrowFunctionExpression4,
        assignmentExpression,
        binaryExpression,
        blockStatement: blockStatement2,
        callExpression: callExpression4,
        conditionalExpression: conditionalExpression2,
        expressionStatement: expressionStatement2,
        identifier: identifier4,
        isIdentifier: isIdentifier2,
        jsxIdentifier,
        logicalExpression,
        LOGICAL_OPERATORS,
        memberExpression: memberExpression2,
        metaProperty,
        numericLiteral,
        objectExpression: objectExpression2,
        restElement,
        returnStatement: returnStatement2,
        sequenceExpression,
        spreadElement,
        stringLiteral: stringLiteral2,
        super: _super,
        thisExpression,
        toExpression,
        unaryExpression
      } = _t;
      function toComputedKey() {
        let key;
        if (this.isMemberExpression()) {
          key = this.node.property;
        } else if (this.isProperty() || this.isMethod()) {
          key = this.node.key;
        } else {
          throw new ReferenceError("todo");
        }
        if (!this.node.computed) {
          if (isIdentifier2(key))
            key = stringLiteral2(key.name);
        }
        return key;
      }
      function ensureBlock() {
        const body = this.get("body");
        const bodyNode = body.node;
        if (Array.isArray(body)) {
          throw new Error("Can't convert array path to a block statement");
        }
        if (!bodyNode) {
          throw new Error("Can't convert node without a body");
        }
        if (body.isBlockStatement()) {
          return bodyNode;
        }
        const statements = [];
        let stringPath = "body";
        let key;
        let listKey;
        if (body.isStatement()) {
          listKey = "body";
          key = 0;
          statements.push(body.node);
        } else {
          stringPath += ".body.0";
          if (this.isFunction()) {
            key = "argument";
            statements.push(returnStatement2(body.node));
          } else {
            key = "expression";
            statements.push(expressionStatement2(body.node));
          }
        }
        this.node.body = blockStatement2(statements);
        const parentPath = this.get(stringPath);
        body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
        return this.node;
      }
      function arrowFunctionToShadowed() {
        if (!this.isArrowFunctionExpression())
          return;
        this.arrowFunctionToExpression();
      }
      function unwrapFunctionEnvironment() {
        if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
          throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
        }
        hoistFunctionEnvironment(this);
      }
      function setType(path, type) {
        path.node.type = type;
      }
      function arrowFunctionToExpression({
        allowInsertArrow = true,
        allowInsertArrowWithRest = allowInsertArrow,
        specCompliant = false,
        noNewArrows = !specCompliant
      } = {}) {
        if (!this.isArrowFunctionExpression()) {
          throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
        }
        const {
          thisBinding,
          fnPath: fn
        } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
        fn.ensureBlock();
        setType(fn, "FunctionExpression");
        if (!noNewArrows) {
          const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
          if (checkBinding) {
            fn.parentPath.scope.push({
              id: checkBinding,
              init: objectExpression2([])
            });
          }
          fn.get("body").unshiftContainer("body", expressionStatement2(callExpression4(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier4(checkBinding.name) : identifier4(thisBinding)])));
          fn.replaceWith(callExpression4(memberExpression2((0, _helperFunctionName.default)(this, true) || fn.node, identifier4("bind")), [checkBinding ? identifier4(checkBinding.name) : thisExpression()]));
          return fn.get("callee.object");
        }
        return fn;
      }
      var getSuperCallsVisitor = (0, _visitors.merge)([{
        CallExpression(child, {
          allSuperCalls
        }) {
          if (!child.get("callee").isSuper())
            return;
          allSuperCalls.push(child);
        }
      }, _helperEnvironmentVisitor.default]);
      function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
        let arrowParent;
        let thisEnvFn = fnPath.findParent((p) => {
          if (p.isArrowFunctionExpression()) {
            var _arrowParent;
            (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;
            return false;
          }
          return p.isFunction() || p.isProgram() || p.isClassProperty({
            static: false
          }) || p.isClassPrivateProperty({
            static: false
          });
        });
        const inConstructor = thisEnvFn.isClassMethod({
          kind: "constructor"
        });
        if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
          if (arrowParent) {
            thisEnvFn = arrowParent;
          } else if (allowInsertArrow) {
            fnPath.replaceWith(callExpression4(arrowFunctionExpression4([], toExpression(fnPath.node)), []));
            thisEnvFn = fnPath.get("callee");
            fnPath = thisEnvFn.get("body");
          } else {
            throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
          }
        }
        const {
          thisPaths,
          argumentsPaths,
          newTargetPaths,
          superProps,
          superCalls
        } = getScopeInformation(fnPath);
        if (inConstructor && superCalls.length > 0) {
          if (!allowInsertArrow) {
            throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
          }
          if (!allowInsertArrowWithRest) {
            throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
          }
          const allSuperCalls = [];
          thisEnvFn.traverse(getSuperCallsVisitor, {
            allSuperCalls
          });
          const superBinding = getSuperBinding(thisEnvFn);
          allSuperCalls.forEach((superCall) => {
            const callee = identifier4(superBinding);
            callee.loc = superCall.node.callee.loc;
            superCall.get("callee").replaceWith(callee);
          });
        }
        if (argumentsPaths.length > 0) {
          const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
            const args = () => identifier4("arguments");
            if (thisEnvFn.scope.path.isProgram()) {
              return conditionalExpression2(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral2("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
            } else {
              return args();
            }
          });
          argumentsPaths.forEach((argumentsChild) => {
            const argsRef = identifier4(argumentsBinding);
            argsRef.loc = argumentsChild.node.loc;
            argumentsChild.replaceWith(argsRef);
          });
        }
        if (newTargetPaths.length > 0) {
          const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier4("new"), identifier4("target")));
          newTargetPaths.forEach((targetChild) => {
            const targetRef = identifier4(newTargetBinding);
            targetRef.loc = targetChild.node.loc;
            targetChild.replaceWith(targetRef);
          });
        }
        if (superProps.length > 0) {
          if (!allowInsertArrow) {
            throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
          }
          const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
          flatSuperProps.forEach((superProp) => {
            const key = superProp.node.computed ? "" : superProp.get("property").node.name;
            const superParentPath = superProp.parentPath;
            const isAssignment = superParentPath.isAssignmentExpression({
              left: superProp.node
            });
            const isCall = superParentPath.isCallExpression({
              callee: superProp.node
            });
            const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
              tag: superProp.node
            });
            const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
            const args = [];
            if (superProp.node.computed) {
              args.push(superProp.get("property").node);
            }
            if (isAssignment) {
              const value = superParentPath.node.right;
              args.push(value);
            }
            const call = callExpression4(identifier4(superBinding), args);
            if (isCall) {
              superParentPath.unshiftContainer("arguments", thisExpression());
              superProp.replaceWith(memberExpression2(call, identifier4("call")));
              thisPaths.push(superParentPath.get("arguments.0"));
            } else if (isAssignment) {
              superParentPath.replaceWith(call);
            } else if (isTaggedTemplate) {
              superProp.replaceWith(callExpression4(memberExpression2(call, identifier4("bind"), false), [thisExpression()]));
              thisPaths.push(superProp.get("arguments.0"));
            } else {
              superProp.replaceWith(call);
            }
          });
        }
        let thisBinding;
        if (thisPaths.length > 0 || !noNewArrows) {
          thisBinding = getThisBinding(thisEnvFn, inConstructor);
          if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
            thisPaths.forEach((thisChild) => {
              const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier4(thisBinding);
              thisRef.loc = thisChild.node.loc;
              thisChild.replaceWith(thisRef);
            });
            if (!noNewArrows)
              thisBinding = null;
          }
        }
        return {
          thisBinding,
          fnPath
        };
      }
      function isLogicalOp(op) {
        return LOGICAL_OPERATORS.includes(op);
      }
      function standardizeSuperProperty(superProp) {
        if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
          const assignmentPath = superProp.parentPath;
          const op = assignmentPath.node.operator.slice(0, -1);
          const value = assignmentPath.node.right;
          const isLogicalAssignment = isLogicalOp(op);
          if (superProp.node.computed) {
            const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
            const object = superProp.node.object;
            const property2 = superProp.node.property;
            assignmentPath.get("left").replaceWith(memberExpression2(object, assignmentExpression("=", tmp, property2), true));
            assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression2(object, identifier4(tmp.name), true), value));
          } else {
            const object = superProp.node.object;
            const property2 = superProp.node.property;
            assignmentPath.get("left").replaceWith(memberExpression2(object, property2));
            assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression2(object, identifier4(property2.name)), value));
          }
          if (isLogicalAssignment) {
            assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
          } else {
            assignmentPath.node.operator = "=";
          }
          return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
        } else if (superProp.parentPath.isUpdateExpression()) {
          const updateExpr = superProp.parentPath;
          const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
          const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
          const parts = [assignmentExpression("=", tmp, memberExpression2(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression2(superProp.node.object, computedKey ? identifier4(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier4(tmp.name), numericLiteral(1)))];
          if (!superProp.parentPath.node.prefix) {
            parts.push(identifier4(tmp.name));
          }
          updateExpr.replaceWith(sequenceExpression(parts));
          const left = updateExpr.get("expressions.0.right");
          const right = updateExpr.get("expressions.1.left");
          return [left, right];
        }
        return [superProp];
        function rightExpression(op, left, right) {
          if (op === "=") {
            return assignmentExpression("=", left, right);
          } else {
            return binaryExpression(op, left, right);
          }
        }
      }
      function hasSuperClass(thisEnvFn) {
        return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
      }
      var assignSuperThisVisitor = (0, _visitors.merge)([{
        CallExpression(child, {
          supers,
          thisBinding
        }) {
          if (!child.get("callee").isSuper())
            return;
          if (supers.has(child.node))
            return;
          supers.add(child.node);
          child.replaceWithMultiple([child.node, assignmentExpression("=", identifier4(thisBinding), identifier4("this"))]);
        }
      }, _helperEnvironmentVisitor.default]);
      function getThisBinding(thisEnvFn, inConstructor) {
        return getBinding(thisEnvFn, "this", (thisBinding) => {
          if (!inConstructor || !hasSuperClass(thisEnvFn))
            return thisExpression();
          thisEnvFn.traverse(assignSuperThisVisitor, {
            supers: /* @__PURE__ */ new WeakSet(),
            thisBinding
          });
        });
      }
      function getSuperBinding(thisEnvFn) {
        return getBinding(thisEnvFn, "supercall", () => {
          const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
          return arrowFunctionExpression4([restElement(argsBinding)], callExpression4(_super(), [spreadElement(identifier4(argsBinding.name))]));
        });
      }
      function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
        const op = isAssignment ? "set" : "get";
        return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
          const argsList = [];
          let fnBody;
          if (propName) {
            fnBody = memberExpression2(_super(), identifier4(propName));
          } else {
            const method = thisEnvFn.scope.generateUidIdentifier("prop");
            argsList.unshift(method);
            fnBody = memberExpression2(_super(), identifier4(method.name), true);
          }
          if (isAssignment) {
            const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
            argsList.push(valueIdent);
            fnBody = assignmentExpression("=", fnBody, identifier4(valueIdent.name));
          }
          return arrowFunctionExpression4(argsList, fnBody);
        });
      }
      function getBinding(thisEnvFn, key, init) {
        const cacheKey = "binding:" + key;
        let data = thisEnvFn.getData(cacheKey);
        if (!data) {
          const id = thisEnvFn.scope.generateUidIdentifier(key);
          data = id.name;
          thisEnvFn.setData(cacheKey, data);
          thisEnvFn.scope.push({
            id,
            init: init(data)
          });
        }
        return data;
      }
      var getScopeInformationVisitor = (0, _visitors.merge)([{
        ThisExpression(child, {
          thisPaths
        }) {
          thisPaths.push(child);
        },
        JSXIdentifier(child, {
          thisPaths
        }) {
          if (child.node.name !== "this")
            return;
          if (!child.parentPath.isJSXMemberExpression({
            object: child.node
          }) && !child.parentPath.isJSXOpeningElement({
            name: child.node
          })) {
            return;
          }
          thisPaths.push(child);
        },
        CallExpression(child, {
          superCalls
        }) {
          if (child.get("callee").isSuper())
            superCalls.push(child);
        },
        MemberExpression(child, {
          superProps
        }) {
          if (child.get("object").isSuper())
            superProps.push(child);
        },
        Identifier(child, {
          argumentsPaths
        }) {
          if (!child.isReferencedIdentifier({
            name: "arguments"
          }))
            return;
          let curr = child.scope;
          do {
            if (curr.hasOwnBinding("arguments")) {
              curr.rename("arguments");
              return;
            }
            if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
              break;
            }
          } while (curr = curr.parent);
          argumentsPaths.push(child);
        },
        MetaProperty(child, {
          newTargetPaths
        }) {
          if (!child.get("meta").isIdentifier({
            name: "new"
          }))
            return;
          if (!child.get("property").isIdentifier({
            name: "target"
          }))
            return;
          newTargetPaths.push(child);
        }
      }, _helperEnvironmentVisitor.default]);
      function getScopeInformation(fnPath) {
        const thisPaths = [];
        const argumentsPaths = [];
        const newTargetPaths = [];
        const superProps = [];
        const superCalls = [];
        fnPath.traverse(getScopeInformationVisitor, {
          thisPaths,
          argumentsPaths,
          newTargetPaths,
          superProps,
          superCalls
        });
        return {
          thisPaths,
          argumentsPaths,
          newTargetPaths,
          superProps,
          superCalls
        };
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/introspection.js
  var require_introspection = __commonJS({
    "node_modules/@babel/traverse/lib/path/introspection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
      exports._resolve = _resolve;
      exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
      exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
      exports.equals = equals;
      exports.getSource = getSource;
      exports.has = has;
      exports.is = void 0;
      exports.isCompletionRecord = isCompletionRecord;
      exports.isConstantExpression = isConstantExpression;
      exports.isInStrictMode = isInStrictMode;
      exports.isNodeType = isNodeType;
      exports.isStatementOrBlock = isStatementOrBlock;
      exports.isStatic = isStatic;
      exports.isnt = isnt;
      exports.matchesPattern = matchesPattern;
      exports.referencesImport = referencesImport;
      exports.resolve = resolve;
      exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
      var _t = require_lib4();
      var {
        STATEMENT_OR_BLOCK_KEYS,
        VISITOR_KEYS,
        isBlockStatement,
        isExpression,
        isIdentifier: isIdentifier2,
        isLiteral,
        isStringLiteral,
        isType: isType2,
        matchesPattern: _matchesPattern
      } = _t;
      function matchesPattern(pattern, allowPartial) {
        return _matchesPattern(this.node, pattern, allowPartial);
      }
      function has(key) {
        const val = this.node && this.node[key];
        if (val && Array.isArray(val)) {
          return !!val.length;
        } else {
          return !!val;
        }
      }
      function isStatic() {
        return this.scope.isStatic(this.node);
      }
      var is2 = has;
      exports.is = is2;
      function isnt(key) {
        return !this.has(key);
      }
      function equals(key, value) {
        return this.node[key] === value;
      }
      function isNodeType(type) {
        return isType2(this.type, type);
      }
      function canHaveVariableDeclarationOrExpression() {
        return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
      }
      function canSwapBetweenExpressionAndStatement(replacement) {
        if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
          return false;
        }
        if (this.isExpression()) {
          return isBlockStatement(replacement);
        } else if (this.isBlockStatement()) {
          return isExpression(replacement);
        }
        return false;
      }
      function isCompletionRecord(allowInsideFunction) {
        let path = this;
        let first = true;
        do {
          const {
            type,
            container
          } = path;
          if (!first && (path.isFunction() || type === "StaticBlock")) {
            return !!allowInsideFunction;
          }
          first = false;
          if (Array.isArray(container) && path.key !== container.length - 1) {
            return false;
          }
        } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());
        return true;
      }
      function isStatementOrBlock() {
        if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
          return false;
        } else {
          return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
        }
      }
      function referencesImport(moduleSource, importName) {
        if (!this.isReferencedIdentifier()) {
          if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
            value: importName
          }) : this.node.property.name === importName)) {
            const object = this.get("object");
            return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
          }
          return false;
        }
        const binding = this.scope.getBinding(this.node.name);
        if (!binding || binding.kind !== "module")
          return false;
        const path = binding.path;
        const parent = path.parentPath;
        if (!parent.isImportDeclaration())
          return false;
        if (parent.node.source.value === moduleSource) {
          if (!importName)
            return true;
        } else {
          return false;
        }
        if (path.isImportDefaultSpecifier() && importName === "default") {
          return true;
        }
        if (path.isImportNamespaceSpecifier() && importName === "*") {
          return true;
        }
        if (path.isImportSpecifier() && isIdentifier2(path.node.imported, {
          name: importName
        })) {
          return true;
        }
        return false;
      }
      function getSource() {
        const node = this.node;
        if (node.end) {
          const code2 = this.hub.getCode();
          if (code2)
            return code2.slice(node.start, node.end);
        }
        return "";
      }
      function willIMaybeExecuteBefore(target) {
        return this._guessExecutionStatusRelativeTo(target) !== "after";
      }
      function getOuterFunction(path) {
        return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
      }
      function isExecutionUncertain(type, key) {
        switch (type) {
          case "LogicalExpression":
            return key === "right";
          case "ConditionalExpression":
          case "IfStatement":
            return key === "consequent" || key === "alternate";
          case "WhileStatement":
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForOfStatement":
            return key === "body";
          case "ForStatement":
            return key === "body" || key === "update";
          case "SwitchStatement":
            return key === "cases";
          case "TryStatement":
            return key === "handler";
          case "AssignmentPattern":
            return key === "right";
          case "OptionalMemberExpression":
            return key === "property";
          case "OptionalCallExpression":
            return key === "arguments";
          default:
            return false;
        }
      }
      function isExecutionUncertainInList(paths, maxIndex) {
        for (let i = 0; i < maxIndex; i++) {
          const path = paths[i];
          if (isExecutionUncertain(path.parent.type, path.parentKey)) {
            return true;
          }
        }
        return false;
      }
      var SYMBOL_CHECKING = Symbol();
      function _guessExecutionStatusRelativeTo(target) {
        return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
      }
      function _guessExecutionStatusRelativeToCached(base, target, cache) {
        const funcParent = {
          this: getOuterFunction(base),
          target: getOuterFunction(target)
        };
        if (funcParent.target.node !== funcParent.this.node) {
          return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
        }
        const paths = {
          target: target.getAncestry(),
          this: base.getAncestry()
        };
        if (paths.target.indexOf(base) >= 0)
          return "after";
        if (paths.this.indexOf(target) >= 0)
          return "before";
        let commonPath;
        const commonIndex = {
          target: 0,
          this: 0
        };
        while (!commonPath && commonIndex.this < paths.this.length) {
          const path = paths.this[commonIndex.this];
          commonIndex.target = paths.target.indexOf(path);
          if (commonIndex.target >= 0) {
            commonPath = path;
          } else {
            commonIndex.this++;
          }
        }
        if (!commonPath) {
          throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
        }
        if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
          return "unknown";
        }
        const divergence = {
          this: paths.this[commonIndex.this - 1],
          target: paths.target[commonIndex.target - 1]
        };
        if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
          return divergence.target.key > divergence.this.key ? "before" : "after";
        }
        const keys = VISITOR_KEYS[commonPath.type];
        const keyPosition = {
          this: keys.indexOf(divergence.this.parentKey),
          target: keys.indexOf(divergence.target.parentKey)
        };
        return keyPosition.target > keyPosition.this ? "before" : "after";
      }
      function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {
        if (!target.isFunctionDeclaration()) {
          if (_guessExecutionStatusRelativeToCached(base, target, cache) === "before") {
            return "before";
          }
          return "unknown";
        } else if (target.parentPath.isExportDeclaration()) {
          return "unknown";
        }
        const binding = target.scope.getBinding(target.node.id.name);
        if (!binding.references)
          return "before";
        const referencePaths = binding.referencePaths;
        let allStatus;
        for (const path of referencePaths) {
          const childOfFunction = !!path.find((path2) => path2.node === target.node);
          if (childOfFunction)
            continue;
          if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
            return "unknown";
          }
          const status = _guessExecutionStatusRelativeToCached(base, path, cache);
          if (allStatus && allStatus !== status) {
            return "unknown";
          } else {
            allStatus = status;
          }
        }
        return allStatus;
      }
      function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {
        let nodeMap = cache.get(base.node);
        let cached;
        if (!nodeMap) {
          cache.set(base.node, nodeMap = /* @__PURE__ */ new Map());
        } else if (cached = nodeMap.get(target.node)) {
          if (cached === SYMBOL_CHECKING) {
            return "unknown";
          }
          return cached;
        }
        nodeMap.set(target.node, SYMBOL_CHECKING);
        const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
        nodeMap.set(target.node, result);
        return result;
      }
      function resolve(dangerous, resolved) {
        return this._resolve(dangerous, resolved) || this;
      }
      function _resolve(dangerous, resolved) {
        if (resolved && resolved.indexOf(this) >= 0)
          return;
        resolved = resolved || [];
        resolved.push(this);
        if (this.isVariableDeclarator()) {
          if (this.get("id").isIdentifier()) {
            return this.get("init").resolve(dangerous, resolved);
          } else {
          }
        } else if (this.isReferencedIdentifier()) {
          const binding = this.scope.getBinding(this.node.name);
          if (!binding)
            return;
          if (!binding.constant)
            return;
          if (binding.kind === "module")
            return;
          if (binding.path !== this) {
            const ret = binding.path.resolve(dangerous, resolved);
            if (this.find((parent) => parent.node === ret.node))
              return;
            return ret;
          }
        } else if (this.isTypeCastExpression()) {
          return this.get("expression").resolve(dangerous, resolved);
        } else if (dangerous && this.isMemberExpression()) {
          const targetKey = this.toComputedKey();
          if (!isLiteral(targetKey))
            return;
          const targetName = targetKey.value;
          const target = this.get("object").resolve(dangerous, resolved);
          if (target.isObjectExpression()) {
            const props = target.get("properties");
            for (const prop of props) {
              if (!prop.isProperty())
                continue;
              const key = prop.get("key");
              let match = prop.isnt("computed") && key.isIdentifier({
                name: targetName
              });
              match = match || key.isLiteral({
                value: targetName
              });
              if (match)
                return prop.get("value").resolve(dangerous, resolved);
            }
          } else if (target.isArrayExpression() && !isNaN(+targetName)) {
            const elems = target.get("elements");
            const elem = elems[targetName];
            if (elem)
              return elem.resolve(dangerous, resolved);
          }
        }
      }
      function isConstantExpression() {
        if (this.isIdentifier()) {
          const binding = this.scope.getBinding(this.node.name);
          if (!binding)
            return false;
          return binding.constant;
        }
        if (this.isLiteral()) {
          if (this.isRegExpLiteral()) {
            return false;
          }
          if (this.isTemplateLiteral()) {
            return this.get("expressions").every((expression) => expression.isConstantExpression());
          }
          return true;
        }
        if (this.isUnaryExpression()) {
          if (this.node.operator !== "void") {
            return false;
          }
          return this.get("argument").isConstantExpression();
        }
        if (this.isBinaryExpression()) {
          const {
            operator
          } = this.node;
          return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
        }
        return false;
      }
      function isInStrictMode() {
        const start = this.isProgram() ? this : this.parentPath;
        const strictParent = start.find((path) => {
          if (path.isProgram({
            sourceType: "module"
          }))
            return true;
          if (path.isClass())
            return true;
          if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
            return false;
          }
          let body;
          if (path.isFunction()) {
            body = path.node.body;
          } else if (path.isProgram()) {
            body = path.node;
          } else {
            return false;
          }
          for (const directive of body.directives) {
            if (directive.value.value === "use strict") {
              return true;
            }
          }
        });
        return !!strictParent;
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/context.js
  var require_context = __commonJS({
    "node_modules/@babel/traverse/lib/path/context.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._call = _call;
      exports._getQueueContexts = _getQueueContexts;
      exports._resyncKey = _resyncKey;
      exports._resyncList = _resyncList;
      exports._resyncParent = _resyncParent;
      exports._resyncRemoved = _resyncRemoved;
      exports.call = call;
      exports.isBlacklisted = exports.isDenylisted = isDenylisted;
      exports.popContext = popContext;
      exports.pushContext = pushContext;
      exports.requeue = requeue;
      exports.resync = resync;
      exports.setContext = setContext;
      exports.setKey = setKey;
      exports.setScope = setScope;
      exports.setup = setup;
      exports.skip = skip;
      exports.skipKey = skipKey;
      exports.stop = stop;
      exports.visit = visit;
      var _traverseNode = require_traverse_node();
      var _index = require_path();
      function call(key) {
        const opts = this.opts;
        this.debug(key);
        if (this.node) {
          if (this._call(opts[key]))
            return true;
        }
        if (this.node) {
          return this._call(opts[this.node.type] && opts[this.node.type][key]);
        }
        return false;
      }
      function _call(fns) {
        if (!fns)
          return false;
        for (const fn of fns) {
          if (!fn)
            continue;
          const node = this.node;
          if (!node)
            return true;
          const ret = fn.call(this.state, this, this.state);
          if (ret && typeof ret === "object" && typeof ret.then === "function") {
            throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
          }
          if (ret) {
            throw new Error(`Unexpected return value from visitor method ${fn}`);
          }
          if (this.node !== node)
            return true;
          if (this._traverseFlags > 0)
            return true;
        }
        return false;
      }
      function isDenylisted() {
        var _this$opts$denylist;
        const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
        return denylist && denylist.indexOf(this.node.type) > -1;
      }
      function restoreContext(path, context) {
        if (path.context !== context) {
          path.context = context;
          path.state = context.state;
          path.opts = context.opts;
        }
      }
      function visit() {
        if (!this.node) {
          return false;
        }
        if (this.isDenylisted()) {
          return false;
        }
        if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
          return false;
        }
        const currentContext = this.context;
        if (this.shouldSkip || this.call("enter")) {
          this.debug("Skip...");
          return this.shouldStop;
        }
        restoreContext(this, currentContext);
        this.debug("Recursing into...");
        this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
        restoreContext(this, currentContext);
        this.call("exit");
        return this.shouldStop;
      }
      function skip() {
        this.shouldSkip = true;
      }
      function skipKey(key) {
        if (this.skipKeys == null) {
          this.skipKeys = {};
        }
        this.skipKeys[key] = true;
      }
      function stop() {
        this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
      }
      function setScope() {
        if (this.opts && this.opts.noScope)
          return;
        let path = this.parentPath;
        if ((this.key === "key" || this.listKey === "decorators") && path.isMethod() || this.key === "discriminant" && path.isSwitchStatement()) {
          path = path.parentPath;
        }
        let target;
        while (path && !target) {
          if (path.opts && path.opts.noScope)
            return;
          target = path.scope;
          path = path.parentPath;
        }
        this.scope = this.getScope(target);
        if (this.scope)
          this.scope.init();
      }
      function setContext(context) {
        if (this.skipKeys != null) {
          this.skipKeys = {};
        }
        this._traverseFlags = 0;
        if (context) {
          this.context = context;
          this.state = context.state;
          this.opts = context.opts;
        }
        this.setScope();
        return this;
      }
      function resync() {
        if (this.removed)
          return;
        this._resyncParent();
        this._resyncList();
        this._resyncKey();
      }
      function _resyncParent() {
        if (this.parentPath) {
          this.parent = this.parentPath.node;
        }
      }
      function _resyncKey() {
        if (!this.container)
          return;
        if (this.node === this.container[this.key]) {
          return;
        }
        if (Array.isArray(this.container)) {
          for (let i = 0; i < this.container.length; i++) {
            if (this.container[i] === this.node) {
              return this.setKey(i);
            }
          }
        } else {
          for (const key of Object.keys(this.container)) {
            if (this.container[key] === this.node) {
              return this.setKey(key);
            }
          }
        }
        this.key = null;
      }
      function _resyncList() {
        if (!this.parent || !this.inList)
          return;
        const newContainer = this.parent[this.listKey];
        if (this.container === newContainer)
          return;
        this.container = newContainer || null;
      }
      function _resyncRemoved() {
        if (this.key == null || !this.container || this.container[this.key] !== this.node) {
          this._markRemoved();
        }
      }
      function popContext() {
        this.contexts.pop();
        if (this.contexts.length > 0) {
          this.setContext(this.contexts[this.contexts.length - 1]);
        } else {
          this.setContext(void 0);
        }
      }
      function pushContext(context) {
        this.contexts.push(context);
        this.setContext(context);
      }
      function setup(parentPath, container, listKey, key) {
        this.listKey = listKey;
        this.container = container;
        this.parentPath = parentPath || this.parentPath;
        this.setKey(key);
      }
      function setKey(key) {
        var _this$node;
        this.key = key;
        this.node = this.container[this.key];
        this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
      }
      function requeue(pathToQueue = this) {
        if (pathToQueue.removed)
          return;
        ;
        const contexts = this.contexts;
        for (const context of contexts) {
          context.maybeQueue(pathToQueue);
        }
      }
      function _getQueueContexts() {
        let path = this;
        let contexts = this.contexts;
        while (!contexts.length) {
          path = path.parentPath;
          if (!path)
            break;
          contexts = path.contexts;
        }
        return contexts;
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
  var require_removal_hooks = __commonJS({
    "node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hooks = void 0;
      var hooks = [function(self2, parent) {
        const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
        if (removeParent) {
          parent.remove();
          return true;
        }
      }, function(self2, parent) {
        if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
          parent.replaceWith(parent.node.expressions[0]);
          return true;
        }
      }, function(self2, parent) {
        if (parent.isBinary()) {
          if (self2.key === "left") {
            parent.replaceWith(parent.node.right);
          } else {
            parent.replaceWith(parent.node.left);
          }
          return true;
        }
      }, function(self2, parent) {
        if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
          self2.replaceWith({
            type: "BlockStatement",
            body: []
          });
          return true;
        }
      }];
      exports.hooks = hooks;
    }
  });

  // node_modules/@babel/traverse/lib/path/removal.js
  var require_removal = __commonJS({
    "node_modules/@babel/traverse/lib/path/removal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._assertUnremoved = _assertUnremoved;
      exports._callRemovalHooks = _callRemovalHooks;
      exports._markRemoved = _markRemoved;
      exports._remove = _remove;
      exports._removeFromScope = _removeFromScope;
      exports.remove = remove;
      var _removalHooks = require_removal_hooks();
      var _cache = require_cache();
      var _index = require_path();
      function remove() {
        var _this$opts;
        this._assertUnremoved();
        this.resync();
        if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
          this._removeFromScope();
        }
        if (this._callRemovalHooks()) {
          this._markRemoved();
          return;
        }
        this.shareCommentsWithSiblings();
        this._remove();
        this._markRemoved();
      }
      function _removeFromScope() {
        const bindings = this.getBindingIdentifiers();
        Object.keys(bindings).forEach((name41) => this.scope.removeBinding(name41));
      }
      function _callRemovalHooks() {
        for (const fn of _removalHooks.hooks) {
          if (fn(this, this.parentPath))
            return true;
        }
      }
      function _remove() {
        if (Array.isArray(this.container)) {
          this.container.splice(this.key, 1);
          this.updateSiblingKeys(this.key, -1);
        } else {
          this._replaceWith(null);
        }
      }
      function _markRemoved() {
        this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
        if (this.parent)
          _cache.path.get(this.parent).delete(this.node);
        this.node = null;
      }
      function _assertUnremoved() {
        if (this.removed) {
          throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
        }
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/lib/hoister.js
  var require_hoister = __commonJS({
    "node_modules/@babel/traverse/lib/path/lib/hoister.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _t = require_lib4();
      var _t2 = _t;
      var {
        react
      } = _t;
      var {
        cloneNode,
        jsxExpressionContainer,
        variableDeclaration: variableDeclaration2,
        variableDeclarator: variableDeclarator2
      } = _t2;
      var referenceVisitor = {
        ReferencedIdentifier(path, state) {
          if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
            return;
          }
          if (path.node.name === "this") {
            let scope = path.scope;
            do {
              if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
                break;
              }
            } while (scope = scope.parent);
            if (scope)
              state.breakOnScopePaths.push(scope.path);
          }
          const binding = path.scope.getBinding(path.node.name);
          if (!binding)
            return;
          for (const violation of binding.constantViolations) {
            if (violation.scope !== binding.path.scope) {
              state.mutableBinding = true;
              path.stop();
              return;
            }
          }
          if (binding !== state.scope.getBinding(path.node.name))
            return;
          state.bindings[path.node.name] = binding;
        }
      };
      var PathHoister = class {
        constructor(path, scope) {
          this.breakOnScopePaths = void 0;
          this.bindings = void 0;
          this.mutableBinding = void 0;
          this.scopes = void 0;
          this.scope = void 0;
          this.path = void 0;
          this.attachAfter = void 0;
          this.breakOnScopePaths = [];
          this.bindings = {};
          this.mutableBinding = false;
          this.scopes = [];
          this.scope = scope;
          this.path = path;
          this.attachAfter = false;
        }
        isCompatibleScope(scope) {
          for (const key of Object.keys(this.bindings)) {
            const binding = this.bindings[key];
            if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
              return false;
            }
          }
          return true;
        }
        getCompatibleScopes() {
          let scope = this.path.scope;
          do {
            if (this.isCompatibleScope(scope)) {
              this.scopes.push(scope);
            } else {
              break;
            }
            if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
              break;
            }
          } while (scope = scope.parent);
        }
        getAttachmentPath() {
          let path = this._getAttachmentPath();
          if (!path)
            return;
          let targetScope = path.scope;
          if (targetScope.path === path) {
            targetScope = path.scope.parent;
          }
          if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
            for (const name41 of Object.keys(this.bindings)) {
              if (!targetScope.hasOwnBinding(name41))
                continue;
              const binding = this.bindings[name41];
              if (binding.kind === "param" || binding.path.parentKey === "params") {
                continue;
              }
              const bindingParentPath = this.getAttachmentParentForPath(binding.path);
              if (bindingParentPath.key >= path.key) {
                this.attachAfter = true;
                path = binding.path;
                for (const violationPath of binding.constantViolations) {
                  if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                    path = violationPath;
                  }
                }
              }
            }
          }
          return path;
        }
        _getAttachmentPath() {
          const scopes = this.scopes;
          const scope = scopes.pop();
          if (!scope)
            return;
          if (scope.path.isFunction()) {
            if (this.hasOwnParamBindings(scope)) {
              if (this.scope === scope)
                return;
              const bodies = scope.path.get("body").get("body");
              for (let i = 0; i < bodies.length; i++) {
                if (bodies[i].node._blockHoist)
                  continue;
                return bodies[i];
              }
            } else {
              return this.getNextScopeAttachmentParent();
            }
          } else if (scope.path.isProgram()) {
            return this.getNextScopeAttachmentParent();
          }
        }
        getNextScopeAttachmentParent() {
          const scope = this.scopes.pop();
          if (scope)
            return this.getAttachmentParentForPath(scope.path);
        }
        getAttachmentParentForPath(path) {
          do {
            if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
              return path;
            }
          } while (path = path.parentPath);
        }
        hasOwnParamBindings(scope) {
          for (const name41 of Object.keys(this.bindings)) {
            if (!scope.hasOwnBinding(name41))
              continue;
            const binding = this.bindings[name41];
            if (binding.kind === "param" && binding.constant)
              return true;
          }
          return false;
        }
        run() {
          this.path.traverse(referenceVisitor, this);
          if (this.mutableBinding)
            return;
          this.getCompatibleScopes();
          const attachTo = this.getAttachmentPath();
          if (!attachTo)
            return;
          if (attachTo.getFunctionParent() === this.path.getFunctionParent())
            return;
          let uid = attachTo.scope.generateUidIdentifier("ref");
          const declarator = variableDeclarator2(uid, this.path.node);
          const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
          const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration2("var", [declarator])]);
          const parent = this.path.parentPath;
          if (parent.isJSXElement() && this.path.container === parent.node.children) {
            uid = jsxExpressionContainer(uid);
          }
          this.path.replaceWith(cloneNode(uid));
          return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
        }
      };
      exports.default = PathHoister;
    }
  });

  // node_modules/@babel/traverse/lib/path/modification.js
  var require_modification = __commonJS({
    "node_modules/@babel/traverse/lib/path/modification.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._containerInsert = _containerInsert;
      exports._containerInsertAfter = _containerInsertAfter;
      exports._containerInsertBefore = _containerInsertBefore;
      exports._verifyNodeList = _verifyNodeList;
      exports.hoist = hoist;
      exports.insertAfter = insertAfter;
      exports.insertBefore = insertBefore;
      exports.pushContainer = pushContainer;
      exports.unshiftContainer = unshiftContainer;
      exports.updateSiblingKeys = updateSiblingKeys;
      var _cache = require_cache();
      var _hoister = require_hoister();
      var _index = require_path();
      var _t = require_lib4();
      var {
        arrowFunctionExpression: arrowFunctionExpression4,
        assertExpression,
        assignmentExpression,
        blockStatement: blockStatement2,
        callExpression: callExpression4,
        cloneNode,
        expressionStatement: expressionStatement2,
        isAssignmentExpression: isAssignmentExpression2,
        isCallExpression,
        isExportNamedDeclaration,
        isExpression,
        isIdentifier: isIdentifier2,
        isSequenceExpression: isSequenceExpression2,
        isSuper,
        thisExpression
      } = _t;
      function insertBefore(nodes_) {
        this._assertUnremoved();
        const nodes = this._verifyNodeList(nodes_);
        const {
          parentPath,
          parent
        } = this;
        if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
          return parentPath.insertBefore(nodes);
        } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
          if (this.node)
            nodes.push(this.node);
          return this.replaceExpressionWithStatements(nodes);
        } else if (Array.isArray(this.container)) {
          return this._containerInsertBefore(nodes);
        } else if (this.isStatementOrBlock()) {
          const node = this.node;
          const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
          this.replaceWith(blockStatement2(shouldInsertCurrentNode ? [node] : []));
          return this.unshiftContainer("body", nodes);
        } else {
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }
      }
      function _containerInsert(from, nodes) {
        this.updateSiblingKeys(from, nodes.length);
        const paths = [];
        this.container.splice(from, 0, ...nodes);
        for (let i = 0; i < nodes.length; i++) {
          const to = from + i;
          const path = this.getSibling(to);
          paths.push(path);
          if (this.context && this.context.queue) {
            path.pushContext(this.context);
          }
        }
        const contexts = this._getQueueContexts();
        for (const path of paths) {
          path.setScope();
          path.debug("Inserted.");
          for (const context of contexts) {
            context.maybeQueue(path, true);
          }
        }
        return paths;
      }
      function _containerInsertBefore(nodes) {
        return this._containerInsert(this.key, nodes);
      }
      function _containerInsertAfter(nodes) {
        return this._containerInsert(this.key + 1, nodes);
      }
      var last = (arr) => arr[arr.length - 1];
      function isHiddenInSequenceExpression(path) {
        return isSequenceExpression2(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
      }
      function isAlmostConstantAssignment(node, scope) {
        if (!isAssignmentExpression2(node) || !isIdentifier2(node.left)) {
          return false;
        }
        const blockScope = scope.getBlockParent();
        return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
      }
      function insertAfter(nodes_) {
        this._assertUnremoved();
        if (this.isSequenceExpression()) {
          return last(this.get("expressions")).insertAfter(nodes_);
        }
        const nodes = this._verifyNodeList(nodes_);
        const {
          parentPath,
          parent
        } = this;
        if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
          return parentPath.insertAfter(nodes.map((node) => {
            return isExpression(node) ? expressionStatement2(node) : node;
          }));
        } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
          if (this.node) {
            const node = this.node;
            let {
              scope
            } = this;
            if (scope.path.isPattern()) {
              assertExpression(node);
              this.replaceWith(callExpression4(arrowFunctionExpression4([], node), []));
              this.get("callee.body").insertAfter(nodes);
              return [this];
            }
            if (isHiddenInSequenceExpression(this)) {
              nodes.unshift(node);
            } else if (isCallExpression(node) && isSuper(node.callee)) {
              nodes.unshift(node);
              nodes.push(thisExpression());
            } else if (isAlmostConstantAssignment(node, scope)) {
              nodes.unshift(node);
              nodes.push(cloneNode(node.left));
            } else if (scope.isPure(node, true)) {
              nodes.push(node);
            } else {
              if (parentPath.isMethod({
                computed: true,
                key: node
              })) {
                scope = scope.parent;
              }
              const temp = scope.generateDeclaredUidIdentifier();
              nodes.unshift(expressionStatement2(assignmentExpression("=", cloneNode(temp), node)));
              nodes.push(expressionStatement2(cloneNode(temp)));
            }
          }
          return this.replaceExpressionWithStatements(nodes);
        } else if (Array.isArray(this.container)) {
          return this._containerInsertAfter(nodes);
        } else if (this.isStatementOrBlock()) {
          const node = this.node;
          const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
          this.replaceWith(blockStatement2(shouldInsertCurrentNode ? [node] : []));
          return this.pushContainer("body", nodes);
        } else {
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }
      }
      function updateSiblingKeys(fromIndex, incrementBy) {
        if (!this.parent)
          return;
        const paths = _cache.path.get(this.parent);
        for (const [, path] of paths) {
          if (path.key >= fromIndex) {
            path.key += incrementBy;
          }
        }
      }
      function _verifyNodeList(nodes) {
        if (!nodes) {
          return [];
        }
        if (!Array.isArray(nodes)) {
          nodes = [nodes];
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          let msg;
          if (!node) {
            msg = "has falsy node";
          } else if (typeof node !== "object") {
            msg = "contains a non-object node";
          } else if (!node.type) {
            msg = "without a type";
          } else if (node instanceof _index.default) {
            msg = "has a NodePath when it expected a raw object";
          }
          if (msg) {
            const type = Array.isArray(node) ? "array" : typeof node;
            throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
          }
        }
        return nodes;
      }
      function unshiftContainer(listKey, nodes) {
        this._assertUnremoved();
        nodes = this._verifyNodeList(nodes);
        const path = _index.default.get({
          parentPath: this,
          parent: this.node,
          container: this.node[listKey],
          listKey,
          key: 0
        }).setContext(this.context);
        return path._containerInsertBefore(nodes);
      }
      function pushContainer(listKey, nodes) {
        this._assertUnremoved();
        const verifiedNodes = this._verifyNodeList(nodes);
        const container = this.node[listKey];
        const path = _index.default.get({
          parentPath: this,
          parent: this.node,
          container,
          listKey,
          key: container.length
        }).setContext(this.context);
        return path.replaceWithMultiple(verifiedNodes);
      }
      function hoist(scope = this.scope) {
        const hoister = new _hoister.default(this, scope);
        return hoister.run();
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/family.js
  var require_family = __commonJS({
    "node_modules/@babel/traverse/lib/path/family.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._getKey = _getKey;
      exports._getPattern = _getPattern;
      exports.get = get;
      exports.getAllNextSiblings = getAllNextSiblings;
      exports.getAllPrevSiblings = getAllPrevSiblings;
      exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
      exports.getBindingIdentifiers = getBindingIdentifiers;
      exports.getCompletionRecords = getCompletionRecords;
      exports.getNextSibling = getNextSibling;
      exports.getOpposite = getOpposite;
      exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
      exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
      exports.getPrevSibling = getPrevSibling;
      exports.getSibling = getSibling;
      var _index = require_path();
      var _t = require_lib4();
      var {
        getBindingIdentifiers: _getBindingIdentifiers,
        getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
        isDeclaration,
        numericLiteral,
        unaryExpression
      } = _t;
      var NORMAL_COMPLETION = 0;
      var BREAK_COMPLETION = 1;
      function NormalCompletion(path) {
        return {
          type: NORMAL_COMPLETION,
          path
        };
      }
      function BreakCompletion(path) {
        return {
          type: BREAK_COMPLETION,
          path
        };
      }
      function getOpposite() {
        if (this.key === "left") {
          return this.getSibling("right");
        } else if (this.key === "right") {
          return this.getSibling("left");
        }
        return null;
      }
      function addCompletionRecords(path, records, context) {
        if (path) {
          records.push(..._getCompletionRecords(path, context));
        }
        return records;
      }
      function completionRecordForSwitch(cases, records, context) {
        let lastNormalCompletions = [];
        for (let i = 0; i < cases.length; i++) {
          const casePath = cases[i];
          const caseCompletions = _getCompletionRecords(casePath, context);
          const normalCompletions = [];
          const breakCompletions = [];
          for (const c of caseCompletions) {
            if (c.type === NORMAL_COMPLETION) {
              normalCompletions.push(c);
            }
            if (c.type === BREAK_COMPLETION) {
              breakCompletions.push(c);
            }
          }
          if (normalCompletions.length) {
            lastNormalCompletions = normalCompletions;
          }
          records.push(...breakCompletions);
        }
        records.push(...lastNormalCompletions);
        return records;
      }
      function normalCompletionToBreak(completions) {
        completions.forEach((c) => {
          c.type = BREAK_COMPLETION;
        });
      }
      function replaceBreakStatementInBreakCompletion(completions, reachable) {
        completions.forEach((c) => {
          if (c.path.isBreakStatement({
            label: null
          })) {
            if (reachable) {
              c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
            } else {
              c.path.remove();
            }
          }
        });
      }
      function getStatementListCompletion(paths, context) {
        const completions = [];
        if (context.canHaveBreak) {
          let lastNormalCompletions = [];
          for (let i = 0; i < paths.length; i++) {
            const path = paths[i];
            const newContext = Object.assign({}, context, {
              inCaseClause: false
            });
            if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
              newContext.shouldPopulateBreak = true;
            } else {
              newContext.shouldPopulateBreak = false;
            }
            const statementCompletions = _getCompletionRecords(path, newContext);
            if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
              if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({
                label: null
              }))) {
                normalCompletionToBreak(lastNormalCompletions);
                completions.push(...lastNormalCompletions);
                if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
                  completions.push(...statementCompletions);
                  replaceBreakStatementInBreakCompletion(statementCompletions, true);
                }
                replaceBreakStatementInBreakCompletion(statementCompletions, false);
              } else {
                completions.push(...statementCompletions);
                if (!context.shouldPopulateBreak) {
                  replaceBreakStatementInBreakCompletion(statementCompletions, true);
                }
              }
              break;
            }
            if (i === paths.length - 1) {
              completions.push(...statementCompletions);
            } else {
              lastNormalCompletions = [];
              for (let i2 = 0; i2 < statementCompletions.length; i2++) {
                const c = statementCompletions[i2];
                if (c.type === BREAK_COMPLETION) {
                  completions.push(c);
                }
                if (c.type === NORMAL_COMPLETION) {
                  lastNormalCompletions.push(c);
                }
              }
            }
          }
        } else if (paths.length) {
          for (let i = paths.length - 1; i >= 0; i--) {
            const pathCompletions = _getCompletionRecords(paths[i], context);
            if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
              completions.push(...pathCompletions);
              break;
            }
          }
        }
        return completions;
      }
      function _getCompletionRecords(path, context) {
        let records = [];
        if (path.isIfStatement()) {
          records = addCompletionRecords(path.get("consequent"), records, context);
          records = addCompletionRecords(path.get("alternate"), records, context);
        } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
          return addCompletionRecords(path.get("body"), records, context);
        } else if (path.isProgram() || path.isBlockStatement()) {
          return getStatementListCompletion(path.get("body"), context);
        } else if (path.isFunction()) {
          return _getCompletionRecords(path.get("body"), context);
        } else if (path.isTryStatement()) {
          records = addCompletionRecords(path.get("block"), records, context);
          records = addCompletionRecords(path.get("handler"), records, context);
        } else if (path.isCatchClause()) {
          return addCompletionRecords(path.get("body"), records, context);
        } else if (path.isSwitchStatement()) {
          return completionRecordForSwitch(path.get("cases"), records, context);
        } else if (path.isSwitchCase()) {
          return getStatementListCompletion(path.get("consequent"), {
            canHaveBreak: true,
            shouldPopulateBreak: false,
            inCaseClause: true
          });
        } else if (path.isBreakStatement()) {
          records.push(BreakCompletion(path));
        } else {
          records.push(NormalCompletion(path));
        }
        return records;
      }
      function getCompletionRecords() {
        const records = _getCompletionRecords(this, {
          canHaveBreak: false,
          shouldPopulateBreak: false,
          inCaseClause: false
        });
        return records.map((r) => r.path);
      }
      function getSibling(key) {
        return _index.default.get({
          parentPath: this.parentPath,
          parent: this.parent,
          container: this.container,
          listKey: this.listKey,
          key
        }).setContext(this.context);
      }
      function getPrevSibling() {
        return this.getSibling(this.key - 1);
      }
      function getNextSibling() {
        return this.getSibling(this.key + 1);
      }
      function getAllNextSiblings() {
        let _key = this.key;
        let sibling = this.getSibling(++_key);
        const siblings = [];
        while (sibling.node) {
          siblings.push(sibling);
          sibling = this.getSibling(++_key);
        }
        return siblings;
      }
      function getAllPrevSiblings() {
        let _key = this.key;
        let sibling = this.getSibling(--_key);
        const siblings = [];
        while (sibling.node) {
          siblings.push(sibling);
          sibling = this.getSibling(--_key);
        }
        return siblings;
      }
      function get(key, context = true) {
        if (context === true)
          context = this.context;
        const parts = key.split(".");
        if (parts.length === 1) {
          return this._getKey(key, context);
        } else {
          return this._getPattern(parts, context);
        }
      }
      function _getKey(key, context) {
        const node = this.node;
        const container = node[key];
        if (Array.isArray(container)) {
          return container.map((_, i) => {
            return _index.default.get({
              listKey: key,
              parentPath: this,
              parent: node,
              container,
              key: i
            }).setContext(context);
          });
        } else {
          return _index.default.get({
            parentPath: this,
            parent: node,
            container: node,
            key
          }).setContext(context);
        }
      }
      function _getPattern(parts, context) {
        let path = this;
        for (const part of parts) {
          if (part === ".") {
            path = path.parentPath;
          } else {
            if (Array.isArray(path)) {
              path = path[part];
            } else {
              path = path.get(part, context);
            }
          }
        }
        return path;
      }
      function getBindingIdentifiers(duplicates) {
        return _getBindingIdentifiers(this.node, duplicates);
      }
      function getOuterBindingIdentifiers(duplicates) {
        return _getOuterBindingIdentifiers(this.node, duplicates);
      }
      function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
        const path = this;
        const search = [path];
        const ids = /* @__PURE__ */ Object.create(null);
        while (search.length) {
          const id = search.shift();
          if (!id)
            continue;
          if (!id.node)
            continue;
          const keys = _getBindingIdentifiers.keys[id.node.type];
          if (id.isIdentifier()) {
            if (duplicates) {
              const _ids = ids[id.node.name] = ids[id.node.name] || [];
              _ids.push(id);
            } else {
              ids[id.node.name] = id;
            }
            continue;
          }
          if (id.isExportDeclaration()) {
            const declaration = id.get("declaration");
            if (isDeclaration(declaration)) {
              search.push(declaration);
            }
            continue;
          }
          if (outerOnly) {
            if (id.isFunctionDeclaration()) {
              search.push(id.get("id"));
              continue;
            }
            if (id.isFunctionExpression()) {
              continue;
            }
          }
          if (keys) {
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const child = id.get(key);
              if (Array.isArray(child)) {
                search.push(...child);
              } else if (child.node) {
                search.push(child);
              }
            }
          }
        }
        return ids;
      }
      function getOuterBindingIdentifierPaths(duplicates = false) {
        return this.getBindingIdentifierPaths(duplicates, true);
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/comments.js
  var require_comments = __commonJS({
    "node_modules/@babel/traverse/lib/path/comments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.addComment = addComment;
      exports.addComments = addComments;
      exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
      var _t = require_lib4();
      var {
        addComment: _addComment,
        addComments: _addComments
      } = _t;
      function shareCommentsWithSiblings() {
        if (typeof this.key === "string")
          return;
        const node = this.node;
        if (!node)
          return;
        const trailing = node.trailingComments;
        const leading = node.leadingComments;
        if (!trailing && !leading)
          return;
        const prev = this.getSibling(this.key - 1);
        const next = this.getSibling(this.key + 1);
        const hasPrev = Boolean(prev.node);
        const hasNext = Boolean(next.node);
        if (hasPrev && !hasNext) {
          prev.addComments("trailing", trailing);
        } else if (hasNext && !hasPrev) {
          next.addComments("leading", leading);
        }
      }
      function addComment(type, content, line) {
        _addComment(this.node, type, content, line);
      }
      function addComments(type, comments) {
        _addComments(this.node, type, comments);
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
  var require_virtual_types_validator = __commonJS({
    "node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isBindingIdentifier = isBindingIdentifier;
      exports.isBlockScoped = isBlockScoped;
      exports.isExistentialTypeParam = isExistentialTypeParam;
      exports.isExpression = isExpression;
      exports.isFlow = isFlow;
      exports.isForAwaitStatement = isForAwaitStatement;
      exports.isGenerated = isGenerated;
      exports.isNumericLiteralTypeAnnotation = isNumericLiteralTypeAnnotation;
      exports.isPure = isPure;
      exports.isReferenced = isReferenced;
      exports.isReferencedIdentifier = isReferencedIdentifier;
      exports.isReferencedMemberExpression = isReferencedMemberExpression;
      exports.isRestProperty = isRestProperty;
      exports.isScope = isScope;
      exports.isSpreadProperty = isSpreadProperty;
      exports.isStatement = isStatement;
      exports.isUser = isUser;
      exports.isVar = isVar;
      var _t = require_lib4();
      var {
        isBinding,
        isBlockScoped: nodeIsBlockScoped,
        isExportDeclaration,
        isExpression: nodeIsExpression,
        isFlow: nodeIsFlow,
        isForStatement,
        isForXStatement,
        isIdentifier: isIdentifier2,
        isImportDeclaration,
        isImportSpecifier,
        isJSXIdentifier,
        isJSXMemberExpression,
        isMemberExpression: isMemberExpression2,
        isRestElement: nodeIsRestElement,
        isReferenced: nodeIsReferenced,
        isScope: nodeIsScope,
        isStatement: nodeIsStatement,
        isVar: nodeIsVar,
        isVariableDeclaration,
        react,
        isForOfStatement
      } = _t;
      var {
        isCompatTag
      } = react;
      function isReferencedIdentifier(opts) {
        const {
          node,
          parent
        } = this;
        if (!isIdentifier2(node, opts) && !isJSXMemberExpression(parent, opts)) {
          if (isJSXIdentifier(node, opts)) {
            if (isCompatTag(node.name))
              return false;
          } else {
            return false;
          }
        }
        return nodeIsReferenced(node, parent, this.parentPath.parent);
      }
      function isReferencedMemberExpression() {
        const {
          node,
          parent
        } = this;
        return isMemberExpression2(node) && nodeIsReferenced(node, parent);
      }
      function isBindingIdentifier() {
        const {
          node,
          parent
        } = this;
        const grandparent = this.parentPath.parent;
        return isIdentifier2(node) && isBinding(node, parent, grandparent);
      }
      function isStatement() {
        const {
          node,
          parent
        } = this;
        if (nodeIsStatement(node)) {
          if (isVariableDeclaration(node)) {
            if (isForXStatement(parent, {
              left: node
            }))
              return false;
            if (isForStatement(parent, {
              init: node
            }))
              return false;
          }
          return true;
        } else {
          return false;
        }
      }
      function isExpression() {
        if (this.isIdentifier()) {
          return this.isReferencedIdentifier();
        } else {
          return nodeIsExpression(this.node);
        }
      }
      function isScope() {
        return nodeIsScope(this.node, this.parent);
      }
      function isReferenced() {
        return nodeIsReferenced(this.node, this.parent);
      }
      function isBlockScoped() {
        return nodeIsBlockScoped(this.node);
      }
      function isVar() {
        return nodeIsVar(this.node);
      }
      function isUser() {
        return this.node && !!this.node.loc;
      }
      function isGenerated() {
        return !this.isUser();
      }
      function isPure(constantsOnly) {
        return this.scope.isPure(this.node, constantsOnly);
      }
      function isFlow() {
        const {
          node
        } = this;
        if (nodeIsFlow(node)) {
          return true;
        } else if (isImportDeclaration(node)) {
          return node.importKind === "type" || node.importKind === "typeof";
        } else if (isExportDeclaration(node)) {
          return node.exportKind === "type";
        } else if (isImportSpecifier(node)) {
          return node.importKind === "type" || node.importKind === "typeof";
        } else {
          return false;
        }
      }
      function isRestProperty() {
        return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();
      }
      function isSpreadProperty() {
        return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();
      }
      function isForAwaitStatement() {
        return isForOfStatement(this.node, {
          await: true
        });
      }
      function isExistentialTypeParam() {
        throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
      }
      function isNumericLiteralTypeAnnotation() {
        throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
      }
    }
  });

  // node_modules/@babel/traverse/lib/path/index.js
  var require_path = __commonJS({
    "node_modules/@babel/traverse/lib/path/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;
      var virtualTypes = require_virtual_types();
      var _debug = require_browser3();
      var _index = require_lib13();
      var _scope = require_scope();
      var _t = require_lib4();
      var t4 = _t;
      var _cache = require_cache();
      var _generator = require_lib5();
      var NodePath_ancestry = require_ancestry();
      var NodePath_inference = require_inference();
      var NodePath_replacement = require_replacement();
      var NodePath_evaluation = require_evaluation();
      var NodePath_conversion = require_conversion();
      var NodePath_introspection = require_introspection();
      var NodePath_context = require_context();
      var NodePath_removal = require_removal();
      var NodePath_modification = require_modification();
      var NodePath_family = require_family();
      var NodePath_comments = require_comments();
      var NodePath_virtual_types_validator = require_virtual_types_validator();
      var {
        validate
      } = _t;
      var debug = _debug("babel");
      var REMOVED = 1 << 0;
      exports.REMOVED = REMOVED;
      var SHOULD_STOP = 1 << 1;
      exports.SHOULD_STOP = SHOULD_STOP;
      var SHOULD_SKIP = 1 << 2;
      exports.SHOULD_SKIP = SHOULD_SKIP;
      var NodePath = class {
        constructor(hub, parent) {
          this.contexts = [];
          this.state = null;
          this.opts = null;
          this._traverseFlags = 0;
          this.skipKeys = null;
          this.parentPath = null;
          this.container = null;
          this.listKey = null;
          this.key = null;
          this.node = null;
          this.type = null;
          this.parent = parent;
          this.hub = hub;
          this.data = null;
          this.context = null;
          this.scope = null;
        }
        static get({
          hub,
          parentPath,
          parent,
          container,
          listKey,
          key
        }) {
          if (!hub && parentPath) {
            hub = parentPath.hub;
          }
          if (!parent) {
            throw new Error("To get a node path the parent needs to exist");
          }
          const targetNode = container[key];
          let paths = _cache.path.get(parent);
          if (!paths) {
            paths = /* @__PURE__ */ new Map();
            _cache.path.set(parent, paths);
          }
          let path = paths.get(targetNode);
          if (!path) {
            path = new NodePath(hub, parent);
            if (targetNode)
              paths.set(targetNode, path);
          }
          path.setup(parentPath, container, listKey, key);
          return path;
        }
        getScope(scope) {
          return this.isScope() ? new _scope.default(this) : scope;
        }
        setData(key, val) {
          if (this.data == null) {
            this.data = /* @__PURE__ */ Object.create(null);
          }
          return this.data[key] = val;
        }
        getData(key, def) {
          if (this.data == null) {
            this.data = /* @__PURE__ */ Object.create(null);
          }
          let val = this.data[key];
          if (val === void 0 && def !== void 0)
            val = this.data[key] = def;
          return val;
        }
        hasNode() {
          return this.node != null;
        }
        buildCodeFrameError(msg, Error2 = SyntaxError) {
          return this.hub.buildError(this.node, msg, Error2);
        }
        traverse(visitor, state) {
          (0, _index.default)(this.node, visitor, this.scope, state, this);
        }
        set(key, node) {
          validate(this.node, key, node);
          this.node[key] = node;
        }
        getPathLocation() {
          const parts = [];
          let path = this;
          do {
            let key = path.key;
            if (path.inList)
              key = `${path.listKey}[${key}]`;
            parts.unshift(key);
          } while (path = path.parentPath);
          return parts.join(".");
        }
        debug(message) {
          if (!debug.enabled)
            return;
          debug(`${this.getPathLocation()} ${this.type}: ${message}`);
        }
        toString() {
          return (0, _generator.default)(this.node).code;
        }
        get inList() {
          return !!this.listKey;
        }
        set inList(inList) {
          if (!inList) {
            this.listKey = null;
          }
        }
        get parentKey() {
          return this.listKey || this.key;
        }
        get shouldSkip() {
          return !!(this._traverseFlags & SHOULD_SKIP);
        }
        set shouldSkip(v) {
          if (v) {
            this._traverseFlags |= SHOULD_SKIP;
          } else {
            this._traverseFlags &= ~SHOULD_SKIP;
          }
        }
        get shouldStop() {
          return !!(this._traverseFlags & SHOULD_STOP);
        }
        set shouldStop(v) {
          if (v) {
            this._traverseFlags |= SHOULD_STOP;
          } else {
            this._traverseFlags &= ~SHOULD_STOP;
          }
        }
        get removed() {
          return !!(this._traverseFlags & REMOVED);
        }
        set removed(v) {
          if (v) {
            this._traverseFlags |= REMOVED;
          } else {
            this._traverseFlags &= ~REMOVED;
          }
        }
      };
      Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
      {
        NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      }
      for (const type of t4.TYPES) {
        const typeKey = `is${type}`;
        const fn = t4[typeKey];
        NodePath.prototype[typeKey] = function(opts) {
          return fn(this.node, opts);
        };
        NodePath.prototype[`assert${type}`] = function(opts) {
          if (!fn(this.node, opts)) {
            throw new TypeError(`Expected node path of type ${type}`);
          }
        };
      }
      Object.assign(NodePath.prototype, NodePath_virtual_types_validator);
      for (const type of Object.keys(virtualTypes)) {
        if (type[0] === "_")
          continue;
        if (!t4.TYPES.includes(type))
          t4.TYPES.push(type);
      }
      var _default = NodePath;
      exports.default = _default;
    }
  });

  // node_modules/@babel/traverse/lib/context.js
  var require_context2 = __commonJS({
    "node_modules/@babel/traverse/lib/context.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _path = require_path();
      var _t = require_lib4();
      var {
        VISITOR_KEYS
      } = _t;
      var TraversalContext = class {
        constructor(scope, opts, state, parentPath) {
          this.queue = null;
          this.priorityQueue = null;
          this.parentPath = parentPath;
          this.scope = scope;
          this.state = state;
          this.opts = opts;
        }
        shouldVisit(node) {
          const opts = this.opts;
          if (opts.enter || opts.exit)
            return true;
          if (opts[node.type])
            return true;
          const keys = VISITOR_KEYS[node.type];
          if (!(keys != null && keys.length))
            return false;
          for (const key of keys) {
            if (node[key]) {
              return true;
            }
          }
          return false;
        }
        create(node, container, key, listKey) {
          return _path.default.get({
            parentPath: this.parentPath,
            parent: node,
            container,
            key,
            listKey
          });
        }
        maybeQueue(path, notPriority) {
          if (this.queue) {
            if (notPriority) {
              this.queue.push(path);
            } else {
              this.priorityQueue.push(path);
            }
          }
        }
        visitMultiple(container, parent, listKey) {
          if (container.length === 0)
            return false;
          const queue = [];
          for (let key = 0; key < container.length; key++) {
            const node = container[key];
            if (node && this.shouldVisit(node)) {
              queue.push(this.create(parent, container, key, listKey));
            }
          }
          return this.visitQueue(queue);
        }
        visitSingle(node, key) {
          if (this.shouldVisit(node[key])) {
            return this.visitQueue([this.create(node, node, key)]);
          } else {
            return false;
          }
        }
        visitQueue(queue) {
          this.queue = queue;
          this.priorityQueue = [];
          const visited = /* @__PURE__ */ new WeakSet();
          let stop = false;
          for (const path of queue) {
            path.resync();
            if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
              path.pushContext(this);
            }
            if (path.key === null)
              continue;
            const {
              node
            } = path;
            if (visited.has(node))
              continue;
            if (node)
              visited.add(node);
            if (path.visit()) {
              stop = true;
              break;
            }
            if (this.priorityQueue.length) {
              stop = this.visitQueue(this.priorityQueue);
              this.priorityQueue = [];
              this.queue = queue;
              if (stop)
                break;
            }
          }
          for (const path of queue) {
            path.popContext();
          }
          this.queue = null;
          return stop;
        }
        visit(node, key) {
          const nodes = node[key];
          if (!nodes)
            return false;
          if (Array.isArray(nodes)) {
            return this.visitMultiple(nodes, node, key);
          } else {
            return this.visitSingle(node, key);
          }
        }
      };
      exports.default = TraversalContext;
    }
  });

  // node_modules/@babel/traverse/lib/traverse-node.js
  var require_traverse_node = __commonJS({
    "node_modules/@babel/traverse/lib/traverse-node.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.traverseNode = traverseNode;
      var _context = require_context2();
      var _t = require_lib4();
      var {
        VISITOR_KEYS
      } = _t;
      function traverseNode(node, opts, scope, state, path, skipKeys) {
        const keys = VISITOR_KEYS[node.type];
        if (!keys)
          return false;
        const context = new _context.default(scope, opts, state, path);
        for (const key of keys) {
          if (skipKeys && skipKeys[key])
            continue;
          if (context.visit(node, key)) {
            return true;
          }
        }
        return false;
      }
    }
  });

  // node_modules/@babel/traverse/lib/hub.js
  var require_hub = __commonJS({
    "node_modules/@babel/traverse/lib/hub.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var Hub = class {
        getCode() {
        }
        getScope() {
        }
        addHelper() {
          throw new Error("Helpers are not supported by the default hub.");
        }
        buildError(node, msg, Error2 = TypeError) {
          return new Error2(msg);
        }
      };
      exports.default = Hub;
    }
  });

  // node_modules/@babel/traverse/lib/index.js
  var require_lib13 = __commonJS({
    "node_modules/@babel/traverse/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "Hub", {
        enumerable: true,
        get: function() {
          return _hub.default;
        }
      });
      Object.defineProperty(exports, "NodePath", {
        enumerable: true,
        get: function() {
          return _path.default;
        }
      });
      Object.defineProperty(exports, "Scope", {
        enumerable: true,
        get: function() {
          return _scope.default;
        }
      });
      exports.visitors = exports.default = void 0;
      var visitors = require_visitors();
      exports.visitors = visitors;
      var _t = require_lib4();
      var cache = require_cache();
      var _traverseNode = require_traverse_node();
      var _path = require_path();
      var _scope = require_scope();
      var _hub = require_hub();
      var {
        VISITOR_KEYS,
        removeProperties,
        traverseFast
      } = _t;
      function traverse(parent, opts = {}, scope, state, parentPath) {
        if (!parent)
          return;
        if (!opts.noScope && !scope) {
          if (parent.type !== "Program" && parent.type !== "File") {
            throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
          }
        }
        if (!VISITOR_KEYS[parent.type]) {
          return;
        }
        visitors.explode(opts);
        (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath);
      }
      var _default = traverse;
      exports.default = _default;
      traverse.visitors = visitors;
      traverse.verify = visitors.verify;
      traverse.explode = visitors.explode;
      traverse.cheap = function(node, enter) {
        return traverseFast(node, enter);
      };
      traverse.node = function(node, opts, scope, state, path, skipKeys) {
        (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);
      };
      traverse.clearNode = function(node, opts) {
        removeProperties(node, opts);
        cache.path.delete(node);
      };
      traverse.removeProperties = function(tree, opts) {
        traverseFast(tree, traverse.clearNode, opts);
        return tree;
      };
      function hasDenylistedType(path, state) {
        if (path.node.type === state.type) {
          state.has = true;
          path.stop();
        }
      }
      traverse.hasType = function(tree, type, denylistTypes) {
        if (denylistTypes != null && denylistTypes.includes(tree.type))
          return false;
        if (tree.type === type)
          return true;
        const state = {
          has: false,
          type
        };
        traverse(tree, {
          noScope: true,
          denylist: denylistTypes,
          enter: hasDenylistedType
        }, null, state);
        return state.has;
      };
      traverse.cache = cache;
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    computed: () => computed,
    effect: () => effect,
    h: () => h,
    mount: () => mount,
    parseSFC: () => parseSFC,
    reactive: () => reactive
  });

  // src/shared/process-buffer-polyfill.ts
  var buffer = __toESM(require_buffer(), 1);
  var import_process = __toESM(require_browser(), 1);

  // src/types.ts
  var VnodeType = {
    /** 元素节点类型 */
    element: "element",
    /** 文本节点类型 */
    textNode: "textNode",
    /** 组件节点类型 */
    component: "component"
  };

  // src/shared/utils.ts
  var isBrowser = () => !!globalThis.window;
  var NAME = "frame3";
  var is = {
    string: (obj) => Object.prototype.toString.call(obj) === "[object String]",
    number: (obj) => Object.prototype.toString.call(obj) === "[object Number]",
    boolean: (obj) => Object.prototype.toString.call(obj) === "[object Boolean]",
    undefined: (obj) => Object.prototype.toString.call(obj) === "[object Undefined]",
    null: (obj) => Object.prototype.toString.call(obj) === "[object Null]",
    function: (obj) => Object.prototype.toString.call(obj) === "[object Function]",
    object: (obj) => Object.prototype.toString.call(obj) === "[object Object]",
    array: (obj) => Object.prototype.toString.call(obj) === "[object Array]"
  };
  var vnodeIs = {
    component: (vnode) => vnode?.type === VnodeType.component,
    element: (vnode) => vnode?.type === VnodeType.element,
    textNode: (vnode) => vnode?.type === VnodeType.textNode
  };

  // src/shared/process-buffer-polyfill.ts
  if (isBrowser()) {
    ;
    window.Buffer = buffer.Buffer;
    window.process = import_process.default;
  }
  var processAndBufferPolyfill = () => {
  };

  // node_modules/css-tree/lib/tokenizer/types.js
  var EOF = 0;
  var Ident = 1;
  var Function2 = 2;
  var AtKeyword = 3;
  var Hash = 4;
  var String2 = 5;
  var BadString = 6;
  var Url = 7;
  var BadUrl = 8;
  var Delim = 9;
  var Number2 = 10;
  var Percentage = 11;
  var Dimension = 12;
  var WhiteSpace = 13;
  var CDO = 14;
  var CDC = 15;
  var Colon = 16;
  var Semicolon = 17;
  var Comma = 18;
  var LeftSquareBracket = 19;
  var RightSquareBracket = 20;
  var LeftParenthesis = 21;
  var RightParenthesis = 22;
  var LeftCurlyBracket = 23;
  var RightCurlyBracket = 24;
  var Comment = 25;

  // node_modules/css-tree/lib/tokenizer/char-code-definitions.js
  var EOF2 = 0;
  function isDigit(code2) {
    return code2 >= 48 && code2 <= 57;
  }
  function isHexDigit(code2) {
    return isDigit(code2) || // 0 .. 9
    code2 >= 65 && code2 <= 70 || // A .. F
    code2 >= 97 && code2 <= 102;
  }
  function isUppercaseLetter(code2) {
    return code2 >= 65 && code2 <= 90;
  }
  function isLowercaseLetter(code2) {
    return code2 >= 97 && code2 <= 122;
  }
  function isLetter(code2) {
    return isUppercaseLetter(code2) || isLowercaseLetter(code2);
  }
  function isNonAscii(code2) {
    return code2 >= 128;
  }
  function isNameStart(code2) {
    return isLetter(code2) || isNonAscii(code2) || code2 === 95;
  }
  function isName(code2) {
    return isNameStart(code2) || isDigit(code2) || code2 === 45;
  }
  function isNonPrintable(code2) {
    return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
  }
  function isNewline(code2) {
    return code2 === 10 || code2 === 13 || code2 === 12;
  }
  function isWhiteSpace(code2) {
    return isNewline(code2) || code2 === 32 || code2 === 9;
  }
  function isValidEscape(first, second) {
    if (first !== 92) {
      return false;
    }
    if (isNewline(second) || second === EOF2) {
      return false;
    }
    return true;
  }
  function isIdentifierStart(first, second, third) {
    if (first === 45) {
      return isNameStart(second) || second === 45 || isValidEscape(second, third);
    }
    if (isNameStart(first)) {
      return true;
    }
    if (first === 92) {
      return isValidEscape(first, second);
    }
    return false;
  }
  function isNumberStart(first, second, third) {
    if (first === 43 || first === 45) {
      if (isDigit(second)) {
        return 2;
      }
      return second === 46 && isDigit(third) ? 3 : 0;
    }
    if (first === 46) {
      return isDigit(second) ? 2 : 0;
    }
    if (isDigit(first)) {
      return 1;
    }
    return 0;
  }
  function isBOM(code2) {
    if (code2 === 65279) {
      return 1;
    }
    if (code2 === 65534) {
      return 1;
    }
    return 0;
  }
  var CATEGORY = new Array(128);
  var EofCategory = 128;
  var WhiteSpaceCategory = 130;
  var DigitCategory = 131;
  var NameStartCategory = 132;
  var NonPrintableCategory = 133;
  for (let i = 0; i < CATEGORY.length; i++) {
    CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
  }
  function charCodeCategory(code2) {
    return code2 < 128 ? CATEGORY[code2] : NameStartCategory;
  }

  // node_modules/css-tree/lib/tokenizer/utils.js
  function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
  }
  function getNewlineLength(source, offset, code2) {
    if (code2 === 13 && getCharCode(source, offset + 1) === 10) {
      return 2;
    }
    return 1;
  }
  function cmpChar(testStr, offset, referenceCode) {
    let code2 = testStr.charCodeAt(offset);
    if (isUppercaseLetter(code2)) {
      code2 = code2 | 32;
    }
    return code2 === referenceCode;
  }
  function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
      return false;
    }
    if (start < 0 || end > testStr.length) {
      return false;
    }
    for (let i = start; i < end; i++) {
      const referenceCode = referenceStr.charCodeAt(i - start);
      let testCode = testStr.charCodeAt(i);
      if (isUppercaseLetter(testCode)) {
        testCode = testCode | 32;
      }
      if (testCode !== referenceCode) {
        return false;
      }
    }
    return true;
  }
  function findWhiteSpaceStart(source, offset) {
    for (; offset >= 0; offset--) {
      if (!isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset + 1;
  }
  function findWhiteSpaceEnd(source, offset) {
    for (; offset < source.length; offset++) {
      if (!isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset;
  }
  function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
      if (!isDigit(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset;
  }
  function consumeEscaped(source, offset) {
    offset += 2;
    if (isHexDigit(getCharCode(source, offset - 1))) {
      for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
        if (!isHexDigit(getCharCode(source, offset))) {
          break;
        }
      }
      const code2 = getCharCode(source, offset);
      if (isWhiteSpace(code2)) {
        offset += getNewlineLength(source, offset, code2);
      }
    }
    return offset;
  }
  function consumeName(source, offset) {
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      if (isName(code2)) {
        continue;
      }
      if (isValidEscape(code2, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset) - 1;
        continue;
      }
      break;
    }
    return offset;
  }
  function consumeNumber(source, offset) {
    let code2 = source.charCodeAt(offset);
    if (code2 === 43 || code2 === 45) {
      code2 = source.charCodeAt(offset += 1);
    }
    if (isDigit(code2)) {
      offset = findDecimalNumberEnd(source, offset + 1);
      code2 = source.charCodeAt(offset);
    }
    if (code2 === 46 && isDigit(source.charCodeAt(offset + 1))) {
      offset += 2;
      offset = findDecimalNumberEnd(source, offset);
    }
    if (cmpChar(
      source,
      offset,
      101
      /* e */
    )) {
      let sign = 0;
      code2 = source.charCodeAt(offset + 1);
      if (code2 === 45 || code2 === 43) {
        sign = 1;
        code2 = source.charCodeAt(offset + 2);
      }
      if (isDigit(code2)) {
        offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
      }
    }
    return offset;
  }
  function consumeBadUrlRemnants(source, offset) {
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      if (code2 === 41) {
        offset++;
        break;
      }
      if (isValidEscape(code2, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset);
      }
    }
    return offset;
  }
  function decodeEscaped(escaped) {
    if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {
      return escaped[0];
    }
    let code2 = parseInt(escaped, 16);
    if (code2 === 0 || // If this number is zero,
    code2 >= 55296 && code2 <= 57343 || // or is for a surrogate,
    code2 > 1114111) {
      code2 = 65533;
    }
    return String.fromCodePoint(code2);
  }

  // node_modules/css-tree/lib/tokenizer/names.js
  var names_default = [
    "EOF-token",
    "ident-token",
    "function-token",
    "at-keyword-token",
    "hash-token",
    "string-token",
    "bad-string-token",
    "url-token",
    "bad-url-token",
    "delim-token",
    "number-token",
    "percentage-token",
    "dimension-token",
    "whitespace-token",
    "CDO-token",
    "CDC-token",
    "colon-token",
    "semicolon-token",
    "comma-token",
    "[-token",
    "]-token",
    "(-token",
    ")-token",
    "{-token",
    "}-token"
  ];

  // node_modules/css-tree/lib/tokenizer/adopt-buffer.js
  var MIN_SIZE = 16 * 1024;
  function adoptBuffer(buffer2 = null, size) {
    if (buffer2 === null || buffer2.length < size) {
      return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
    }
    return buffer2;
  }

  // node_modules/css-tree/lib/tokenizer/OffsetToLocation.js
  var N = 10;
  var F = 12;
  var R = 13;
  function computeLinesAndColumns(host) {
    const source = host.source;
    const sourceLength = source.length;
    const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
    const lines = adoptBuffer(host.lines, sourceLength);
    const columns = adoptBuffer(host.columns, sourceLength);
    let line = host.startLine;
    let column = host.startColumn;
    for (let i = startOffset; i < sourceLength; i++) {
      const code2 = source.charCodeAt(i);
      lines[i] = line;
      columns[i] = column++;
      if (code2 === N || code2 === R || code2 === F) {
        if (code2 === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
          i++;
          lines[i] = line;
          columns[i] = column;
        }
        line++;
        column = 1;
      }
    }
    lines[sourceLength] = line;
    columns[sourceLength] = column;
    host.lines = lines;
    host.columns = columns;
    host.computed = true;
  }
  var OffsetToLocation = class {
    constructor() {
      this.lines = null;
      this.columns = null;
      this.computed = false;
    }
    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
      this.source = source;
      this.startOffset = startOffset;
      this.startLine = startLine;
      this.startColumn = startColumn;
      this.computed = false;
    }
    getLocation(offset, filename) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }
      return {
        source: filename,
        offset: this.startOffset + offset,
        line: this.lines[offset],
        column: this.columns[offset]
      };
    }
    getLocationRange(start, end, filename) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }
      return {
        source: filename,
        start: {
          offset: this.startOffset + start,
          line: this.lines[start],
          column: this.columns[start]
        },
        end: {
          offset: this.startOffset + end,
          line: this.lines[end],
          column: this.columns[end]
        }
      };
    }
  };

  // node_modules/css-tree/lib/tokenizer/TokenStream.js
  var OFFSET_MASK = 16777215;
  var TYPE_SHIFT = 24;
  var balancePair = /* @__PURE__ */ new Map([
    [Function2, RightParenthesis],
    [LeftParenthesis, RightParenthesis],
    [LeftSquareBracket, RightSquareBracket],
    [LeftCurlyBracket, RightCurlyBracket]
  ]);
  var TokenStream = class {
    constructor(source, tokenize3) {
      this.setSource(source, tokenize3);
    }
    reset() {
      this.eof = false;
      this.tokenIndex = -1;
      this.tokenType = 0;
      this.tokenStart = this.firstCharOffset;
      this.tokenEnd = this.firstCharOffset;
    }
    setSource(source = "", tokenize3 = () => {
    }) {
      source = String(source || "");
      const sourceLength = source.length;
      const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1);
      const balance = adoptBuffer(this.balance, source.length + 1);
      let tokenCount = 0;
      let balanceCloseType = 0;
      let balanceStart = 0;
      let firstCharOffset = -1;
      this.offsetAndType = null;
      this.balance = null;
      tokenize3(source, (type, start, end) => {
        switch (type) {
          default:
            balance[tokenCount] = sourceLength;
            break;
          case balanceCloseType: {
            let balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balanceCloseType = balanceStart >> TYPE_SHIFT;
            balance[tokenCount] = balancePrev;
            balance[balancePrev++] = tokenCount;
            for (; balancePrev < tokenCount; balancePrev++) {
              if (balance[balancePrev] === sourceLength) {
                balance[balancePrev] = tokenCount;
              }
            }
            break;
          }
          case LeftParenthesis:
          case Function2:
          case LeftSquareBracket:
          case LeftCurlyBracket:
            balance[tokenCount] = balanceStart;
            balanceCloseType = balancePair.get(type);
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
        }
        offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;
        if (firstCharOffset === -1) {
          firstCharOffset = start;
        }
      });
      offsetAndType[tokenCount] = EOF << TYPE_SHIFT | sourceLength;
      balance[tokenCount] = sourceLength;
      balance[sourceLength] = sourceLength;
      while (balanceStart !== 0) {
        const balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
      }
      this.source = source;
      this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
      this.tokenCount = tokenCount;
      this.offsetAndType = offsetAndType;
      this.balance = balance;
      this.reset();
      this.next();
    }
    lookupType(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return this.offsetAndType[offset] >> TYPE_SHIFT;
      }
      return EOF;
    }
    lookupOffset(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return this.offsetAndType[offset - 1] & OFFSET_MASK;
      }
      return this.source.length;
    }
    lookupValue(offset, referenceStr) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return cmpStr(
          this.source,
          this.offsetAndType[offset - 1] & OFFSET_MASK,
          this.offsetAndType[offset] & OFFSET_MASK,
          referenceStr
        );
      }
      return false;
    }
    getTokenStart(tokenIndex) {
      if (tokenIndex === this.tokenIndex) {
        return this.tokenStart;
      }
      if (tokenIndex > 0) {
        return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
      }
      return this.firstCharOffset;
    }
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    }
    isBalanceEdge(pos) {
      return this.balance[this.tokenIndex] < pos;
    }
    isDelim(code2, offset) {
      if (offset) {
        return this.lookupType(offset) === Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code2;
      }
      return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code2;
    }
    skip(tokenCount) {
      let next = this.tokenIndex + tokenCount;
      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.tokenIndex = this.tokenCount;
        this.next();
      }
    }
    next() {
      let next = this.tokenIndex + 1;
      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.tokenEnd;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.eof = true;
        this.tokenIndex = this.tokenCount;
        this.tokenType = EOF;
        this.tokenStart = this.tokenEnd = this.source.length;
      }
    }
    skipSC() {
      while (this.tokenType === WhiteSpace || this.tokenType === Comment) {
        this.next();
      }
    }
    skipUntilBalanced(startToken, stopConsume) {
      let cursor = startToken;
      let balanceEnd;
      let offset;
      loop:
        for (; cursor < this.tokenCount; cursor++) {
          balanceEnd = this.balance[cursor];
          if (balanceEnd < startToken) {
            break loop;
          }
          offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
          switch (stopConsume(this.source.charCodeAt(offset))) {
            case 1:
              break loop;
            case 2:
              cursor++;
              break loop;
            default:
              if (this.balance[balanceEnd] === cursor) {
                cursor = balanceEnd;
              }
          }
        }
      this.skip(cursor - this.tokenIndex);
    }
    forEachToken(fn) {
      for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
        const start = offset;
        const item = this.offsetAndType[i];
        const end = item & OFFSET_MASK;
        const type = item >> TYPE_SHIFT;
        offset = end;
        fn(type, start, end, i);
      }
    }
    dump() {
      const tokens = new Array(this.tokenCount);
      this.forEachToken((type, start, end, index) => {
        tokens[index] = {
          idx: index,
          type: names_default[type],
          chunk: this.source.substring(start, end),
          balance: this.balance[index]
        };
      });
      return tokens;
    }
  };

  // node_modules/css-tree/lib/tokenizer/index.js
  function tokenize(source, onToken) {
    function getCharCode2(offset2) {
      return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
    }
    function consumeNumericToken() {
      offset = consumeNumber(source, offset);
      if (isIdentifierStart(getCharCode2(offset), getCharCode2(offset + 1), getCharCode2(offset + 2))) {
        type = Dimension;
        offset = consumeName(source, offset);
        return;
      }
      if (getCharCode2(offset) === 37) {
        type = Percentage;
        offset++;
        return;
      }
      type = Number2;
    }
    function consumeIdentLikeToken() {
      const nameStartOffset = offset;
      offset = consumeName(source, offset);
      if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode2(offset) === 40) {
        offset = findWhiteSpaceEnd(source, offset + 1);
        if (getCharCode2(offset) === 34 || getCharCode2(offset) === 39) {
          type = Function2;
          offset = nameStartOffset + 4;
          return;
        }
        consumeUrlToken();
        return;
      }
      if (getCharCode2(offset) === 40) {
        type = Function2;
        offset++;
        return;
      }
      type = Ident;
    }
    function consumeStringToken(endingCodePoint) {
      if (!endingCodePoint) {
        endingCodePoint = getCharCode2(offset++);
      }
      type = String2;
      for (; offset < source.length; offset++) {
        const code2 = source.charCodeAt(offset);
        switch (charCodeCategory(code2)) {
          case endingCodePoint:
            offset++;
            return;
          case WhiteSpaceCategory:
            if (isNewline(code2)) {
              offset += getNewlineLength(source, offset, code2);
              type = BadString;
              return;
            }
            break;
          case 92:
            if (offset === source.length - 1) {
              break;
            }
            const nextCode = getCharCode2(offset + 1);
            if (isNewline(nextCode)) {
              offset += getNewlineLength(source, offset + 1, nextCode);
            } else if (isValidEscape(code2, nextCode)) {
              offset = consumeEscaped(source, offset) - 1;
            }
            break;
        }
      }
    }
    function consumeUrlToken() {
      type = Url;
      offset = findWhiteSpaceEnd(source, offset);
      for (; offset < source.length; offset++) {
        const code2 = source.charCodeAt(offset);
        switch (charCodeCategory(code2)) {
          case 41:
            offset++;
            return;
          case WhiteSpaceCategory:
            offset = findWhiteSpaceEnd(source, offset);
            if (getCharCode2(offset) === 41 || offset >= source.length) {
              if (offset < source.length) {
                offset++;
              }
              return;
            }
            offset = consumeBadUrlRemnants(source, offset);
            type = BadUrl;
            return;
          case 34:
          case 39:
          case 40:
          case NonPrintableCategory:
            offset = consumeBadUrlRemnants(source, offset);
            type = BadUrl;
            return;
          case 92:
            if (isValidEscape(code2, getCharCode2(offset + 1))) {
              offset = consumeEscaped(source, offset) - 1;
              break;
            }
            offset = consumeBadUrlRemnants(source, offset);
            type = BadUrl;
            return;
        }
      }
    }
    source = String(source || "");
    const sourceLength = source.length;
    let start = isBOM(getCharCode2(0));
    let offset = start;
    let type;
    while (offset < sourceLength) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory(code2)) {
        case WhiteSpaceCategory:
          type = WhiteSpace;
          offset = findWhiteSpaceEnd(source, offset + 1);
          break;
        case 34:
          consumeStringToken();
          break;
        case 35:
          if (isName(getCharCode2(offset + 1)) || isValidEscape(getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            type = Hash;
            offset = consumeName(source, offset + 1);
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 39:
          consumeStringToken();
          break;
        case 40:
          type = LeftParenthesis;
          offset++;
          break;
        case 41:
          type = RightParenthesis;
          offset++;
          break;
        case 43:
          if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            consumeNumericToken();
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 44:
          type = Comma;
          offset++;
          break;
        case 45:
          if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            consumeNumericToken();
          } else {
            if (getCharCode2(offset + 1) === 45 && getCharCode2(offset + 2) === 62) {
              type = CDC;
              offset = offset + 3;
            } else {
              if (isIdentifierStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
                consumeIdentLikeToken();
              } else {
                type = Delim;
                offset++;
              }
            }
          }
          break;
        case 46:
          if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            consumeNumericToken();
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 47:
          if (getCharCode2(offset + 1) === 42) {
            type = Comment;
            offset = source.indexOf("*/", offset + 2);
            offset = offset === -1 ? source.length : offset + 2;
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 58:
          type = Colon;
          offset++;
          break;
        case 59:
          type = Semicolon;
          offset++;
          break;
        case 60:
          if (getCharCode2(offset + 1) === 33 && getCharCode2(offset + 2) === 45 && getCharCode2(offset + 3) === 45) {
            type = CDO;
            offset = offset + 4;
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 64:
          if (isIdentifierStart(getCharCode2(offset + 1), getCharCode2(offset + 2), getCharCode2(offset + 3))) {
            type = AtKeyword;
            offset = consumeName(source, offset + 1);
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 91:
          type = LeftSquareBracket;
          offset++;
          break;
        case 92:
          if (isValidEscape(code2, getCharCode2(offset + 1))) {
            consumeIdentLikeToken();
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 93:
          type = RightSquareBracket;
          offset++;
          break;
        case 123:
          type = LeftCurlyBracket;
          offset++;
          break;
        case 125:
          type = RightCurlyBracket;
          offset++;
          break;
        case DigitCategory:
          consumeNumericToken();
          break;
        case NameStartCategory:
          consumeIdentLikeToken();
          break;
        default:
          type = Delim;
          offset++;
      }
      onToken(type, start, start = offset);
    }
  }

  // node_modules/css-tree/lib/utils/List.js
  var releasedCursors = null;
  var List = class {
    static createItem(data) {
      return {
        prev: null,
        next: null,
        data
      };
    }
    constructor() {
      this.head = null;
      this.tail = null;
      this.cursor = null;
    }
    createItem(data) {
      return List.createItem(data);
    }
    // cursor helpers
    allocateCursor(prev, next) {
      let cursor;
      if (releasedCursors !== null) {
        cursor = releasedCursors;
        releasedCursors = releasedCursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = this.cursor;
      } else {
        cursor = {
          prev,
          next,
          cursor: this.cursor
        };
      }
      this.cursor = cursor;
      return cursor;
    }
    releaseCursor() {
      const { cursor } = this;
      this.cursor = cursor.cursor;
      cursor.prev = null;
      cursor.next = null;
      cursor.cursor = releasedCursors;
      releasedCursors = cursor;
    }
    updateCursors(prevOld, prevNew, nextOld, nextNew) {
      let { cursor } = this;
      while (cursor !== null) {
        if (cursor.prev === prevOld) {
          cursor.prev = prevNew;
        }
        if (cursor.next === nextOld) {
          cursor.next = nextNew;
        }
        cursor = cursor.cursor;
      }
    }
    *[Symbol.iterator]() {
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        yield cursor.data;
      }
    }
    // getters
    get size() {
      let size = 0;
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        size++;
      }
      return size;
    }
    get isEmpty() {
      return this.head === null;
    }
    get first() {
      return this.head && this.head.data;
    }
    get last() {
      return this.tail && this.tail.data;
    }
    // convertors
    fromArray(array) {
      let cursor = null;
      this.head = null;
      for (let data of array) {
        const item = List.createItem(data);
        if (cursor !== null) {
          cursor.next = item;
        } else {
          this.head = item;
        }
        item.prev = cursor;
        cursor = item;
      }
      this.tail = cursor;
      return this;
    }
    toArray() {
      return [...this];
    }
    toJSON() {
      return [...this];
    }
    // array-like methods
    forEach(fn, thisArg = this) {
      const cursor = this.allocateCursor(null, this.head);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        fn.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    forEachRight(fn, thisArg = this) {
      const cursor = this.allocateCursor(this.tail, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        fn.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    reduce(fn, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(null, this.head);
      let acc = initialValue;
      let item;
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        acc = fn.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    reduceRight(fn, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(this.tail, null);
      let acc = initialValue;
      let item;
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        acc = fn.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    some(fn, thisArg = this) {
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        if (fn.call(thisArg, cursor.data, cursor, this)) {
          return true;
        }
      }
      return false;
    }
    map(fn, thisArg = this) {
      const result = new List();
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        result.appendData(fn.call(thisArg, cursor.data, cursor, this));
      }
      return result;
    }
    filter(fn, thisArg = this) {
      const result = new List();
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        if (fn.call(thisArg, cursor.data, cursor, this)) {
          result.appendData(cursor.data);
        }
      }
      return result;
    }
    nextUntil(start, fn, thisArg = this) {
      if (start === null) {
        return;
      }
      const cursor = this.allocateCursor(null, start);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        if (fn.call(thisArg, item.data, item, this)) {
          break;
        }
      }
      this.releaseCursor();
    }
    prevUntil(start, fn, thisArg = this) {
      if (start === null) {
        return;
      }
      const cursor = this.allocateCursor(start, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        if (fn.call(thisArg, item.data, item, this)) {
          break;
        }
      }
      this.releaseCursor();
    }
    // mutation
    clear() {
      this.head = null;
      this.tail = null;
    }
    copy() {
      const result = new List();
      for (let data of this) {
        result.appendData(data);
      }
      return result;
    }
    prepend(item) {
      this.updateCursors(null, item, this.head, item);
      if (this.head !== null) {
        this.head.prev = item;
        item.next = this.head;
      } else {
        this.tail = item;
      }
      this.head = item;
      return this;
    }
    prependData(data) {
      return this.prepend(List.createItem(data));
    }
    append(item) {
      return this.insert(item);
    }
    appendData(data) {
      return this.insert(List.createItem(data));
    }
    insert(item, before = null) {
      if (before !== null) {
        this.updateCursors(before.prev, item, before, item);
        if (before.prev === null) {
          if (this.head !== before) {
            throw new Error("before doesn't belong to list");
          }
          this.head = item;
          before.prev = item;
          item.next = before;
          this.updateCursors(null, item);
        } else {
          before.prev.next = item;
          item.prev = before.prev;
          before.prev = item;
          item.next = before;
        }
      } else {
        this.updateCursors(this.tail, item, null, item);
        if (this.tail !== null) {
          this.tail.next = item;
          item.prev = this.tail;
        } else {
          this.head = item;
        }
        this.tail = item;
      }
      return this;
    }
    insertData(data, before) {
      return this.insert(List.createItem(data), before);
    }
    remove(item) {
      this.updateCursors(item, item.prev, item, item.next);
      if (item.prev !== null) {
        item.prev.next = item.next;
      } else {
        if (this.head !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.head = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      } else {
        if (this.tail !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.tail = item.prev;
      }
      item.prev = null;
      item.next = null;
      return item;
    }
    push(data) {
      this.insert(List.createItem(data));
    }
    pop() {
      return this.tail !== null ? this.remove(this.tail) : null;
    }
    unshift(data) {
      this.prepend(List.createItem(data));
    }
    shift() {
      return this.head !== null ? this.remove(this.head) : null;
    }
    prependList(list) {
      return this.insertList(list, this.head);
    }
    appendList(list) {
      return this.insertList(list);
    }
    insertList(list, before) {
      if (list.head === null) {
        return this;
      }
      if (before !== void 0 && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);
        if (before.prev !== null) {
          before.prev.next = list.head;
          list.head.prev = before.prev;
        } else {
          this.head = list.head;
        }
        before.prev = list.tail;
        list.tail.next = before;
      } else {
        this.updateCursors(this.tail, list.tail, null, list.head);
        if (this.tail !== null) {
          this.tail.next = list.head;
          list.head.prev = this.tail;
        } else {
          this.head = list.head;
        }
        this.tail = list.tail;
      }
      list.head = null;
      list.tail = null;
      return this;
    }
    replace(oldItem, newItemOrList) {
      if ("head" in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
      } else {
        this.insert(newItemOrList, oldItem);
      }
      this.remove(oldItem);
    }
  };

  // node_modules/css-tree/lib/utils/create-custom-error.js
  function createCustomError(name41, message) {
    const error = Object.create(SyntaxError.prototype);
    const errorStack = new Error();
    return Object.assign(error, {
      name: name41,
      message,
      get stack() {
        return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name41}: ${message}
`);
      }
    });
  }

  // node_modules/css-tree/lib/parser/SyntaxError.js
  var MAX_LINE_LENGTH = 100;
  var OFFSET_CORRECTION = 60;
  var TAB_REPLACEMENT = "    ";
  function sourceFragment({ source, line, column }, extraLines) {
    function processLines(start, end) {
      return lines.slice(start, end).map(
        (line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2
      ).join("\n");
    }
    const lines = source.split(/\r\n?|\n|\f/);
    const startLine = Math.max(1, line - extraLines) - 1;
    const endLine = Math.min(line + extraLines, lines.length + 1);
    const maxNumLength = Math.max(4, String(endLine).length) + 1;
    let cutLeft = 0;
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
    if (column > MAX_LINE_LENGTH) {
      cutLeft = column - OFFSET_CORRECTION + 3;
      column = OFFSET_CORRECTION - 2;
    }
    for (let i = startLine; i <= endLine; i++) {
      if (i >= 0 && i < lines.length) {
        lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
        lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
      }
    }
    return [
      processLines(startLine, line),
      new Array(column + maxNumLength + 2).join("-") + "^",
      processLines(line, endLine)
    ].filter(Boolean).join("\n");
  }
  function SyntaxError2(message, source, offset, line, column) {
    const error = Object.assign(createCustomError("SyntaxError", message), {
      source,
      offset,
      line,
      column,
      sourceFragment(extraLines) {
        return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
      },
      get formattedMessage() {
        return `Parse error: ${message}
` + sourceFragment({ source, line, column }, 2);
      }
    });
    return error;
  }

  // node_modules/css-tree/lib/parser/sequence.js
  function readSequence(recognizer) {
    const children = this.createList();
    let space = false;
    const context = {
      recognizer
    };
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
          this.next();
          continue;
        case WhiteSpace:
          space = true;
          this.next();
          continue;
      }
      let child = recognizer.getNode.call(this, context);
      if (child === void 0) {
        break;
      }
      if (space) {
        if (recognizer.onWhiteSpace) {
          recognizer.onWhiteSpace.call(this, child, children, context);
        }
        space = false;
      }
      children.push(child);
    }
    if (space && recognizer.onWhiteSpace) {
      recognizer.onWhiteSpace.call(this, null, children, context);
    }
    return children;
  }

  // node_modules/css-tree/lib/parser/create.js
  var NOOP = () => {
  };
  var EXCLAMATIONMARK = 33;
  var NUMBERSIGN = 35;
  var SEMICOLON = 59;
  var LEFTCURLYBRACKET = 123;
  var NULL = 0;
  function createParseContext(name41) {
    return function() {
      return this[name41]();
    };
  }
  function fetchParseValues(dict) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const name41 in dict) {
      const item = dict[name41];
      if (item.parse) {
        result[name41] = item.parse;
      }
    }
    return result;
  }
  function processConfig(config) {
    const parseConfig = {
      context: /* @__PURE__ */ Object.create(null),
      scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
      atrule: fetchParseValues(config.atrule),
      pseudo: fetchParseValues(config.pseudo),
      node: fetchParseValues(config.node)
    };
    for (const name41 in config.parseContext) {
      switch (typeof config.parseContext[name41]) {
        case "function":
          parseConfig.context[name41] = config.parseContext[name41];
          break;
        case "string":
          parseConfig.context[name41] = createParseContext(config.parseContext[name41]);
          break;
      }
    }
    return {
      config: parseConfig,
      ...parseConfig,
      ...parseConfig.node
    };
  }
  function createParser(config) {
    let source = "";
    let filename = "<unknown>";
    let needPositions = false;
    let onParseError = NOOP;
    let onParseErrorThrow = false;
    const locationMap = new OffsetToLocation();
    const parser = Object.assign(new TokenStream(), processConfig(config || {}), {
      parseAtrulePrelude: true,
      parseRulePrelude: true,
      parseValue: true,
      parseCustomProperty: false,
      readSequence,
      consumeUntilBalanceEnd: () => 0,
      consumeUntilLeftCurlyBracket(code2) {
        return code2 === LEFTCURLYBRACKET ? 1 : 0;
      },
      consumeUntilLeftCurlyBracketOrSemicolon(code2) {
        return code2 === LEFTCURLYBRACKET || code2 === SEMICOLON ? 1 : 0;
      },
      consumeUntilExclamationMarkOrSemicolon(code2) {
        return code2 === EXCLAMATIONMARK || code2 === SEMICOLON ? 1 : 0;
      },
      consumeUntilSemicolonIncluded(code2) {
        return code2 === SEMICOLON ? 2 : 0;
      },
      createList() {
        return new List();
      },
      createSingleNodeList(node) {
        return new List().appendData(node);
      },
      getFirstListNode(list) {
        return list && list.first;
      },
      getLastListNode(list) {
        return list && list.last;
      },
      parseWithFallback(consumer, fallback) {
        const startToken = this.tokenIndex;
        try {
          return consumer.call(this);
        } catch (e) {
          if (onParseErrorThrow) {
            throw e;
          }
          const fallbackNode = fallback.call(this, startToken);
          onParseErrorThrow = true;
          onParseError(e, fallbackNode);
          onParseErrorThrow = false;
          return fallbackNode;
        }
      },
      lookupNonWSType(offset) {
        let type;
        do {
          type = this.lookupType(offset++);
          if (type !== WhiteSpace) {
            return type;
          }
        } while (type !== NULL);
        return NULL;
      },
      charCodeAt(offset) {
        return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
      },
      substring(offsetStart, offsetEnd) {
        return source.substring(offsetStart, offsetEnd);
      },
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      },
      cmpChar(offset, charCode2) {
        return cmpChar(source, offset, charCode2);
      },
      cmpStr(offsetStart, offsetEnd, str) {
        return cmpStr(source, offsetStart, offsetEnd, str);
      },
      consume(tokenType2) {
        const start = this.tokenStart;
        this.eat(tokenType2);
        return this.substrToCursor(start);
      },
      consumeFunctionName() {
        const name41 = source.substring(this.tokenStart, this.tokenEnd - 1);
        this.eat(Function2);
        return name41;
      },
      consumeNumber(type) {
        const number2 = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));
        this.eat(type);
        return number2;
      },
      eat(tokenType2) {
        if (this.tokenType !== tokenType2) {
          const tokenName = names_default[tokenType2].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
          let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
          let offset = this.tokenStart;
          switch (tokenType2) {
            case Ident:
              if (this.tokenType === Function2 || this.tokenType === Url) {
                offset = this.tokenEnd - 1;
                message = "Identifier is expected but function found";
              } else {
                message = "Identifier is expected";
              }
              break;
            case Hash:
              if (this.isDelim(NUMBERSIGN)) {
                this.next();
                offset++;
                message = "Name is expected";
              }
              break;
            case Percentage:
              if (this.tokenType === Number2) {
                offset = this.tokenEnd;
                message = "Percent sign is expected";
              }
              break;
          }
          this.error(message, offset);
        }
        this.next();
      },
      eatIdent(name41) {
        if (this.tokenType !== Ident || this.lookupValue(0, name41) === false) {
          this.error(`Identifier "${name41}" is expected`);
        }
        this.next();
      },
      eatDelim(code2) {
        if (!this.isDelim(code2)) {
          this.error(`Delim "${String.fromCharCode(code2)}" is expected`);
        }
        this.next();
      },
      getLocation(start, end) {
        if (needPositions) {
          return locationMap.getLocationRange(
            start,
            end,
            filename
          );
        }
        return null;
      },
      getLocationFromList(list) {
        if (needPositions) {
          const head = this.getFirstListNode(list);
          const tail = this.getLastListNode(list);
          return locationMap.getLocationRange(
            head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
            tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
            filename
          );
        }
        return null;
      },
      error(message, offset) {
        const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
        throw new SyntaxError2(
          message || "Unexpected input",
          source,
          location.offset,
          location.line,
          location.column
        );
      }
    });
    const parse44 = function(source_, options) {
      source = source_;
      options = options || {};
      parser.setSource(source, tokenize);
      locationMap.setSource(
        source,
        options.offset,
        options.line,
        options.column
      );
      filename = options.filename || "<unknown>";
      needPositions = Boolean(options.positions);
      onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
      onParseErrorThrow = false;
      parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
      parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
      parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
      parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
      const { context = "default", onComment } = options;
      if (context in parser.context === false) {
        throw new Error("Unknown context `" + context + "`");
      }
      if (typeof onComment === "function") {
        parser.forEachToken((type, start, end) => {
          if (type === Comment) {
            const loc = parser.getLocation(start, end);
            const value = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
            onComment(value, loc);
          }
        });
      }
      const ast = parser.context[context].call(parser, options);
      if (!parser.eof) {
        parser.error();
      }
      return ast;
    };
    return Object.assign(parse44, {
      SyntaxError: SyntaxError2,
      config: parser.config
    });
  }

  // node_modules/css-tree/lib/generator/sourceMap.js
  var import_source_map_generator = __toESM(require_source_map_generator(), 1);
  var trackNodes = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
  function generateSourceMap(handlers) {
    const map = new import_source_map_generator.SourceMapGenerator();
    const generated = {
      line: 1,
      column: 0
    };
    const original = {
      line: 0,
      // should be zero to add first mapping
      column: 0
    };
    const activatedGenerated = {
      line: 1,
      column: 0
    };
    const activatedMapping = {
      generated: activatedGenerated
    };
    let line = 1;
    let column = 0;
    let sourceMappingActive = false;
    const origHandlersNode = handlers.node;
    handlers.node = function(node) {
      if (node.loc && node.loc.start && trackNodes.has(node.type)) {
        const nodeLine = node.loc.start.line;
        const nodeColumn = node.loc.start.column - 1;
        if (original.line !== nodeLine || original.column !== nodeColumn) {
          original.line = nodeLine;
          original.column = nodeColumn;
          generated.line = line;
          generated.column = column;
          if (sourceMappingActive) {
            sourceMappingActive = false;
            if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
              map.addMapping(activatedMapping);
            }
          }
          sourceMappingActive = true;
          map.addMapping({
            source: node.loc.source,
            original,
            generated
          });
        }
      }
      origHandlersNode.call(this, node);
      if (sourceMappingActive && trackNodes.has(node.type)) {
        activatedGenerated.line = line;
        activatedGenerated.column = column;
      }
    };
    const origHandlersEmit = handlers.emit;
    handlers.emit = function(value, type, auto) {
      for (let i = 0; i < value.length; i++) {
        if (value.charCodeAt(i) === 10) {
          line++;
          column = 0;
        } else {
          column++;
        }
      }
      origHandlersEmit(value, type, auto);
    };
    const origHandlersResult = handlers.result;
    handlers.result = function() {
      if (sourceMappingActive) {
        map.addMapping(activatedMapping);
      }
      return {
        css: origHandlersResult(),
        map
      };
    };
    return handlers;
  }

  // node_modules/css-tree/lib/generator/token-before.js
  var token_before_exports = {};
  __export(token_before_exports, {
    safe: () => safe,
    spec: () => spec
  });
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var code = (type, value) => {
    if (type === Delim) {
      type = value;
    }
    if (typeof type === "string") {
      const charCode2 = type.charCodeAt(0);
      return charCode2 > 127 ? 32768 : charCode2 << 8;
    }
    return type;
  };
  var specPairs = [
    [Ident, Ident],
    [Ident, Function2],
    [Ident, Url],
    [Ident, BadUrl],
    [Ident, "-"],
    [Ident, Number2],
    [Ident, Percentage],
    [Ident, Dimension],
    [Ident, CDC],
    [Ident, LeftParenthesis],
    [AtKeyword, Ident],
    [AtKeyword, Function2],
    [AtKeyword, Url],
    [AtKeyword, BadUrl],
    [AtKeyword, "-"],
    [AtKeyword, Number2],
    [AtKeyword, Percentage],
    [AtKeyword, Dimension],
    [AtKeyword, CDC],
    [Hash, Ident],
    [Hash, Function2],
    [Hash, Url],
    [Hash, BadUrl],
    [Hash, "-"],
    [Hash, Number2],
    [Hash, Percentage],
    [Hash, Dimension],
    [Hash, CDC],
    [Dimension, Ident],
    [Dimension, Function2],
    [Dimension, Url],
    [Dimension, BadUrl],
    [Dimension, "-"],
    [Dimension, Number2],
    [Dimension, Percentage],
    [Dimension, Dimension],
    [Dimension, CDC],
    ["#", Ident],
    ["#", Function2],
    ["#", Url],
    ["#", BadUrl],
    ["#", "-"],
    ["#", Number2],
    ["#", Percentage],
    ["#", Dimension],
    ["-", Ident],
    ["-", Function2],
    ["-", Url],
    ["-", BadUrl],
    ["-", "-"],
    ["-", Number2],
    ["-", Percentage],
    ["-", Dimension],
    [Number2, Ident],
    [Number2, Function2],
    [Number2, Url],
    [Number2, BadUrl],
    [Number2, Number2],
    [Number2, Percentage],
    [Number2, Dimension],
    ["@", Ident],
    ["@", Function2],
    ["@", Url],
    ["@", BadUrl],
    ["@", "-"],
    [".", Number2],
    [".", Percentage],
    [".", Dimension],
    ["+", Number2],
    ["+", Percentage],
    ["+", Dimension],
    ["/", "*"]
  ];
  var safePairs = specPairs.concat([
    [AtKeyword, LeftParenthesis],
    [AtKeyword, String2],
    [AtKeyword, Colon],
    [RightParenthesis, Ident],
    [RightParenthesis, Function2],
    [RightParenthesis, Url],
    [Url, Ident],
    [Url, Function2],
    [Url, Url]
  ]);
  function createMap(pairs) {
    const isWhiteSpaceRequired = new Set(
      pairs.map(([prev, next]) => code(prev) << 16 | code(next))
    );
    return function(prevCode, type, value) {
      const nextCode = code(type, value);
      const nextCharCode = value.charCodeAt(0);
      const emitWs = nextCharCode === HYPHENMINUS || nextCharCode === PLUSSIGN ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
      if (emitWs) {
        this.emit(" ", WhiteSpace, true);
      }
      return nextCode;
    };
  }
  var spec = createMap(specPairs);
  var safe = createMap(safePairs);

  // node_modules/css-tree/lib/generator/create.js
  var REVERSESOLIDUS = 92;
  function processChildren(node, delimeter) {
    if (typeof delimeter === "function") {
      let prev = null;
      node.children.forEach((node2) => {
        if (prev !== null) {
          delimeter.call(this, prev);
        }
        this.node(node2);
        prev = node2;
      });
      return;
    }
    node.children.forEach(this.node, this);
  }
  function processChunk(chunk) {
    tokenize(chunk, (type, start, end) => {
      this.token(type, chunk.slice(start, end));
    });
  }
  function createGenerator(config) {
    const types = /* @__PURE__ */ new Map();
    for (let name41 in config.node) {
      types.set(name41, config.node[name41].generate);
    }
    return function(node, options) {
      let buffer2 = "";
      let prevCode = 0;
      let handlers = {
        node(node2) {
          if (types.has(node2.type)) {
            types.get(node2.type).call(publicApi, node2);
          } else {
            throw new Error("Unknown node type: " + node2.type);
          }
        },
        tokenBefore: safe,
        token(type, value) {
          prevCode = this.tokenBefore(prevCode, type, value);
          this.emit(value, type, false);
          if (type === Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
            this.emit("\n", WhiteSpace, true);
          }
        },
        emit(value) {
          buffer2 += value;
        },
        result() {
          return buffer2;
        }
      };
      if (options) {
        if (typeof options.decorator === "function") {
          handlers = options.decorator(handlers);
        }
        if (options.sourceMap) {
          handlers = generateSourceMap(handlers);
        }
        if (options.mode in token_before_exports) {
          handlers.tokenBefore = token_before_exports[options.mode];
        }
      }
      const publicApi = {
        node: (node2) => handlers.node(node2),
        children: processChildren,
        token: (type, value) => handlers.token(type, value),
        tokenize: processChunk
      };
      handlers.node(node);
      return handlers.result();
    };
  }

  // node_modules/css-tree/lib/convertor/create.js
  function createConvertor(walk3) {
    return {
      fromPlainObject: function(ast) {
        walk3(ast, {
          enter: function(node) {
            if (node.children && node.children instanceof List === false) {
              node.children = new List().fromArray(node.children);
            }
          }
        });
        return ast;
      },
      toPlainObject: function(ast) {
        walk3(ast, {
          leave: function(node) {
            if (node.children && node.children instanceof List) {
              node.children = node.children.toArray();
            }
          }
        });
        return ast;
      }
    };
  }

  // node_modules/css-tree/lib/walker/create.js
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  var noop = function() {
  };
  function ensureFunction(value) {
    return typeof value === "function" ? value : noop;
  }
  function invokeForType(fn, type) {
    return function(node, item, list) {
      if (node.type === type) {
        fn.call(this, node, item, list);
      }
    };
  }
  function getWalkersFromStructure(name41, nodeType) {
    const structure41 = nodeType.structure;
    const walkers = [];
    for (const key in structure41) {
      if (hasOwnProperty2.call(structure41, key) === false) {
        continue;
      }
      let fieldTypes = structure41[key];
      const walker = {
        name: key,
        type: false,
        nullable: false
      };
      if (!Array.isArray(fieldTypes)) {
        fieldTypes = [fieldTypes];
      }
      for (const fieldType of fieldTypes) {
        if (fieldType === null) {
          walker.nullable = true;
        } else if (typeof fieldType === "string") {
          walker.type = "node";
        } else if (Array.isArray(fieldType)) {
          walker.type = "list";
        }
      }
      if (walker.type) {
        walkers.push(walker);
      }
    }
    if (walkers.length) {
      return {
        context: nodeType.walkContext,
        fields: walkers
      };
    }
    return null;
  }
  function getTypesFromConfig(config) {
    const types = {};
    for (const name41 in config.node) {
      if (hasOwnProperty2.call(config.node, name41)) {
        const nodeType = config.node[name41];
        if (!nodeType.structure) {
          throw new Error("Missed `structure` field in `" + name41 + "` node type definition");
        }
        types[name41] = getWalkersFromStructure(name41, nodeType);
      }
    }
    return types;
  }
  function createTypeIterator(config, reverse) {
    const fields = config.fields.slice();
    const contextName = config.context;
    const useContext = typeof contextName === "string";
    if (reverse) {
      fields.reverse();
    }
    return function(node, context, walk3, walkReducer) {
      let prevContextValue;
      if (useContext) {
        prevContextValue = context[contextName];
        context[contextName] = node;
      }
      for (const field of fields) {
        const ref = node[field.name];
        if (!field.nullable || ref) {
          if (field.type === "list") {
            var breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
            if (breakWalk) {
              return true;
            }
          } else if (walk3(ref)) {
            return true;
          }
        }
      }
      if (useContext) {
        context[contextName] = prevContextValue;
      }
    };
  }
  function createFastTraveralMap({
    StyleSheet,
    Atrule,
    Rule,
    Block,
    DeclarationList
  }) {
    return {
      Atrule: {
        StyleSheet,
        Atrule,
        Rule,
        Block
      },
      Rule: {
        StyleSheet,
        Atrule,
        Rule,
        Block
      },
      Declaration: {
        StyleSheet,
        Atrule,
        Rule,
        Block,
        DeclarationList
      }
    };
  }
  function createWalker(config) {
    const types = getTypesFromConfig(config);
    const iteratorsNatural = {};
    const iteratorsReverse = {};
    const breakWalk = Symbol("break-walk");
    const skipNode = Symbol("skip-node");
    for (const name41 in types) {
      if (hasOwnProperty2.call(types, name41) && types[name41] !== null) {
        iteratorsNatural[name41] = createTypeIterator(types[name41], false);
        iteratorsReverse[name41] = createTypeIterator(types[name41], true);
      }
    }
    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
    const walk3 = function(root, options) {
      function walkNode(node, item, list) {
        var enterRet = enter.call(context, node, item, list);
        if (enterRet === breakWalk) {
          return true;
        }
        if (enterRet === skipNode) {
          return false;
        }
        if (iterators.hasOwnProperty(node.type)) {
          if (iterators[node.type](node, context, walkNode, walkReducer)) {
            return true;
          }
        }
        if (leave.call(context, node, item, list) === breakWalk) {
          return true;
        }
        return false;
      }
      let enter = noop;
      let leave = noop;
      let iterators = iteratorsNatural;
      let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
      const context = {
        break: breakWalk,
        skip: skipNode,
        root,
        stylesheet: null,
        atrule: null,
        atrulePrelude: null,
        rule: null,
        selector: null,
        block: null,
        declaration: null,
        function: null
      };
      if (typeof options === "function") {
        enter = options;
      } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
        if (options.reverse) {
          iterators = iteratorsReverse;
        }
        if (options.visit) {
          if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
            iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
          } else if (!types.hasOwnProperty(options.visit)) {
            throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).sort().join(", ") + ")");
          }
          enter = invokeForType(enter, options.visit);
          leave = invokeForType(leave, options.visit);
        }
      }
      if (enter === noop && leave === noop) {
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      }
      walkNode(root);
    };
    walk3.break = breakWalk;
    walk3.skip = skipNode;
    walk3.find = function(ast, fn) {
      let found = null;
      walk3(ast, function(node, item, list) {
        if (fn.call(this, node, item, list)) {
          found = node;
          return breakWalk;
        }
      });
      return found;
    };
    walk3.findLast = function(ast, fn) {
      let found = null;
      walk3(ast, {
        reverse: true,
        enter: function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found = node;
            return breakWalk;
          }
        }
      });
      return found;
    };
    walk3.findAll = function(ast, fn) {
      const found = [];
      walk3(ast, function(node, item, list) {
        if (fn.call(this, node, item, list)) {
          found.push(node);
        }
      });
      return found;
    };
    return walk3;
  }

  // node_modules/css-tree/lib/definition-syntax/generate.js
  function noop2(value) {
    return value;
  }
  function generateMultiplier(multiplier) {
    const { min, max, comma } = multiplier;
    if (min === 0 && max === 0) {
      return "*";
    }
    if (min === 0 && max === 1) {
      return "?";
    }
    if (min === 1 && max === 0) {
      return comma ? "#" : "+";
    }
    if (min === 1 && max === 1) {
      return "";
    }
    return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
  }
  function generateTypeOpts(node) {
    switch (node.type) {
      case "Range":
        return " [" + (node.min === null ? "-\u221E" : node.min) + "," + (node.max === null ? "\u221E" : node.max) + "]";
      default:
        throw new Error("Unknown node type `" + node.type + "`");
    }
  }
  function generateSequence(node, decorate, forceBraces, compact) {
    const combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
    const result = node.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
    if (node.explicit || forceBraces) {
      return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
    }
    return result;
  }
  function internalGenerate(node, decorate, forceBraces, compact) {
    let result;
    switch (node.type) {
      case "Group":
        result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
        break;
      case "Multiplier":
        return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
      case "Type":
        result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
        break;
      case "Property":
        result = "<'" + node.name + "'>";
        break;
      case "Keyword":
        result = node.name;
        break;
      case "AtKeyword":
        result = "@" + node.name;
        break;
      case "Function":
        result = node.name + "(";
        break;
      case "String":
      case "Token":
        result = node.value;
        break;
      case "Comma":
        result = ",";
        break;
      default:
        throw new Error("Unknown node type `" + node.type + "`");
    }
    return decorate(result, node);
  }
  function generate(node, options) {
    let decorate = noop2;
    let forceBraces = false;
    let compact = false;
    if (typeof options === "function") {
      decorate = options;
    } else if (options) {
      forceBraces = Boolean(options.forceBraces);
      compact = Boolean(options.compact);
      if (typeof options.decorate === "function") {
        decorate = options.decorate;
      }
    }
    return internalGenerate(node, decorate, forceBraces, compact);
  }

  // node_modules/css-tree/lib/lexer/error.js
  var defaultLoc = { offset: 0, line: 1, column: 1 };
  function locateMismatch(matchResult, node) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = "";
    let start;
    let end;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i].value;
      if (i === longestMatch) {
        mismatchLength = token.length;
        mismatchOffset = css.length;
      }
      if (badNode !== null && tokens[i].node === badNode) {
        if (i <= longestMatch) {
          entries++;
        } else {
          entries = 0;
        }
      }
      css += token;
    }
    if (longestMatch === tokens.length || entries > 1) {
      start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
      end = buildLoc(start);
    } else {
      start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
      end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }
    return {
      css,
      mismatchOffset,
      mismatchLength,
      start,
      end
    };
  }
  function fromLoc(node, point) {
    const value = node && node.loc && node.loc[point];
    if (value) {
      return "line" in value ? buildLoc(value) : value;
    }
    return null;
  }
  function buildLoc({ offset, line, column }, extra) {
    const loc = {
      offset,
      line,
      column
    };
    if (extra) {
      const lines = extra.split(/\n|\r\n?|\f/);
      loc.offset += extra.length;
      loc.line += lines.length - 1;
      loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }
    return loc;
  }
  var SyntaxReferenceError = function(type, referenceName) {
    const error = createCustomError(
      "SyntaxReferenceError",
      type + (referenceName ? " `" + referenceName + "`" : "")
    );
    error.reference = referenceName;
    return error;
  };
  var SyntaxMatchError = function(message, syntax, node, matchResult) {
    const error = createCustomError("SyntaxMatchError", message);
    const {
      css,
      mismatchOffset,
      mismatchLength,
      start,
      end
    } = locateMismatch(matchResult, node);
    error.rawMessage = message;
    error.syntax = syntax ? generate(syntax) : "<generic>";
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
    Object.assign(error, start);
    error.loc = {
      source: node && node.loc && node.loc.source || "<unknown>",
      start,
      end
    };
    return error;
  };

  // node_modules/css-tree/lib/utils/names.js
  var keywords = /* @__PURE__ */ new Map();
  var properties = /* @__PURE__ */ new Map();
  var HYPHENMINUS2 = 45;
  var keyword = getKeywordDescriptor;
  var property = getPropertyDescriptor;
  function isCustomProperty(str, offset) {
    offset = offset || 0;
    return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS2 && str.charCodeAt(offset + 1) === HYPHENMINUS2;
  }
  function getVendorPrefix(str, offset) {
    offset = offset || 0;
    if (str.length - offset >= 3) {
      if (str.charCodeAt(offset) === HYPHENMINUS2 && str.charCodeAt(offset + 1) !== HYPHENMINUS2) {
        const secondDashIndex = str.indexOf("-", offset + 2);
        if (secondDashIndex !== -1) {
          return str.substring(offset, secondDashIndex + 1);
        }
      }
    }
    return "";
  }
  function getKeywordDescriptor(keyword2) {
    if (keywords.has(keyword2)) {
      return keywords.get(keyword2);
    }
    const name41 = keyword2.toLowerCase();
    let descriptor = keywords.get(name41);
    if (descriptor === void 0) {
      const custom = isCustomProperty(name41, 0);
      const vendor = !custom ? getVendorPrefix(name41, 0) : "";
      descriptor = Object.freeze({
        basename: name41.substr(vendor.length),
        name: name41,
        prefix: vendor,
        vendor,
        custom
      });
    }
    keywords.set(keyword2, descriptor);
    return descriptor;
  }
  function getPropertyDescriptor(property2) {
    if (properties.has(property2)) {
      return properties.get(property2);
    }
    let name41 = property2;
    let hack = property2[0];
    if (hack === "/") {
      hack = property2[1] === "/" ? "//" : "/";
    } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
      hack = "";
    }
    const custom = isCustomProperty(name41, hack.length);
    if (!custom) {
      name41 = name41.toLowerCase();
      if (properties.has(name41)) {
        const descriptor2 = properties.get(name41);
        properties.set(property2, descriptor2);
        return descriptor2;
      }
    }
    const vendor = !custom ? getVendorPrefix(name41, hack.length) : "";
    const prefix = name41.substr(0, hack.length + vendor.length);
    const descriptor = Object.freeze({
      basename: name41.substr(prefix.length),
      name: name41.substr(hack.length),
      hack,
      vendor,
      prefix,
      custom
    });
    properties.set(property2, descriptor);
    return descriptor;
  }

  // node_modules/css-tree/lib/lexer/generic-an-plus-b.js
  var PLUSSIGN2 = 43;
  var HYPHENMINUS3 = 45;
  var N2 = 110;
  var DISALLOW_SIGN = true;
  var ALLOW_SIGN = false;
  function isDelim(token, code2) {
    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
  }
  function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === WhiteSpace || token.type === Comment)) {
      token = getNextToken(++offset);
    }
    return offset;
  }
  function checkInteger(token, valueOffset, disallowSign, offset) {
    if (!token) {
      return 0;
    }
    const code2 = token.value.charCodeAt(valueOffset);
    if (code2 === PLUSSIGN2 || code2 === HYPHENMINUS3) {
      if (disallowSign) {
        return 0;
      }
      valueOffset++;
    }
    for (; valueOffset < token.value.length; valueOffset++) {
      if (!isDigit(token.value.charCodeAt(valueOffset))) {
        return 0;
      }
    }
    return offset + 1;
  }
  function consumeB(token, offset_, getNextToken) {
    let sign = false;
    let offset = skipSC(token, offset_, getNextToken);
    token = getNextToken(offset);
    if (token === null) {
      return offset_;
    }
    if (token.type !== Number2) {
      if (isDelim(token, PLUSSIGN2) || isDelim(token, HYPHENMINUS3)) {
        sign = true;
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        if (token === null || token.type !== Number2) {
          return 0;
        }
      } else {
        return offset_;
      }
    }
    if (!sign) {
      const code2 = token.value.charCodeAt(0);
      if (code2 !== PLUSSIGN2 && code2 !== HYPHENMINUS3) {
        return 0;
      }
    }
    return checkInteger(token, sign ? 0 : 1, sign, offset);
  }
  function anPlusB(token, getNextToken) {
    let offset = 0;
    if (!token) {
      return 0;
    }
    if (token.type === Number2) {
      return checkInteger(token, 0, ALLOW_SIGN, offset);
    } else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS3) {
      if (!cmpChar(token.value, 1, N2)) {
        return 0;
      }
      switch (token.value.length) {
        case 2:
          return consumeB(getNextToken(++offset), offset, getNextToken);
        case 3:
          if (token.value.charCodeAt(2) !== HYPHENMINUS3) {
            return 0;
          }
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger(token, 0, DISALLOW_SIGN, offset);
        default:
          if (token.value.charCodeAt(2) !== HYPHENMINUS3) {
            return 0;
          }
          return checkInteger(token, 3, DISALLOW_SIGN, offset);
      }
    } else if (token.type === Ident || isDelim(token, PLUSSIGN2) && getNextToken(offset + 1).type === Ident) {
      if (token.type !== Ident) {
        token = getNextToken(++offset);
      }
      if (token === null || !cmpChar(token.value, 0, N2)) {
        return 0;
      }
      switch (token.value.length) {
        case 1:
          return consumeB(getNextToken(++offset), offset, getNextToken);
        case 2:
          if (token.value.charCodeAt(1) !== HYPHENMINUS3) {
            return 0;
          }
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger(token, 0, DISALLOW_SIGN, offset);
        default:
          if (token.value.charCodeAt(1) !== HYPHENMINUS3) {
            return 0;
          }
          return checkInteger(token, 2, DISALLOW_SIGN, offset);
      }
    } else if (token.type === Dimension) {
      let code2 = token.value.charCodeAt(0);
      let sign = code2 === PLUSSIGN2 || code2 === HYPHENMINUS3 ? 1 : 0;
      let i = sign;
      for (; i < token.value.length; i++) {
        if (!isDigit(token.value.charCodeAt(i))) {
          break;
        }
      }
      if (i === sign) {
        return 0;
      }
      if (!cmpChar(token.value, i, N2)) {
        return 0;
      }
      if (i + 1 === token.value.length) {
        return consumeB(getNextToken(++offset), offset, getNextToken);
      } else {
        if (token.value.charCodeAt(i + 1) !== HYPHENMINUS3) {
          return 0;
        }
        if (i + 2 === token.value.length) {
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger(token, 0, DISALLOW_SIGN, offset);
        } else {
          return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
        }
      }
    }
    return 0;
  }

  // node_modules/css-tree/lib/lexer/generic-urange.js
  var PLUSSIGN3 = 43;
  var HYPHENMINUS4 = 45;
  var QUESTIONMARK = 63;
  var U = 117;
  function isDelim2(token, code2) {
    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
  }
  function startsWith(token, code2) {
    return token.value.charCodeAt(0) === code2;
  }
  function hexSequence(token, offset, allowDash) {
    let hexlen = 0;
    for (let pos = offset; pos < token.value.length; pos++) {
      const code2 = token.value.charCodeAt(pos);
      if (code2 === HYPHENMINUS4 && allowDash && hexlen !== 0) {
        hexSequence(token, offset + hexlen + 1, false);
        return 6;
      }
      if (!isHexDigit(code2)) {
        return 0;
      }
      if (++hexlen > 6) {
        return 0;
      }
      ;
    }
    return hexlen;
  }
  function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
      return 0;
    }
    while (isDelim2(getNextToken(length), QUESTIONMARK)) {
      if (++consumed > 6) {
        return 0;
      }
      length++;
    }
    return length;
  }
  function urange(token, getNextToken) {
    let length = 0;
    if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U)) {
      return 0;
    }
    token = getNextToken(++length);
    if (token === null) {
      return 0;
    }
    if (isDelim2(token, PLUSSIGN3)) {
      token = getNextToken(++length);
      if (token === null) {
        return 0;
      }
      if (token.type === Ident) {
        return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
      }
      if (isDelim2(token, QUESTIONMARK)) {
        return withQuestionMarkSequence(1, ++length, getNextToken);
      }
      return 0;
    }
    if (token.type === Number2) {
      const consumedHexLength = hexSequence(token, 1, true);
      if (consumedHexLength === 0) {
        return 0;
      }
      token = getNextToken(++length);
      if (token === null) {
        return length;
      }
      if (token.type === Dimension || token.type === Number2) {
        if (!startsWith(token, HYPHENMINUS4) || !hexSequence(token, 1, false)) {
          return 0;
        }
        return length + 1;
      }
      return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    }
    if (token.type === Dimension) {
      return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }
    return 0;
  }

  // node_modules/css-tree/lib/lexer/generic.js
  var cssWideKeywords = ["unset", "initial", "inherit"];
  var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
  var balancePair2 = /* @__PURE__ */ new Map([
    [Function2, RightParenthesis],
    [LeftParenthesis, RightParenthesis],
    [LeftSquareBracket, RightSquareBracket],
    [LeftCurlyBracket, RightCurlyBracket]
  ]);
  var LENGTH = [
    // https://www.w3.org/TR/css-values-3/#lengths
    "px",
    "mm",
    "cm",
    "in",
    "pt",
    "pc",
    "q",
    // absolute length units
    "em",
    "ex",
    "ch",
    "rem",
    // relative length units
    "vh",
    "vw",
    "vmin",
    "vmax",
    "vm"
    // viewport-percentage lengths
  ];
  var ANGLE = ["deg", "grad", "rad", "turn"];
  var TIME = ["s", "ms"];
  var FREQUENCY = ["hz", "khz"];
  var RESOLUTION = ["dpi", "dpcm", "dppx", "x"];
  var FLEX = ["fr"];
  var DECIBEL = ["db"];
  var SEMITONES = ["st"];
  function charCode(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
  }
  function eqStr(actual, expected) {
    return cmpStr(actual, 0, actual.length, expected);
  }
  function eqStrAny(actual, expected) {
    for (let i = 0; i < expected.length; i++) {
      if (eqStr(actual, expected[i])) {
        return true;
      }
    }
    return false;
  }
  function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
      return false;
    }
    return str.charCodeAt(offset) === 92 && // U+005C REVERSE SOLIDUS (\)
    isDigit(str.charCodeAt(offset + 1));
  }
  function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === "Range") {
      const num = Number(
        numEnd !== void 0 && numEnd !== value.length ? value.substr(0, numEnd) : value
      );
      if (isNaN(num)) {
        return true;
      }
      if (opts.min !== null && num < opts.min) {
        return true;
      }
      if (opts.max !== null && num > opts.max) {
        return true;
      }
    }
    return false;
  }
  function consumeFunction(token, getNextToken) {
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;
    scan:
      do {
        switch (token.type) {
          case RightCurlyBracket:
          case RightParenthesis:
          case RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            break;
          case Function2:
          case LeftParenthesis:
          case LeftSquareBracket:
          case LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair2.get(token.type);
            break;
        }
        length++;
      } while (token = getNextToken(length));
    return length;
  }
  function calc(next) {
    return function(token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }
      if (token.type === Function2 && eqStrAny(token.value, calcFunctionNames)) {
        return consumeFunction(token, getNextToken);
      }
      return next(token, getNextToken, opts);
    };
  }
  function tokenType(expectedTokenType) {
    return function(token) {
      if (token === null || token.type !== expectedTokenType) {
        return 0;
      }
      return 1;
    };
  }
  function func(name41) {
    name41 = name41 + "(";
    return function(token, getNextToken) {
      if (token !== null && eqStr(token.value, name41)) {
        return consumeFunction(token, getNextToken);
      }
      return 0;
    };
  }
  function customIdent(token) {
    if (token === null || token.type !== Ident) {
      return 0;
    }
    const name41 = token.value.toLowerCase();
    if (eqStrAny(name41, cssWideKeywords)) {
      return 0;
    }
    if (eqStr(name41, "default")) {
      return 0;
    }
    return 1;
  }
  function customPropertyName(token) {
    if (token === null || token.type !== Ident) {
      return 0;
    }
    if (charCode(token.value, 0) !== 45 || charCode(token.value, 1) !== 45) {
      return 0;
    }
    return 1;
  }
  function hexColor(token) {
    if (token === null || token.type !== Hash) {
      return 0;
    }
    const length = token.value.length;
    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
      return 0;
    }
    for (let i = 1; i < length; i++) {
      if (!isHexDigit(token.value.charCodeAt(i))) {
        return 0;
      }
    }
    return 1;
  }
  function idSelector(token) {
    if (token === null || token.type !== Hash) {
      return 0;
    }
    if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
      return 0;
    }
    return 1;
  }
  function declarationValue(token, getNextToken) {
    if (!token) {
      return 0;
    }
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;
    scan:
      do {
        switch (token.type) {
          case BadString:
          case BadUrl:
            break scan;
          case RightCurlyBracket:
          case RightParenthesis:
          case RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            break;
          case Semicolon:
            if (balanceCloseType === 0) {
              break scan;
            }
            break;
          case Delim:
            if (balanceCloseType === 0 && token.value === "!") {
              break scan;
            }
            break;
          case Function2:
          case LeftParenthesis:
          case LeftSquareBracket:
          case LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair2.get(token.type);
            break;
        }
        length++;
      } while (token = getNextToken(length));
    return length;
  }
  function anyValue(token, getNextToken) {
    if (!token) {
      return 0;
    }
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;
    scan:
      do {
        switch (token.type) {
          case BadString:
          case BadUrl:
            break scan;
          case RightCurlyBracket:
          case RightParenthesis:
          case RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            break;
          case Function2:
          case LeftParenthesis:
          case LeftSquareBracket:
          case LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair2.get(token.type);
            break;
        }
        length++;
      } while (token = getNextToken(length));
    return length;
  }
  function dimension(type) {
    if (type) {
      type = new Set(type);
    }
    return function(token, getNextToken, opts) {
      if (token === null || token.type !== Dimension) {
        return 0;
      }
      const numberEnd = consumeNumber(token.value, 0);
      if (type !== null) {
        const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
        const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
        if (type.has(unit.toLowerCase()) === false) {
          return 0;
        }
      }
      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }
      return 1;
    };
  }
  function percentage(token, getNextToken, opts) {
    if (token === null || token.type !== Percentage) {
      return 0;
    }
    if (outOfRange(opts, token.value, token.value.length - 1)) {
      return 0;
    }
    return 1;
  }
  function zero(next) {
    if (typeof next !== "function") {
      next = function() {
        return 0;
      };
    }
    return function(token, getNextToken, opts) {
      if (token !== null && token.type === Number2) {
        if (Number(token.value) === 0) {
          return 1;
        }
      }
      return next(token, getNextToken, opts);
    };
  }
  function number(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    const numberEnd = consumeNumber(token.value, 0);
    const isNumber = numberEnd === token.value.length;
    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
      return 0;
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  }
  function integer(token, getNextToken, opts) {
    if (token === null || token.type !== Number2) {
      return 0;
    }
    let i = token.value.charCodeAt(0) === 43 || // U+002B PLUS SIGN (+)
    token.value.charCodeAt(0) === 45 ? 1 : 0;
    for (; i < token.value.length; i++) {
      if (!isDigit(token.value.charCodeAt(i))) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, i)) {
      return 0;
    }
    return 1;
  }
  var generic_default = {
    // token types
    "ident-token": tokenType(Ident),
    "function-token": tokenType(Function2),
    "at-keyword-token": tokenType(AtKeyword),
    "hash-token": tokenType(Hash),
    "string-token": tokenType(String2),
    "bad-string-token": tokenType(BadString),
    "url-token": tokenType(Url),
    "bad-url-token": tokenType(BadUrl),
    "delim-token": tokenType(Delim),
    "number-token": tokenType(Number2),
    "percentage-token": tokenType(Percentage),
    "dimension-token": tokenType(Dimension),
    "whitespace-token": tokenType(WhiteSpace),
    "CDO-token": tokenType(CDO),
    "CDC-token": tokenType(CDC),
    "colon-token": tokenType(Colon),
    "semicolon-token": tokenType(Semicolon),
    "comma-token": tokenType(Comma),
    "[-token": tokenType(LeftSquareBracket),
    "]-token": tokenType(RightSquareBracket),
    "(-token": tokenType(LeftParenthesis),
    ")-token": tokenType(RightParenthesis),
    "{-token": tokenType(LeftCurlyBracket),
    "}-token": tokenType(RightCurlyBracket),
    // token type aliases
    "string": tokenType(String2),
    "ident": tokenType(Ident),
    // complex types
    "custom-ident": customIdent,
    "custom-property-name": customPropertyName,
    "hex-color": hexColor,
    "id-selector": idSelector,
    // element( <id-selector> )
    "an-plus-b": anPlusB,
    "urange": urange,
    "declaration-value": declarationValue,
    "any-value": anyValue,
    // dimensions
    "dimension": calc(dimension(null)),
    "angle": calc(dimension(ANGLE)),
    "decibel": calc(dimension(DECIBEL)),
    "frequency": calc(dimension(FREQUENCY)),
    "flex": calc(dimension(FLEX)),
    "length": calc(zero(dimension(LENGTH))),
    "resolution": calc(dimension(RESOLUTION)),
    "semitones": calc(dimension(SEMITONES)),
    "time": calc(dimension(TIME)),
    // percentage
    "percentage": calc(percentage),
    // numeric
    "zero": zero(),
    "number": calc(number),
    "integer": calc(integer),
    // old IE stuff
    "-ms-legacy-expression": func("expression")
  };

  // node_modules/css-tree/lib/definition-syntax/SyntaxError.js
  function SyntaxError3(message, input, offset) {
    return Object.assign(createCustomError("SyntaxError", message), {
      input,
      offset,
      rawMessage: message,
      message: message + "\n  " + input + "\n--" + new Array((offset || input.length) + 1).join("-") + "^"
    });
  }

  // node_modules/css-tree/lib/definition-syntax/tokenizer.js
  var TAB = 9;
  var N3 = 10;
  var F2 = 12;
  var R2 = 13;
  var SPACE = 32;
  var Tokenizer = class {
    constructor(str) {
      this.str = str;
      this.pos = 0;
    }
    charCodeAt(pos) {
      return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    }
    charCode() {
      return this.charCodeAt(this.pos);
    }
    nextCharCode() {
      return this.charCodeAt(this.pos + 1);
    }
    nextNonWsCode(pos) {
      return this.charCodeAt(this.findWsEnd(pos));
    }
    findWsEnd(pos) {
      for (; pos < this.str.length; pos++) {
        const code2 = this.str.charCodeAt(pos);
        if (code2 !== R2 && code2 !== N3 && code2 !== F2 && code2 !== SPACE && code2 !== TAB) {
          break;
        }
      }
      return pos;
    }
    substringToPos(end) {
      return this.str.substring(this.pos, this.pos = end);
    }
    eat(code2) {
      if (this.charCode() !== code2) {
        this.error("Expect `" + String.fromCharCode(code2) + "`");
      }
      this.pos++;
    }
    peek() {
      return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
    }
    error(message) {
      throw new SyntaxError3(message, this.str, this.pos);
    }
  };

  // node_modules/css-tree/lib/definition-syntax/parse.js
  var TAB2 = 9;
  var N4 = 10;
  var F3 = 12;
  var R3 = 13;
  var SPACE2 = 32;
  var EXCLAMATIONMARK2 = 33;
  var NUMBERSIGN2 = 35;
  var AMPERSAND = 38;
  var APOSTROPHE = 39;
  var LEFTPARENTHESIS = 40;
  var RIGHTPARENTHESIS = 41;
  var ASTERISK = 42;
  var PLUSSIGN4 = 43;
  var COMMA = 44;
  var HYPERMINUS = 45;
  var LESSTHANSIGN = 60;
  var GREATERTHANSIGN = 62;
  var QUESTIONMARK2 = 63;
  var COMMERCIALAT = 64;
  var LEFTSQUAREBRACKET = 91;
  var RIGHTSQUAREBRACKET = 93;
  var LEFTCURLYBRACKET2 = 123;
  var VERTICALLINE = 124;
  var RIGHTCURLYBRACKET = 125;
  var INFINITY = 8734;
  var NAME_CHAR = new Uint8Array(128).map(
    (_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
  );
  var COMBINATOR_PRECEDENCE = {
    " ": 1,
    "&&": 2,
    "||": 3,
    "|": 4
  };
  function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(
      tokenizer.findWsEnd(tokenizer.pos)
    );
  }
  function scanWord(tokenizer) {
    let end = tokenizer.pos;
    for (; end < tokenizer.str.length; end++) {
      const code2 = tokenizer.str.charCodeAt(end);
      if (code2 >= 128 || NAME_CHAR[code2] === 0) {
        break;
      }
    }
    if (tokenizer.pos === end) {
      tokenizer.error("Expect a keyword");
    }
    return tokenizer.substringToPos(end);
  }
  function scanNumber(tokenizer) {
    let end = tokenizer.pos;
    for (; end < tokenizer.str.length; end++) {
      const code2 = tokenizer.str.charCodeAt(end);
      if (code2 < 48 || code2 > 57) {
        break;
      }
    }
    if (tokenizer.pos === end) {
      tokenizer.error("Expect a number");
    }
    return tokenizer.substringToPos(end);
  }
  function scanString(tokenizer) {
    const end = tokenizer.str.indexOf("'", tokenizer.pos + 1);
    if (end === -1) {
      tokenizer.pos = tokenizer.str.length;
      tokenizer.error("Expect an apostrophe");
    }
    return tokenizer.substringToPos(end + 1);
  }
  function readMultiplierRange(tokenizer) {
    let min = null;
    let max = null;
    tokenizer.eat(LEFTCURLYBRACKET2);
    min = scanNumber(tokenizer);
    if (tokenizer.charCode() === COMMA) {
      tokenizer.pos++;
      if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
        max = scanNumber(tokenizer);
      }
    } else {
      max = min;
    }
    tokenizer.eat(RIGHTCURLYBRACKET);
    return {
      min: Number(min),
      max: max ? Number(max) : 0
    };
  }
  function readMultiplier(tokenizer) {
    let range = null;
    let comma = false;
    switch (tokenizer.charCode()) {
      case ASTERISK:
        tokenizer.pos++;
        range = {
          min: 0,
          max: 0
        };
        break;
      case PLUSSIGN4:
        tokenizer.pos++;
        range = {
          min: 1,
          max: 0
        };
        break;
      case QUESTIONMARK2:
        tokenizer.pos++;
        range = {
          min: 0,
          max: 1
        };
        break;
      case NUMBERSIGN2:
        tokenizer.pos++;
        comma = true;
        if (tokenizer.charCode() === LEFTCURLYBRACKET2) {
          range = readMultiplierRange(tokenizer);
        } else {
          range = {
            min: 1,
            max: 0
          };
        }
        break;
      case LEFTCURLYBRACKET2:
        range = readMultiplierRange(tokenizer);
        break;
      default:
        return null;
    }
    return {
      type: "Multiplier",
      comma,
      min: range.min,
      max: range.max,
      term: null
    };
  }
  function maybeMultiplied(tokenizer, node) {
    const multiplier = readMultiplier(tokenizer);
    if (multiplier !== null) {
      multiplier.term = node;
      return multiplier;
    }
    return node;
  }
  function maybeToken(tokenizer) {
    const ch = tokenizer.peek();
    if (ch === "") {
      return null;
    }
    return {
      type: "Token",
      value: ch
    };
  }
  function readProperty(tokenizer) {
    let name41;
    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE);
    name41 = scanWord(tokenizer);
    tokenizer.eat(APOSTROPHE);
    tokenizer.eat(GREATERTHANSIGN);
    return maybeMultiplied(tokenizer, {
      type: "Property",
      name: name41
    });
  }
  function readTypeRange(tokenizer) {
    let min = null;
    let max = null;
    let sign = 1;
    tokenizer.eat(LEFTSQUAREBRACKET);
    if (tokenizer.charCode() === HYPERMINUS) {
      tokenizer.peek();
      sign = -1;
    }
    if (sign == -1 && tokenizer.charCode() === INFINITY) {
      tokenizer.peek();
    } else {
      min = sign * Number(scanNumber(tokenizer));
    }
    scanSpaces(tokenizer);
    tokenizer.eat(COMMA);
    scanSpaces(tokenizer);
    if (tokenizer.charCode() === INFINITY) {
      tokenizer.peek();
    } else {
      sign = 1;
      if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
      }
      max = sign * Number(scanNumber(tokenizer));
    }
    tokenizer.eat(RIGHTSQUAREBRACKET);
    if (min === null && max === null) {
      return null;
    }
    return {
      type: "Range",
      min,
      max
    };
  }
  function readType(tokenizer) {
    let name41;
    let opts = null;
    tokenizer.eat(LESSTHANSIGN);
    name41 = scanWord(tokenizer);
    if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
      tokenizer.pos += 2;
      name41 += "()";
    }
    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
      scanSpaces(tokenizer);
      opts = readTypeRange(tokenizer);
    }
    tokenizer.eat(GREATERTHANSIGN);
    return maybeMultiplied(tokenizer, {
      type: "Type",
      name: name41,
      opts
    });
  }
  function readKeywordOrFunction(tokenizer) {
    const name41 = scanWord(tokenizer);
    if (tokenizer.charCode() === LEFTPARENTHESIS) {
      tokenizer.pos++;
      return {
        type: "Function",
        name: name41
      };
    }
    return maybeMultiplied(tokenizer, {
      type: "Keyword",
      name: name41
    });
  }
  function regroupTerms(terms, combinators) {
    function createGroup(terms2, combinator2) {
      return {
        type: "Group",
        terms: terms2,
        combinator: combinator2,
        disallowEmpty: false,
        explicit: false
      };
    }
    let combinator;
    combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
    while (combinators.length > 0) {
      combinator = combinators.shift();
      let i = 0;
      let subgroupStart = 0;
      for (; i < terms.length; i++) {
        const term = terms[i];
        if (term.type === "Combinator") {
          if (term.value === combinator) {
            if (subgroupStart === -1) {
              subgroupStart = i - 1;
            }
            terms.splice(i, 1);
            i--;
          } else {
            if (subgroupStart !== -1 && i - subgroupStart > 1) {
              terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
              );
              i = subgroupStart + 1;
            }
            subgroupStart = -1;
          }
        }
      }
      if (subgroupStart !== -1 && combinators.length) {
        terms.splice(
          subgroupStart,
          i - subgroupStart,
          createGroup(terms.slice(subgroupStart, i), combinator)
        );
      }
    }
    return combinator;
  }
  function readImplicitGroup(tokenizer) {
    const terms = [];
    const combinators = {};
    let token;
    let prevToken = null;
    let prevTokenPos = tokenizer.pos;
    while (token = peek(tokenizer)) {
      if (token.type !== "Spaces") {
        if (token.type === "Combinator") {
          if (prevToken === null || prevToken.type === "Combinator") {
            tokenizer.pos = prevTokenPos;
            tokenizer.error("Unexpected combinator");
          }
          combinators[token.value] = true;
        } else if (prevToken !== null && prevToken.type !== "Combinator") {
          combinators[" "] = true;
          terms.push({
            type: "Combinator",
            value: " "
          });
        }
        terms.push(token);
        prevToken = token;
        prevTokenPos = tokenizer.pos;
      }
    }
    if (prevToken !== null && prevToken.type === "Combinator") {
      tokenizer.pos -= prevTokenPos;
      tokenizer.error("Unexpected combinator");
    }
    return {
      type: "Group",
      terms,
      combinator: regroupTerms(terms, combinators) || " ",
      disallowEmpty: false,
      explicit: false
    };
  }
  function readGroup(tokenizer) {
    let result;
    tokenizer.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET);
    result.explicit = true;
    if (tokenizer.charCode() === EXCLAMATIONMARK2) {
      tokenizer.pos++;
      result.disallowEmpty = true;
    }
    return result;
  }
  function peek(tokenizer) {
    let code2 = tokenizer.charCode();
    if (code2 < 128 && NAME_CHAR[code2] === 1) {
      return readKeywordOrFunction(tokenizer);
    }
    switch (code2) {
      case RIGHTSQUAREBRACKET:
        break;
      case LEFTSQUAREBRACKET:
        return maybeMultiplied(tokenizer, readGroup(tokenizer));
      case LESSTHANSIGN:
        return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);
      case VERTICALLINE:
        return {
          type: "Combinator",
          value: tokenizer.substringToPos(
            tokenizer.pos + (tokenizer.nextCharCode() === VERTICALLINE ? 2 : 1)
          )
        };
      case AMPERSAND:
        tokenizer.pos++;
        tokenizer.eat(AMPERSAND);
        return {
          type: "Combinator",
          value: "&&"
        };
      case COMMA:
        tokenizer.pos++;
        return {
          type: "Comma"
        };
      case APOSTROPHE:
        return maybeMultiplied(tokenizer, {
          type: "String",
          value: scanString(tokenizer)
        });
      case SPACE2:
      case TAB2:
      case N4:
      case R3:
      case F3:
        return {
          type: "Spaces",
          value: scanSpaces(tokenizer)
        };
      case COMMERCIALAT:
        code2 = tokenizer.nextCharCode();
        if (code2 < 128 && NAME_CHAR[code2] === 1) {
          tokenizer.pos++;
          return {
            type: "AtKeyword",
            name: scanWord(tokenizer)
          };
        }
        return maybeToken(tokenizer);
      case ASTERISK:
      case PLUSSIGN4:
      case QUESTIONMARK2:
      case NUMBERSIGN2:
      case EXCLAMATIONMARK2:
        break;
      case LEFTCURLYBRACKET2:
        code2 = tokenizer.nextCharCode();
        if (code2 < 48 || code2 > 57) {
          return maybeToken(tokenizer);
        }
        break;
      default:
        return maybeToken(tokenizer);
    }
  }
  function parse(source) {
    const tokenizer = new Tokenizer(source);
    const result = readImplicitGroup(tokenizer);
    if (tokenizer.pos !== source.length) {
      tokenizer.error("Unexpected input");
    }
    if (result.terms.length === 1 && result.terms[0].type === "Group") {
      return result.terms[0];
    }
    return result;
  }

  // node_modules/css-tree/lib/definition-syntax/walk.js
  var noop3 = function() {
  };
  function ensureFunction2(value) {
    return typeof value === "function" ? value : noop3;
  }
  function walk(node, options, context) {
    function walk3(node2) {
      enter.call(context, node2);
      switch (node2.type) {
        case "Group":
          node2.terms.forEach(walk3);
          break;
        case "Multiplier":
          walk3(node2.term);
          break;
        case "Type":
        case "Property":
        case "Keyword":
        case "AtKeyword":
        case "Function":
        case "String":
        case "Token":
        case "Comma":
          break;
        default:
          throw new Error("Unknown type: " + node2.type);
      }
      leave.call(context, node2);
    }
    let enter = noop3;
    let leave = noop3;
    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction2(options.enter);
      leave = ensureFunction2(options.leave);
    }
    if (enter === noop3 && leave === noop3) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walk3(node, context);
  }

  // node_modules/css-tree/lib/lexer/prepare-tokens.js
  var astToTokens = {
    decorator: function(handlers) {
      const tokens = [];
      let curNode = null;
      return {
        ...handlers,
        node(node) {
          const tmp = curNode;
          curNode = node;
          handlers.node.call(this, node);
          curNode = tmp;
        },
        emit(value, type, auto) {
          tokens.push({
            type,
            value,
            node: auto ? null : curNode
          });
        },
        result() {
          return tokens;
        }
      };
    }
  };
  function stringToTokens(str) {
    const tokens = [];
    tokenize(
      str,
      (type, start, end) => tokens.push({
        type,
        value: str.slice(start, end),
        node: null
      })
    );
    return tokens;
  }
  function prepare_tokens_default(value, syntax) {
    if (typeof value === "string") {
      return stringToTokens(value);
    }
    return syntax.generate(value, astToTokens);
  }

  // node_modules/css-tree/lib/lexer/match-graph.js
  var MATCH = { type: "Match" };
  var MISMATCH = { type: "Mismatch" };
  var DISALLOW_EMPTY = { type: "DisallowEmpty" };
  var LEFTPARENTHESIS2 = 40;
  var RIGHTPARENTHESIS2 = 41;
  function createCondition(match, thenBranch, elseBranch) {
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
      return match;
    }
    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
      return match;
    }
    if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
      thenBranch = match.then;
      match = match.match;
    }
    return {
      type: "If",
      match,
      then: thenBranch,
      else: elseBranch
    };
  }
  function isFunctionType(name41) {
    return name41.length > 2 && name41.charCodeAt(name41.length - 2) === LEFTPARENTHESIS2 && name41.charCodeAt(name41.length - 1) === RIGHTPARENTHESIS2;
  }
  function isEnumCapatible(term) {
    return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
  }
  function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
      case " ": {
        let result = MATCH;
        for (let i = terms.length - 1; i >= 0; i--) {
          const term = terms[i];
          result = createCondition(
            term,
            result,
            MISMATCH
          );
        }
        ;
        return result;
      }
      case "|": {
        let result = MISMATCH;
        let map = null;
        for (let i = terms.length - 1; i >= 0; i--) {
          let term = terms[i];
          if (isEnumCapatible(term)) {
            if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
              map = /* @__PURE__ */ Object.create(null);
              result = createCondition(
                {
                  type: "Enum",
                  map
                },
                MATCH,
                result
              );
            }
            if (map !== null) {
              const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
              if (key in map === false) {
                map[key] = term;
                continue;
              }
            }
          }
          map = null;
          result = createCondition(
            term,
            MATCH,
            result
          );
        }
        ;
        return result;
      }
      case "&&": {
        if (terms.length > 5) {
          return {
            type: "MatchOnce",
            terms,
            all: true
          };
        }
        let result = MISMATCH;
        for (let i = terms.length - 1; i >= 0; i--) {
          const term = terms[i];
          let thenClause;
          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(
              combinator,
              terms.filter(function(newGroupTerm) {
                return newGroupTerm !== term;
              }),
              false
            );
          } else {
            thenClause = MATCH;
          }
          result = createCondition(
            term,
            thenClause,
            result
          );
        }
        ;
        return result;
      }
      case "||": {
        if (terms.length > 5) {
          return {
            type: "MatchOnce",
            terms,
            all: false
          };
        }
        let result = atLeastOneTermMatched ? MATCH : MISMATCH;
        for (let i = terms.length - 1; i >= 0; i--) {
          const term = terms[i];
          let thenClause;
          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(
              combinator,
              terms.filter(function(newGroupTerm) {
                return newGroupTerm !== term;
              }),
              true
            );
          } else {
            thenClause = MATCH;
          }
          result = createCondition(
            term,
            thenClause,
            result
          );
        }
        ;
        return result;
      }
    }
  }
  function buildMultiplierMatchGraph(node) {
    let result = MATCH;
    let matchTerm = buildMatchGraphInternal(node.term);
    if (node.max === 0) {
      matchTerm = createCondition(
        matchTerm,
        DISALLOW_EMPTY,
        MISMATCH
      );
      result = createCondition(
        matchTerm,
        null,
        // will be a loop
        MISMATCH
      );
      result.then = createCondition(
        MATCH,
        MATCH,
        result
        // make a loop
      );
      if (node.comma) {
        result.then.else = createCondition(
          { type: "Comma", syntax: node },
          result,
          MISMATCH
        );
      }
    } else {
      for (let i = node.min || 1; i <= node.max; i++) {
        if (node.comma && result !== MATCH) {
          result = createCondition(
            { type: "Comma", syntax: node },
            result,
            MISMATCH
          );
        }
        result = createCondition(
          matchTerm,
          createCondition(
            MATCH,
            MATCH,
            result
          ),
          MISMATCH
        );
      }
    }
    if (node.min === 0) {
      result = createCondition(
        MATCH,
        MATCH,
        result
      );
    } else {
      for (let i = 0; i < node.min - 1; i++) {
        if (node.comma && result !== MATCH) {
          result = createCondition(
            { type: "Comma", syntax: node },
            result,
            MISMATCH
          );
        }
        result = createCondition(
          matchTerm,
          result,
          MISMATCH
        );
      }
    }
    return result;
  }
  function buildMatchGraphInternal(node) {
    if (typeof node === "function") {
      return {
        type: "Generic",
        fn: node
      };
    }
    switch (node.type) {
      case "Group": {
        let result = buildGroupMatchGraph(
          node.combinator,
          node.terms.map(buildMatchGraphInternal),
          false
        );
        if (node.disallowEmpty) {
          result = createCondition(
            result,
            DISALLOW_EMPTY,
            MISMATCH
          );
        }
        return result;
      }
      case "Multiplier":
        return buildMultiplierMatchGraph(node);
      case "Type":
      case "Property":
        return {
          type: node.type,
          name: node.name,
          syntax: node
        };
      case "Keyword":
        return {
          type: node.type,
          name: node.name.toLowerCase(),
          syntax: node
        };
      case "AtKeyword":
        return {
          type: node.type,
          name: "@" + node.name.toLowerCase(),
          syntax: node
        };
      case "Function":
        return {
          type: node.type,
          name: node.name.toLowerCase() + "(",
          syntax: node
        };
      case "String":
        if (node.value.length === 3) {
          return {
            type: "Token",
            value: node.value.charAt(1),
            syntax: node
          };
        }
        return {
          type: node.type,
          value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
          syntax: node
        };
      case "Token":
        return {
          type: node.type,
          value: node.value,
          syntax: node
        };
      case "Comma":
        return {
          type: node.type,
          syntax: node
        };
      default:
        throw new Error("Unknown node type:", node.type);
    }
  }
  function buildMatchGraph(syntaxTree, ref) {
    if (typeof syntaxTree === "string") {
      syntaxTree = parse(syntaxTree);
    }
    return {
      type: "MatchGraph",
      match: buildMatchGraphInternal(syntaxTree),
      syntax: ref || null,
      source: syntaxTree
    };
  }

  // node_modules/css-tree/lib/lexer/match.js
  var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
  var STUB = 0;
  var TOKEN = 1;
  var OPEN_SYNTAX = 2;
  var CLOSE_SYNTAX = 3;
  var EXIT_REASON_MATCH = "Match";
  var EXIT_REASON_MISMATCH = "Mismatch";
  var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
  var ITERATION_LIMIT = 15e3;
  var totalIterationCount = 0;
  function reverseList(list) {
    let prev = null;
    let next = null;
    let item = list;
    while (item !== null) {
      next = item.prev;
      item.prev = prev;
      prev = item;
      item = next;
    }
    return prev;
  }
  function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
      return false;
    }
    for (let i = 0; i < testStr.length; i++) {
      const referenceCode = referenceStr.charCodeAt(i);
      let testCode = testStr.charCodeAt(i);
      if (testCode >= 65 && testCode <= 90) {
        testCode = testCode | 32;
      }
      if (testCode !== referenceCode) {
        return false;
      }
    }
    return true;
  }
  function isContextEdgeDelim(token) {
    if (token.type !== Delim) {
      return false;
    }
    return token.value !== "?";
  }
  function isCommaContextStart(token) {
    if (token === null) {
      return true;
    }
    return token.type === Comma || token.type === Function2 || token.type === LeftParenthesis || token.type === LeftSquareBracket || token.type === LeftCurlyBracket || isContextEdgeDelim(token);
  }
  function isCommaContextEnd(token) {
    if (token === null) {
      return true;
    }
    return token.type === RightParenthesis || token.type === RightSquareBracket || token.type === RightCurlyBracket || token.type === Delim;
  }
  function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
      do {
        tokenIndex++;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
      } while (token !== null && (token.type === WhiteSpace || token.type === Comment));
    }
    function getNextToken(offset) {
      const nextIndex = tokenIndex + offset;
      return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }
    function stateSnapshotFromSyntax(nextState, prev) {
      return {
        nextState,
        matchStack,
        syntaxStack,
        thenStack,
        tokenIndex,
        prev
      };
    }
    function pushThenStack(nextState) {
      thenStack = {
        nextState,
        matchStack,
        syntaxStack,
        prev: thenStack
      };
    }
    function pushElseStack(nextState) {
      elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }
    function addTokenToMatch() {
      matchStack = {
        type: TOKEN,
        syntax: state.syntax,
        token,
        prev: matchStack
      };
      moveToNextToken();
      syntaxStash = null;
      if (tokenIndex > longestMatch) {
        longestMatch = tokenIndex;
      }
    }
    function openSyntax() {
      syntaxStack = {
        syntax: state.syntax,
        opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
        prev: syntaxStack
      };
      matchStack = {
        type: OPEN_SYNTAX,
        syntax: state.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    function closeSyntax() {
      if (matchStack.type === OPEN_SYNTAX) {
        matchStack = matchStack.prev;
      } else {
        matchStack = {
          type: CLOSE_SYNTAX,
          syntax: syntaxStack.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }
      syntaxStack = syntaxStack.prev;
    }
    let syntaxStack = null;
    let thenStack = null;
    let elseStack = null;
    let syntaxStash = null;
    let iterationCount = 0;
    let exitReason = null;
    let token = null;
    let tokenIndex = -1;
    let longestMatch = 0;
    let matchStack = {
      type: STUB,
      syntax: null,
      token: null,
      prev: null
    };
    moveToNextToken();
    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
      switch (state.type) {
        case "Match":
          if (thenStack === null) {
            if (token !== null) {
              if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                state = MISMATCH;
                break;
              }
            }
            exitReason = EXIT_REASON_MATCH;
            break;
          }
          state = thenStack.nextState;
          if (state === DISALLOW_EMPTY) {
            if (thenStack.matchStack === matchStack) {
              state = MISMATCH;
              break;
            } else {
              state = MATCH;
            }
          }
          while (thenStack.syntaxStack !== syntaxStack) {
            closeSyntax();
          }
          thenStack = thenStack.prev;
          break;
        case "Mismatch":
          if (syntaxStash !== null && syntaxStash !== false) {
            if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
              elseStack = syntaxStash;
              syntaxStash = false;
            }
          } else if (elseStack === null) {
            exitReason = EXIT_REASON_MISMATCH;
            break;
          }
          state = elseStack.nextState;
          thenStack = elseStack.thenStack;
          syntaxStack = elseStack.syntaxStack;
          matchStack = elseStack.matchStack;
          tokenIndex = elseStack.tokenIndex;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
          elseStack = elseStack.prev;
          break;
        case "MatchGraph":
          state = state.match;
          break;
        case "If":
          if (state.else !== MISMATCH) {
            pushElseStack(state.else);
          }
          if (state.then !== MATCH) {
            pushThenStack(state.then);
          }
          state = state.match;
          break;
        case "MatchOnce":
          state = {
            type: "MatchOnceBuffer",
            syntax: state,
            index: 0,
            mask: 0
          };
          break;
        case "MatchOnceBuffer": {
          const terms = state.syntax.terms;
          if (state.index === terms.length) {
            if (state.mask === 0 || state.syntax.all) {
              state = MISMATCH;
              break;
            }
            state = MATCH;
            break;
          }
          if (state.mask === (1 << terms.length) - 1) {
            state = MATCH;
            break;
          }
          for (; state.index < terms.length; state.index++) {
            const matchFlag = 1 << state.index;
            if ((state.mask & matchFlag) === 0) {
              pushElseStack(state);
              pushThenStack({
                type: "AddMatchOnce",
                syntax: state.syntax,
                mask: state.mask | matchFlag
              });
              state = terms[state.index++];
              break;
            }
          }
          break;
        }
        case "AddMatchOnce":
          state = {
            type: "MatchOnceBuffer",
            syntax: state.syntax,
            index: 0,
            mask: state.mask
          };
          break;
        case "Enum":
          if (token !== null) {
            let name41 = token.value.toLowerCase();
            if (name41.indexOf("\\") !== -1) {
              name41 = name41.replace(/\\[09].*$/, "");
            }
            if (hasOwnProperty3.call(state.map, name41)) {
              state = state.map[name41];
              break;
            }
          }
          state = MISMATCH;
          break;
        case "Generic": {
          const opts = syntaxStack !== null ? syntaxStack.opts : null;
          const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
          if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
            while (tokenIndex < lastTokenIndex2) {
              addTokenToMatch();
            }
            state = MATCH;
          } else {
            state = MISMATCH;
          }
          break;
        }
        case "Type":
        case "Property": {
          const syntaxDict = state.type === "Type" ? "types" : "properties";
          const dictSyntax = hasOwnProperty3.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
          if (!dictSyntax || !dictSyntax.match) {
            throw new Error(
              "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
            );
          }
          if (syntaxStash !== false && token !== null && state.type === "Type") {
            const lowPriorityMatching = (
              // https://drafts.csswg.org/css-values-4/#custom-idents
              // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
              // can only claim the keyword if no other unfulfilled production can claim it.
              state.name === "custom-ident" && token.type === Ident || // https://drafts.csswg.org/css-values-4/#lengths
              // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
              // it must parse as a <number>
              state.name === "length" && token.value === "0"
            );
            if (lowPriorityMatching) {
              if (syntaxStash === null) {
                syntaxStash = stateSnapshotFromSyntax(state, elseStack);
              }
              state = MISMATCH;
              break;
            }
          }
          openSyntax();
          state = dictSyntax.match;
          break;
        }
        case "Keyword": {
          const name41 = state.name;
          if (token !== null) {
            let keywordName = token.value;
            if (keywordName.indexOf("\\") !== -1) {
              keywordName = keywordName.replace(/\\[09].*$/, "");
            }
            if (areStringsEqualCaseInsensitive(keywordName, name41)) {
              addTokenToMatch();
              state = MATCH;
              break;
            }
          }
          state = MISMATCH;
          break;
        }
        case "AtKeyword":
        case "Function":
          if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
          state = MISMATCH;
          break;
        case "Token":
          if (token !== null && token.value === state.value) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
          state = MISMATCH;
          break;
        case "Comma":
          if (token !== null && token.type === Comma) {
            if (isCommaContextStart(matchStack.token)) {
              state = MISMATCH;
            } else {
              addTokenToMatch();
              state = isCommaContextEnd(token) ? MISMATCH : MATCH;
            }
          } else {
            state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
          }
          break;
        case "String":
          let string = "";
          let lastTokenIndex = tokenIndex;
          for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
            string += tokens[lastTokenIndex].value;
          }
          if (areStringsEqualCaseInsensitive(string, state.value)) {
            while (tokenIndex < lastTokenIndex) {
              addTokenToMatch();
            }
            state = MATCH;
          } else {
            state = MISMATCH;
          }
          break;
        default:
          throw new Error("Unknown node type: " + state.type);
      }
    }
    totalIterationCount += iterationCount;
    switch (exitReason) {
      case null:
        console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
        exitReason = EXIT_REASON_ITERATION_LIMIT;
        matchStack = null;
        break;
      case EXIT_REASON_MATCH:
        while (syntaxStack !== null) {
          closeSyntax();
        }
        break;
      default:
        matchStack = null;
    }
    return {
      tokens,
      reason: exitReason,
      iterations: iterationCount,
      match: matchStack,
      longestMatch
    };
  }
  function matchAsTree(tokens, matchGraph, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
    if (matchResult.match === null) {
      return matchResult;
    }
    let item = matchResult.match;
    let host = matchResult.match = {
      syntax: matchGraph.syntax || null,
      match: []
    };
    const hostStack = [host];
    item = reverseList(item).prev;
    while (item !== null) {
      switch (item.type) {
        case OPEN_SYNTAX:
          host.match.push(host = {
            syntax: item.syntax,
            match: []
          });
          hostStack.push(host);
          break;
        case CLOSE_SYNTAX:
          hostStack.pop();
          host = hostStack[hostStack.length - 1];
          break;
        default:
          host.match.push({
            syntax: item.syntax || null,
            token: item.token.value,
            node: item.token.node
          });
      }
      item = item.prev;
    }
    return matchResult;
  }

  // node_modules/css-tree/lib/lexer/trace.js
  var trace_exports = {};
  __export(trace_exports, {
    getTrace: () => getTrace,
    isKeyword: () => isKeyword,
    isProperty: () => isProperty,
    isType: () => isType
  });
  function getTrace(node) {
    function shouldPutToTrace(syntax) {
      if (syntax === null) {
        return false;
      }
      return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
    }
    function hasMatch(matchNode) {
      if (Array.isArray(matchNode.match)) {
        for (let i = 0; i < matchNode.match.length; i++) {
          if (hasMatch(matchNode.match[i])) {
            if (shouldPutToTrace(matchNode.syntax)) {
              result.unshift(matchNode.syntax);
            }
            return true;
          }
        }
      } else if (matchNode.node === node) {
        result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
        return true;
      }
      return false;
    }
    let result = null;
    if (this.matched !== null) {
      hasMatch(this.matched);
    }
    return result;
  }
  function isType(node, type) {
    return testNode(this, node, (match) => match.type === "Type" && match.name === type);
  }
  function isProperty(node, property2) {
    return testNode(this, node, (match) => match.type === "Property" && match.name === property2);
  }
  function isKeyword(node) {
    return testNode(this, node, (match) => match.type === "Keyword");
  }
  function testNode(match, node, fn) {
    const trace = getTrace.call(match, node);
    if (trace === null) {
      return false;
    }
    return trace.some(fn);
  }

  // node_modules/css-tree/lib/lexer/search.js
  function getFirstMatchNode(matchNode) {
    if ("node" in matchNode) {
      return matchNode.node;
    }
    return getFirstMatchNode(matchNode.match[0]);
  }
  function getLastMatchNode(matchNode) {
    if ("node" in matchNode) {
      return matchNode.node;
    }
    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
  }
  function matchFragments(lexer2, ast, match, type, name41) {
    function findFragments(matchNode) {
      if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name41) {
        const start = getFirstMatchNode(matchNode);
        const end = getLastMatchNode(matchNode);
        lexer2.syntax.walk(ast, function(node, item, list) {
          if (node === start) {
            const nodes = new List();
            do {
              nodes.appendData(item.data);
              if (item.data === end) {
                break;
              }
              item = item.next;
            } while (item !== null);
            fragments.push({
              parent: list,
              nodes
            });
          }
        });
      }
      if (Array.isArray(matchNode.match)) {
        matchNode.match.forEach(findFragments);
      }
    }
    const fragments = [];
    if (match.matched !== null) {
      findFragments(match.matched);
    }
    return fragments;
  }

  // node_modules/css-tree/lib/lexer/structure.js
  var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
  function isValidNumber(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
  }
  function isValidLocation(loc) {
    return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
  }
  function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
      if (!node || node.constructor !== Object) {
        return warn(node, "Type of node should be an Object");
      }
      for (let key in node) {
        let valid = true;
        if (hasOwnProperty4.call(node, key) === false) {
          continue;
        }
        if (key === "type") {
          if (node.type !== type) {
            warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
          }
        } else if (key === "loc") {
          if (node.loc === null) {
            continue;
          } else if (node.loc && node.loc.constructor === Object) {
            if (typeof node.loc.source !== "string") {
              key += ".source";
            } else if (!isValidLocation(node.loc.start)) {
              key += ".start";
            } else if (!isValidLocation(node.loc.end)) {
              key += ".end";
            } else {
              continue;
            }
          }
          valid = false;
        } else if (fields.hasOwnProperty(key)) {
          valid = false;
          for (let i = 0; !valid && i < fields[key].length; i++) {
            const fieldType = fields[key][i];
            switch (fieldType) {
              case String:
                valid = typeof node[key] === "string";
                break;
              case Boolean:
                valid = typeof node[key] === "boolean";
                break;
              case null:
                valid = node[key] === null;
                break;
              default:
                if (typeof fieldType === "string") {
                  valid = node[key] && node[key].type === fieldType;
                } else if (Array.isArray(fieldType)) {
                  valid = node[key] instanceof List;
                }
            }
          }
        } else {
          warn(node, "Unknown field `" + key + "` for " + type + " node type");
        }
        if (!valid) {
          warn(node, "Bad value for `" + type + "." + key + "`");
        }
      }
      for (const key in fields) {
        if (hasOwnProperty4.call(fields, key) && hasOwnProperty4.call(node, key) === false) {
          warn(node, "Field `" + type + "." + key + "` is missed");
        }
      }
    };
  }
  function processStructure(name41, nodeType) {
    const structure41 = nodeType.structure;
    const fields = {
      type: String,
      loc: true
    };
    const docs = {
      type: '"' + name41 + '"'
    };
    for (const key in structure41) {
      if (hasOwnProperty4.call(structure41, key) === false) {
        continue;
      }
      const docsTypes = [];
      const fieldTypes = fields[key] = Array.isArray(structure41[key]) ? structure41[key].slice() : [structure41[key]];
      for (let i = 0; i < fieldTypes.length; i++) {
        const fieldType = fieldTypes[i];
        if (fieldType === String || fieldType === Boolean) {
          docsTypes.push(fieldType.name);
        } else if (fieldType === null) {
          docsTypes.push("null");
        } else if (typeof fieldType === "string") {
          docsTypes.push("<" + fieldType + ">");
        } else if (Array.isArray(fieldType)) {
          docsTypes.push("List");
        } else {
          throw new Error("Wrong value `" + fieldType + "` in `" + name41 + "." + key + "` structure definition");
        }
      }
      docs[key] = docsTypes.join(" | ");
    }
    return {
      docs,
      check: createNodeStructureChecker(name41, fields)
    };
  }
  function getStructureFromConfig(config) {
    const structure41 = {};
    if (config.node) {
      for (const name41 in config.node) {
        if (hasOwnProperty4.call(config.node, name41)) {
          const nodeType = config.node[name41];
          if (nodeType.structure) {
            structure41[name41] = processStructure(name41, nodeType);
          } else {
            throw new Error("Missed `structure` field in `" + name41 + "` node type definition");
          }
        }
      }
    }
    return structure41;
  }

  // node_modules/css-tree/lib/lexer/Lexer.js
  var cssWideKeywords2 = buildMatchGraph("inherit | initial | unset");
  var cssWideKeywordsWithExpression = buildMatchGraph("inherit | initial | unset | <-ms-legacy-expression>");
  function dumpMapSyntax(map, compact, syntaxAsAst) {
    const result = {};
    for (const name41 in map) {
      if (map[name41].syntax) {
        result[name41] = syntaxAsAst ? map[name41].syntax : generate(map[name41].syntax, { compact });
      }
    }
    return result;
  }
  function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};
    for (const [name41, atrule] of Object.entries(map)) {
      result[name41] = {
        prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, { compact })),
        descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
      };
    }
    return result;
  }
  function valueHasVar(tokens) {
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i].value.toLowerCase() === "var(") {
        return true;
      }
    }
    return false;
  }
  function buildMatchResult(matched, error, iterations) {
    return {
      matched,
      iterations,
      error,
      ...trace_exports
    };
  }
  function matchSyntax(lexer2, syntax, value, useCommon) {
    const tokens = prepare_tokens_default(value, lexer2.syntax);
    let result;
    if (valueHasVar(tokens)) {
      return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
    }
    if (useCommon) {
      result = matchAsTree(tokens, lexer2.valueCommonSyntax, lexer2);
    }
    if (!useCommon || !result.match) {
      result = matchAsTree(tokens, syntax.match, lexer2);
      if (!result.match) {
        return buildMatchResult(
          null,
          new SyntaxMatchError(result.reason, syntax.syntax, value, result),
          result.iterations
        );
      }
    }
    return buildMatchResult(result.match, null, result.iterations);
  }
  var Lexer = class {
    constructor(config, syntax, structure41) {
      this.valueCommonSyntax = cssWideKeywords2;
      this.syntax = syntax;
      this.generic = false;
      this.atrules = /* @__PURE__ */ Object.create(null);
      this.properties = /* @__PURE__ */ Object.create(null);
      this.types = /* @__PURE__ */ Object.create(null);
      this.structure = structure41 || getStructureFromConfig(config);
      if (config) {
        if (config.types) {
          for (const name41 in config.types) {
            this.addType_(name41, config.types[name41]);
          }
        }
        if (config.generic) {
          this.generic = true;
          for (const name41 in generic_default) {
            this.addType_(name41, generic_default[name41]);
          }
        }
        if (config.atrules) {
          for (const name41 in config.atrules) {
            this.addAtrule_(name41, config.atrules[name41]);
          }
        }
        if (config.properties) {
          for (const name41 in config.properties) {
            this.addProperty_(name41, config.properties[name41]);
          }
        }
      }
    }
    checkStructure(ast) {
      function collectWarning(node, message) {
        warns.push({ node, message });
      }
      const structure41 = this.structure;
      const warns = [];
      this.syntax.walk(ast, function(node) {
        if (structure41.hasOwnProperty(node.type)) {
          structure41[node.type].check(node, collectWarning);
        } else {
          collectWarning(node, "Unknown node type `" + node.type + "`");
        }
      });
      return warns.length ? warns : false;
    }
    createDescriptor(syntax, type, name41, parent = null) {
      const ref = {
        type,
        name: name41
      };
      const descriptor = {
        type,
        name: name41,
        parent,
        serializable: typeof syntax === "string" || syntax && typeof syntax.type === "string",
        syntax: null,
        match: null
      };
      if (typeof syntax === "function") {
        descriptor.match = buildMatchGraph(syntax, ref);
      } else {
        if (typeof syntax === "string") {
          Object.defineProperty(descriptor, "syntax", {
            get() {
              Object.defineProperty(descriptor, "syntax", {
                value: parse(syntax)
              });
              return descriptor.syntax;
            }
          });
        } else {
          descriptor.syntax = syntax;
        }
        Object.defineProperty(descriptor, "match", {
          get() {
            Object.defineProperty(descriptor, "match", {
              value: buildMatchGraph(descriptor.syntax, ref)
            });
            return descriptor.match;
          }
        });
      }
      return descriptor;
    }
    addAtrule_(name41, syntax) {
      if (!syntax) {
        return;
      }
      this.atrules[name41] = {
        type: "Atrule",
        name: name41,
        prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name41) : null,
        descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce(
          (map, descName) => {
            map[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name41);
            return map;
          },
          /* @__PURE__ */ Object.create(null)
        ) : null
      };
    }
    addProperty_(name41, syntax) {
      if (!syntax) {
        return;
      }
      this.properties[name41] = this.createDescriptor(syntax, "Property", name41);
    }
    addType_(name41, syntax) {
      if (!syntax) {
        return;
      }
      this.types[name41] = this.createDescriptor(syntax, "Type", name41);
      if (syntax === generic_default["-ms-legacy-expression"]) {
        this.valueCommonSyntax = cssWideKeywordsWithExpression;
      }
    }
    checkAtruleName(atruleName) {
      if (!this.getAtrule(atruleName)) {
        return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
      }
    }
    checkAtrulePrelude(atruleName, prelude) {
      const error = this.checkAtruleName(atruleName);
      if (error) {
        return error;
      }
      const atrule = this.getAtrule(atruleName);
      if (!atrule.prelude && prelude) {
        return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
      }
      if (atrule.prelude && !prelude) {
        return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
      }
    }
    checkAtruleDescriptorName(atruleName, descriptorName) {
      const error = this.checkAtruleName(atruleName);
      if (error) {
        return error;
      }
      const atrule = this.getAtrule(atruleName);
      const descriptor = keyword(descriptorName);
      if (!atrule.descriptors) {
        return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
      }
      if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
        return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
      }
    }
    checkPropertyName(propertyName) {
      if (!this.getProperty(propertyName)) {
        return new SyntaxReferenceError("Unknown property", propertyName);
      }
    }
    matchAtrulePrelude(atruleName, prelude) {
      const error = this.checkAtrulePrelude(atruleName, prelude);
      if (error) {
        return buildMatchResult(null, error);
      }
      if (!prelude) {
        return buildMatchResult(null, null);
      }
      return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);
    }
    matchAtruleDescriptor(atruleName, descriptorName, value) {
      const error = this.checkAtruleDescriptorName(atruleName, descriptorName);
      if (error) {
        return buildMatchResult(null, error);
      }
      const atrule = this.getAtrule(atruleName);
      const descriptor = keyword(descriptorName);
      return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    }
    matchDeclaration(node) {
      if (node.type !== "Declaration") {
        return buildMatchResult(null, new Error("Not a Declaration node"));
      }
      return this.matchProperty(node.property, node.value);
    }
    matchProperty(propertyName, value) {
      if (property(propertyName).custom) {
        return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
      }
      const error = this.checkPropertyName(propertyName);
      if (error) {
        return buildMatchResult(null, error);
      }
      return matchSyntax(this, this.getProperty(propertyName), value, true);
    }
    matchType(typeName, value) {
      const typeSyntax = this.getType(typeName);
      if (!typeSyntax) {
        return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
      }
      return matchSyntax(this, typeSyntax, value, false);
    }
    match(syntax, value) {
      if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
        return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
      }
      if (typeof syntax === "string" || !syntax.match) {
        syntax = this.createDescriptor(syntax, "Type", "anonymous");
      }
      return matchSyntax(this, syntax, value, false);
    }
    findValueFragments(propertyName, value, type, name41) {
      return matchFragments(this, value, this.matchProperty(propertyName, value), type, name41);
    }
    findDeclarationValueFragments(declaration, type, name41) {
      return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name41);
    }
    findAllFragments(ast, type, name41) {
      const result = [];
      this.syntax.walk(ast, {
        visit: "Declaration",
        enter: (declaration) => {
          result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name41));
        }
      });
      return result;
    }
    getAtrule(atruleName, fallbackBasename = true) {
      const atrule = keyword(atruleName);
      const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
      return atruleEntry || null;
    }
    getAtrulePrelude(atruleName, fallbackBasename = true) {
      const atrule = this.getAtrule(atruleName, fallbackBasename);
      return atrule && atrule.prelude || null;
    }
    getAtruleDescriptor(atruleName, name41) {
      return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name41] || null : null;
    }
    getProperty(propertyName, fallbackBasename = true) {
      const property2 = property(propertyName);
      const propertyEntry = property2.vendor && fallbackBasename ? this.properties[property2.name] || this.properties[property2.basename] : this.properties[property2.name];
      return propertyEntry || null;
    }
    getType(name41) {
      return hasOwnProperty.call(this.types, name41) ? this.types[name41] : null;
    }
    validate() {
      function validate(syntax, name41, broken, descriptor) {
        if (broken.has(name41)) {
          return broken.get(name41);
        }
        broken.set(name41, false);
        if (descriptor.syntax !== null) {
          walk(descriptor.syntax, function(node) {
            if (node.type !== "Type" && node.type !== "Property") {
              return;
            }
            const map = node.type === "Type" ? syntax.types : syntax.properties;
            const brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
            if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
              broken.set(name41, true);
            }
          }, this);
        }
      }
      let brokenTypes = /* @__PURE__ */ new Map();
      let brokenProperties = /* @__PURE__ */ new Map();
      for (const key in this.types) {
        validate(this, key, brokenTypes, this.types[key]);
      }
      for (const key in this.properties) {
        validate(this, key, brokenProperties, this.properties[key]);
      }
      brokenTypes = [...brokenTypes.keys()].filter((name41) => brokenTypes.get(name41));
      brokenProperties = [...brokenProperties.keys()].filter((name41) => brokenProperties.get(name41));
      if (brokenTypes.length || brokenProperties.length) {
        return {
          types: brokenTypes,
          properties: brokenProperties
        };
      }
      return null;
    }
    dump(syntaxAsAst, pretty) {
      return {
        generic: this.generic,
        types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
        properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
        atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
      };
    }
    toString() {
      return JSON.stringify(this.dump());
    }
  };

  // node_modules/css-tree/lib/syntax/config/mix.js
  var { hasOwnProperty: hasOwnProperty5 } = Object.prototype;
  var shape = {
    generic: true,
    types: appendOrAssign,
    atrules: {
      prelude: appendOrAssignOrNull,
      descriptors: appendOrAssignOrNull
    },
    properties: appendOrAssign,
    parseContext: assign,
    scope: deepAssign,
    atrule: ["parse"],
    pseudo: ["parse"],
    node: ["name", "structure", "parse", "generate", "walkContext"]
  };
  function isObject(value) {
    return value && value.constructor === Object;
  }
  function copy(value) {
    return isObject(value) ? { ...value } : value;
  }
  function assign(dest, src) {
    return Object.assign(dest, src);
  }
  function deepAssign(dest, src) {
    for (const key in src) {
      if (hasOwnProperty5.call(src, key)) {
        if (isObject(dest[key])) {
          deepAssign(dest[key], copy(src[key]));
        } else {
          dest[key] = copy(src[key]);
        }
      }
    }
    return dest;
  }
  function append(a, b) {
    if (typeof b === "string" && /^\s*\|/.test(b)) {
      return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
    }
    return b || null;
  }
  function appendOrAssign(a, b) {
    if (typeof b === "string") {
      return append(a, b);
    }
    const result = { ...a };
    for (let key in b) {
      if (hasOwnProperty5.call(b, key)) {
        result[key] = append(hasOwnProperty5.call(a, key) ? a[key] : void 0, b[key]);
      }
    }
    return result;
  }
  function appendOrAssignOrNull(a, b) {
    const result = appendOrAssign(a, b);
    return !isObject(result) || Object.keys(result).length ? result : null;
  }
  function mix(dest, src, shape2) {
    for (const key in shape2) {
      if (hasOwnProperty5.call(shape2, key) === false) {
        continue;
      }
      if (shape2[key] === true) {
        if (key in src) {
          if (hasOwnProperty5.call(src, key)) {
            dest[key] = copy(src[key]);
          }
        }
      } else if (shape2[key]) {
        if (typeof shape2[key] === "function") {
          const fn = shape2[key];
          dest[key] = fn({}, dest[key]);
          dest[key] = fn(dest[key] || {}, src[key]);
        } else if (isObject(shape2[key])) {
          const result = {};
          for (let name41 in dest[key]) {
            result[name41] = mix({}, dest[key][name41], shape2[key]);
          }
          for (let name41 in src[key]) {
            result[name41] = mix(result[name41] || {}, src[key][name41], shape2[key]);
          }
          dest[key] = result;
        } else if (Array.isArray(shape2[key])) {
          const res = {};
          const innerShape = shape2[key].reduce(function(s, k) {
            s[k] = true;
            return s;
          }, {});
          for (const [name41, value] of Object.entries(dest[key] || {})) {
            res[name41] = {};
            if (value) {
              mix(res[name41], value, innerShape);
            }
          }
          for (const name41 in src[key]) {
            if (hasOwnProperty5.call(src[key], name41)) {
              if (!res[name41]) {
                res[name41] = {};
              }
              if (src[key] && src[key][name41]) {
                mix(res[name41], src[key][name41], innerShape);
              }
            }
          }
          dest[key] = res;
        }
      }
    }
    return dest;
  }
  var mix_default = (dest, src) => mix(dest, src, shape);

  // node_modules/css-tree/lib/syntax/create.js
  function createSyntax(config) {
    const parse44 = createParser(config);
    const walk3 = createWalker(config);
    const generate43 = createGenerator(config);
    const { fromPlainObject: fromPlainObject2, toPlainObject: toPlainObject2 } = createConvertor(walk3);
    const syntax = {
      lexer: null,
      createLexer: (config2) => new Lexer(config2, syntax, syntax.lexer.structure),
      tokenize,
      parse: parse44,
      generate: generate43,
      walk: walk3,
      find: walk3.find,
      findLast: walk3.findLast,
      findAll: walk3.findAll,
      fromPlainObject: fromPlainObject2,
      toPlainObject: toPlainObject2,
      fork: function(extension) {
        const base = mix_default({}, config);
        return createSyntax(
          typeof extension === "function" ? extension(base, Object.assign) : mix_default(base, extension)
        );
      }
    };
    syntax.lexer = new Lexer({
      generic: true,
      types: config.types,
      atrules: config.atrules,
      properties: config.properties,
      node: config.node
    }, syntax);
    return syntax;
  }
  var create_default = (config) => createSyntax(mix_default({}, config));

  // node_modules/css-tree/dist/data.js
  var data_default = {
    "generic": true,
    "types": {
      "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
      "alpha-value": "<number>|<percentage>",
      "angle-percentage": "<angle>|<percentage>",
      "angular-color-hint": "<angle-percentage>",
      "angular-color-stop": "<color>&&<color-stop-angle>?",
      "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
      "animateable-feature": "scroll-position|contents|<custom-ident>",
      "attachment": "scroll|fixed|local",
      "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
      "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
      "attr-modifier": "i|s",
      "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
      "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
      "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
      "baseline-position": "[first|last]? baseline",
      "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
      "bg-image": "none|<image>",
      "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
      "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
      "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
      "blur()": "blur( <length> )",
      "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
      "box": "border-box|padding-box|content-box",
      "brightness()": "brightness( <number-percentage> )",
      "calc()": "calc( <calc-sum> )",
      "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
      "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
      "calc-value": "<number>|<dimension>|<percentage>|( <calc-sum> )",
      "cf-final-image": "<image>|<color>",
      "cf-mixing-image": "<percentage>?&&<image>",
      "circle()": "circle( [<shape-radius>]? [at <position>]? )",
      "clamp()": "clamp( <calc-sum>#{3} )",
      "class-selector": "'.' <ident-token>",
      "clip-source": "<url>",
      "color": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>",
      "color-stop": "<color-stop-length>|<color-stop-angle>",
      "color-stop-angle": "<angle-percentage>{1,2}",
      "color-stop-length": "<length-percentage>{1,2}",
      "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
      "combinator": "'>'|'+'|'~'|['||']",
      "common-lig-values": "[common-ligatures|no-common-ligatures]",
      "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
      "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
      "compositing-operator": "add|subtract|intersect|exclude",
      "compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!",
      "compound-selector-list": "<compound-selector>#",
      "complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
      "complex-selector-list": "<complex-selector>#",
      "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
      "contextual-alt-values": "[contextual|no-contextual]",
      "content-distribution": "space-between|space-around|space-evenly|stretch",
      "content-list": "[<string>|contents|<image>|<quote>|<target>|<leader()>|<attr()>|counter( <ident> , <'list-style-type'>? )]+",
      "content-position": "center|start|end|flex-start|flex-end",
      "content-replacement": "<image>",
      "contrast()": "contrast( [<number-percentage>] )",
      "counter()": "counter( <custom-ident> , <counter-style>? )",
      "counter-style": "<counter-style-name>|symbols( )",
      "counter-style-name": "<custom-ident>",
      "counters()": "counters( <custom-ident> , <string> , <counter-style>? )",
      "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
      "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
      "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
      "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
      "display-box": "contents|none",
      "display-inside": "flow|flow-root|table|flex|grid|ruby",
      "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
      "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
      "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
      "display-outside": "block|inline|run-in",
      "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
      "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
      "east-asian-width-values": "[full-width|proportional-width]",
      "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
      "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
      "ending-shape": "circle|ellipse",
      "env()": "env( <custom-ident> , <declaration-value>? )",
      "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
      "family-name": "<string>|<custom-ident>+",
      "feature-tag-value": "<string> [<integer>|on|off]?",
      "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
      "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
      "feature-value-block-list": "<feature-value-block>+",
      "feature-value-declaration": "<custom-ident> : <integer>+ ;",
      "feature-value-declaration-list": "<feature-value-declaration>",
      "feature-value-name": "<custom-ident>",
      "fill-rule": "nonzero|evenodd",
      "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
      "filter-function-list": "[<filter-function>|<url>]+",
      "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
      "fit-content()": "fit-content( [<length>|<percentage>] )",
      "fixed-breadth": "<length-percentage>",
      "fixed-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
      "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
      "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
      "font-variant-css21": "[normal|small-caps]",
      "font-weight-absolute": "normal|bold|<number [1,1000]>",
      "frequency-percentage": "<frequency>|<percentage>",
      "general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )",
      "generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system",
      "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
      "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
      "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<-legacy-gradient>",
      "grayscale()": "grayscale( <number-percentage> )",
      "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
      "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
      "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
      "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
      "hue": "<number>|<angle>",
      "hue-rotate()": "hue-rotate( <angle> )",
      "image": "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
      "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
      "image-set()": "image-set( <image-set-option># )",
      "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
      "image-src": "<url>|<string>",
      "image-tags": "ltr|rtl",
      "inflexible-breadth": "<length>|<percentage>|min-content|max-content|auto",
      "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
      "invert()": "invert( <number-percentage> )",
      "keyframes-name": "<custom-ident>|<string>",
      "keyframe-block": "<keyframe-selector># { <declaration-list> }",
      "keyframe-block-list": "<keyframe-block>+",
      "keyframe-selector": "from|to|<percentage>",
      "leader()": "leader( <leader-type> )",
      "leader-type": "dotted|solid|space|<string>",
      "length-percentage": "<length>|<percentage>",
      "line-names": "'[' <custom-ident>* ']'",
      "line-name-list": "[<line-names>|<name-repeat>]+",
      "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
      "line-width": "<length>|thin|medium|thick",
      "linear-color-hint": "<length-percentage>",
      "linear-color-stop": "<color> <color-stop-length>?",
      "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
      "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
      "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
      "mask-reference": "none|<image>|<mask-source>",
      "mask-source": "<url>",
      "masking-mode": "alpha|luminance|match-source",
      "matrix()": "matrix( <number>#{6} )",
      "matrix3d()": "matrix3d( <number>#{16} )",
      "max()": "max( <calc-sum># )",
      "media-and": "<media-in-parens> [and <media-in-parens>]+",
      "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
      "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
      "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
      "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
      "media-not": "not <media-in-parens>",
      "media-or": "<media-in-parens> [or <media-in-parens>]+",
      "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
      "media-query-list": "<media-query>#",
      "media-type": "<ident>",
      "mf-boolean": "<mf-name>",
      "mf-name": "<ident>",
      "mf-plain": "<mf-name> : <mf-value>",
      "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
      "mf-value": "<number>|<dimension>|<ident>|<ratio>",
      "min()": "min( <calc-sum># )",
      "minmax()": "minmax( [<length>|<percentage>|min-content|max-content|auto] , [<length>|<percentage>|<flex>|min-content|max-content|auto] )",
      "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>",
      "namespace-prefix": "<ident>",
      "ns-prefix": "[<ident-token>|'*']? '|'",
      "number-percentage": "<number>|<percentage>",
      "numeric-figure-values": "[lining-nums|oldstyle-nums]",
      "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
      "numeric-spacing-values": "[proportional-nums|tabular-nums]",
      "nth": "<an-plus-b>|even|odd",
      "opacity()": "opacity( [<number-percentage>] )",
      "overflow-position": "unsafe|safe",
      "outline-radius": "<length>|<percentage>",
      "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
      "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
      "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
      "page-selector-list": "[<page-selector>#]?",
      "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
      "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
      "path()": "path( [<fill-rule> ,]? <string> )",
      "paint()": "paint( <ident> , <declaration-value>? )",
      "perspective()": "perspective( <length> )",
      "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
      "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
      "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
      "pseudo-element-selector": "':' <pseudo-class-selector>",
      "pseudo-page": ": [left|right|first|blank]",
      "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
      "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
      "relative-selector": "<combinator>? <complex-selector>",
      "relative-selector-list": "<relative-selector>#",
      "relative-size": "larger|smaller",
      "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
      "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
      "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
      "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
      "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
      "rotate()": "rotate( [<angle>|<zero>] )",
      "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
      "rotateX()": "rotateX( [<angle>|<zero>] )",
      "rotateY()": "rotateY( [<angle>|<zero>] )",
      "rotateZ()": "rotateZ( [<angle>|<zero>] )",
      "saturate()": "saturate( <number-percentage> )",
      "scale()": "scale( <number> , <number>? )",
      "scale3d()": "scale3d( <number> , <number> , <number> )",
      "scaleX()": "scaleX( <number> )",
      "scaleY()": "scaleY( <number> )",
      "scaleZ()": "scaleZ( <number> )",
      "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
      "shape-radius": "<length-percentage>|closest-side|farthest-side",
      "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
      "skewX()": "skewX( [<angle>|<zero>] )",
      "skewY()": "skewY( [<angle>|<zero>] )",
      "sepia()": "sepia( <number-percentage> )",
      "shadow": "inset?&&<length>{2,4}&&<color>?",
      "shadow-t": "[<length>{2,3}&&<color>?]",
      "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
      "shape-box": "<box>|margin-box",
      "side-or-corner": "[left|right]||[top|bottom]",
      "single-animation": "<time>||<easing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]",
      "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
      "single-animation-fill-mode": "none|forwards|backwards|both",
      "single-animation-iteration-count": "infinite|<number>",
      "single-animation-play-state": "running|paused",
      "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>",
      "single-transition-property": "all|<custom-ident>",
      "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
      "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
      "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
      "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
      "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
      "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
      "supports-feature": "<supports-decl>|<supports-selector-fn>",
      "supports-decl": "( <declaration> )",
      "supports-selector-fn": "selector( <complex-selector> )",
      "symbol": "<string>|<image>|<custom-ident>",
      "target": "<target-counter()>|<target-counters()>|<target-text()>",
      "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
      "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
      "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
      "time-percentage": "<time>|<percentage>",
      "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
      "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
      "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
      "track-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <track-size>]+ <line-names>? )",
      "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( [<length>|<percentage>] )",
      "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
      "transform-list": "<transform-function>+",
      "translate()": "translate( <length-percentage> , <length-percentage>? )",
      "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
      "translateX()": "translateX( <length-percentage> )",
      "translateY()": "translateY( <length-percentage> )",
      "translateZ()": "translateZ( <length> )",
      "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
      "type-selector": "<wq-name>|<ns-prefix>? '*'",
      "var()": "var( <custom-property-name> , <declaration-value>? )",
      "viewport-length": "auto|<length-percentage>",
      "visual-box": "content-box|padding-box|border-box",
      "wq-name": "<ns-prefix>? <ident-token>",
      "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
      "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
      "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
      "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
      "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
      "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
      "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
      "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
      "-legacy-radial-gradient-shape": "circle|ellipse",
      "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
      "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
      "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
      "-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
      "-non-standard-width": "fill-available|min-intrinsic|intrinsic|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content",
      "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
      "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
      "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
      "-webkit-gradient-radius": "<length>|<percentage>",
      "-webkit-gradient-type": "linear|radial",
      "-webkit-mask-box-repeat": "repeat|stretch|round",
      "-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text",
      "-ms-filter-function-list": "<-ms-filter-function>+",
      "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
      "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
      "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
      "-ms-filter": "<string>",
      "age": "child|young|old",
      "attr-name": "<wq-name>",
      "attr-fallback": "<any-value>",
      "border-radius": "<length-percentage>{1,2}",
      "bottom": "<length>|auto",
      "generic-voice": "[<age>? <gender> <integer>?]",
      "gender": "male|female|neutral",
      "left": "<length>|auto",
      "mask-image": "<mask-reference>#",
      "name-repeat": "repeat( [<positive-integer>|auto-fill] , <line-names>+ )",
      "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
      "ratio": "<integer> / <integer>",
      "right": "<length>|auto",
      "svg-length": "<percentage>|<length>|<number>",
      "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
      "top": "<length>|auto",
      "track-group": "'(' [<string>* <track-minmax> <string>*]+ ')' ['[' <positive-integer> ']']?|<track-minmax>",
      "track-list-v0": "[<string>* <track-group> <string>*]+|none",
      "track-minmax": "minmax( <track-breadth> , <track-breadth> )|auto|<track-breadth>|fit-content",
      "x": "<number>",
      "y": "<number>",
      "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
      "declaration-list": "[<declaration>? ';']* <declaration>?",
      "url": "url( <string> <url-modifier>* )|<url-token>",
      "url-modifier": "<ident>|<function-token> <any-value> )",
      "number-zero-one": "<number [0,1]>",
      "number-one-or-greater": "<number [1,\u221E]>",
      "positive-integer": "<integer [0,\u221E]>",
      "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box"
    },
    "properties": {
      "--*": "<declaration-value>",
      "-ms-accelerator": "false|true",
      "-ms-block-progression": "tb|rl|bt|lr",
      "-ms-content-zoom-chaining": "none|chained",
      "-ms-content-zooming": "none|zoom",
      "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
      "-ms-content-zoom-limit-max": "<percentage>",
      "-ms-content-zoom-limit-min": "<percentage>",
      "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
      "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
      "-ms-content-zoom-snap-type": "none|proximity|mandatory",
      "-ms-filter": "<string>",
      "-ms-flow-from": "[none|<custom-ident>]#",
      "-ms-flow-into": "[none|<custom-ident>]#",
      "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
      "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
      "-ms-high-contrast-adjust": "auto|none",
      "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
      "-ms-hyphenate-limit-lines": "no-limit|<integer>",
      "-ms-hyphenate-limit-zone": "<percentage>|<length>",
      "-ms-ime-align": "auto|after",
      "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
      "-ms-scrollbar-3dlight-color": "<color>",
      "-ms-scrollbar-arrow-color": "<color>",
      "-ms-scrollbar-base-color": "<color>",
      "-ms-scrollbar-darkshadow-color": "<color>",
      "-ms-scrollbar-face-color": "<color>",
      "-ms-scrollbar-highlight-color": "<color>",
      "-ms-scrollbar-shadow-color": "<color>",
      "-ms-scrollbar-track-color": "<color>",
      "-ms-scroll-chaining": "chained|none",
      "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
      "-ms-scroll-limit-x-max": "auto|<length>",
      "-ms-scroll-limit-x-min": "<length>",
      "-ms-scroll-limit-y-max": "auto|<length>",
      "-ms-scroll-limit-y-min": "<length>",
      "-ms-scroll-rails": "none|railed",
      "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
      "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
      "-ms-scroll-snap-type": "none|proximity|mandatory",
      "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
      "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
      "-ms-scroll-translation": "none|vertical-to-horizontal",
      "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
      "-ms-touch-select": "grippers|none",
      "-ms-user-select": "none|element|text",
      "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
      "-ms-wrap-margin": "<length>",
      "-ms-wrap-through": "wrap|none",
      "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
      "-moz-binding": "<url>|none",
      "-moz-border-bottom-colors": "<color>+|none",
      "-moz-border-left-colors": "<color>+|none",
      "-moz-border-right-colors": "<color>+|none",
      "-moz-border-top-colors": "<color>+|none",
      "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
      "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
      "-moz-force-broken-image-icon": "0|1",
      "-moz-image-region": "<shape>|auto",
      "-moz-orient": "inline|block|horizontal|vertical",
      "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
      "-moz-outline-radius-bottomleft": "<outline-radius>",
      "-moz-outline-radius-bottomright": "<outline-radius>",
      "-moz-outline-radius-topleft": "<outline-radius>",
      "-moz-outline-radius-topright": "<outline-radius>",
      "-moz-stack-sizing": "ignore|stretch-to-fit",
      "-moz-text-blink": "none|blink",
      "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
      "-moz-user-input": "auto|none|enabled|disabled",
      "-moz-user-modify": "read-only|read-write|write-only",
      "-moz-window-dragging": "drag|no-drag",
      "-moz-window-shadow": "default|menu|tooltip|sheet|none",
      "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
      "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
      "-webkit-border-before-color": "<color>",
      "-webkit-border-before-style": "<'border-style'>",
      "-webkit-border-before-width": "<'border-width'>",
      "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
      "-webkit-line-clamp": "none|<integer>",
      "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
      "-webkit-mask-attachment": "<attachment>#",
      "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
      "-webkit-mask-composite": "<composite-style>#",
      "-webkit-mask-image": "<mask-reference>#",
      "-webkit-mask-origin": "[<box>|border|padding|content]#",
      "-webkit-mask-position": "<position>#",
      "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
      "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
      "-webkit-mask-repeat": "<repeat-style>#",
      "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
      "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
      "-webkit-mask-size": "<bg-size>#",
      "-webkit-overflow-scrolling": "auto|touch",
      "-webkit-tap-highlight-color": "<color>",
      "-webkit-text-fill-color": "<color>",
      "-webkit-text-stroke": "<length>||<color>",
      "-webkit-text-stroke-color": "<color>",
      "-webkit-text-stroke-width": "<length>",
      "-webkit-touch-callout": "default|none",
      "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
      "accent-color": "auto|<color>",
      "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
      "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
      "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
      "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
      "all": "initial|inherit|unset|revert",
      "animation": "<single-animation>#",
      "animation-delay": "<time>#",
      "animation-direction": "<single-animation-direction>#",
      "animation-duration": "<time>#",
      "animation-fill-mode": "<single-animation-fill-mode>#",
      "animation-iteration-count": "<single-animation-iteration-count>#",
      "animation-name": "[none|<keyframes-name>]#",
      "animation-play-state": "<single-animation-play-state>#",
      "animation-timing-function": "<easing-function>#",
      "appearance": "none|auto|textfield|menulist-button|<compat-auto>",
      "aspect-ratio": "auto|<ratio>",
      "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
      "backdrop-filter": "none|<filter-function-list>",
      "backface-visibility": "visible|hidden",
      "background": "[<bg-layer> ,]* <final-bg-layer>",
      "background-attachment": "<attachment>#",
      "background-blend-mode": "<blend-mode>#",
      "background-clip": "<box>#",
      "background-color": "<color>",
      "background-image": "<bg-image>#",
      "background-origin": "<box>#",
      "background-position": "<bg-position>#",
      "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
      "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
      "background-repeat": "<repeat-style>#",
      "background-size": "<bg-size>#",
      "block-overflow": "clip|ellipsis|<string>",
      "block-size": "<'width'>",
      "border": "<line-width>||<line-style>||<color>",
      "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-block-color": "<'border-top-color'>{1,2}",
      "border-block-style": "<'border-top-style'>",
      "border-block-width": "<'border-top-width'>",
      "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-block-end-color": "<'border-top-color'>",
      "border-block-end-style": "<'border-top-style'>",
      "border-block-end-width": "<'border-top-width'>",
      "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-block-start-color": "<'border-top-color'>",
      "border-block-start-style": "<'border-top-style'>",
      "border-block-start-width": "<'border-top-width'>",
      "border-bottom": "<line-width>||<line-style>||<color>",
      "border-bottom-color": "<'border-top-color'>",
      "border-bottom-left-radius": "<length-percentage>{1,2}",
      "border-bottom-right-radius": "<length-percentage>{1,2}",
      "border-bottom-style": "<line-style>",
      "border-bottom-width": "<line-width>",
      "border-collapse": "collapse|separate",
      "border-color": "<color>{1,4}",
      "border-end-end-radius": "<length-percentage>{1,2}",
      "border-end-start-radius": "<length-percentage>{1,2}",
      "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
      "border-image-outset": "[<length>|<number>]{1,4}",
      "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
      "border-image-slice": "<number-percentage>{1,4}&&fill?",
      "border-image-source": "none|<image>",
      "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
      "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-inline-color": "<'border-top-color'>{1,2}",
      "border-inline-style": "<'border-top-style'>",
      "border-inline-width": "<'border-top-width'>",
      "border-inline-end-color": "<'border-top-color'>",
      "border-inline-end-style": "<'border-top-style'>",
      "border-inline-end-width": "<'border-top-width'>",
      "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
      "border-inline-start-color": "<'border-top-color'>",
      "border-inline-start-style": "<'border-top-style'>",
      "border-inline-start-width": "<'border-top-width'>",
      "border-left": "<line-width>||<line-style>||<color>",
      "border-left-color": "<color>",
      "border-left-style": "<line-style>",
      "border-left-width": "<line-width>",
      "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
      "border-right": "<line-width>||<line-style>||<color>",
      "border-right-color": "<color>",
      "border-right-style": "<line-style>",
      "border-right-width": "<line-width>",
      "border-spacing": "<length> <length>?",
      "border-start-end-radius": "<length-percentage>{1,2}",
      "border-start-start-radius": "<length-percentage>{1,2}",
      "border-style": "<line-style>{1,4}",
      "border-top": "<line-width>||<line-style>||<color>",
      "border-top-color": "<color>",
      "border-top-left-radius": "<length-percentage>{1,2}",
      "border-top-right-radius": "<length-percentage>{1,2}",
      "border-top-style": "<line-style>",
      "border-top-width": "<line-width>",
      "border-width": "<line-width>{1,4}",
      "bottom": "<length>|<percentage>|auto",
      "box-align": "start|center|end|baseline|stretch",
      "box-decoration-break": "slice|clone",
      "box-direction": "normal|reverse|inherit",
      "box-flex": "<number>",
      "box-flex-group": "<integer>",
      "box-lines": "single|multiple",
      "box-ordinal-group": "<integer>",
      "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
      "box-pack": "start|center|end|justify",
      "box-shadow": "none|<shadow>#",
      "box-sizing": "content-box|border-box",
      "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
      "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
      "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
      "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
      "caret-color": "auto|<color>",
      "clear": "none|left|right|both|inline-start|inline-end",
      "clip": "<shape>|auto",
      "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
      "color": "<color>",
      "color-adjust": "economy|exact",
      "color-scheme": "normal|[light|dark|<custom-ident>]+",
      "column-count": "<integer>|auto",
      "column-fill": "auto|balance|balance-all",
      "column-gap": "normal|<length-percentage>",
      "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
      "column-rule-color": "<color>",
      "column-rule-style": "<'border-style'>",
      "column-rule-width": "<'border-width'>",
      "column-span": "none|all",
      "column-width": "<length>|auto",
      "columns": "<'column-width'>||<'column-count'>",
      "contain": "none|strict|content|[size||layout||style||paint]",
      "content": "normal|none|[<content-replacement>|<content-list>] [/ <string>]?",
      "content-visibility": "visible|auto|hidden",
      "counter-increment": "[<custom-ident> <integer>?]+|none",
      "counter-reset": "[<custom-ident> <integer>?]+|none",
      "counter-set": "[<custom-ident> <integer>?]+|none",
      "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
      "direction": "ltr|rtl",
      "display": "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
      "empty-cells": "show|hide",
      "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
      "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
      "flex-basis": "content|<'width'>",
      "flex-direction": "row|row-reverse|column|column-reverse",
      "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
      "flex-grow": "<number>",
      "flex-shrink": "<number>",
      "flex-wrap": "nowrap|wrap|wrap-reverse",
      "float": "left|right|none|inline-start|inline-end",
      "font": "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar",
      "font-family": "[<family-name>|<generic-family>]#",
      "font-feature-settings": "normal|<feature-tag-value>#",
      "font-kerning": "auto|normal|none",
      "font-language-override": "normal|<string>",
      "font-optical-sizing": "auto|none",
      "font-variation-settings": "normal|[<string> <number>]#",
      "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
      "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
      "font-smooth": "auto|never|always|<absolute-size>|<length>",
      "font-stretch": "<font-stretch-absolute>",
      "font-style": "normal|italic|oblique <angle>?",
      "font-synthesis": "none|[weight||style||small-caps]",
      "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
      "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
      "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
      "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
      "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
      "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
      "font-variant-position": "normal|sub|super",
      "font-weight": "<font-weight-absolute>|bolder|lighter",
      "forced-color-adjust": "auto|none",
      "gap": "<'row-gap'> <'column-gap'>?",
      "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
      "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
      "grid-auto-columns": "<track-size>+",
      "grid-auto-flow": "[row|column]||dense",
      "grid-auto-rows": "<track-size>+",
      "grid-column": "<grid-line> [/ <grid-line>]?",
      "grid-column-end": "<grid-line>",
      "grid-column-gap": "<length-percentage>",
      "grid-column-start": "<grid-line>",
      "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
      "grid-row": "<grid-line> [/ <grid-line>]?",
      "grid-row-end": "<grid-line>",
      "grid-row-gap": "<length-percentage>",
      "grid-row-start": "<grid-line>",
      "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
      "grid-template-areas": "none|<string>+",
      "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
      "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
      "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
      "height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
      "hyphens": "none|manual|auto",
      "image-orientation": "from-image|<angle>|[<angle>? flip]",
      "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
      "image-resolution": "[from-image||<resolution>]&&snap?",
      "ime-mode": "auto|normal|active|inactive|disabled",
      "initial-letter": "normal|[<number> <integer>?]",
      "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
      "inline-size": "<'width'>",
      "inset": "<'top'>{1,4}",
      "inset-block": "<'top'>{1,2}",
      "inset-block-end": "<'top'>",
      "inset-block-start": "<'top'>",
      "inset-inline": "<'top'>{1,2}",
      "inset-inline-end": "<'top'>",
      "inset-inline-start": "<'top'>",
      "isolation": "auto|isolate",
      "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
      "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
      "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
      "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
      "left": "<length>|<percentage>|auto",
      "letter-spacing": "normal|<length-percentage>",
      "line-break": "auto|loose|normal|strict|anywhere",
      "line-clamp": "none|<integer>",
      "line-height": "normal|<number>|<length>|<percentage>",
      "line-height-step": "<length>",
      "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
      "list-style-image": "<image>|none",
      "list-style-position": "inside|outside",
      "list-style-type": "<counter-style>|<string>|none",
      "margin": "[<length>|<percentage>|auto]{1,4}",
      "margin-block": "<'margin-left'>{1,2}",
      "margin-block-end": "<'margin-left'>",
      "margin-block-start": "<'margin-left'>",
      "margin-bottom": "<length>|<percentage>|auto",
      "margin-inline": "<'margin-left'>{1,2}",
      "margin-inline-end": "<'margin-left'>",
      "margin-inline-start": "<'margin-left'>",
      "margin-left": "<length>|<percentage>|auto",
      "margin-right": "<length>|<percentage>|auto",
      "margin-top": "<length>|<percentage>|auto",
      "margin-trim": "none|in-flow|all",
      "mask": "<mask-layer>#",
      "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
      "mask-border-mode": "luminance|alpha",
      "mask-border-outset": "[<length>|<number>]{1,4}",
      "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
      "mask-border-slice": "<number-percentage>{1,4} fill?",
      "mask-border-source": "none|<image>",
      "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
      "mask-clip": "[<geometry-box>|no-clip]#",
      "mask-composite": "<compositing-operator>#",
      "mask-image": "<mask-reference>#",
      "mask-mode": "<masking-mode>#",
      "mask-origin": "<geometry-box>#",
      "mask-position": "<position>#",
      "mask-repeat": "<repeat-style>#",
      "mask-size": "<bg-size>#",
      "mask-type": "luminance|alpha",
      "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
      "math-style": "normal|compact",
      "max-block-size": "<'max-width'>",
      "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
      "max-inline-size": "<'max-width'>",
      "max-lines": "none|<integer>",
      "max-width": "none|<length-percentage>|min-content|max-content|fit-content( <length-percentage> )|<-non-standard-width>",
      "min-block-size": "<'min-width'>",
      "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
      "min-inline-size": "<'min-width'>",
      "min-width": "auto|<length-percentage>|min-content|max-content|fit-content( <length-percentage> )|<-non-standard-width>",
      "mix-blend-mode": "<blend-mode>",
      "object-fit": "fill|contain|cover|none|scale-down",
      "object-position": "<position>",
      "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
      "offset-anchor": "auto|<position>",
      "offset-distance": "<length-percentage>",
      "offset-path": "none|ray( [<angle>&&<size>&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]",
      "offset-position": "auto|<position>",
      "offset-rotate": "[auto|reverse]||<angle>",
      "opacity": "<alpha-value>",
      "order": "<integer>",
      "orphans": "<integer>",
      "outline": "[<'outline-color'>||<'outline-style'>||<'outline-width'>]",
      "outline-color": "<color>|invert",
      "outline-offset": "<length>",
      "outline-style": "auto|<'border-style'>",
      "outline-width": "<line-width>",
      "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
      "overflow-anchor": "auto|none",
      "overflow-block": "visible|hidden|clip|scroll|auto",
      "overflow-clip-box": "padding-box|content-box",
      "overflow-clip-margin": "<visual-box>||<length [0,\u221E]>",
      "overflow-inline": "visible|hidden|clip|scroll|auto",
      "overflow-wrap": "normal|break-word|anywhere",
      "overflow-x": "visible|hidden|clip|scroll|auto",
      "overflow-y": "visible|hidden|clip|scroll|auto",
      "overscroll-behavior": "[contain|none|auto]{1,2}",
      "overscroll-behavior-block": "contain|none|auto",
      "overscroll-behavior-inline": "contain|none|auto",
      "overscroll-behavior-x": "contain|none|auto",
      "overscroll-behavior-y": "contain|none|auto",
      "padding": "[<length>|<percentage>]{1,4}",
      "padding-block": "<'padding-left'>{1,2}",
      "padding-block-end": "<'padding-left'>",
      "padding-block-start": "<'padding-left'>",
      "padding-bottom": "<length>|<percentage>",
      "padding-inline": "<'padding-left'>{1,2}",
      "padding-inline-end": "<'padding-left'>",
      "padding-inline-start": "<'padding-left'>",
      "padding-left": "<length>|<percentage>",
      "padding-right": "<length>|<percentage>",
      "padding-top": "<length>|<percentage>",
      "page-break-after": "auto|always|avoid|left|right|recto|verso",
      "page-break-before": "auto|always|avoid|left|right|recto|verso",
      "page-break-inside": "auto|avoid",
      "paint-order": "normal|[fill||stroke||markers]",
      "perspective": "none|<length>",
      "perspective-origin": "<position>",
      "place-content": "<'align-content'> <'justify-content'>?",
      "place-items": "<'align-items'> <'justify-items'>?",
      "place-self": "<'align-self'> <'justify-self'>?",
      "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
      "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
      "quotes": "none|auto|[<string> <string>]+",
      "resize": "none|both|horizontal|vertical|block|inline",
      "right": "<length>|<percentage>|auto",
      "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
      "row-gap": "normal|<length-percentage>",
      "ruby-align": "start|center|space-between|space-around",
      "ruby-merge": "separate|collapse|auto",
      "ruby-position": "[alternate||[over|under]]|inter-character",
      "scale": "none|<number>{1,3}",
      "scrollbar-color": "auto|<color>{2}",
      "scrollbar-gutter": "auto|stable&&both-edges?",
      "scrollbar-width": "auto|thin|none",
      "scroll-behavior": "auto|smooth",
      "scroll-margin": "<length>{1,4}",
      "scroll-margin-block": "<length>{1,2}",
      "scroll-margin-block-start": "<length>",
      "scroll-margin-block-end": "<length>",
      "scroll-margin-bottom": "<length>",
      "scroll-margin-inline": "<length>{1,2}",
      "scroll-margin-inline-start": "<length>",
      "scroll-margin-inline-end": "<length>",
      "scroll-margin-left": "<length>",
      "scroll-margin-right": "<length>",
      "scroll-margin-top": "<length>",
      "scroll-padding": "[auto|<length-percentage>]{1,4}",
      "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
      "scroll-padding-block-start": "auto|<length-percentage>",
      "scroll-padding-block-end": "auto|<length-percentage>",
      "scroll-padding-bottom": "auto|<length-percentage>",
      "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
      "scroll-padding-inline-start": "auto|<length-percentage>",
      "scroll-padding-inline-end": "auto|<length-percentage>",
      "scroll-padding-left": "auto|<length-percentage>",
      "scroll-padding-right": "auto|<length-percentage>",
      "scroll-padding-top": "auto|<length-percentage>",
      "scroll-snap-align": "[none|start|end|center]{1,2}",
      "scroll-snap-coordinate": "none|<position>#",
      "scroll-snap-destination": "<position>",
      "scroll-snap-points-x": "none|repeat( <length-percentage> )",
      "scroll-snap-points-y": "none|repeat( <length-percentage> )",
      "scroll-snap-stop": "normal|always",
      "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
      "scroll-snap-type-x": "none|mandatory|proximity",
      "scroll-snap-type-y": "none|mandatory|proximity",
      "shape-image-threshold": "<alpha-value>",
      "shape-margin": "<length-percentage>",
      "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
      "tab-size": "<integer>|<length>",
      "table-layout": "auto|fixed",
      "text-align": "start|end|left|right|center|justify|match-parent",
      "text-align-last": "auto|start|end|left|right|center|justify",
      "text-combine-upright": "none|all|[digits <integer>?]",
      "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
      "text-decoration-color": "<color>",
      "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
      "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
      "text-decoration-skip-ink": "auto|all|none",
      "text-decoration-style": "solid|double|dotted|dashed|wavy",
      "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
      "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
      "text-emphasis-color": "<color>",
      "text-emphasis-position": "[over|under]&&[right|left]",
      "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
      "text-indent": "<length-percentage>&&hanging?&&each-line?",
      "text-justify": "auto|inter-character|inter-word|none",
      "text-orientation": "mixed|upright|sideways",
      "text-overflow": "[clip|ellipsis|<string>]{1,2}",
      "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
      "text-shadow": "none|<shadow-t>#",
      "text-size-adjust": "none|auto|<percentage>",
      "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
      "text-underline-offset": "auto|<length>|<percentage>",
      "text-underline-position": "auto|from-font|[under||[left|right]]",
      "top": "<length>|<percentage>|auto",
      "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
      "transform": "none|<transform-list>",
      "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
      "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
      "transform-style": "flat|preserve-3d",
      "transition": "<single-transition>#",
      "transition-delay": "<time>#",
      "transition-duration": "<time>#",
      "transition-property": "none|<single-transition-property>#",
      "transition-timing-function": "<easing-function>#",
      "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
      "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
      "user-select": "auto|text|none|contain|all",
      "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
      "visibility": "visible|hidden|collapse",
      "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces",
      "widows": "<integer>",
      "width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|fit-content|-moz-fit-content|-webkit-fit-content",
      "will-change": "auto|<animateable-feature>#",
      "word-break": "normal|break-all|keep-all|break-word",
      "word-spacing": "normal|<length>",
      "word-wrap": "normal|break-word",
      "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
      "z-index": "auto|<integer>",
      "zoom": "normal|reset|<number>|<percentage>",
      "-moz-background-clip": "padding|border",
      "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
      "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
      "-moz-border-radius-topleft": "<'border-top-left-radius'>",
      "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
      "-moz-control-character-visibility": "visible|hidden",
      "-moz-osx-font-smoothing": "auto|grayscale",
      "-moz-user-select": "none|text|all|-moz-none",
      "-ms-flex-align": "start|end|center|baseline|stretch",
      "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
      "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
      "-ms-flex-negative": "<'flex-shrink'>",
      "-ms-flex-pack": "start|end|center|justify|distribute",
      "-ms-flex-order": "<integer>",
      "-ms-flex-positive": "<'flex-grow'>",
      "-ms-flex-preferred-size": "<'flex-basis'>",
      "-ms-interpolation-mode": "nearest-neighbor|bicubic",
      "-ms-grid-column-align": "start|end|center|stretch",
      "-ms-grid-row-align": "start|end|center|stretch",
      "-ms-hyphenate-limit-last": "none|always|column|page|spread",
      "-webkit-background-clip": "[<box>|border|padding|content|text]#",
      "-webkit-column-break-after": "always|auto|avoid",
      "-webkit-column-break-before": "always|auto|avoid",
      "-webkit-column-break-inside": "always|auto|avoid",
      "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
      "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
      "-webkit-print-color-adjust": "economy|exact",
      "-webkit-text-security": "none|circle|disc|square",
      "-webkit-user-drag": "none|element|auto",
      "-webkit-user-select": "auto|none|text|all",
      "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
      "baseline-shift": "baseline|sub|super|<svg-length>",
      "behavior": "<url>+",
      "clip-rule": "nonzero|evenodd",
      "cue": "<'cue-before'> <'cue-after'>?",
      "cue-after": "<url> <decibel>?|none",
      "cue-before": "<url> <decibel>?|none",
      "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
      "fill": "<paint>",
      "fill-opacity": "<number-zero-one>",
      "fill-rule": "nonzero|evenodd",
      "glyph-orientation-horizontal": "<angle>",
      "glyph-orientation-vertical": "<angle>",
      "kerning": "auto|<svg-length>",
      "marker": "none|<url>",
      "marker-end": "none|<url>",
      "marker-mid": "none|<url>",
      "marker-start": "none|<url>",
      "pause": "<'pause-before'> <'pause-after'>?",
      "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "rest": "<'rest-before'> <'rest-after'>?",
      "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
      "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
      "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
      "speak": "auto|none|normal",
      "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
      "stroke": "<paint>",
      "stroke-dasharray": "none|[<svg-length>+]#",
      "stroke-dashoffset": "<svg-length>",
      "stroke-linecap": "butt|round|square",
      "stroke-linejoin": "miter|round|bevel",
      "stroke-miterlimit": "<number-one-or-greater>",
      "stroke-opacity": "<number-zero-one>",
      "stroke-width": "<svg-length>",
      "text-anchor": "start|middle|end",
      "unicode-range": "<urange>#",
      "voice-balance": "<number>|left|center|right|leftwards|rightwards",
      "voice-duration": "auto|<time>",
      "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
      "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
      "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
      "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
      "voice-stress": "normal|strong|moderate|none|reduced",
      "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]"
    },
    "atrules": {
      "charset": {
        "prelude": "<string>",
        "descriptors": null
      },
      "counter-style": {
        "prelude": "<counter-style-name>",
        "descriptors": {
          "additive-symbols": "[<integer>&&<symbol>]#",
          "fallback": "<counter-style-name>",
          "negative": "<symbol> <symbol>?",
          "pad": "<integer>&&<symbol>",
          "prefix": "<symbol>",
          "range": "[[<integer>|infinite]{2}]#|auto",
          "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
          "suffix": "<symbol>",
          "symbols": "<symbol>+",
          "system": "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
        }
      },
      "document": {
        "prelude": "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
        "descriptors": null
      },
      "font-face": {
        "prelude": null,
        "descriptors": {
          "ascent-override": "normal|<percentage>",
          "descent-override": "normal|<percentage>",
          "font-display": "[auto|block|swap|fallback|optional]",
          "font-family": "<family-name>",
          "font-feature-settings": "normal|<feature-tag-value>#",
          "font-variation-settings": "normal|[<string> <number>]#",
          "font-stretch": "<font-stretch-absolute>{1,2}",
          "font-style": "normal|italic|oblique <angle>{0,2}",
          "font-weight": "<font-weight-absolute>{1,2}",
          "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
          "line-gap-override": "normal|<percentage>",
          "size-adjust": "<percentage>",
          "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
          "unicode-range": "<urange>#"
        }
      },
      "font-feature-values": {
        "prelude": "<family-name>#",
        "descriptors": null
      },
      "import": {
        "prelude": "[<string>|<url>] [<media-query-list>]?",
        "descriptors": null
      },
      "keyframes": {
        "prelude": "<keyframes-name>",
        "descriptors": null
      },
      "media": {
        "prelude": "<media-query-list>",
        "descriptors": null
      },
      "namespace": {
        "prelude": "<namespace-prefix>? [<string>|<url>]",
        "descriptors": null
      },
      "page": {
        "prelude": "<page-selector-list>",
        "descriptors": {
          "bleed": "auto|<length>",
          "marks": "none|[crop||cross]",
          "size": "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
        }
      },
      "property": {
        "prelude": "<custom-property-name>",
        "descriptors": {
          "syntax": "<string>",
          "inherits": "true|false",
          "initial-value": "<string>"
        }
      },
      "supports": {
        "prelude": "<supports-condition>",
        "descriptors": null
      },
      "viewport": {
        "prelude": null,
        "descriptors": {
          "height": "<viewport-length>{1,2}",
          "max-height": "<viewport-length>",
          "max-width": "<viewport-length>",
          "max-zoom": "auto|<number>|<percentage>",
          "min-height": "<viewport-length>",
          "min-width": "<viewport-length>",
          "min-zoom": "auto|<number>|<percentage>",
          "orientation": "auto|portrait|landscape",
          "user-zoom": "zoom|fixed",
          "viewport-fit": "auto|contain|cover",
          "width": "<viewport-length>{1,2}",
          "zoom": "auto|<number>|<percentage>"
        }
      }
    }
  };

  // node_modules/css-tree/lib/syntax/node/index.js
  var node_exports = {};
  __export(node_exports, {
    AnPlusB: () => AnPlusB_exports,
    Atrule: () => Atrule_exports,
    AtrulePrelude: () => AtrulePrelude_exports,
    AttributeSelector: () => AttributeSelector_exports,
    Block: () => Block_exports,
    Brackets: () => Brackets_exports,
    CDC: () => CDC_exports,
    CDO: () => CDO_exports,
    ClassSelector: () => ClassSelector_exports,
    Combinator: () => Combinator_exports,
    Comment: () => Comment_exports,
    Declaration: () => Declaration_exports,
    DeclarationList: () => DeclarationList_exports,
    Dimension: () => Dimension_exports,
    Function: () => Function_exports,
    Hash: () => Hash_exports,
    IdSelector: () => IdSelector_exports,
    Identifier: () => Identifier_exports,
    MediaFeature: () => MediaFeature_exports,
    MediaQuery: () => MediaQuery_exports,
    MediaQueryList: () => MediaQueryList_exports,
    Nth: () => Nth_exports,
    Number: () => Number_exports,
    Operator: () => Operator_exports,
    Parentheses: () => Parentheses_exports,
    Percentage: () => Percentage_exports,
    PseudoClassSelector: () => PseudoClassSelector_exports,
    PseudoElementSelector: () => PseudoElementSelector_exports,
    Ratio: () => Ratio_exports,
    Raw: () => Raw_exports,
    Rule: () => Rule_exports,
    Selector: () => Selector_exports,
    SelectorList: () => SelectorList_exports,
    String: () => String_exports,
    StyleSheet: () => StyleSheet_exports,
    TypeSelector: () => TypeSelector_exports,
    UnicodeRange: () => UnicodeRange_exports,
    Url: () => Url_exports,
    Value: () => Value_exports,
    WhiteSpace: () => WhiteSpace_exports
  });

  // node_modules/css-tree/lib/syntax/node/AnPlusB.js
  var AnPlusB_exports = {};
  __export(AnPlusB_exports, {
    generate: () => generate2,
    name: () => name,
    parse: () => parse2,
    structure: () => structure
  });
  var PLUSSIGN5 = 43;
  var HYPHENMINUS5 = 45;
  var N5 = 110;
  var DISALLOW_SIGN2 = true;
  var ALLOW_SIGN2 = false;
  function checkInteger2(offset, disallowSign) {
    let pos = this.tokenStart + offset;
    const code2 = this.charCodeAt(pos);
    if (code2 === PLUSSIGN5 || code2 === HYPHENMINUS5) {
      if (disallowSign) {
        this.error("Number sign is not allowed");
      }
      pos++;
    }
    for (; pos < this.tokenEnd; pos++) {
      if (!isDigit(this.charCodeAt(pos))) {
        this.error("Integer is expected", pos);
      }
    }
  }
  function checkTokenIsInteger(disallowSign) {
    return checkInteger2.call(this, 0, disallowSign);
  }
  function expectCharCode(offset, code2) {
    if (!this.cmpChar(this.tokenStart + offset, code2)) {
      let msg = "";
      switch (code2) {
        case N5:
          msg = "N is expected";
          break;
        case HYPHENMINUS5:
          msg = "HyphenMinus is expected";
          break;
      }
      this.error(msg, this.tokenStart + offset);
    }
  }
  function consumeB2() {
    let offset = 0;
    let sign = 0;
    let type = this.tokenType;
    while (type === WhiteSpace || type === Comment) {
      type = this.lookupType(++offset);
    }
    if (type !== Number2) {
      if (this.isDelim(PLUSSIGN5, offset) || this.isDelim(HYPHENMINUS5, offset)) {
        sign = this.isDelim(PLUSSIGN5, offset) ? PLUSSIGN5 : HYPHENMINUS5;
        do {
          type = this.lookupType(++offset);
        } while (type === WhiteSpace || type === Comment);
        if (type !== Number2) {
          this.skip(offset);
          checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        }
      } else {
        return null;
      }
    }
    if (offset > 0) {
      this.skip(offset);
    }
    if (sign === 0) {
      type = this.charCodeAt(this.tokenStart);
      if (type !== PLUSSIGN5 && type !== HYPHENMINUS5) {
        this.error("Number sign is expected");
      }
    }
    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS5 ? "-" + this.consume(Number2) : this.consume(Number2);
  }
  var name = "AnPlusB";
  var structure = {
    a: [String, null],
    b: [String, null]
  };
  function parse2() {
    const start = this.tokenStart;
    let a = null;
    let b = null;
    if (this.tokenType === Number2) {
      checkTokenIsInteger.call(this, ALLOW_SIGN2);
      b = this.consume(Number2);
    } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS5)) {
      a = "-1";
      expectCharCode.call(this, 1, N5);
      switch (this.tokenEnd - this.tokenStart) {
        case 2:
          this.next();
          b = consumeB2.call(this);
          break;
        case 3:
          expectCharCode.call(this, 2, HYPHENMINUS5);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN2);
          b = "-" + this.consume(Number2);
          break;
        default:
          expectCharCode.call(this, 2, HYPHENMINUS5);
          checkInteger2.call(this, 3, DISALLOW_SIGN2);
          this.next();
          b = this.substrToCursor(start + 2);
      }
    } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN5) && this.lookupType(1) === Ident) {
      let sign = 0;
      a = "1";
      if (this.isDelim(PLUSSIGN5)) {
        sign = 1;
        this.next();
      }
      expectCharCode.call(this, 0, N5);
      switch (this.tokenEnd - this.tokenStart) {
        case 1:
          this.next();
          b = consumeB2.call(this);
          break;
        case 2:
          expectCharCode.call(this, 1, HYPHENMINUS5);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN2);
          b = "-" + this.consume(Number2);
          break;
        default:
          expectCharCode.call(this, 1, HYPHENMINUS5);
          checkInteger2.call(this, 2, DISALLOW_SIGN2);
          this.next();
          b = this.substrToCursor(start + sign + 1);
      }
    } else if (this.tokenType === Dimension) {
      const code2 = this.charCodeAt(this.tokenStart);
      const sign = code2 === PLUSSIGN5 || code2 === HYPHENMINUS5;
      let i = this.tokenStart + sign;
      for (; i < this.tokenEnd; i++) {
        if (!isDigit(this.charCodeAt(i))) {
          break;
        }
      }
      if (i === this.tokenStart + sign) {
        this.error("Integer is expected", this.tokenStart + sign);
      }
      expectCharCode.call(this, i - this.tokenStart, N5);
      a = this.substring(start, i);
      if (i + 1 === this.tokenEnd) {
        this.next();
        b = consumeB2.call(this);
      } else {
        expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS5);
        if (i + 2 === this.tokenEnd) {
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN2);
          b = "-" + this.consume(Number2);
        } else {
          checkInteger2.call(this, i - this.tokenStart + 2, DISALLOW_SIGN2);
          this.next();
          b = this.substrToCursor(i + 1);
        }
      }
    } else {
      this.error();
    }
    if (a !== null && a.charCodeAt(0) === PLUSSIGN5) {
      a = a.substr(1);
    }
    if (b !== null && b.charCodeAt(0) === PLUSSIGN5) {
      b = b.substr(1);
    }
    return {
      type: "AnPlusB",
      loc: this.getLocation(start, this.tokenStart),
      a,
      b
    };
  }
  function generate2(node) {
    if (node.a) {
      const a = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
      if (node.b) {
        const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
        this.tokenize(a + b);
      } else {
        this.tokenize(a);
      }
    } else {
      this.tokenize(node.b);
    }
  }

  // node_modules/css-tree/lib/syntax/node/Atrule.js
  var Atrule_exports = {};
  __export(Atrule_exports, {
    generate: () => generate3,
    name: () => name2,
    parse: () => parse3,
    structure: () => structure2,
    walkContext: () => walkContext
  });
  function consumeRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
  }
  function isDeclarationBlockAtrule() {
    for (let offset = 1, type; type = this.lookupType(offset); offset++) {
      if (type === RightCurlyBracket) {
        return true;
      }
      if (type === LeftCurlyBracket || type === AtKeyword) {
        return false;
      }
    }
    return false;
  }
  var name2 = "Atrule";
  var walkContext = "atrule";
  var structure2 = {
    name: String,
    prelude: ["AtrulePrelude", "Raw", null],
    block: ["Block", null]
  };
  function parse3() {
    const start = this.tokenStart;
    let name41;
    let nameLowerCase;
    let prelude = null;
    let block = null;
    this.eat(AtKeyword);
    name41 = this.substrToCursor(start + 1);
    nameLowerCase = name41.toLowerCase();
    this.skipSC();
    if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
      if (this.parseAtrulePrelude) {
        prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name41), consumeRaw);
      } else {
        prelude = consumeRaw.call(this, this.tokenIndex);
      }
      this.skipSC();
    }
    switch (this.tokenType) {
      case Semicolon:
        this.next();
        break;
      case LeftCurlyBracket:
        if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
          block = this.atrule[nameLowerCase].block.call(this);
        } else {
          block = this.Block(isDeclarationBlockAtrule.call(this));
        }
        break;
    }
    return {
      type: "Atrule",
      loc: this.getLocation(start, this.tokenStart),
      name: name41,
      prelude,
      block
    };
  }
  function generate3(node) {
    this.token(AtKeyword, "@" + node.name);
    if (node.prelude !== null) {
      this.node(node.prelude);
    }
    if (node.block) {
      this.node(node.block);
    } else {
      this.token(Semicolon, ";");
    }
  }

  // node_modules/css-tree/lib/syntax/node/AtrulePrelude.js
  var AtrulePrelude_exports = {};
  __export(AtrulePrelude_exports, {
    generate: () => generate4,
    name: () => name3,
    parse: () => parse4,
    structure: () => structure3,
    walkContext: () => walkContext2
  });
  var name3 = "AtrulePrelude";
  var walkContext2 = "atrulePrelude";
  var structure3 = {
    children: [[]]
  };
  function parse4(name41) {
    let children = null;
    if (name41 !== null) {
      name41 = name41.toLowerCase();
    }
    this.skipSC();
    if (hasOwnProperty.call(this.atrule, name41) && typeof this.atrule[name41].prelude === "function") {
      children = this.atrule[name41].prelude.call(this);
    } else {
      children = this.readSequence(this.scope.AtrulePrelude);
    }
    this.skipSC();
    if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
      this.error("Semicolon or block is expected");
    }
    return {
      type: "AtrulePrelude",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate4(node) {
    this.children(node);
  }

  // node_modules/css-tree/lib/syntax/node/AttributeSelector.js
  var AttributeSelector_exports = {};
  __export(AttributeSelector_exports, {
    generate: () => generate5,
    name: () => name4,
    parse: () => parse5,
    structure: () => structure4
  });
  var DOLLARSIGN = 36;
  var ASTERISK2 = 42;
  var EQUALSSIGN = 61;
  var CIRCUMFLEXACCENT = 94;
  var VERTICALLINE2 = 124;
  var TILDE = 126;
  function getAttributeName() {
    if (this.eof) {
      this.error("Unexpected end of input");
    }
    const start = this.tokenStart;
    let expectIdent = false;
    let checkColon = true;
    if (this.isDelim(ASTERISK2)) {
      expectIdent = true;
      checkColon = false;
      this.next();
    } else if (!this.isDelim(VERTICALLINE2)) {
      this.eat(Ident);
    }
    if (this.isDelim(VERTICALLINE2)) {
      if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
        this.next();
        this.eat(Ident);
      } else if (expectIdent) {
        this.error("Identifier is expected", this.tokenEnd);
      }
    } else if (expectIdent) {
      this.error("Vertical line is expected");
    }
    if (checkColon && this.tokenType === Colon) {
      this.next();
      this.eat(Ident);
    }
    return {
      type: "Identifier",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function getOperator() {
    const start = this.tokenStart;
    const code2 = this.charCodeAt(start);
    if (code2 !== EQUALSSIGN && // =
    code2 !== TILDE && // ~=
    code2 !== CIRCUMFLEXACCENT && // ^=
    code2 !== DOLLARSIGN && // $=
    code2 !== ASTERISK2 && // *=
    code2 !== VERTICALLINE2) {
      this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
    }
    this.next();
    if (code2 !== EQUALSSIGN) {
      if (!this.isDelim(EQUALSSIGN)) {
        this.error("Equal sign is expected");
      }
      this.next();
    }
    return this.substrToCursor(start);
  }
  var name4 = "AttributeSelector";
  var structure4 = {
    name: "Identifier",
    matcher: [String, null],
    value: ["String", "Identifier", null],
    flags: [String, null]
  };
  function parse5() {
    const start = this.tokenStart;
    let name41;
    let matcher = null;
    let value = null;
    let flags = null;
    this.eat(LeftSquareBracket);
    this.skipSC();
    name41 = getAttributeName.call(this);
    this.skipSC();
    if (this.tokenType !== RightSquareBracket) {
      if (this.tokenType !== Ident) {
        matcher = getOperator.call(this);
        this.skipSC();
        value = this.tokenType === String2 ? this.String() : this.Identifier();
        this.skipSC();
      }
      if (this.tokenType === Ident) {
        flags = this.consume(Ident);
        this.skipSC();
      }
    }
    this.eat(RightSquareBracket);
    return {
      type: "AttributeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name41,
      matcher,
      value,
      flags
    };
  }
  function generate5(node) {
    this.token(Delim, "[");
    this.node(node.name);
    if (node.matcher !== null) {
      this.tokenize(node.matcher);
      this.node(node.value);
    }
    if (node.flags !== null) {
      this.token(Ident, node.flags);
    }
    this.token(Delim, "]");
  }

  // node_modules/css-tree/lib/syntax/node/Block.js
  var Block_exports = {};
  __export(Block_exports, {
    generate: () => generate6,
    name: () => name5,
    parse: () => parse6,
    structure: () => structure5,
    walkContext: () => walkContext3
  });
  function consumeRaw2(startToken) {
    return this.Raw(startToken, null, true);
  }
  function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw2);
  }
  function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
  }
  function consumeDeclaration() {
    if (this.tokenType === Semicolon) {
      return consumeRawDeclaration.call(this, this.tokenIndex);
    }
    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
    if (this.tokenType === Semicolon) {
      this.next();
    }
    return node;
  }
  var name5 = "Block";
  var walkContext3 = "block";
  var structure5 = {
    children: [[
      "Atrule",
      "Rule",
      "Declaration"
    ]]
  };
  function parse6(isDeclaration) {
    const consumer = isDeclaration ? consumeDeclaration : consumeRule;
    const start = this.tokenStart;
    let children = this.createList();
    this.eat(LeftCurlyBracket);
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case RightCurlyBracket:
            break scan;
          case WhiteSpace:
          case Comment:
            this.next();
            break;
          case AtKeyword:
            children.push(this.parseWithFallback(this.Atrule, consumeRaw2));
            break;
          default:
            children.push(consumer.call(this));
        }
      }
    if (!this.eof) {
      this.eat(RightCurlyBracket);
    }
    return {
      type: "Block",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate6(node) {
    this.token(LeftCurlyBracket, "{");
    this.children(node, (prev) => {
      if (prev.type === "Declaration") {
        this.token(Semicolon, ";");
      }
    });
    this.token(RightCurlyBracket, "}");
  }

  // node_modules/css-tree/lib/syntax/node/Brackets.js
  var Brackets_exports = {};
  __export(Brackets_exports, {
    generate: () => generate7,
    name: () => name6,
    parse: () => parse7,
    structure: () => structure6
  });
  var name6 = "Brackets";
  var structure6 = {
    children: [[]]
  };
  function parse7(readSequence3, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(LeftSquareBracket);
    children = readSequence3.call(this, recognizer);
    if (!this.eof) {
      this.eat(RightSquareBracket);
    }
    return {
      type: "Brackets",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate7(node) {
    this.token(Delim, "[");
    this.children(node);
    this.token(Delim, "]");
  }

  // node_modules/css-tree/lib/syntax/node/CDC.js
  var CDC_exports = {};
  __export(CDC_exports, {
    generate: () => generate8,
    name: () => name7,
    parse: () => parse8,
    structure: () => structure7
  });
  var name7 = "CDC";
  var structure7 = [];
  function parse8() {
    const start = this.tokenStart;
    this.eat(CDC);
    return {
      type: "CDC",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate8() {
    this.token(CDC, "-->");
  }

  // node_modules/css-tree/lib/syntax/node/CDO.js
  var CDO_exports = {};
  __export(CDO_exports, {
    generate: () => generate9,
    name: () => name8,
    parse: () => parse9,
    structure: () => structure8
  });
  var name8 = "CDO";
  var structure8 = [];
  function parse9() {
    const start = this.tokenStart;
    this.eat(CDO);
    return {
      type: "CDO",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate9() {
    this.token(CDO, "<!--");
  }

  // node_modules/css-tree/lib/syntax/node/ClassSelector.js
  var ClassSelector_exports = {};
  __export(ClassSelector_exports, {
    generate: () => generate10,
    name: () => name9,
    parse: () => parse10,
    structure: () => structure9
  });
  var FULLSTOP = 46;
  var name9 = "ClassSelector";
  var structure9 = {
    name: String
  };
  function parse10() {
    this.eatDelim(FULLSTOP);
    return {
      type: "ClassSelector",
      loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
      name: this.consume(Ident)
    };
  }
  function generate10(node) {
    this.token(Delim, ".");
    this.token(Ident, node.name);
  }

  // node_modules/css-tree/lib/syntax/node/Combinator.js
  var Combinator_exports = {};
  __export(Combinator_exports, {
    generate: () => generate11,
    name: () => name10,
    parse: () => parse11,
    structure: () => structure10
  });
  var PLUSSIGN6 = 43;
  var SOLIDUS = 47;
  var GREATERTHANSIGN2 = 62;
  var TILDE2 = 126;
  var name10 = "Combinator";
  var structure10 = {
    name: String
  };
  function parse11() {
    const start = this.tokenStart;
    let name41;
    switch (this.tokenType) {
      case WhiteSpace:
        name41 = " ";
        break;
      case Delim:
        switch (this.charCodeAt(this.tokenStart)) {
          case GREATERTHANSIGN2:
          case PLUSSIGN6:
          case TILDE2:
            this.next();
            break;
          case SOLIDUS:
            this.next();
            this.eatIdent("deep");
            this.eatDelim(SOLIDUS);
            break;
          default:
            this.error("Combinator is expected");
        }
        name41 = this.substrToCursor(start);
        break;
    }
    return {
      type: "Combinator",
      loc: this.getLocation(start, this.tokenStart),
      name: name41
    };
  }
  function generate11(node) {
    this.tokenize(node.name);
  }

  // node_modules/css-tree/lib/syntax/node/Comment.js
  var Comment_exports = {};
  __export(Comment_exports, {
    generate: () => generate12,
    name: () => name11,
    parse: () => parse12,
    structure: () => structure11
  });
  var ASTERISK3 = 42;
  var SOLIDUS2 = 47;
  var name11 = "Comment";
  var structure11 = {
    value: String
  };
  function parse12() {
    const start = this.tokenStart;
    let end = this.tokenEnd;
    this.eat(Comment);
    if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK3 && this.charCodeAt(end - 1) === SOLIDUS2) {
      end -= 2;
    }
    return {
      type: "Comment",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substring(start + 2, end)
    };
  }
  function generate12(node) {
    this.token(Comment, "/*" + node.value + "*/");
  }

  // node_modules/css-tree/lib/syntax/node/Declaration.js
  var Declaration_exports = {};
  __export(Declaration_exports, {
    generate: () => generate13,
    name: () => name12,
    parse: () => parse13,
    structure: () => structure12,
    walkContext: () => walkContext4
  });
  var EXCLAMATIONMARK3 = 33;
  var NUMBERSIGN3 = 35;
  var DOLLARSIGN2 = 36;
  var AMPERSAND2 = 38;
  var ASTERISK4 = 42;
  var PLUSSIGN7 = 43;
  var SOLIDUS3 = 47;
  function consumeValueRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
  }
  function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
  }
  function consumeValue() {
    const startValueToken = this.tokenIndex;
    const value = this.Value();
    if (value.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK3) === false && this.isBalanceEdge(startValueToken) === false) {
      this.error();
    }
    return value;
  }
  var name12 = "Declaration";
  var walkContext4 = "declaration";
  var structure12 = {
    important: [Boolean, String],
    property: String,
    value: ["Value", "Raw"]
  };
  function parse13() {
    const start = this.tokenStart;
    const startToken = this.tokenIndex;
    const property2 = readProperty2.call(this);
    const customProperty = isCustomProperty(property2);
    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    const consumeRaw7 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    let important = false;
    let value;
    this.skipSC();
    this.eat(Colon);
    const valueStart = this.tokenIndex;
    if (!customProperty) {
      this.skipSC();
    }
    if (parseValue) {
      value = this.parseWithFallback(consumeValue, consumeRaw7);
    } else {
      value = consumeRaw7.call(this, this.tokenIndex);
    }
    if (customProperty && value.type === "Value" && value.children.isEmpty) {
      for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
        if (this.lookupType(offset) === WhiteSpace) {
          value.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    if (this.isDelim(EXCLAMATIONMARK3)) {
      important = getImportant.call(this);
      this.skipSC();
    }
    if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false) {
      this.error();
    }
    return {
      type: "Declaration",
      loc: this.getLocation(start, this.tokenStart),
      important,
      property: property2,
      value
    };
  }
  function generate13(node) {
    this.token(Ident, node.property);
    this.token(Colon, ":");
    this.node(node.value);
    if (node.important) {
      this.token(Delim, "!");
      this.token(Ident, node.important === true ? "important" : node.important);
    }
  }
  function readProperty2() {
    const start = this.tokenStart;
    if (this.tokenType === Delim) {
      switch (this.charCodeAt(this.tokenStart)) {
        case ASTERISK4:
        case DOLLARSIGN2:
        case PLUSSIGN7:
        case NUMBERSIGN3:
        case AMPERSAND2:
          this.next();
          break;
        case SOLIDUS3:
          this.next();
          if (this.isDelim(SOLIDUS3)) {
            this.next();
          }
          break;
      }
    }
    if (this.tokenType === Hash) {
      this.eat(Hash);
    } else {
      this.eat(Ident);
    }
    return this.substrToCursor(start);
  }
  function getImportant() {
    this.eat(Delim);
    this.skipSC();
    const important = this.consume(Ident);
    return important === "important" ? true : important;
  }

  // node_modules/css-tree/lib/syntax/node/DeclarationList.js
  var DeclarationList_exports = {};
  __export(DeclarationList_exports, {
    generate: () => generate14,
    name: () => name13,
    parse: () => parse14,
    structure: () => structure13
  });
  function consumeRaw3(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
  }
  var name13 = "DeclarationList";
  var structure13 = {
    children: [[
      "Declaration"
    ]]
  };
  function parse14() {
    const children = this.createList();
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case WhiteSpace:
          case Comment:
          case Semicolon:
            this.next();
            break;
          default:
            children.push(this.parseWithFallback(this.Declaration, consumeRaw3));
        }
      }
    return {
      type: "DeclarationList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate14(node) {
    this.children(node, (prev) => {
      if (prev.type === "Declaration") {
        this.token(Semicolon, ";");
      }
    });
  }

  // node_modules/css-tree/lib/syntax/node/Dimension.js
  var Dimension_exports = {};
  __export(Dimension_exports, {
    generate: () => generate15,
    name: () => name14,
    parse: () => parse15,
    structure: () => structure14
  });
  var name14 = "Dimension";
  var structure14 = {
    value: String,
    unit: String
  };
  function parse15() {
    const start = this.tokenStart;
    const value = this.consumeNumber(Dimension);
    return {
      type: "Dimension",
      loc: this.getLocation(start, this.tokenStart),
      value,
      unit: this.substring(start + value.length, this.tokenStart)
    };
  }
  function generate15(node) {
    this.token(Dimension, node.value + node.unit);
  }

  // node_modules/css-tree/lib/syntax/node/Function.js
  var Function_exports = {};
  __export(Function_exports, {
    generate: () => generate16,
    name: () => name15,
    parse: () => parse16,
    structure: () => structure15,
    walkContext: () => walkContext5
  });
  var name15 = "Function";
  var walkContext5 = "function";
  var structure15 = {
    name: String,
    children: [[]]
  };
  function parse16(readSequence3, recognizer) {
    const start = this.tokenStart;
    const name41 = this.consumeFunctionName();
    const nameLowerCase = name41.toLowerCase();
    let children;
    children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence3.call(this, recognizer);
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "Function",
      loc: this.getLocation(start, this.tokenStart),
      name: name41,
      children
    };
  }
  function generate16(node) {
    this.token(Function2, node.name + "(");
    this.children(node);
    this.token(RightParenthesis, ")");
  }

  // node_modules/css-tree/lib/syntax/node/Hash.js
  var Hash_exports = {};
  __export(Hash_exports, {
    generate: () => generate17,
    name: () => name16,
    parse: () => parse17,
    structure: () => structure16,
    xxx: () => xxx
  });
  var xxx = "XXX";
  var name16 = "Hash";
  var structure16 = {
    value: String
  };
  function parse17() {
    const start = this.tokenStart;
    this.eat(Hash);
    return {
      type: "Hash",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start + 1)
    };
  }
  function generate17(node) {
    this.token(Hash, "#" + node.value);
  }

  // node_modules/css-tree/lib/syntax/node/Identifier.js
  var Identifier_exports = {};
  __export(Identifier_exports, {
    generate: () => generate18,
    name: () => name17,
    parse: () => parse18,
    structure: () => structure17
  });
  var name17 = "Identifier";
  var structure17 = {
    name: String
  };
  function parse18() {
    return {
      type: "Identifier",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      name: this.consume(Ident)
    };
  }
  function generate18(node) {
    this.token(Ident, node.name);
  }

  // node_modules/css-tree/lib/syntax/node/IdSelector.js
  var IdSelector_exports = {};
  __export(IdSelector_exports, {
    generate: () => generate19,
    name: () => name18,
    parse: () => parse19,
    structure: () => structure18
  });
  var name18 = "IdSelector";
  var structure18 = {
    name: String
  };
  function parse19() {
    const start = this.tokenStart;
    this.eat(Hash);
    return {
      type: "IdSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start + 1)
    };
  }
  function generate19(node) {
    this.token(Hash, "#" + node.name);
  }

  // node_modules/css-tree/lib/syntax/node/MediaFeature.js
  var MediaFeature_exports = {};
  __export(MediaFeature_exports, {
    generate: () => generate20,
    name: () => name19,
    parse: () => parse20,
    structure: () => structure19
  });
  var name19 = "MediaFeature";
  var structure19 = {
    name: String,
    value: ["Identifier", "Number", "Dimension", "Ratio", null]
  };
  function parse20() {
    const start = this.tokenStart;
    let name41;
    let value = null;
    this.eat(LeftParenthesis);
    this.skipSC();
    name41 = this.consume(Ident);
    this.skipSC();
    if (this.tokenType !== RightParenthesis) {
      this.eat(Colon);
      this.skipSC();
      switch (this.tokenType) {
        case Number2:
          if (this.lookupNonWSType(1) === Delim) {
            value = this.Ratio();
          } else {
            value = this.Number();
          }
          break;
        case Dimension:
          value = this.Dimension();
          break;
        case Ident:
          value = this.Identifier();
          break;
        default:
          this.error("Number, dimension, ratio or identifier is expected");
      }
      this.skipSC();
    }
    this.eat(RightParenthesis);
    return {
      type: "MediaFeature",
      loc: this.getLocation(start, this.tokenStart),
      name: name41,
      value
    };
  }
  function generate20(node) {
    this.token(LeftParenthesis, "(");
    this.token(Ident, node.name);
    if (node.value !== null) {
      this.token(Colon, ":");
      this.node(node.value);
    }
    this.token(RightParenthesis, ")");
  }

  // node_modules/css-tree/lib/syntax/node/MediaQuery.js
  var MediaQuery_exports = {};
  __export(MediaQuery_exports, {
    generate: () => generate21,
    name: () => name20,
    parse: () => parse21,
    structure: () => structure20
  });
  var name20 = "MediaQuery";
  var structure20 = {
    children: [[
      "Identifier",
      "MediaFeature",
      "WhiteSpace"
    ]]
  };
  function parse21() {
    const children = this.createList();
    let child = null;
    this.skipSC();
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case Comment:
          case WhiteSpace:
            this.next();
            continue;
          case Ident:
            child = this.Identifier();
            break;
          case LeftParenthesis:
            child = this.MediaFeature();
            break;
          default:
            break scan;
        }
        children.push(child);
      }
    if (child === null) {
      this.error("Identifier or parenthesis is expected");
    }
    return {
      type: "MediaQuery",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate21(node) {
    this.children(node);
  }

  // node_modules/css-tree/lib/syntax/node/MediaQueryList.js
  var MediaQueryList_exports = {};
  __export(MediaQueryList_exports, {
    generate: () => generate22,
    name: () => name21,
    parse: () => parse22,
    structure: () => structure21
  });
  var name21 = "MediaQueryList";
  var structure21 = {
    children: [[
      "MediaQuery"
    ]]
  };
  function parse22() {
    const children = this.createList();
    this.skipSC();
    while (!this.eof) {
      children.push(this.MediaQuery());
      if (this.tokenType !== Comma) {
        break;
      }
      this.next();
    }
    return {
      type: "MediaQueryList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate22(node) {
    this.children(node, () => this.token(Comma, ","));
  }

  // node_modules/css-tree/lib/syntax/node/Nth.js
  var Nth_exports = {};
  __export(Nth_exports, {
    generate: () => generate23,
    name: () => name22,
    parse: () => parse23,
    structure: () => structure22
  });
  var name22 = "Nth";
  var structure22 = {
    nth: ["AnPlusB", "Identifier"],
    selector: ["SelectorList", null]
  };
  function parse23() {
    this.skipSC();
    const start = this.tokenStart;
    let end = start;
    let selector2 = null;
    let nth2;
    if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
      nth2 = this.Identifier();
    } else {
      nth2 = this.AnPlusB();
    }
    end = this.tokenStart;
    this.skipSC();
    if (this.lookupValue(0, "of")) {
      this.next();
      selector2 = this.SelectorList();
      end = this.tokenStart;
    }
    return {
      type: "Nth",
      loc: this.getLocation(start, end),
      nth: nth2,
      selector: selector2
    };
  }
  function generate23(node) {
    this.node(node.nth);
    if (node.selector !== null) {
      this.token(Ident, "of");
      this.node(node.selector);
    }
  }

  // node_modules/css-tree/lib/syntax/node/Number.js
  var Number_exports = {};
  __export(Number_exports, {
    generate: () => generate24,
    name: () => name23,
    parse: () => parse24,
    structure: () => structure23
  });
  var name23 = "Number";
  var structure23 = {
    value: String
  };
  function parse24() {
    return {
      type: "Number",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consume(Number2)
    };
  }
  function generate24(node) {
    this.token(Number2, node.value);
  }

  // node_modules/css-tree/lib/syntax/node/Operator.js
  var Operator_exports = {};
  __export(Operator_exports, {
    generate: () => generate25,
    name: () => name24,
    parse: () => parse25,
    structure: () => structure24
  });
  var name24 = "Operator";
  var structure24 = {
    value: String
  };
  function parse25() {
    const start = this.tokenStart;
    this.next();
    return {
      type: "Operator",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function generate25(node) {
    this.tokenize(node.value);
  }

  // node_modules/css-tree/lib/syntax/node/Parentheses.js
  var Parentheses_exports = {};
  __export(Parentheses_exports, {
    generate: () => generate26,
    name: () => name25,
    parse: () => parse26,
    structure: () => structure25
  });
  var name25 = "Parentheses";
  var structure25 = {
    children: [[]]
  };
  function parse26(readSequence3, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(LeftParenthesis);
    children = readSequence3.call(this, recognizer);
    if (!this.eof) {
      this.eat(RightParenthesis);
    }
    return {
      type: "Parentheses",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate26(node) {
    this.token(LeftParenthesis, "(");
    this.children(node);
    this.token(RightParenthesis, ")");
  }

  // node_modules/css-tree/lib/syntax/node/Percentage.js
  var Percentage_exports = {};
  __export(Percentage_exports, {
    generate: () => generate27,
    name: () => name26,
    parse: () => parse27,
    structure: () => structure26
  });
  var name26 = "Percentage";
  var structure26 = {
    value: String
  };
  function parse27() {
    return {
      type: "Percentage",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consumeNumber(Percentage)
    };
  }
  function generate27(node) {
    this.token(Percentage, node.value + "%");
  }

  // node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js
  var PseudoClassSelector_exports = {};
  __export(PseudoClassSelector_exports, {
    generate: () => generate28,
    name: () => name27,
    parse: () => parse28,
    structure: () => structure27,
    walkContext: () => walkContext6
  });
  var name27 = "PseudoClassSelector";
  var walkContext6 = "function";
  var structure27 = {
    name: String,
    children: [["Raw"], null]
  };
  function parse28() {
    const start = this.tokenStart;
    let children = null;
    let name41;
    let nameLowerCase;
    this.eat(Colon);
    if (this.tokenType === Function2) {
      name41 = this.consumeFunctionName();
      nameLowerCase = name41.toLowerCase();
      if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(
          this.Raw(this.tokenIndex, null, false)
        );
      }
      this.eat(RightParenthesis);
    } else {
      name41 = this.consume(Ident);
    }
    return {
      type: "PseudoClassSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name41,
      children
    };
  }
  function generate28(node) {
    this.token(Colon, ":");
    if (node.children === null) {
      this.token(Ident, node.name);
    } else {
      this.token(Function2, node.name + "(");
      this.children(node);
      this.token(RightParenthesis, ")");
    }
  }

  // node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js
  var PseudoElementSelector_exports = {};
  __export(PseudoElementSelector_exports, {
    generate: () => generate29,
    name: () => name28,
    parse: () => parse29,
    structure: () => structure28,
    walkContext: () => walkContext7
  });
  var name28 = "PseudoElementSelector";
  var walkContext7 = "function";
  var structure28 = {
    name: String,
    children: [["Raw"], null]
  };
  function parse29() {
    const start = this.tokenStart;
    let children = null;
    let name41;
    let nameLowerCase;
    this.eat(Colon);
    this.eat(Colon);
    if (this.tokenType === Function2) {
      name41 = this.consumeFunctionName();
      nameLowerCase = name41.toLowerCase();
      if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(
          this.Raw(this.tokenIndex, null, false)
        );
      }
      this.eat(RightParenthesis);
    } else {
      name41 = this.consume(Ident);
    }
    return {
      type: "PseudoElementSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name41,
      children
    };
  }
  function generate29(node) {
    this.token(Colon, ":");
    this.token(Colon, ":");
    if (node.children === null) {
      this.token(Ident, node.name);
    } else {
      this.token(Function2, node.name + "(");
      this.children(node);
      this.token(RightParenthesis, ")");
    }
  }

  // node_modules/css-tree/lib/syntax/node/Ratio.js
  var Ratio_exports = {};
  __export(Ratio_exports, {
    generate: () => generate30,
    name: () => name29,
    parse: () => parse30,
    structure: () => structure29
  });
  var SOLIDUS4 = 47;
  var FULLSTOP2 = 46;
  function consumeNumber2() {
    this.skipSC();
    const value = this.consume(Number2);
    for (let i = 0; i < value.length; i++) {
      const code2 = value.charCodeAt(i);
      if (!isDigit(code2) && code2 !== FULLSTOP2) {
        this.error("Unsigned number is expected", this.tokenStart - value.length + i);
      }
    }
    if (Number(value) === 0) {
      this.error("Zero number is not allowed", this.tokenStart - value.length);
    }
    return value;
  }
  var name29 = "Ratio";
  var structure29 = {
    left: String,
    right: String
  };
  function parse30() {
    const start = this.tokenStart;
    const left = consumeNumber2.call(this);
    let right;
    this.skipSC();
    this.eatDelim(SOLIDUS4);
    right = consumeNumber2.call(this);
    return {
      type: "Ratio",
      loc: this.getLocation(start, this.tokenStart),
      left,
      right
    };
  }
  function generate30(node) {
    this.token(Number2, node.left);
    this.token(Delim, "/");
    this.token(Number2, node.right);
  }

  // node_modules/css-tree/lib/syntax/node/Raw.js
  var Raw_exports = {};
  __export(Raw_exports, {
    generate: () => generate31,
    name: () => name30,
    parse: () => parse31,
    structure: () => structure30
  });
  function getOffsetExcludeWS() {
    if (this.tokenIndex > 0) {
      if (this.lookupType(-1) === WhiteSpace) {
        return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
      }
    }
    return this.tokenStart;
  }
  var name30 = "Raw";
  var structure30 = {
    value: String
  };
  function parse31(startToken, consumeUntil, excludeWhiteSpace) {
    const startOffset = this.getTokenStart(startToken);
    let endOffset;
    this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);
    if (excludeWhiteSpace && this.tokenStart > startOffset) {
      endOffset = getOffsetExcludeWS.call(this);
    } else {
      endOffset = this.tokenStart;
    }
    return {
      type: "Raw",
      loc: this.getLocation(startOffset, endOffset),
      value: this.substring(startOffset, endOffset)
    };
  }
  function generate31(node) {
    this.tokenize(node.value);
  }

  // node_modules/css-tree/lib/syntax/node/Rule.js
  var Rule_exports = {};
  __export(Rule_exports, {
    generate: () => generate32,
    name: () => name31,
    parse: () => parse32,
    structure: () => structure31,
    walkContext: () => walkContext8
  });
  function consumeRaw4(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
  }
  function consumePrelude() {
    const prelude = this.SelectorList();
    if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket) {
      this.error();
    }
    return prelude;
  }
  var name31 = "Rule";
  var walkContext8 = "rule";
  var structure31 = {
    prelude: ["SelectorList", "Raw"],
    block: ["Block"]
  };
  function parse32() {
    const startToken = this.tokenIndex;
    const startOffset = this.tokenStart;
    let prelude;
    let block;
    if (this.parseRulePrelude) {
      prelude = this.parseWithFallback(consumePrelude, consumeRaw4);
    } else {
      prelude = consumeRaw4.call(this, startToken);
    }
    block = this.Block(true);
    return {
      type: "Rule",
      loc: this.getLocation(startOffset, this.tokenStart),
      prelude,
      block
    };
  }
  function generate32(node) {
    this.node(node.prelude);
    this.node(node.block);
  }

  // node_modules/css-tree/lib/syntax/node/Selector.js
  var Selector_exports = {};
  __export(Selector_exports, {
    generate: () => generate33,
    name: () => name32,
    parse: () => parse33,
    structure: () => structure32
  });
  var name32 = "Selector";
  var structure32 = {
    children: [[
      "TypeSelector",
      "IdSelector",
      "ClassSelector",
      "AttributeSelector",
      "PseudoClassSelector",
      "PseudoElementSelector",
      "Combinator",
      "WhiteSpace"
    ]]
  };
  function parse33() {
    const children = this.readSequence(this.scope.Selector);
    if (this.getFirstListNode(children) === null) {
      this.error("Selector is expected");
    }
    return {
      type: "Selector",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate33(node) {
    this.children(node);
  }

  // node_modules/css-tree/lib/syntax/node/SelectorList.js
  var SelectorList_exports = {};
  __export(SelectorList_exports, {
    generate: () => generate34,
    name: () => name33,
    parse: () => parse34,
    structure: () => structure33,
    walkContext: () => walkContext9
  });
  var name33 = "SelectorList";
  var walkContext9 = "selector";
  var structure33 = {
    children: [[
      "Selector",
      "Raw"
    ]]
  };
  function parse34() {
    const children = this.createList();
    while (!this.eof) {
      children.push(this.Selector());
      if (this.tokenType === Comma) {
        this.next();
        continue;
      }
      break;
    }
    return {
      type: "SelectorList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate34(node) {
    this.children(node, () => this.token(Comma, ","));
  }

  // node_modules/css-tree/lib/syntax/node/String.js
  var String_exports = {};
  __export(String_exports, {
    generate: () => generate35,
    name: () => name34,
    parse: () => parse35,
    structure: () => structure34
  });

  // node_modules/css-tree/lib/utils/string.js
  var REVERSE_SOLIDUS = 92;
  var QUOTATION_MARK = 34;
  var APOSTROPHE2 = 39;
  function decode(str) {
    const len = str.length;
    const firstChar = str.charCodeAt(0);
    const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE2 ? 1 : 0;
    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
    let decoded = "";
    for (let i = start; i <= end; i++) {
      let code2 = str.charCodeAt(i);
      if (code2 === REVERSE_SOLIDUS) {
        if (i === end) {
          if (i !== len - 1) {
            decoded = str.substr(i + 1);
          }
          break;
        }
        code2 = str.charCodeAt(++i);
        if (isValidEscape(REVERSE_SOLIDUS, code2)) {
          const escapeStart = i - 1;
          const escapeEnd = consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }
    return decoded;
  }
  function encode(str, apostrophe) {
    const quote = apostrophe ? "'" : '"';
    const quoteCode = apostrophe ? APOSTROPHE2 : QUOTATION_MARK;
    let encoded = "";
    let wsBeforeHexIsNeeded = false;
    for (let i = 0; i < str.length; i++) {
      const code2 = str.charCodeAt(i);
      if (code2 === 0) {
        encoded += "\uFFFD";
        continue;
      }
      if (code2 <= 31 || code2 === 127) {
        encoded += "\\" + code2.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }
      if (code2 === quoteCode || code2 === REVERSE_SOLIDUS) {
        encoded += "\\" + str.charAt(i);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && (isHexDigit(code2) || isWhiteSpace(code2))) {
          encoded += " ";
        }
        encoded += str.charAt(i);
        wsBeforeHexIsNeeded = false;
      }
    }
    return quote + encoded + quote;
  }

  // node_modules/css-tree/lib/syntax/node/String.js
  var name34 = "String";
  var structure34 = {
    value: String
  };
  function parse35() {
    return {
      type: "String",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: decode(this.consume(String2))
    };
  }
  function generate35(node) {
    this.token(String2, encode(node.value));
  }

  // node_modules/css-tree/lib/syntax/node/StyleSheet.js
  var StyleSheet_exports = {};
  __export(StyleSheet_exports, {
    generate: () => generate36,
    name: () => name35,
    parse: () => parse36,
    structure: () => structure35,
    walkContext: () => walkContext10
  });
  var EXCLAMATIONMARK4 = 33;
  function consumeRaw5(startToken) {
    return this.Raw(startToken, null, false);
  }
  var name35 = "StyleSheet";
  var walkContext10 = "stylesheet";
  var structure35 = {
    children: [[
      "Comment",
      "CDO",
      "CDC",
      "Atrule",
      "Rule",
      "Raw"
    ]]
  };
  function parse36() {
    const start = this.tokenStart;
    const children = this.createList();
    let child;
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case WhiteSpace:
            this.next();
            continue;
          case Comment:
            if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK4) {
              this.next();
              continue;
            }
            child = this.Comment();
            break;
          case CDO:
            child = this.CDO();
            break;
          case CDC:
            child = this.CDC();
            break;
          case AtKeyword:
            child = this.parseWithFallback(this.Atrule, consumeRaw5);
            break;
          default:
            child = this.parseWithFallback(this.Rule, consumeRaw5);
        }
        children.push(child);
      }
    return {
      type: "StyleSheet",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate36(node) {
    this.children(node);
  }

  // node_modules/css-tree/lib/syntax/node/TypeSelector.js
  var TypeSelector_exports = {};
  __export(TypeSelector_exports, {
    generate: () => generate37,
    name: () => name36,
    parse: () => parse37,
    structure: () => structure36
  });
  var ASTERISK5 = 42;
  var VERTICALLINE3 = 124;
  function eatIdentifierOrAsterisk() {
    if (this.tokenType !== Ident && this.isDelim(ASTERISK5) === false) {
      this.error("Identifier or asterisk is expected");
    }
    this.next();
  }
  var name36 = "TypeSelector";
  var structure36 = {
    name: String
  };
  function parse37() {
    const start = this.tokenStart;
    if (this.isDelim(VERTICALLINE3)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    } else {
      eatIdentifierOrAsterisk.call(this);
      if (this.isDelim(VERTICALLINE3)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
      }
    }
    return {
      type: "TypeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function generate37(node) {
    this.tokenize(node.name);
  }

  // node_modules/css-tree/lib/syntax/node/UnicodeRange.js
  var UnicodeRange_exports = {};
  __export(UnicodeRange_exports, {
    generate: () => generate38,
    name: () => name37,
    parse: () => parse38,
    structure: () => structure37
  });
  var PLUSSIGN8 = 43;
  var HYPHENMINUS6 = 45;
  var QUESTIONMARK3 = 63;
  function eatHexSequence(offset, allowDash) {
    let len = 0;
    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
      const code2 = this.charCodeAt(pos);
      if (code2 === HYPHENMINUS6 && allowDash && len !== 0) {
        eatHexSequence.call(this, offset + len + 1, false);
        return -1;
      }
      if (!isHexDigit(code2)) {
        this.error(
          allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
          pos
        );
      }
      if (++len > 6) {
        this.error("Too many hex digits", pos);
      }
      ;
    }
    this.next();
    return len;
  }
  function eatQuestionMarkSequence(max) {
    let count = 0;
    while (this.isDelim(QUESTIONMARK3)) {
      if (++count > max) {
        this.error("Too many question marks");
      }
      this.next();
    }
  }
  function startsWith2(code2) {
    if (this.charCodeAt(this.tokenStart) !== code2) {
      this.error((code2 === PLUSSIGN8 ? "Plus sign" : "Hyphen minus") + " is expected");
    }
  }
  function scanUnicodeRange() {
    let hexLength = 0;
    switch (this.tokenType) {
      case Number2:
        hexLength = eatHexSequence.call(this, 1, true);
        if (this.isDelim(QUESTIONMARK3)) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
          break;
        }
        if (this.tokenType === Dimension || this.tokenType === Number2) {
          startsWith2.call(this, HYPHENMINUS6);
          eatHexSequence.call(this, 1, false);
          break;
        }
        break;
      case Dimension:
        hexLength = eatHexSequence.call(this, 1, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      default:
        this.eatDelim(PLUSSIGN8);
        if (this.tokenType === Ident) {
          hexLength = eatHexSequence.call(this, 0, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          break;
        }
        if (this.isDelim(QUESTIONMARK3)) {
          this.next();
          eatQuestionMarkSequence.call(this, 5);
          break;
        }
        this.error("Hex digit or question mark is expected");
    }
  }
  var name37 = "UnicodeRange";
  var structure37 = {
    value: String
  };
  function parse38() {
    const start = this.tokenStart;
    this.eatIdent("u");
    scanUnicodeRange.call(this);
    return {
      type: "UnicodeRange",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function generate38(node) {
    this.tokenize(node.value);
  }

  // node_modules/css-tree/lib/syntax/node/Url.js
  var Url_exports = {};
  __export(Url_exports, {
    generate: () => generate39,
    name: () => name38,
    parse: () => parse39,
    structure: () => structure38
  });

  // node_modules/css-tree/lib/utils/url.js
  var SPACE3 = 32;
  var REVERSE_SOLIDUS2 = 92;
  var QUOTATION_MARK2 = 34;
  var APOSTROPHE3 = 39;
  var LEFTPARENTHESIS3 = 40;
  var RIGHTPARENTHESIS3 = 41;
  function decode2(str) {
    const len = str.length;
    let start = 4;
    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS3 ? len - 2 : len - 1;
    let decoded = "";
    while (start < end && isWhiteSpace(str.charCodeAt(start))) {
      start++;
    }
    while (start < end && isWhiteSpace(str.charCodeAt(end))) {
      end--;
    }
    for (let i = start; i <= end; i++) {
      let code2 = str.charCodeAt(i);
      if (code2 === REVERSE_SOLIDUS2) {
        if (i === end) {
          if (i !== len - 1) {
            decoded = str.substr(i + 1);
          }
          break;
        }
        code2 = str.charCodeAt(++i);
        if (isValidEscape(REVERSE_SOLIDUS2, code2)) {
          const escapeStart = i - 1;
          const escapeEnd = consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }
    return decoded;
  }
  function encode2(str) {
    let encoded = "";
    let wsBeforeHexIsNeeded = false;
    for (let i = 0; i < str.length; i++) {
      const code2 = str.charCodeAt(i);
      if (code2 === 0) {
        encoded += "\uFFFD";
        continue;
      }
      if (code2 <= 31 || code2 === 127) {
        encoded += "\\" + code2.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }
      if (code2 === SPACE3 || code2 === REVERSE_SOLIDUS2 || code2 === QUOTATION_MARK2 || code2 === APOSTROPHE3 || code2 === LEFTPARENTHESIS3 || code2 === RIGHTPARENTHESIS3) {
        encoded += "\\" + str.charAt(i);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && isHexDigit(code2)) {
          encoded += " ";
        }
        encoded += str.charAt(i);
        wsBeforeHexIsNeeded = false;
      }
    }
    return "url(" + encoded + ")";
  }

  // node_modules/css-tree/lib/syntax/node/Url.js
  var name38 = "Url";
  var structure38 = {
    value: String
  };
  function parse39() {
    const start = this.tokenStart;
    let value;
    switch (this.tokenType) {
      case Url:
        value = decode2(this.consume(Url));
        break;
      case Function2:
        if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
          this.error("Function name must be `url`");
        }
        this.eat(Function2);
        this.skipSC();
        value = decode(this.consume(String2));
        this.skipSC();
        if (!this.eof) {
          this.eat(RightParenthesis);
        }
        break;
      default:
        this.error("Url or Function is expected");
    }
    return {
      type: "Url",
      loc: this.getLocation(start, this.tokenStart),
      value
    };
  }
  function generate39(node) {
    this.token(Url, encode2(node.value));
  }

  // node_modules/css-tree/lib/syntax/node/Value.js
  var Value_exports = {};
  __export(Value_exports, {
    generate: () => generate40,
    name: () => name39,
    parse: () => parse40,
    structure: () => structure39
  });
  var name39 = "Value";
  var structure39 = {
    children: [[]]
  };
  function parse40() {
    const start = this.tokenStart;
    const children = this.readSequence(this.scope.Value);
    return {
      type: "Value",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate40(node) {
    this.children(node);
  }

  // node_modules/css-tree/lib/syntax/node/WhiteSpace.js
  var WhiteSpace_exports = {};
  __export(WhiteSpace_exports, {
    generate: () => generate41,
    name: () => name40,
    parse: () => parse41,
    structure: () => structure40
  });
  var SPACE4 = Object.freeze({
    type: "WhiteSpace",
    loc: null,
    value: " "
  });
  var name40 = "WhiteSpace";
  var structure40 = {
    value: String
  };
  function parse41() {
    this.eat(WhiteSpace);
    return SPACE4;
  }
  function generate41(node) {
    this.token(WhiteSpace, node.value);
  }

  // node_modules/css-tree/lib/syntax/config/lexer.js
  var lexer_default = {
    generic: true,
    ...data_default,
    node: node_exports
  };

  // node_modules/css-tree/lib/syntax/scope/index.js
  var scope_exports = {};
  __export(scope_exports, {
    AtrulePrelude: () => atrulePrelude_default,
    Selector: () => selector_default,
    Value: () => value_default
  });

  // node_modules/css-tree/lib/syntax/scope/default.js
  var NUMBERSIGN4 = 35;
  var ASTERISK6 = 42;
  var PLUSSIGN9 = 43;
  var HYPHENMINUS7 = 45;
  var SOLIDUS5 = 47;
  var U2 = 117;
  function defaultRecognizer(context) {
    switch (this.tokenType) {
      case Hash:
        return this.Hash();
      case Comma:
        return this.Operator();
      case LeftParenthesis:
        return this.Parentheses(this.readSequence, context.recognizer);
      case LeftSquareBracket:
        return this.Brackets(this.readSequence, context.recognizer);
      case String2:
        return this.String();
      case Dimension:
        return this.Dimension();
      case Percentage:
        return this.Percentage();
      case Number2:
        return this.Number();
      case Function2:
        return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
      case Url:
        return this.Url();
      case Ident:
        if (this.cmpChar(this.tokenStart, U2) && this.cmpChar(this.tokenStart + 1, PLUSSIGN9)) {
          return this.UnicodeRange();
        } else {
          return this.Identifier();
        }
      case Delim: {
        const code2 = this.charCodeAt(this.tokenStart);
        if (code2 === SOLIDUS5 || code2 === ASTERISK6 || code2 === PLUSSIGN9 || code2 === HYPHENMINUS7) {
          return this.Operator();
        }
        if (code2 === NUMBERSIGN4) {
          this.error("Hex or identifier is expected", this.tokenStart + 1);
        }
        break;
      }
    }
  }

  // node_modules/css-tree/lib/syntax/scope/atrulePrelude.js
  var atrulePrelude_default = {
    getNode: defaultRecognizer
  };

  // node_modules/css-tree/lib/syntax/scope/selector.js
  var NUMBERSIGN5 = 35;
  var ASTERISK7 = 42;
  var PLUSSIGN10 = 43;
  var SOLIDUS6 = 47;
  var FULLSTOP3 = 46;
  var GREATERTHANSIGN3 = 62;
  var VERTICALLINE4 = 124;
  var TILDE3 = 126;
  function onWhiteSpace(next, children) {
    if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
      children.push({
        // FIXME: this.Combinator() should be used instead
        type: "Combinator",
        loc: null,
        name: " "
      });
    }
  }
  function getNode() {
    switch (this.tokenType) {
      case LeftSquareBracket:
        return this.AttributeSelector();
      case Hash:
        return this.IdSelector();
      case Colon:
        if (this.lookupType(1) === Colon) {
          return this.PseudoElementSelector();
        } else {
          return this.PseudoClassSelector();
        }
      case Ident:
        return this.TypeSelector();
      case Number2:
      case Percentage:
        return this.Percentage();
      case Dimension:
        if (this.charCodeAt(this.tokenStart) === FULLSTOP3) {
          this.error("Identifier is expected", this.tokenStart + 1);
        }
        break;
      case Delim: {
        const code2 = this.charCodeAt(this.tokenStart);
        switch (code2) {
          case PLUSSIGN10:
          case GREATERTHANSIGN3:
          case TILDE3:
          case SOLIDUS6:
            return this.Combinator();
          case FULLSTOP3:
            return this.ClassSelector();
          case ASTERISK7:
          case VERTICALLINE4:
            return this.TypeSelector();
          case NUMBERSIGN5:
            return this.IdSelector();
        }
        break;
      }
    }
  }
  var selector_default = {
    onWhiteSpace,
    getNode
  };

  // node_modules/css-tree/lib/syntax/function/expression.js
  function expression_default() {
    return this.createSingleNodeList(
      this.Raw(this.tokenIndex, null, false)
    );
  }

  // node_modules/css-tree/lib/syntax/function/var.js
  function var_default() {
    const children = this.createList();
    this.skipSC();
    children.push(this.Identifier());
    this.skipSC();
    if (this.tokenType === Comma) {
      children.push(this.Operator());
      const startIndex = this.tokenIndex;
      const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
      if (value.type === "Value" && value.children.isEmpty) {
        for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
          if (this.lookupType(offset) === WhiteSpace) {
            value.children.appendData({
              type: "WhiteSpace",
              loc: null,
              value: " "
            });
            break;
          }
        }
      }
      children.push(value);
    }
    return children;
  }

  // node_modules/css-tree/lib/syntax/scope/value.js
  function isPlusMinusOperator(node) {
    return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
  }
  var value_default = {
    getNode: defaultRecognizer,
    onWhiteSpace: function(next, children) {
      if (isPlusMinusOperator(next)) {
        next.value = " " + next.value;
      }
      if (isPlusMinusOperator(children.last)) {
        children.last.value += " ";
      }
    },
    "expression": expression_default,
    "var": var_default
  };

  // node_modules/css-tree/lib/syntax/atrule/font-face.js
  var font_face_default = {
    parse: {
      prelude: null,
      block() {
        return this.Block(true);
      }
    }
  };

  // node_modules/css-tree/lib/syntax/atrule/import.js
  var import_default3 = {
    parse: {
      prelude() {
        const children = this.createList();
        this.skipSC();
        switch (this.tokenType) {
          case String2:
            children.push(this.String());
            break;
          case Url:
          case Function2:
            children.push(this.Url());
            break;
          default:
            this.error("String or url() is expected");
        }
        if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis) {
          children.push(this.MediaQueryList());
        }
        return children;
      },
      block: null
    }
  };

  // node_modules/css-tree/lib/syntax/atrule/media.js
  var media_default = {
    parse: {
      prelude() {
        return this.createSingleNodeList(
          this.MediaQueryList()
        );
      },
      block() {
        return this.Block(false);
      }
    }
  };

  // node_modules/css-tree/lib/syntax/atrule/page.js
  var page_default = {
    parse: {
      prelude() {
        return this.createSingleNodeList(
          this.SelectorList()
        );
      },
      block() {
        return this.Block(true);
      }
    }
  };

  // node_modules/css-tree/lib/syntax/atrule/supports.js
  function consumeRaw6() {
    return this.createSingleNodeList(
      this.Raw(this.tokenIndex, null, false)
    );
  }
  function parentheses() {
    this.skipSC();
    if (this.tokenType === Ident && this.lookupNonWSType(1) === Colon) {
      return this.createSingleNodeList(
        this.Declaration()
      );
    }
    return readSequence2.call(this);
  }
  function readSequence2() {
    const children = this.createList();
    let child;
    this.skipSC();
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case Comment:
          case WhiteSpace:
            this.next();
            continue;
          case Function2:
            child = this.Function(consumeRaw6, this.scope.AtrulePrelude);
            break;
          case Ident:
            child = this.Identifier();
            break;
          case LeftParenthesis:
            child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
            break;
          default:
            break scan;
        }
        children.push(child);
      }
    return children;
  }
  var supports_default = {
    parse: {
      prelude() {
        const children = readSequence2.call(this);
        if (this.getFirstListNode(children) === null) {
          this.error("Condition is expected");
        }
        return children;
      },
      block() {
        return this.Block(false);
      }
    }
  };

  // node_modules/css-tree/lib/syntax/atrule/index.js
  var atrule_default = {
    "font-face": font_face_default,
    "import": import_default3,
    media: media_default,
    page: page_default,
    supports: supports_default
  };

  // node_modules/css-tree/lib/syntax/pseudo/index.js
  var selectorList = {
    parse() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    }
  };
  var selector = {
    parse() {
      return this.createSingleNodeList(
        this.Selector()
      );
    }
  };
  var identList = {
    parse() {
      return this.createSingleNodeList(
        this.Identifier()
      );
    }
  };
  var nth = {
    parse() {
      return this.createSingleNodeList(
        this.Nth()
      );
    }
  };
  var pseudo_default = {
    "dir": identList,
    "has": selectorList,
    "lang": identList,
    "matches": selectorList,
    "not": selectorList,
    "nth-child": nth,
    "nth-last-child": nth,
    "nth-last-of-type": nth,
    "nth-of-type": nth,
    "slotted": selector
  };

  // node_modules/css-tree/lib/syntax/config/parser.js
  var parser_default = {
    parseContext: {
      default: "StyleSheet",
      stylesheet: "StyleSheet",
      atrule: "Atrule",
      atrulePrelude: function(options) {
        return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
      },
      mediaQueryList: "MediaQueryList",
      mediaQuery: "MediaQuery",
      rule: "Rule",
      selectorList: "SelectorList",
      selector: "Selector",
      block: function() {
        return this.Block(true);
      },
      declarationList: "DeclarationList",
      declaration: "Declaration",
      value: "Value"
    },
    scope: scope_exports,
    atrule: atrule_default,
    pseudo: pseudo_default,
    node: node_exports
  };

  // node_modules/css-tree/lib/syntax/config/walker.js
  var walker_default = {
    node: node_exports
  };

  // node_modules/css-tree/lib/syntax/index.js
  var syntax_default = create_default({
    ...lexer_default,
    ...parser_default,
    ...walker_default
  });

  // node_modules/css-tree/lib/index.js
  var {
    tokenize: tokenize2,
    parse: parse42,
    generate: generate42,
    lexer,
    createLexer,
    walk: walk2,
    find,
    findLast,
    findAll,
    toPlainObject,
    fromPlainObject,
    fork
  } = syntax_default;

  // src/parse/parse-sfc.ts
  var import_prettier = __toESM(require_standalone(), 1);
  var import_parser_babel = __toESM(require_parser_babel(), 1);

  // src/parse/parse-js.ts
  var import_parser2 = __toESM(require_lib(), 1);
  var t3 = __toESM(require_lib4(), 1);

  // src/parse/parse-jsx.ts
  var t = __toESM(require_lib4(), 1);

  // src/parse/shared.ts
  var import_generator = __toESM(require_lib5(), 1);
  var import_template = __toESM(require_lib8(), 1);
  var import_traverse = __toESM(require_lib13(), 1);
  var babelTraverse = import_traverse.default.default;
  var babelGenerate = import_generator.default.default;
  var babelTemplate = import_template.default.default;
  var uuid = () => Math.random().toString(36).slice(2, 12);
  var reatciveIdentifers = /* @__PURE__ */ new Set();
  var propIdentifiers = /* @__PURE__ */ new Set();
  var parseState = { toMountElementSelector: "", hasJsx: false, isInJsx: false };
  var FrameApi = isBrowser() ? {
    h: `${NAME}.h`,
    reactive: `${NAME}.reactive`,
    computed: `${NAME}.computed`,
    effect: `${NAME}.effect`,
    mount: `${NAME}.mount`
  } : {
    h: "$_h",
    reactive: "$_reactive",
    computed: "$_computed",
    effect: "$_effect",
    mount: "$_mount"
  };

  // src/parse/parse-jsx.ts
  var jsxStack = [];
  var getJsxStackLastOne = () => jsxStack[jsxStack.length - 1];
  function babelTraverseJSXOption() {
    return {
      JSXOpeningElement(path) {
        const { node, parentPath } = path;
        const currentJsx = {
          tag: node.name.name,
          props: { "scope-id": t.stringLiteral(scopeId) },
          children: [],
          isSelfClose: node.selfClosing,
          jsxElementPath: parentPath
        };
        const prevJsx = getJsxStackLastOne();
        if (!prevJsx)
          return void jsxStack.push(currentJsx);
        if (prevJsx.isSelfClose) {
          prevJsx.jsxElementPath.replaceWith(createHydrateCall(prevJsx));
          jsxStack.pop();
        } else if (t.isJSXElement(currentJsx.jsxElementPath.parentPath?.node)) {
          prevJsx.children.push(currentJsx.jsxElementPath.node);
        }
        jsxStack.push(currentJsx);
        parseState.hasJsx = true;
        parseState.isInJsx = true;
      },
      JSXAttribute({ node }) {
        const { name: name41, value } = node;
        const currentJsx = getJsxStackLastOne();
        const propKey = name41.name;
        const propValue = t.isJSXExpressionContainer(value) ? value.expression : value;
        currentJsx.props[propKey] = propValue;
      },
      JSXText({ node }) {
        if (!node.value.match(/[^\n\s]/))
          return;
        const currentJsx = getJsxStackLastOne();
        currentJsx.children.push(t.stringLiteral(node.value));
      },
      JSXExpressionContainer(path) {
        const { node, parent: parentNode } = path;
        if (t.isJSXAttribute(parentNode))
          return;
        const currentJsx = getJsxStackLastOne();
        currentJsx.children.push(node.expression);
      },
      JSXClosingElement() {
        const currentJsx = getJsxStackLastOne();
        currentJsx.jsxElementPath.replaceWith(createHydrateCall(currentJsx));
        jsxStack.pop();
        if (!jsxStack.length)
          parseState.isInJsx = false;
      },
      LogicalExpression(path) {
        if (!t.isJSXExpressionContainer(path.parent))
          return;
        const { left, right, operator } = path.node;
        const conditionalExpression2 = operator === "||" ? t.conditionalExpression(left, t.identifier("undefined"), right) : t.conditionalExpression(left, right, t.identifier("undefined"));
        path.replaceWith(conditionalExpression2);
      },
      ArrowFunctionExpression(path) {
        if (!t.isJSXExpressionContainer(path.parent))
          return;
        const computedCall = t.callExpression(t.identifier(FrameApi.computed), [t.arrowFunctionExpression([], path.node)]);
        path.replaceWith(t.memberExpression(computedCall, t.identifier("value")));
      }
    };
  }
  function createHydrateCall({ tag, props, children }) {
    return t.callExpression(t.identifier(FrameApi.h), [
      tag[0].toUpperCase() === tag[0] ? t.identifier(tag) : t.stringLiteral(tag),
      t.objectExpression(
        Object.entries(props).map(([propKey, propValue]) => t.objectProperty(t.stringLiteral(propKey), propValue))
      ),
      t.arrayExpression(children)
    ]);
  }

  // src/parse/parse-label.ts
  var t2 = __toESM(require_lib4(), 1);
  function babelTraverseLabelOption() {
    return {
      LabeledStatement(path) {
        const { name: name41 } = path.node.label;
        if (name41 === "props")
          return parsePropsLabel(path);
        if (name41 === "ref")
          return parseRefLabel(path);
        if (name41 === "computed")
          return parseComputedLabel(path);
        if (name41 === "effect")
          return parseEffectLabel(path);
        if (name41 === "jsx")
          return parseJsxLabel(path);
      }
    };
  }
  function parseRefLabel(path) {
    const { node } = path;
    if (!t2.isExpressionStatement(node.body))
      return path.remove();
    if (!t2.isAssignmentExpression(node.body.expression))
      return path.remove();
    const { left: identifier4, right: value } = node.body.expression;
    identifier4.noNeedDotValue = true;
    reatciveIdentifers.add(babelGenerate(identifier4).code);
    const reactiveCall = t2.callExpression(t2.identifier(FrameApi.reactive), [value]);
    const reactiveDeclaration = t2.variableDeclaration("const", [t2.variableDeclarator(identifier4, reactiveCall)]);
    path.replaceWith(reactiveDeclaration);
  }
  function parseComputedLabel(path) {
    const { node } = path;
    if (!t2.isExpressionStatement(node.body))
      return path.remove();
    if (!t2.isAssignmentExpression(node.body.expression))
      return path.remove();
    const { left: identifier4, right: computedExpression } = node.body.expression;
    identifier4.noNeedDotValue = true;
    reatciveIdentifers.add(babelGenerate(identifier4).code);
    const computedCaller = t2.identifier(FrameApi.computed);
    const computedCallback = t2.isArrowFunctionExpression(computedExpression) ? computedExpression : t2.arrowFunctionExpression([], computedExpression);
    const computedCall = t2.callExpression(computedCaller, [computedCallback]);
    const computedDeclaration = t2.variableDeclaration("const", [t2.variableDeclarator(identifier4, computedCall)]);
    path.replaceWith(computedDeclaration);
  }
  function parseEffectLabel(path) {
    const { node } = path;
    if (!t2.isExpressionStatement(node.body) && !t2.isBlock(node.body))
      return path.remove();
    const effectCaller = t2.identifier(FrameApi.effect);
    const effectCallback = t2.isBlock(node.body) ? t2.arrowFunctionExpression([], node.body) : t2.isArrowFunctionExpression(node.body.expression) ? node.body.expression : t2.arrowFunctionExpression([], node.body.expression);
    const effectCall = t2.callExpression(effectCaller, [effectCallback]);
    path.replaceWith(effectCall);
  }
  function parsePropsLabel(path) {
    const {
      node: { body }
    } = path;
    if (!t2.isExpressionStatement(body))
      return path.remove();
    if (t2.isIdentifier(body.expression)) {
      propIdentifiers.add(body.expression.name);
    }
    let multiIdentifiers = [];
    if (t2.isSequenceExpression(body.expression)) {
      multiIdentifiers = body.expression.expressions;
    }
    if (t2.isArrayExpression(body.expression)) {
      multiIdentifiers = body.expression.elements;
    }
    multiIdentifiers.filter((i) => t2.isIdentifier(i)).map((i) => i.name).forEach((prop) => propIdentifiers.add(prop));
    path.remove();
  }
  function parseJsxLabel(path) {
    const { node } = path;
    if (!t2.isExpressionStatement(node.body))
      return path.remove();
    const jsxLabelRightExpression = node.body.expression;
    let jsx;
    if (t2.isSequenceExpression(jsxLabelRightExpression)) {
      jsx = jsxLabelRightExpression.expressions[0];
      parseState.toMountElementSelector = jsxLabelRightExpression.expressions[1];
    } else {
      jsx = jsxLabelRightExpression;
    }
    if (!t2.isJSXElement(jsx))
      return path.remove();
    const renderFunction = t2.arrowFunctionExpression([], jsx);
    const returnStatement2 = t2.returnStatement(renderFunction);
    const cssInJs = babelTemplate.ast(cssParsers.map((parseCss2) => parseCss2()).join(""));
    path.replaceWith(returnStatement2);
    path.insertBefore(cssInJs);
  }

  // src/parse/parse-js.ts
  var cssParsers = [];
  function parseJs(js) {
    const ast = (0, import_parser2.parse)(js, { plugins: ["jsx"] });
    babelTraverse(ast, {
      ...babelTraverseLabelOption(),
      ...babelTraverseDotValueOption(),
      ...babelTraverseJSXOption(),
      exit(path) {
        if (t3.isProgram(path.node) && parseState.hasJsx) {
          wrapProgram(path);
        }
      }
    });
    return babelGenerate(ast).code;
  }
  function babelTraverseDotValueOption() {
    return {
      Identifier(path) {
        if (path.node.noNeedDotValue || !reatciveIdentifers.has(path.node.name) || t3.isMemberExpression(path.parent) && path.node.start !== path.parent.start)
          return;
        path.replaceWith(t3.identifier(`${path.node.name}.value`));
        path.skip();
      }
    };
  }
  var done = false;
  function wrapProgram(path) {
    if (done)
      return;
    done = true;
    const props = t3.objectPattern(
      [...propIdentifiers].map((propName) => t3.objectProperty(t3.identifier(propName), t3.identifier(propName)))
    );
    const componentFunction = t3.arrowFunctionExpression([props], t3.blockStatement(path.node.body));
    if (isBrowser()) {
      const mountCall = t3.callExpression(t3.identifier(FrameApi.mount), [
        componentFunction,
        parseState.toMountElementSelector || t3.identifier("document.body")
      ]);
      path.replaceWith(t3.program([t3.expressionStatement(mountCall)]));
      return;
    }
    path.replaceWith(t3.program([t3.exportDefaultDeclaration(componentFunction)]));
  }

  // src/parse/parse-sfc.ts
  var scopeId = uuid();
  function parseSFC(sfcSource) {
    const [jsSource, cssCource] = getJsAndCssFromSFC(sfcSource);
    cssParsers.push(() => parseCss(cssCource));
    const js = parseJs(jsSource);
    return (0, import_prettier.format)(js, { parser: "babel", plugins: [import_parser_babel.default] });
  }
  function getJsAndCssFromSFC(sfcSource) {
    let [js, css, char, inScript, inStyle] = ["", "", "", false, false];
    for (let i = 0; i < sfcSource.length; i++) {
      char = sfcSource[i];
      if (char === "<" && sfcSource.slice(i + 1, i + 9) === "/script>")
        inScript = false;
      if (char === "<" && sfcSource.slice(i + 1, i + 8) === "/style>")
        inStyle = false;
      if (inScript)
        js += char;
      if (inStyle)
        css += char;
      if (char === ">" && sfcSource.slice(i - 7, i) === "<script")
        inScript = true;
      if (char === ">" && sfcSource.slice(i - 6, i) === "<style")
        inStyle = true;
    }
    return [js, css];
  }

  // src/parse/parse-css.ts
  var additionalJsForAddCss = [];
  var parseCss = (css) => {
    const ast = parse42(css);
    walk2(ast, {
      visit: "Rule",
      enter(rule) {
        const { prelude, block } = rule;
        prelude.children.last.children.appendData({
          type: "AttributeSelector",
          name: { name: `scope-${scopeId}`, type: "Identifier" },
          matcher: null,
          value: null,
          flags: null
        });
        walk2(block, {
          visit: "Declaration",
          enter(declaration) {
            if (declaration.value.type !== "Value")
              return;
            const parentheses2 = [...declaration.value.children].find((i) => i.type === "Parentheses");
            if (!parentheses2)
              return;
            const selector2 = generate42(prelude);
            const parenthesesJsExpression = generate42(parentheses2).replace(/^\(('|"|`)?/, "").replace(/('|"|`)?\)$/, "");
            parentheses2.type = "Raw";
            parentheses2.value = "${" + parenthesesJsExpression + "}";
            const style = `${selector2}{${generate42(declaration)};}`;
            additionalJsForAddCss.push(`
          ${FrameApi.effect}((prevState) => {
            if (prevState.style) return prevState.style.innerHTML = \`${style}\`; 
            const style = document.createElement('style');
            style.innerHTML = \`${style}\`;
            const head = document.head || document.documentElement;
            head.appendChild((prevState.style = style));
          }, { style: '' });`);
            declaration.value.children.clear();
          }
        });
      }
    });
    additionalJsForAddCss.push(
      `(document.head || document.documentElement).insertAdjacentHTML('beforeend', '<style>${generate42(ast)}</style>');`
    );
    return additionalJsForAddCss.join("");
  };

  // src/core/reactive.ts
  var targetObjMap = /* @__PURE__ */ new WeakMap();
  var currentCallback;
  function reactive(value) {
    return function makeReactive(obj) {
      return new Proxy(obj, {
        get(target, key) {
          record(target, key);
          const gotValue = Reflect.get(target, key);
          return typeof gotValue === "object" ? makeReactive(gotValue) : gotValue;
        },
        set(target, key, value2) {
          Reflect.set(target, key, value2);
          trigger(target, key);
          return true;
        }
      });
    }({ value });
  }
  function effect(cb, lastState) {
    currentCallback = () => cb(lastState);
    const res = currentCallback(lastState);
    currentCallback = null;
    return res;
  }
  function computed(cb) {
    const result = reactive(void 0);
    effect(() => result.value = cb());
    return result;
  }
  function record(targetObj, key) {
    if (!currentCallback)
      return;
    const orArray = Array.isArray(targetObj) ? targetObj : Array.isArray(targetObj[key]) ? targetObj[key] : null;
    if (orArray) {
      if (!targetObjMap.get(orArray)) {
        targetObjMap.set(orArray, /* @__PURE__ */ new Set());
      }
      const callbacks = targetObjMap.get(orArray);
      return callbacks.add(currentCallback);
    }
    if (!targetObjMap.get(targetObj)) {
      targetObjMap.set(targetObj, /* @__PURE__ */ new Map());
    }
    const keyTocallbacksMap = targetObjMap.get(targetObj);
    if (!keyTocallbacksMap.get(key)) {
      keyTocallbacksMap.set(key, /* @__PURE__ */ new Set());
    }
    keyTocallbacksMap.get(key).add(currentCallback);
  }
  function trigger(targetObj, key) {
    if (key === "length" || !targetObj.hasOwnProperty(key))
      return;
    if (Array.isArray(targetObj)) {
      const array = targetObj;
      const callbacks = targetObjMap.get(array);
      callbacks?.forEach((callback) => callback !== currentCallback && callback());
    } else {
      const keyTocallbacksMap = targetObjMap.get(targetObj);
      keyTocallbacksMap?.get(key)?.forEach((callback) => callback !== currentCallback && callback());
    }
  }

  // src/core/diff.ts
  function diffElementVnodeChildren(prevVnode, currentVnode, parentDom) {
    if (isElementWithOneTextNodeChild(prevVnode) || isElementWithOneTextNodeChild(currentVnode)) {
      if (isElementWithOneTextNodeChild(prevVnode) && isElementWithOneTextNodeChild(currentVnode)) {
        parentDom.textContent = currentVnode.children[0].children[0];
      }
      if (isElementWithOneTextNodeChild(prevVnode) && !isElementWithOneTextNodeChild(currentVnode)) {
        for (const child of currentVnode.children)
          mountVnode(child, parentDom);
      }
      if (!isElementWithOneTextNodeChild(currentVnode) && isElementWithOneTextNodeChild(currentVnode)) {
        unmountVnode(prevVnode);
        parentDom.textContent = currentVnode.children[0].children[0];
      }
    }
    if (prevVnode.children[0].key && currentVnode.children[0].key) {
      diffKeyedChildren(prevVnode.children, currentVnode.children, parentDom);
    } else {
      diffUnKeyedChildren(prevVnode.children, currentVnode.children, parentDom);
    }
  }
  function isElementWithOneTextNodeChild(vnode) {
    return vnode.children.length === 1 && vnode.children[0]?.type === VnodeType.textNode;
  }
  function diffUnKeyedChildren(prevChildren, currentChildren, parentDom) {
    const prevChildrenLength = prevChildren.length;
    const currentChildrenLength = currentChildren.length;
    const shiftLength = Math.min(prevChildrenLength, currentChildrenLength);
    for (let i = 0; i < shiftLength; i++) {
      updateVnode(prevChildren[i], currentChildren[i], parentDom);
    }
    if (currentChildrenLength > prevChildrenLength) {
      return currentChildren.slice(shiftLength).forEach((child) => mountVnode(child, parentDom));
    }
    if (prevChildrenLength > currentChildrenLength) {
      return prevChildren.slice(shiftLength).forEach((child) => unmountVnode(child));
    }
  }
  function diffKeyedChildren(prevChildren, currentChildren, parentDom) {
    let headIndex = 0;
    let prevChildrenTailIndex = prevChildren.length - 1;
    let currentChildrenTailIndex = currentChildren.length - 1;
    while (headIndex <= prevChildrenTailIndex && headIndex <= currentChildrenTailIndex && isSameTypeAndKey(prevChildren[headIndex], currentChildren[headIndex])) {
      updateVnode(prevChildren[headIndex], currentChildren[headIndex], parentDom);
      headIndex++;
    }
    while (headIndex <= prevChildrenTailIndex && headIndex <= currentChildrenTailIndex && isSameTypeAndKey(prevChildren[prevChildrenTailIndex], currentChildren[currentChildrenTailIndex])) {
      updateVnode(prevChildren[headIndex], currentChildren[headIndex], parentDom);
      prevChildrenTailIndex--;
      currentChildrenTailIndex--;
    }
    console.log(headIndex, prevChildrenTailIndex, currentChildrenTailIndex);
    if (headIndex > prevChildrenTailIndex) {
      for (let i = headIndex; i <= currentChildrenTailIndex; i++) {
        mountVnode(currentChildren[i], parentDom);
      }
    }
    if (headIndex > currentChildrenTailIndex) {
      for (let i = headIndex; i <= currentChildrenTailIndex; i++) {
        unmountVnode(prevChildren[i]);
      }
    }
  }
  function isSameTypeAndKey(prevVnode, currentVnode) {
    return prevVnode.type === currentVnode.type && prevVnode.key === currentVnode.key;
  }

  // src/core/render-dom.ts
  function mountElement(elementVnode, parentDom) {
    const el = document.createElement(elementVnode.jsxTag);
    parentDom.appendChild(elementVnode.el = el);
    setDomAttributeFromVnodeProps(null, elementVnode, el);
    for (const childVnode of elementVnode.children) {
      mountVnode(childVnode, el);
    }
  }
  function updateElement(preVnode, currentVnode, parentDom) {
    const el = currentVnode.el = preVnode.el;
    if (!el)
      return;
    setDomAttributeFromVnodeProps(preVnode, currentVnode, el);
    diffElementVnodeChildren(preVnode, currentVnode, el);
  }
  function mountTextNode(textNodeVnode, parentDom) {
    const el = document.createTextNode(textNodeVnode.children[0].toString());
    parentDom.appendChild(textNodeVnode.el = el);
  }
  function updateTextNode(preVnode, currentVnode, parentDom) {
    const el = currentVnode.el = preVnode.el;
    el && (el.textContent = currentVnode.children[0].toString());
  }
  function setDomAttributeFromVnodeProps(preVnode, currentVnode, el) {
    const prevProps = preVnode ? preVnode.props : {};
    const currentProps = currentVnode.props;
    const diffedProps = Object.entries(currentProps).map(
      ([propKey, currentPropValue]) => !(propKey in prevProps) ? [propKey, currentPropValue] : prevProps[propKey] !== currentPropValue ? [propKey, currentPropValue] : void 0
    ).filter(Boolean);
    for (const [propkey, propValue] of diffedProps) {
      if (propkey.startsWith("on")) {
        el.addEventListener(propkey.slice(2).toLocaleLowerCase(), propValue);
      } else if (propkey === "style") {
        const styleString = Object.entries(propValue).map(([csskey, cssValue]) => `${csskey}: ${cssValue}`).join(";");
        el.setAttribute("style", styleString);
      } else if (propkey === "className") {
        el.className = propValue;
      } else if (propkey === "scope-id") {
        el.setAttribute(`scope-${propValue}`, "");
      } else {
        el.setAttribute(propkey, propValue);
      }
    }
  }

  // src/core/vnode.ts
  function h(jsxTag, props, children) {
    const vnodeBase = {
      props,
      children,
      el: null,
      componentInstance: null,
      key: props.key
    };
    if (jsxTag === 0) {
      return { type: VnodeType.textNode, jsxTag, ...vnodeBase };
    }
    if (is.string(jsxTag)) {
      vnodeBase.children = specialDealVnodeChildren(vnodeBase.children);
      return { type: VnodeType.element, jsxTag, ...vnodeBase };
    }
    return { type: VnodeType.component, jsxTag, ...vnodeBase };
  }
  function specialDealVnodeChildren(children) {
    const newVnodeChildren = [];
    children.forEach((child) => {
      if (is.string(child) || is.number(child))
        return newVnodeChildren.push(h(0, {}, [child]));
      if (is.array(child))
        return newVnodeChildren.push(...specialDealVnodeChildren(child));
      if (is.undefined(child) || is.null(child))
        return;
      newVnodeChildren.push(child);
    });
    return newVnodeChildren;
  }
  function mount(toMount, parentDom) {
    const componentFunction = typeof toMount === "function" ? toMount : () => () => toMount;
    mountComponentVnode(h(componentFunction, {}, []), parentDom);
  }
  function mountVnode(vnode, parentDom) {
    if (vnodeIs.component(vnode)) {
      return mountComponentVnode(vnode, parentDom);
    }
    if (vnodeIs.element(vnode)) {
      return mountElement(vnode, parentDom);
    }
    if (vnodeIs.textNode(vnode)) {
      return mountTextNode(vnode, parentDom);
    }
  }
  function updateVnode(preVnode, currentVnode, parentDom) {
    if (vnodeIs.component(currentVnode) && vnodeIs.component(preVnode)) {
      return passiveUpdateComponent(preVnode, currentVnode, parentDom);
    }
    if (vnodeIs.element(currentVnode) && vnodeIs.element(preVnode)) {
      return updateElement(preVnode, currentVnode, parentDom);
    }
    if (vnodeIs.textNode(currentVnode) && vnodeIs.textNode(preVnode)) {
      return updateTextNode(preVnode, currentVnode, parentDom);
    }
    unmountVnode(preVnode);
    mountVnode(currentVnode, parentDom);
  }
  function unmountVnode(vnode) {
    if (vnodeIs.component(vnode) && vnode.componentInstance) {
      unmountVnode(vnode.componentInstance.subVnode);
    } else {
      vnode.el?.remove();
    }
  }

  // src/core/component.ts
  function mountComponentVnode(componentVnode, parentDom) {
    const { jsxTag: componentFunction, props } = componentVnode;
    const componentInstance = {
      isMounted: false
    };
    const renderFunction = componentFunction(props);
    componentInstance.update = () => {
      if (!componentInstance.isMounted) {
        const currentSubVnode2 = renderFunction();
        currentSubVnode2.children = specialDealVnodeChildren(currentSubVnode2.children);
        mountVnode(currentSubVnode2, parentDom);
        componentInstance.subVnode = currentSubVnode2;
        componentVnode.el = currentSubVnode2.el;
        return componentInstance.isMounted = true;
      }
      const prevSubVnode = componentInstance.subVnode;
      const currentSubVnode = renderFunction();
      currentSubVnode.children = specialDealVnodeChildren(currentSubVnode.children);
      updateVnode(prevSubVnode, currentSubVnode, parentDom);
      componentInstance.subVnode = currentSubVnode;
      componentVnode.el = currentSubVnode.el;
    };
    effect(componentInstance.update);
  }
  function passiveUpdateComponent(preVnode, currentVnode, parentDom) {
    currentVnode.componentInstance = preVnode.componentInstance;
    currentVnode.componentInstance?.update();
  }

  // src/index.ts
  processAndBufferPolyfill();
  isBrowser() && (window.onload = () => {
    const scripts = [...document.querySelectorAll('[type="text/babel"]')];
    const styles = [...document.querySelectorAll("style")];
    const jsSource = `<script>${scripts.map((script2) => script2.innerHTML).join(";")}<\/script>`;
    const cssSource = `<style>${styles.map((style) => style.innerHTML).join(";")}</style>`;
    scripts.forEach((script2) => script2.remove());
    styles.forEach((style) => style.remove());
    const js = parseSFC(jsSource + cssSource);
    const script = document.createElement("script");
    script.innerHTML = js;
    document.body.insertAdjacentElement("beforeend", script);
  });
  return __toCommonJS(src_exports);
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=index.js.map
